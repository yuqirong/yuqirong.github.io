Java SE
=====

集合
------
* ConcurrentHashMap 和HashTable的区别

JVM
----
* JVM 内存分哪几个区，每个区的作用是什么?
	
	答：java 虚拟机主要分为以下几个区 :
	
	方法区： 
	1. 有时候也称为**永久代** ，在该区内很少发生垃圾回收，但是并不代表不发生 GC ，在这里进行的 GC 主要是对方法区里的常量池和对类型的卸载 
	2. 方法区主要用来存储已被虚拟机加载的类的信息、常量、静态变量和即时编译器编译后的代码等数据。
	3. 该区域是被线程共享的。 
	4. 方法区里有一个运行时常量池，用于存放静态编译产生的字面量和符号引用。该常量池具有动态性，也就是说常量并不一定是编译时确定，运行时生成的常量也会存在这个常量池中。
	
	虚拟机栈 : 
	1. 虚拟机栈也就是我们平常所称的 栈内存 , 它为 java 方法服务，每个方法在执行的时候都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接和方法出口等信息。 
	2. 虚拟机栈是线程私有的，它的生命周期与线程相同。 
	3. 局部变量表里存储的是基本数据类型、 returnAddress 类型（指向一条字节码指令的地址）和对象引用，这个对象引用有可能是指向对象起始地址的一个指针，也有可能是代表对象的句柄或者与对象相关联的位置。局部变量所需的内存空间在编译器间确定 
	4. 操作数栈的作用主要用来存储运算结果以及运算的操作数，它不同于局部变量表通过索引来访问，而是压栈和出栈的方式 
	5. 每个栈帧都包含一个指向运行时常量池中该栈帧所属方法的引用，持有这个引用是为了支持方法调用过程中的动态连接 . 动态链接就是将常量池中的符号引用在运行期转化为直接引用。
	
	本地方法栈 

	本地方法栈和虚拟机栈类似，只不过本地方法栈为 Native 方法服务。
	
	堆 
	
	java 堆是所有线程所共享的一块内存，在虚拟机启动时创建，几乎所有的对象实例都在这里创建，因此该区域经常发生垃圾回收操作。
	
	程序计数器 
	
	内存空间小，字节码解释器工作时通过改变这个计数值可以选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理和线程恢复等功能都需要依赖这个计数器完成。该内存区域是唯一一个 java 虚拟机规范没有规定任何 OOM 情况的区域。

     
* 如和判断一个对象是否存活 ?( 或者 GC 对象的判定方法 )

	答：判断一个对象是否存活有两种方法 :
	
	1.引用计数法 
	
	所谓引用计数法就是给每一个对象设置一个引用计数器，每当有一个地方引用这个对象时，就将计数器加一，引用失效时，计数器就减一。当一个对象的引用计数器为零时，说明此对象没有被引用，也就是 “ 死对象 ”, 将会被垃圾回收 .
	引用计数法有一个缺陷就是无法解决循环引用问题，也就是说当对象 A 引用对象 B ，对象 B 又引用者对象 A ，那么此时 A,B 对象的引用计数器都不为零，也就造成无法完成垃圾回收，所以主流的虚拟机都没有采用这种算法。
	
	2.可达性算法 ( 引用链法 )
	
	该算法的思想是：从一个被称为 GC Roots 的对象开始向下搜索，如果一个对象到 GC Roots 没有任何引用链相连时，则说明此对象不可用。 
	在 java 中可以作为 GC Roots 的对象有以下几种：

	* 虚拟机栈中引用的对象
	* 方法区类静态属性引用的对象
	* 方法区常量池引用的对象
	* 本地方法栈 JNI 引用的对象

	虽然这些算法可以判定一个对象是否能被回收，但是当满足上述条件时，一个对象比 不一定会被回收 。当一个对象不可达 GC Root 时，这个对象并   不会立马被回收 ，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记 
	如果对象在可达性分析中没有与 GC Root 的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行 finalize() 方法。当对象没有覆盖 finalize() 方法或者已被虚拟机调用过，那么就认为是没必要的。 
	如果该对象有必要执行 finalize() 方法，那么这个对象将会放在一个称为 F-Queue 的对队列中，虚拟机会触发一个 Finalize() 线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果 finalize() 执行缓慢或者发生了死锁，那么就会造成 F-Queue 队列一直等待，造成了内存回收系统的崩溃。 GC 对处于 F-Queue 中的对象进行第二次被标记，这时，该对象将被移除 " 即将回收 " 集合，等待回收。

* 简述 java 垃圾回收机制 ?

	答：在 java 中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在 JVM 中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。