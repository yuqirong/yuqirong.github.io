<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[俞其荣的博客 | Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.github.io/"/>
  <updated>2019-11-16T15:26:48.346Z</updated>
  <id>http://yuqirong.github.io/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[RxJava源码解析]]></title>
    <link href="http://yuqirong.github.io/2019/11/16/RxJava%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.github.io/2019/11/16/RxJava源码解析/</id>
    <published>2019-11-16T06:02:25.000Z</published>
    <updated>2019-11-16T15:26:48.346Z</updated>
    <content type="html"><![CDATA[<p>本文中的源码基于 RxJava1<br>RxJava : io.reactivex:rxjava:1.3.4</p>
<p>以下是各个 Part 主要分析源码的方向</p>
<ul>
<li>Part 1: Observable, Observable.OnSubscribe, Subscriber</li>
<li>Part 2: map</li>
<li>Part 3: subscribeOn</li>
<li>Part 4: observeOn</li>
</ul>
<h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><p>先来看一个最简单的 RxJava Demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hi rxjava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>那么，我们就从 Observable.create 的角度开始分析 RxJava 内部源码的实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Deprecated</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，我们上面传入 OnSubscribe 对象 f 被 RxJavaHooks 包装了一下。但是默认情况下的 RxJavaHooks.onCreate 返回的就是 f 本身。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RxJavaHooks</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">OnSubscribe&lt;T&gt; <span class="title">onCreate</span><span class="params">(Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        Func1&lt;Observable.OnSubscribe, Observable.OnSubscribe&gt; f = onObservableCreate;</span><br><span class="line">        <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> f.call(onSubscribe);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> onSubscribe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，根据上面 demo 的代码可以看出，创建出来的 Observable 对象又调用了 subscribe 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.subscribe(subscriber, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 subscribe 内部调用了 <code>subscribe(Subscriber&lt;? super T&gt; subscriber, Observable&lt;T&gt; observable)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &lt;T&gt; <span class="function">Subscription <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber, Observable&lt;T&gt; observable)</span> </span>&#123;</span><br><span class="line"> <span class="comment">// 一开始是对参数的校验</span></span><br><span class="line">    <span class="keyword">if</span> (subscriber == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"subscriber can not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observable.onSubscribe == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"onSubscribe function can not be null."</span>);</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">         * the subscribe function can also be overridden but generally that's not the appropriate approach</span><br><span class="line">         * so I won't mention that in the exception</span><br><span class="line">         */</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 subscriber.onStart 方法，默认是空实现</span></span><br><span class="line">    subscriber.onStart();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * See https://github.com/ReactiveX/RxJava/issues/216 for discussion on "Guideline 6.4: Protect calls</span><br><span class="line">     * to user code from within an Observer"</span><br><span class="line">     */</span></span><br><span class="line">    <span class="comment">// if not already wrapped</span></span><br><span class="line">    <span class="comment">// 把 subscriber 包装成 SafeSubscriber</span></span><br><span class="line">    <span class="keyword">if</span> (!(subscriber <span class="keyword">instanceof</span> SafeSubscriber)) &#123;</span><br><span class="line">        <span class="comment">// assign to `observer` so we return the protected version</span></span><br><span class="line">        subscriber = <span class="keyword">new</span> SafeSubscriber&lt;T&gt;(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The code below is exactly the same an unsafeSubscribe but not used because it would</span></span><br><span class="line">    <span class="comment">// add a significant depth to already huge call stacks.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 开始执行 onSubscribe 的 onCall 方法</span></span><br><span class="line">        RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber);</span><br><span class="line">        <span class="keyword">return</span> RxJavaHooks.onObservableReturn(subscriber);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// special handling for certain Throwable/Error/Exception types</span></span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="comment">// in case the subscriber can't listen to exceptions anymore</span></span><br><span class="line">        <span class="keyword">if</span> (subscriber.isUnsubscribed()) &#123;</span><br><span class="line">            RxJavaHooks.onError(RxJavaHooks.onObservableError(e));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果发生了异常，就调用 subscriber 的 onError 方法</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                subscriber.onError(RxJavaHooks.onObservableError(e));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e2) &#123;</span><br><span class="line">                Exceptions.throwIfFatal(e2);</span><br><span class="line">                <span class="comment">// if this happens it means the onError itself failed (perhaps an invalid function implementation)</span></span><br><span class="line">                <span class="comment">// so we are unable to propagate the error correctly and will just throw</span></span><br><span class="line">                RuntimeException r = <span class="keyword">new</span> OnErrorFailedException(<span class="string">"Error occurred attempting to subscribe ["</span> + e.getMessage() + <span class="string">"] and then again while trying to pass to onError."</span>, e2);</span><br><span class="line">                <span class="comment">// TODO could the hook be the cause of the error in the on error handling.</span></span><br><span class="line">                RxJavaHooks.onObservableError(r);</span><br><span class="line">                <span class="comment">// TODO why aren't we throwing the hook's return value.</span></span><br><span class="line">                <span class="keyword">throw</span> r; <span class="comment">// NOPMD</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们详细的来看下 <code>RxJavaHooks.onObservableStart(observable, observable.onSubscribe).call(subscriber)</code> 这句代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; Observable.<span class="function">OnSubscribe&lt;T&gt; <span class="title">onObservableStart</span><span class="params">(Observable&lt;T&gt; instance, Observable.OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">    Func2&lt;Observable, Observable.OnSubscribe, Observable.OnSubscribe&gt; f = onObservableStart;</span><br><span class="line">    <span class="keyword">if</span> (f != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> f.call(instance, onSubscribe);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> onSubscribe;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和上面的 RxJavaHooks 一样，默认的 hook 只是返回了 onSubscribe 对象。所以这句代码就可以“简化”为 <code>onSubscribe.call(subscriber)</code> 。</p>
<p>也就是执行了 demo 中的 call 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    subscriber.onNext(<span class="string">"hi rxjava"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在 call 方法中又调用了 subscriber 的 onNext 方法。</p>
<p>还记得上面 subscriber 被包装成 SafeSubscriber 了吗？</p>
<p>所以这里就会调用 SafeSubscriber.onNext 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (!done) &#123;</span><br><span class="line">            <span class="comment">// actual就是我们自己定义的subscriber</span></span><br><span class="line">            actual.onNext(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">// we handle here instead of another method so we don't add stacks to the frame</span></span><br><span class="line">        <span class="comment">// which can prevent it from being able to handle StackOverflow</span></span><br><span class="line">        Exceptions.throwOrReport(e, <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 SafeSubscriber.onNext 方法内，会调用真正的 subscriber.onNext 方法。SafeSubscriber 的作用就是是为了防止被调用 onCompleted 之后再重新调用 onNext 。换句话说，SafeSubscriber 就是为了防止重用。</p>
<p>因此，subscriber.onNext 也就被执行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">    System.out.println(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="Part_2"><a href="#Part_2" class="headerlink" title="Part 2"></a>Part 2</h1><p>在这里，我们把上面简单的 demo 稍微增加一点难度，中间加一个转换：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hi rxjava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.map(<span class="keyword">new</span> Func1&lt;String, String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s + <span class="string">"hahaha"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>可以看到，中间加了一层 map 操作符。</p>
<p>所以我们来分析一下 map 中到底干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">map</span><span class="params">(Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; func)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OnSubscribeMap&lt;T, R&gt;(<span class="keyword">this</span>, func));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>map 中调用了 unsafeCreate 方法。我们来看看 unsafeCreate 方法内部</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">unsafeCreate</span><span class="params">(OnSubscribe&lt;T&gt; f)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(RxJavaHooks.onCreate(f));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码多么似曾相识啊，和上面的 Observable.create 比较一下，发现 Observable.unsafeCreate 和 Observable.create 的逻辑是一样的。</p>
<p>所以我们可以知道， map 操作符内部会重新创建一个 Observable ，而这个 Observable 的 OnSubscribe 是一个 OnSubscribeMap 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OnSubscribeMap</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">R</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OnSubscribeMap</span><span class="params">(Observable&lt;T&gt; source, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; transformer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.source = source; <span class="comment">// 原来我们自己创建的 Observable</span></span><br><span class="line">        <span class="keyword">this</span>.transformer = transformer; <span class="comment">// Fun1 转换</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以我们在这里可以小结一下，map 操作符会创建一个新的 Observable 对象，并且它的 OnSubscribe 是一个 OnSubscribeMap 对象，而我们自己的 Observable 会保存在 OnSubscribeMap 里。</p>
<p>再回头看看上面的 demo ，发现 map 创建出来的 Observable 对象调用了 subscribe 方法。在 Part 1 中我们分析过，调用 subscribe 方法内部其实就是会去调用  Observable 中 OnSubscribe 的 call 方法。</p>
<p>所以，我们直接来看 OnSubscribeMap 的 call 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123; <span class="comment">// o 就是我们自定义的 Subscriber</span></span><br><span class="line">    MapSubscriber&lt;T, R&gt; parent = <span class="keyword">new</span> MapSubscriber&lt;T, R&gt;(o, transformer);</span><br><span class="line">    o.add(parent);</span><br><span class="line">    <span class="comment">// source 就是我们自己创建的 Observable</span></span><br><span class="line">    <span class="comment">// 和 subscribe 相比，unsafeSubscribe 内部不会对参数校验，subscriber 不会包装成 SafeSubscriber</span></span><br><span class="line">    source.unsafeSubscribe(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>call 方法内部创建了一个新的 MapSubscriber 对象，</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">MapSubscriber</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MapSubscriber</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; actual, Func1&lt;? <span class="keyword">super</span> T, ? extends R&gt; mapper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.actual = actual; <span class="comment">// actual 就是我们自定义的 Subscriber</span></span><br><span class="line">        <span class="keyword">this</span>.mapper = mapper; <span class="comment">// mapper 就是 Func1 转换</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后让我们自己的 Observable 去 subscribe 这个 MapSubscriber 对象。</p>
<p>那么接着代码就会执行到 MapSubscriber.call 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    R result;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 Func1 转换器 实现从 T 到 R 的转换</span></span><br><span class="line">        <span class="comment">// 在 demo 中就是在 hi rxjava 后面追加 hahaha</span></span><br><span class="line">        result = mapper.call(t);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ex) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(ex);</span><br><span class="line">        unsubscribe();</span><br><span class="line">        onError(OnErrorThrowable.addValueAsLastCause(ex, t));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行我们自定义的 Subscriber 的 onNext 方法</span></span><br><span class="line">    actual.onNext(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，整个 map 操作符的流程就讲完了。不明白的同学可以对照着源码多读几遍，相信你会明白的。</p>
<p>献上官方对 map 操作符的示意图</p>
<p><img src="/uploads/20191116/20191116165321.png" alt="map"></p>
<h1 id="Part_3"><a href="#Part_3" class="headerlink" title="Part 3"></a>Part 3</h1><p>这一小节来看看 subscribeOn 操作，先来看 demo</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hi rxjava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.subscribeOn(Schedulers.io())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先来看看 Schedulers.io() 中到底干了什么。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">io</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RxJavaHooks.onIOScheduler(getInstance().ioScheduler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是获取 Schedulers 单例中的 ioScheduler 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Schedulers <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Schedulers current = INSTANCE.get();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = <span class="keyword">new</span> Schedulers();</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            current.shutdownInstance();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Schedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">    RxJavaSchedulersHook hook = RxJavaPlugins.getInstance().getSchedulersHook();</span><br><span class="line"></span><br><span class="line">    Scheduler c = hook.getComputationScheduler();</span><br><span class="line">    <span class="keyword">if</span> (c != <span class="keyword">null</span>) &#123;</span><br><span class="line">        computationScheduler = c;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        computationScheduler = RxJavaSchedulersHook.createComputationScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Scheduler io = hook.getIOScheduler();</span><br><span class="line">    <span class="keyword">if</span> (io != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ioScheduler = io;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ioScheduler = RxJavaSchedulersHook.createIoScheduler();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Scheduler nt = hook.getNewThreadScheduler();</span><br><span class="line">    <span class="keyword">if</span> (nt != <span class="keyword">null</span>) &#123;</span><br><span class="line">        newThreadScheduler = nt;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        newThreadScheduler = RxJavaSchedulersHook.createNewThreadScheduler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ioScheduler 默认实现是 RxJavaSchedulersHook.createIoScheduler()</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> createIoScheduler(<span class="keyword">new</span> RxThreadFactory(<span class="string">"RxIoScheduler-"</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">createIoScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (threadFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"threadFactory == null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CachedThreadScheduler(threadFactory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认创建一个新的 CachedThreadScheduler 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CachedThreadScheduler</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">    <span class="keyword">this</span>.pool = <span class="keyword">new</span> AtomicReference&lt;CachedWorkerPool&gt;(NONE);</span><br><span class="line">    start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    CachedWorkerPool update =</span><br><span class="line">        <span class="keyword">new</span> CachedWorkerPool(threadFactory, KEEP_ALIVE_TIME, KEEP_ALIVE_UNIT);</span><br><span class="line">    <span class="keyword">if</span> (!pool.compareAndSet(NONE, update)) &#123;</span><br><span class="line">        update.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CachedWorkerPool 构造方法内部会去创建线程池。</p>
<p>然后回过头来看 subscribeOn 方法的内部代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> subscribeOn(scheduler, !(<span class="keyword">this</span>.onSubscribe <span class="keyword">instanceof</span> OnSubscribeCreate));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OperatorSubscribeOn&lt;T&gt;(<span class="keyword">this</span>, scheduler, requestOn));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现逻辑都是类似的，也是创建了一个新的 Observable , 而对应的 OnSubscribe 是一个 OperatorSubscribeOn 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">OperatorSubscribeOn</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">OperatorSubscribeOn</span><span class="params">(Observable&lt;T&gt; source, Scheduler scheduler, <span class="keyword">boolean</span> requestOn)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.scheduler = scheduler;</span><br><span class="line">        <span class="keyword">this</span>.source = source; <span class="comment">// 真正的 Observable</span></span><br><span class="line">        <span class="keyword">this</span>.requestOn = requestOn;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>按照以往的惯例，最后 subscribe 的时候肯定会调用 OperatorSubscribeOn 的 call 方法，所以我们直接去看 call 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Worker inner = scheduler.createWorker();</span><br><span class="line">    <span class="comment">// 创建时传入真正的 subscriber</span></span><br><span class="line">    SubscribeOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> SubscribeOnSubscriber&lt;T&gt;(subscriber, requestOn, inner, source);</span><br><span class="line">    subscriber.add(parent);</span><br><span class="line">    subscriber.add(inner);</span><br><span class="line"></span><br><span class="line">    inner.schedule(parent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>scheduler.createWorker() 是可以理解为在新的工作线程中去做某一个动作（Action0）。前面说过，这里的 scheduler 是 CachedThreadScheduler 类型，所以 createWorker 就是创建了一个 EventLoopWorker 对象。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Worker <span class="title">createWorker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> EventLoopWorker(pool.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用 inner.schedule 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (innerSubscription.isUnsubscribed()) &#123;</span><br><span class="line">        <span class="comment">// don't schedule, we are unsubscribed</span></span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// threadWorker.scheduleActual 就是调用了线程池去执行这个 action0</span></span><br><span class="line">    ScheduledAction s = threadWorker.scheduleActual(<span class="keyword">new</span> Action0() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (isUnsubscribed()) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这里的 action 就是上面的 SubscribeOnSubscriber 对象</span></span><br><span class="line">            <span class="comment">// 因此 SubscribeOnSubscriber 的 call 方法就在工作线程中被调用了 </span></span><br><span class="line">            action.call();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, delayTime, unit);</span><br><span class="line">    innerSubscription.add(s);</span><br><span class="line">    s.addParent(innerSubscription);</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就到 SubscribeOnSubscriber 的 call 方法中看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Observable&lt;T&gt; src = source;</span><br><span class="line">    source = <span class="keyword">null</span>;</span><br><span class="line">    t = Thread.currentThread();</span><br><span class="line">    <span class="comment">// 把真正的 Observable subscribe 到 SubscribeOnSubscriber 中</span></span><br><span class="line">    src.unsafeSubscribe(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，真正的 Observable 调用 call 方法时，会调用 SubscribeOnSubscriber 的 onNext 方法。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// actual 是真正我们自定义的 Subscriber</span></span><br><span class="line">    actual.onNext(t);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SubscribeOnSubscriber 中的 onNext 方法再把参数传给真正的 Subscriber 。</p>
<p>到这里，就把 subscribeOn 切换线程的原理讲完了。</p>
<h1 id="Part_4"><a href="#Part_4" class="headerlink" title="Part 4"></a>Part 4</h1><p>讲完了 subscribeOn ，再来看 observeOn 会简单很多。还是先来个 demo 吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">Observable.create(<span class="keyword">new</span> Observable.OnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> String&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onNext(<span class="string">"hi rxjava"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">.observeOn(AndroidSchedulers.mainThread())</span><br><span class="line">.subscribe(<span class="keyword">new</span> Subscriber&lt;String&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        System.out.println(s);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>先分析 AndroidSchedulers.mainThread() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Scheduler <span class="title">mainThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> getInstance().mainThreadScheduler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和 Schedulers.io 类似，也是去获取 AndroidSchedulers.mainThreadScheduler</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> AndroidSchedulers <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        AndroidSchedulers current = INSTANCE.get();</span><br><span class="line">        <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">        current = <span class="keyword">new</span> AndroidSchedulers();</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE.compareAndSet(<span class="keyword">null</span>, current)) &#123;</span><br><span class="line">            <span class="keyword">return</span> current;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">AndroidSchedulers</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RxAndroidSchedulersHook hook = RxAndroidPlugins.getInstance().getSchedulersHook();</span><br><span class="line"></span><br><span class="line">    Scheduler main = hook.getMainThreadScheduler();</span><br><span class="line">    <span class="keyword">if</span> (main != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mainThreadScheduler = main;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 传入主线程的 looper </span></span><br><span class="line">        mainThreadScheduler = <span class="keyword">new</span> LooperScheduler(Looper.getMainLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LooperScheduler 的构造方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LooperScheduler</span> <span class="keyword">extends</span> <span class="title">Scheduler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Handler handler;</span><br><span class="line"></span><br><span class="line">    LooperScheduler(Looper looper) &#123;</span><br><span class="line">        handler = <span class="keyword">new</span> Handler(looper);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LooperScheduler(Handler handler) &#123;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部就是创建了主线程的 Handler 。然后利用 Handler 去发送消息就行了。</p>
<p>那么我们就来看看 observeOn 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, RxRingBuffer.SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> observeOn(scheduler, <span class="keyword">false</span>, bufferSize);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(Scheduler scheduler, <span class="keyword">boolean</span> delayError, <span class="keyword">int</span> bufferSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> <span class="keyword">instanceof</span> ScalarSynchronousObservable) &#123;</span><br><span class="line">        <span class="keyword">return</span> ((ScalarSynchronousObservable&lt;T&gt;)<span class="keyword">this</span>).scalarScheduleOn(scheduler);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lift(<span class="keyword">new</span> OperatorObserveOn&lt;T&gt;(scheduler, delayError, bufferSize));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 observeOn 内部利用了 lift ，那么什么是 lift 呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(<span class="keyword">final</span> Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafeCreate(<span class="keyword">new</span> OnSubscribeLift&lt;T, R&gt;(onSubscribe, operator));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 lift 内部也是去创建一个新的 Observable ，而且 Observable.OnSubscribe 是一个 OnSubscribeLift 对象。套路都是相似的，不一样的就是需要额外传入一个 Operator 对象。从上面可知， Operator 就是一个 OperatorObserveOn 对象。</p>
<p>接着就去 OnSubscribeLift 的 call 方法中看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> R&gt; o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 执行 operator.call 方法，返回一个 Subscriber 对象</span></span><br><span class="line">        Subscriber&lt;? <span class="keyword">super</span> T&gt; st = RxJavaHooks.onObservableLift(operator).call(o);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// new Subscriber created and being subscribed with so 'onStart' it</span></span><br><span class="line">            st.onStart();</span><br><span class="line">            <span class="comment">// 这里的 parent 就是我们真正的 onSubscribe</span></span><br><span class="line">            parent.call(st);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// localized capture of errors rather than it skipping all operators</span></span><br><span class="line">            <span class="comment">// and ending up in the try/catch of the subscribe method which then</span></span><br><span class="line">            <span class="comment">// prevents onErrorResumeNext and other similar approaches to error handling</span></span><br><span class="line">            Exceptions.throwIfFatal(e);</span><br><span class="line">            st.onError(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        Exceptions.throwIfFatal(e);</span><br><span class="line">        <span class="comment">// if the lift function failed all we can do is pass the error to the final Subscriber</span></span><br><span class="line">        <span class="comment">// as we don't have the operator available to us</span></span><br><span class="line">        o.onError(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 <code>RxJavaHooks.onObservableLift(operator).call(o);</code> ，可以猜到默认hook就是返回 operator 本身。那么我们到 operator.call 中看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; call(Subscriber&lt;? <span class="keyword">super</span> T&gt; child) &#123;</span><br><span class="line">    <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> ImmediateScheduler) &#123;</span><br><span class="line">        <span class="comment">// avoid overhead, execute directly</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (scheduler <span class="keyword">instanceof</span> TrampolineScheduler) &#123;</span><br><span class="line">        <span class="comment">// avoid overhead, execute directly</span></span><br><span class="line">        <span class="keyword">return</span> child;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ObserveOnSubscriber&lt;T&gt; parent = <span class="keyword">new</span> ObserveOnSubscriber&lt;T&gt;(scheduler, child, delayError, bufferSize);</span><br><span class="line">        parent.init();</span><br><span class="line">        <span class="keyword">return</span> parent;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从前面的代码可以知道，这里是 scheduler 是 AndroidScheduler 。所以这里会返回一个 ObserveOnSubscriber 对象。从上面的代码可知，返回了 ObserveOnSubscriber 对象之后，会调用 <code>parent.call(st)</code> 。这里的 parent 就是最原始，也就是我们自定义的 Observable 。所以最后代码就走到了 ObserveOnSubscriber 的 onNext 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserveOnSubscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Action0</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (isUnsubscribed() || finished) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!queue.offer(NotificationLite.next(t))) &#123;</span><br><span class="line">            onError(<span class="keyword">new</span> MissingBackpressureException());</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (counter.getAndIncrement() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 这里的 recursiveScheduler 就是 LooperScheduler</span></span><br><span class="line">            <span class="comment">// 注意这里 schedule 的参数是 this ！！！</span></span><br><span class="line">            recursiveScheduler.schedule(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里会调用 LooperScheduler 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(<span class="keyword">final</span> Action0 action)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里的 action 参数就是 ObserveOnSubscriber 对象</span></span><br><span class="line">    <span class="keyword">return</span> schedule(action, <span class="number">0</span>, TimeUnit.MILLISECONDS);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Subscription <span class="title">schedule</span><span class="params">(Action0 action, <span class="keyword">long</span> delayTime, TimeUnit unit)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (unsubscribed) &#123;</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    action = hook.onSchedule(action);</span><br><span class="line">    <span class="comment">// ScheduledAction 实现了 Runnable 接口</span></span><br><span class="line">    ScheduledAction scheduledAction = <span class="keyword">new</span> ScheduledAction(action, handler);</span><br><span class="line">    <span class="comment">// 之后该 message 会在主线程中取出，然后执行 ScheduledAction</span></span><br><span class="line">    Message message = Message.obtain(handler, scheduledAction);</span><br><span class="line">    message.obj = <span class="keyword">this</span>; <span class="comment">// Used as token for unsubscription operation.</span></span><br><span class="line"></span><br><span class="line">    handler.sendMessageDelayed(message, unit.toMillis(delayTime));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (unsubscribed) &#123;</span><br><span class="line">        handler.removeCallbacks(scheduledAction);</span><br><span class="line">        <span class="keyword">return</span> Subscriptions.unsubscribed();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> scheduledAction;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LooperScheduler.schedule 主要做的就是构造出 message ，然后利用 Handler 把 message 发送到主线程中去执行。所以接着代码就到了 ScheduledAction.run 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledAction</span> <span class="keyword">implements</span> <span class="title">Runnable</span>, <span class="title">Subscription</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 这里的 action 参数就是 ObserveOnSubscriber 对象</span></span><br><span class="line">            <span class="comment">// 所以会调用 ObserveOnSubscriber.call       </span></span><br><span class="line">            action.call();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="comment">// nothing to do but print a System error as this is fatal and there is nowhere else to throw this</span></span><br><span class="line">            IllegalStateException ie;</span><br><span class="line">            <span class="keyword">if</span> (e <span class="keyword">instanceof</span> OnErrorNotImplementedException) &#123;</span><br><span class="line">                ie = <span class="keyword">new</span> IllegalStateException(<span class="string">"Exception thrown on Scheduler.Worker thread. Add `onError` handling."</span>, e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                ie = <span class="keyword">new</span> IllegalStateException(<span class="string">"Fatal Exception thrown on Scheduler.Worker thread."</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">            RxJavaPlugins.getInstance().getErrorHandler().handleError(ie);</span><br><span class="line">            Thread thread = Thread.currentThread();</span><br><span class="line">            thread.getUncaughtExceptionHandler().uncaughtException(thread, ie);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ScheduledAction.run 是在主线程中运行的，而 run 方法中调用了 <code>action.call();</code> 。action 其实就是原来那个 ObserveOnSubscriber 对象。</p>
<p>所以代码再次跳转到 ObserveOnSubscriber.call 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// only execute this from schedule()</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> missed = <span class="number">1L</span>;</span><br><span class="line">    <span class="keyword">long</span> currentEmission = emitted;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// these are accessed in a tight loop around atomics so</span></span><br><span class="line">    <span class="comment">// loading them into local variables avoids the mandatory re-reading</span></span><br><span class="line">    <span class="comment">// of the constant fields</span></span><br><span class="line">    <span class="keyword">final</span> Queue&lt;Object&gt; q = <span class="keyword">this</span>.queue;</span><br><span class="line">    <span class="comment">// 这里的 child 就是真正的我们自定义的 Subscriber</span></span><br><span class="line">    <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; localChild = <span class="keyword">this</span>.child; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// requested and counter are not included to avoid JIT issues with register spilling</span></span><br><span class="line">    <span class="comment">// and their access is is amortized because they are part of the outer loop which runs</span></span><br><span class="line">    <span class="comment">// less frequently (usually after each bufferSize elements)</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">long</span> requestAmount = requested.get();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (requestAmount != currentEmission) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> done = finished;</span><br><span class="line">            Object v = q.poll();</span><br><span class="line">            <span class="keyword">boolean</span> empty = v == <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(done, empty, localChild, q)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (empty) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在主线程中调用了真正的 Subscriber 的 onNext 方法       </span></span><br><span class="line">            localChild.onNext(NotificationLite.&lt;T&gt;getValue(v));</span><br><span class="line"></span><br><span class="line">            currentEmission++;</span><br><span class="line">            <span class="keyword">if</span> (currentEmission == limit) &#123;</span><br><span class="line">                requestAmount = BackpressureUtils.produced(requested, currentEmission);</span><br><span class="line">                request(currentEmission);</span><br><span class="line">                currentEmission = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (requestAmount == currentEmission) &#123;</span><br><span class="line">            <span class="keyword">if</span> (checkTerminated(finished, q.isEmpty(), localChild, q)) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        emitted = currentEmission;</span><br><span class="line">        missed = counter.addAndGet(-missed);</span><br><span class="line">        <span class="keyword">if</span> (missed == <span class="number">0L</span>) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，observeOn 实现切换线程的原理就讲完了。基本的 RxJava 操作中的源码也都讲了一遍。至于其他的操作符后面有空再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本文中的源码基于 RxJava1<br>RxJava : io.reactivex:rxjava:1.3.4</p>
<p>以下是各个 Part 主要分析源码的方向</p>
<ul>
<li>Part 1: Observable, Observable.OnSubscrib]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="RxJava" scheme="http://yuqirong.github.io/tags/RxJava/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Broadcast源码解析]]></title>
    <link href="http://yuqirong.github.io/2019/11/10/Broadcast%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.github.io/2019/11/10/Broadcast源码解析/</id>
    <published>2019-11-10T08:13:22.000Z</published>
    <updated>2019-11-13T14:02:00.372Z</updated>
    <content type="html"><![CDATA[<h1 id="u6CE8_u518C_u5E7F_u64AD"><a href="#u6CE8_u518C_u5E7F_u64AD" class="headerlink" title="注册广播"></a>注册广播</h1><h2 id="ContextImpl"><a href="#ContextImpl" class="headerlink" title="ContextImpl"></a>ContextImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiver(receiver, filter, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(BroadcastReceiver receiver, IntentFilter filter,</span><br><span class="line">        String broadcastPermission, Handler scheduler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> registerReceiverInternal(receiver, getUserId(),</span><br><span class="line">            filter, broadcastPermission, scheduler, getOuterContext());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Intent <span class="title">registerReceiverInternal</span><span class="params">(BroadcastReceiver receiver, <span class="keyword">int</span> userId,</span><br><span class="line">        IntentFilter filter, String broadcastPermission,</span><br><span class="line">        Handler scheduler, Context context)</span> </span>&#123;</span><br><span class="line">    IIntentReceiver rd = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (receiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mPackageInfo != <span class="keyword">null</span> &amp;&amp; context != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            		<span class="comment">// 如果没指定广播接收在哪个线程的handler，就默认主线程的handler</span></span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = mPackageInfo.getReceiverDispatcher(</span><br><span class="line">                receiver, context, scheduler,</span><br><span class="line">                mMainThread.getInstrumentation(), <span class="keyword">true</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (scheduler == <span class="keyword">null</span>) &#123;</span><br><span class="line">                scheduler = mMainThread.getHandler();</span><br><span class="line">            &#125;</span><br><span class="line">            rd = <span class="keyword">new</span> LoadedApk.ReceiverDispatcher(</span><br><span class="line">                    receiver, context, scheduler, <span class="keyword">null</span>, <span class="keyword">true</span>).getIIntentReceiver();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> ActivityManagerNative.getDefault().registerReceiver(</span><br><span class="line">                mMainThread.getApplicationThread(), mBasePackageName,</span><br><span class="line">                rd, filter, broadcastPermission, userId);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="LoadedApk"><a href="#LoadedApk" class="headerlink" title="LoadedApk"></a>LoadedApk</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> IIntentReceiver <span class="title">getReceiverDispatcher</span><span class="params">(BroadcastReceiver r,</span><br><span class="line">        Context context, Handler handler,</span><br><span class="line">        Instrumentation instrumentation, <span class="keyword">boolean</span> registered)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mReceivers) &#123;</span><br><span class="line">        LoadedApk.ReceiverDispatcher rd = <span class="keyword">null</span>;</span><br><span class="line">        ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt; map = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">            map = mReceivers.get(context);</span><br><span class="line">            <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rd = map.get(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (rd == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rd = <span class="keyword">new</span> ReceiverDispatcher(r, context, handler,</span><br><span class="line">                    instrumentation, registered);</span><br><span class="line">            <span class="keyword">if</span> (registered) &#123;</span><br><span class="line">                <span class="keyword">if</span> (map == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    map = <span class="keyword">new</span> ArrayMap&lt;BroadcastReceiver, LoadedApk.ReceiverDispatcher&gt;();</span><br><span class="line">                    mReceivers.put(context, map);</span><br><span class="line">                &#125;</span><br><span class="line">                map.put(r, rd);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            rd.validate(context, handler);</span><br><span class="line">        &#125;</span><br><span class="line">        rd.mForgotten = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">return</span> rd.getIIntentReceiver();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReceiverDispatcher"><a href="#ReceiverDispatcher" class="headerlink" title="ReceiverDispatcher"></a>ReceiverDispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ReceiverDispatcher(BroadcastReceiver receiver, Context context,</span><br><span class="line">        Handler activityThread, Instrumentation instrumentation,</span><br><span class="line">        <span class="keyword">boolean</span> registered) &#123;</span><br><span class="line">    <span class="keyword">if</span> (activityThread == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"Handler must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 其实是个 binder 对象</span></span><br><span class="line">    mIIntentReceiver = <span class="keyword">new</span> InnerReceiver(<span class="keyword">this</span>, !registered);</span><br><span class="line">    mReceiver = receiver;</span><br><span class="line">    mContext = context;</span><br><span class="line">    mActivityThread = activityThread;</span><br><span class="line">    mInstrumentation = instrumentation;</span><br><span class="line">    mRegistered = registered;</span><br><span class="line">    mLocation = <span class="keyword">new</span> IntentReceiverLeaked(<span class="keyword">null</span>);</span><br><span class="line">    mLocation.fillInStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityManagerNative"><a href="#ActivityManagerNative" class="headerlink" title="ActivityManagerNative"></a>ActivityManagerNative</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String packageName,</span><br><span class="line">        IIntentReceiver receiver,</span><br><span class="line">        IntentFilter filter, String perm, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeString(packageName);</span><br><span class="line">    data.writeStrongBinder(receiver != <span class="keyword">null</span> ? receiver.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    filter.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(perm);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    mRemote.transact(REGISTER_RECEIVER_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    Intent intent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> haveIntent = reply.readInt();</span><br><span class="line">    <span class="keyword">if</span> (haveIntent != <span class="number">0</span>) &#123;</span><br><span class="line">        intent = Intent.CREATOR.createFromParcel(reply);</span><br><span class="line">    &#125;</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> intent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">registerReceiver</span><span class="params">(IApplicationThread caller, String callerPackage,</span><br><span class="line">        IIntentReceiver receiver, IntentFilter filter, String permission, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"registerReceiver"</span>);</span><br><span class="line">    ArrayList&lt;Intent&gt; stickyIntents = <span class="keyword">null</span>;</span><br><span class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> callingUid;</span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callerApp = getRecordForAppLocked(caller);</span><br><span class="line">            <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                        <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                        + <span class="string">" (pid="</span> + Binder.getCallingPid()</span><br><span class="line">                        + <span class="string">") when registering receiver "</span> + receiver);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (callerApp.info.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">                    !callerApp.pkgList.containsKey(callerPackage) &amp;&amp;</span><br><span class="line">                    !<span class="string">"android"</span>.equals(callerPackage)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Given caller package "</span> + callerPackage</span><br><span class="line">                        + <span class="string">" is not running in process "</span> + callerApp);</span><br><span class="line">            &#125;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callerPackage = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = Binder.getCallingUid();</span><br><span class="line">            callingPid = Binder.getCallingPid();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        userId = handleIncomingUser(callingPid, callingUid, userId,</span><br><span class="line">                <span class="keyword">true</span>, ALLOW_FULL_ONLY, <span class="string">"registerReceiver"</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">        Iterator&lt;String&gt; actions = filter.actionsIterator();</span><br><span class="line">        <span class="keyword">if</span> (actions == <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;String&gt; noAction = <span class="keyword">new</span> ArrayList&lt;String&gt;(<span class="number">1</span>);</span><br><span class="line">            noAction.add(<span class="keyword">null</span>);</span><br><span class="line">            actions = noAction.iterator();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Collect stickies of users</span></span><br><span class="line">        <span class="keyword">int</span>[] userIds = &#123; UserHandle.USER_ALL, UserHandle.getUserId(callingUid) &#125;;</span><br><span class="line">        <span class="keyword">while</span> (actions.hasNext()) &#123;</span><br><span class="line">            String action = actions.next();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> id : userIds) &#123;</span><br><span class="line">                ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(id);</span><br><span class="line">                <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    ArrayList&lt;Intent&gt; intents = stickies.get(action);</span><br><span class="line">                    <span class="keyword">if</span> (intents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (stickyIntents == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            stickyIntents = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                        &#125;</span><br><span class="line">                        stickyIntents.addAll(intents);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;Intent&gt; allSticky = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (stickyIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ContentResolver resolver = mContext.getContentResolver();</span><br><span class="line">        <span class="comment">// Look for any matching sticky broadcasts...</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, N = stickyIntents.size(); i &lt; N; i++) &#123;</span><br><span class="line">            Intent intent = stickyIntents.get(i);</span><br><span class="line">            <span class="comment">// If intent has scheme "content", it will need to acccess</span></span><br><span class="line">            <span class="comment">// provider that needs to lock mProviderMap in ActivityThread</span></span><br><span class="line">            <span class="comment">// and also it may need to wait application response, so we</span></span><br><span class="line">            <span class="comment">// cannot lock ActivityManagerService here.</span></span><br><span class="line">            <span class="keyword">if</span> (filter.match(resolver, intent, <span class="keyword">true</span>, TAG) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (allSticky == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    allSticky = <span class="keyword">new</span> ArrayList&lt;Intent&gt;();</span><br><span class="line">                &#125;</span><br><span class="line">                allSticky.add(intent);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The first sticky in the list is returned directly back to the client.</span></span><br><span class="line">    Intent sticky = allSticky != <span class="keyword">null</span> ? allSticky.get(<span class="number">0</span>) : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Register receiver "</span> + filter + <span class="string">": "</span> + sticky);</span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span> &amp;&amp; (callerApp.thread == <span class="keyword">null</span></span><br><span class="line">                || callerApp.thread.asBinder() != caller.asBinder())) &#123;</span><br><span class="line">            <span class="comment">// Original caller already died</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ReceiverList rl = mRegisteredReceivers.get(receiver.asBinder());</span><br><span class="line">        <span class="keyword">if</span> (rl == <span class="keyword">null</span>) &#123;</span><br><span class="line">            rl = <span class="keyword">new</span> ReceiverList(<span class="keyword">this</span>, callerApp, callingPid, callingUid,</span><br><span class="line">                    userId, receiver);</span><br><span class="line">            <span class="keyword">if</span> (rl.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                rl.app.receivers.add(rl);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    receiver.asBinder().linkToDeath(rl, <span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    <span class="keyword">return</span> sticky;</span><br><span class="line">                &#125;</span><br><span class="line">                rl.linkedToDeath = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            mRegisteredReceivers.put(receiver.asBinder(), rl);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.uid != callingUid) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for uid "</span> + callingUid</span><br><span class="line">                    + <span class="string">" was previously registered for uid "</span> + rl.uid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.pid != callingPid) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for pid "</span> + callingPid</span><br><span class="line">                    + <span class="string">" was previously registered for pid "</span> + rl.pid);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (rl.userId != userId) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"Receiver requested to register for user "</span> + userId</span><br><span class="line">                    + <span class="string">" was previously registered for user "</span> + rl.userId);</span><br><span class="line">        &#125;</span><br><span class="line">        BroadcastFilter bf = <span class="keyword">new</span> BroadcastFilter(filter, rl, callerPackage,</span><br><span class="line">                permission, callingUid, userId);</span><br><span class="line">        rl.add(bf);</span><br><span class="line">        <span class="keyword">if</span> (!bf.debugCheck()) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"==&gt; For Dynamic broadcast"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mReceiverResolver.addFilter(bf);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Enqueue broadcasts for all existing stickies that match</span></span><br><span class="line">        <span class="comment">// this filter.</span></span><br><span class="line">        <span class="keyword">if</span> (allSticky != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">            receivers.add(bf);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> stickyCount = allSticky.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; stickyCount; i++) &#123;</span><br><span class="line">                Intent intent = allSticky.get(i);</span><br><span class="line">                BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">                BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">1</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, receivers,</span><br><span class="line">                        <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, -<span class="number">1</span>);</span><br><span class="line">                queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">                queue.scheduleBroadcastsLocked();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> sticky;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u53D1_u9001_u5E7F_u64AD"><a href="#u53D1_u9001_u5E7F_u64AD" class="headerlink" title="发送广播"></a>发送广播</h1><h2 id="ContextImpl-1"><a href="#ContextImpl-1" class="headerlink" title="ContextImpl"></a>ContextImpl</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">sendBroadcast</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    warnIfCallingFromSystemProcess();</span><br><span class="line">    String resolvedType = intent.resolveTypeIfNeeded(getContentResolver());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.prepareToLeaveProcess();</span><br><span class="line">        ActivityManagerNative.getDefault().broadcastIntent(</span><br><span class="line">                mMainThread.getApplicationThread(), intent, resolvedType, <span class="keyword">null</span>,</span><br><span class="line">                Activity.RESULT_OK, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, AppOpsManager.OP_NONE, <span class="keyword">null</span>, <span class="keyword">false</span>, <span class="keyword">false</span>,</span><br><span class="line">                getUserId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityManagerNative-1"><a href="#ActivityManagerNative-1" class="headerlink" title="ActivityManagerNative"></a>ActivityManagerNative</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span><br><span class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">        <span class="keyword">int</span> resultCode, String resultData, Bundle map,</span><br><span class="line">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options, <span class="keyword">boolean</span> serialized,</span><br><span class="line">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> <span class="keyword">throws</span> RemoteException</span><br><span class="line"></span>&#123;</span><br><span class="line">    Parcel data = Parcel.obtain();</span><br><span class="line">    Parcel reply = Parcel.obtain();</span><br><span class="line">    data.writeInterfaceToken(IActivityManager.descriptor);</span><br><span class="line">    data.writeStrongBinder(caller != <span class="keyword">null</span> ? caller.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    intent.writeToParcel(data, <span class="number">0</span>);</span><br><span class="line">    data.writeString(resolvedType);</span><br><span class="line">    data.writeStrongBinder(resultTo != <span class="keyword">null</span> ? resultTo.asBinder() : <span class="keyword">null</span>);</span><br><span class="line">    data.writeInt(resultCode);</span><br><span class="line">    data.writeString(resultData);</span><br><span class="line">    data.writeBundle(map);</span><br><span class="line">    data.writeStringArray(requiredPermissions);</span><br><span class="line">    data.writeInt(appOp);</span><br><span class="line">    data.writeBundle(options);</span><br><span class="line">    data.writeInt(serialized ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(sticky ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">    data.writeInt(userId);</span><br><span class="line">    mRemote.transact(BROADCAST_INTENT_TRANSACTION, data, reply, <span class="number">0</span>);</span><br><span class="line">    reply.readException();</span><br><span class="line">    <span class="keyword">int</span> res = reply.readInt();</span><br><span class="line">    reply.recycle();</span><br><span class="line">    data.recycle();</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityManagerService-1"><a href="#ActivityManagerService-1" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntent</span><span class="params">(IApplicationThread caller,</span><br><span class="line">        Intent intent, String resolvedType, IIntentReceiver resultTo,</span><br><span class="line">        <span class="keyword">int</span> resultCode, String resultData, Bundle resultExtras,</span><br><span class="line">        String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options,</span><br><span class="line">        <span class="keyword">boolean</span> serialized, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"broadcastIntent"</span>);</span><br><span class="line">    <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">        intent = verifyBroadcastLocked(intent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ProcessRecord callerApp = getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingPid = Binder.getCallingPid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> callingUid = Binder.getCallingUid();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">int</span> res = broadcastIntentLocked(callerApp,</span><br><span class="line">                callerApp != <span class="keyword">null</span> ? callerApp.info.packageName : <span class="keyword">null</span>,</span><br><span class="line">                intent, resolvedType, resultTo, resultCode, resultData, resultExtras,</span><br><span class="line">                requiredPermissions, appOp, <span class="keyword">null</span>, serialized, sticky,</span><br><span class="line">                callingPid, callingUid, userId);</span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">broadcastIntentLocked</span><span class="params">(ProcessRecord callerApp,</span><br><span class="line">        String callerPackage, Intent intent, String resolvedType,</span><br><span class="line">        IIntentReceiver resultTo, <span class="keyword">int</span> resultCode, String resultData,</span><br><span class="line">        Bundle resultExtras, String[] requiredPermissions, <span class="keyword">int</span> appOp, Bundle options,</span><br><span class="line">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid, <span class="keyword">int</span> userId)</span> </span>&#123;</span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// By default broadcasts do not go to stopped apps.</span></span><br><span class="line">    intent.addFlags(Intent.FLAG_EXCLUDE_STOPPED_PACKAGES);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have not finished booting, don't allow this to launch new processes.</span></span><br><span class="line">    <span class="keyword">if</span> (!mProcessesReady &amp;&amp; (intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>) &#123;</span><br><span class="line">        intent.addFlags(Intent.FLAG_RECEIVER_REGISTERED_ONLY);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">            (sticky ? <span class="string">"Broadcast sticky: "</span>: <span class="string">"Broadcast: "</span>) + intent</span><br><span class="line">            + <span class="string">" ordered="</span> + ordered + <span class="string">" userid="</span> + userId);</span><br><span class="line">    <span class="keyword">if</span> ((resultTo != <span class="keyword">null</span>) &amp;&amp; !ordered) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Broadcast "</span> + intent + <span class="string">" not ordered but result callback requested!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    userId = handleIncomingUser(callingPid, callingUid, userId,</span><br><span class="line">            <span class="keyword">true</span>, ALLOW_NON_FULL, <span class="string">"broadcast"</span>, callerPackage);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who is receiving this broadcast is running.</span></span><br><span class="line">    <span class="comment">// If not, we will just skip it. Make an exception for shutdown broadcasts</span></span><br><span class="line">    <span class="comment">// and upgrade steps.</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userId != UserHandle.USER_ALL &amp;&amp; !isUserRunningLocked(userId, <span class="keyword">false</span>)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((callingUid != Process.SYSTEM_UID</span><br><span class="line">                || (intent.getFlags() &amp; Intent.FLAG_RECEIVER_BOOT_UPGRADE) == <span class="number">0</span>)</span><br><span class="line">                &amp;&amp; !Intent.ACTION_SHUTDOWN.equals(intent.getAction())) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping broadcast of "</span> + intent</span><br><span class="line">                    + <span class="string">": user "</span> + userId + <span class="string">" is stopped"</span>);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_FAILED_USER_STOPPED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BroadcastOptions brOptions = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        brOptions = <span class="keyword">new</span> BroadcastOptions(options);</span><br><span class="line">        <span class="keyword">if</span> (brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// See if the caller is allowed to do this.  Note we are checking against</span></span><br><span class="line">            <span class="comment">// the actual real caller (not whoever provided the operation as say a</span></span><br><span class="line">            <span class="comment">// PendingIntent), because that who is actually supplied the arguments.</span></span><br><span class="line">            <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                    android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST,</span><br><span class="line">                    Binder.getCallingPid(), Binder.getCallingUid(), -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                    != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                        + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span></span><br><span class="line">                        + android.Manifest.permission.CHANGE_DEVICE_IDLE_TEMP_WHITELIST;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Prevent non-system code (defined here to be non-persistent</span><br><span class="line">     * processes) from sending protected broadcasts.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">int</span> callingAppId = UserHandle.getAppId(callingUid);</span><br><span class="line">    <span class="keyword">if</span> (callingAppId == Process.SYSTEM_UID || callingAppId == Process.PHONE_UID</span><br><span class="line">        || callingAppId == Process.SHELL_UID || callingAppId == Process.BLUETOOTH_UID</span><br><span class="line">        || callingAppId == Process.NFC_UID || callingUid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// Always okay.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (callerApp == <span class="keyword">null</span> || !callerApp.persistent) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (AppGlobals.getPackageManager().isProtectedBroadcast(</span><br><span class="line">                    intent.getAction())) &#123;</span><br><span class="line">                String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                        + intent.getAction() + <span class="string">" from pid="</span></span><br><span class="line">                        + callingPid + <span class="string">", uid="</span> + callingUid;</span><br><span class="line">                Slog.w(TAG, msg);</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AppWidgetManager.ACTION_APPWIDGET_CONFIGURE.equals(intent.getAction())) &#123;</span><br><span class="line">                <span class="comment">// Special case for compatibility: we don't want apps to send this,</span></span><br><span class="line">                <span class="comment">// but historically it has not been protected and apps may be using it</span></span><br><span class="line">                <span class="comment">// to poke their own app widget.  So, instead of making it protected,</span></span><br><span class="line">                <span class="comment">// just limit it to the caller.</span></span><br><span class="line">                <span class="keyword">if</span> (callerApp == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                            + intent.getAction() + <span class="string">" from unknown caller."</span>;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// They are good enough to send to an explicit component...  verify</span></span><br><span class="line">                    <span class="comment">// it is being sent to the calling app.</span></span><br><span class="line">                    <span class="keyword">if</span> (!intent.getComponent().getPackageName().equals(</span><br><span class="line">                            callerApp.info.packageName)) &#123;</span><br><span class="line">                        String msg = <span class="string">"Permission Denial: not allowed to send broadcast "</span></span><br><span class="line">                                + intent.getAction() + <span class="string">" to "</span></span><br><span class="line">                                + intent.getComponent().getPackageName() + <span class="string">" from "</span></span><br><span class="line">                                + callerApp.info.packageName;</span><br><span class="line">                        Slog.w(TAG, msg);</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// Limit broadcast to their own package.</span></span><br><span class="line">                    intent.setPackage(callerApp.info.packageName);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Remote exception"</span>, e);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> String action = intent.getAction();</span><br><span class="line">    <span class="keyword">if</span> (action != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                <span class="comment">// Handle special intents: if this broadcast is from the package</span></span><br><span class="line">                <span class="comment">// manager about a package being removed, we need to remove all of</span></span><br><span class="line">                <span class="comment">// its activities from the history stack.</span></span><br><span class="line">                <span class="keyword">if</span> (checkComponentPermission(</span><br><span class="line">                        android.Manifest.permission.BROADCAST_PACKAGE_REMOVED,</span><br><span class="line">                        callingPid, callingUid, -<span class="number">1</span>, <span class="keyword">true</span>)</span><br><span class="line">                        != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    String msg = <span class="string">"Permission Denial: "</span> + intent.getAction()</span><br><span class="line">                            + <span class="string">" broadcast from "</span> + callerPackage + <span class="string">" (pid="</span> + callingPid</span><br><span class="line">                            + <span class="string">", uid="</span> + callingUid + <span class="string">")"</span></span><br><span class="line">                            + <span class="string">" requires "</span></span><br><span class="line">                            + android.Manifest.permission.BROADCAST_PACKAGE_REMOVED;</span><br><span class="line">                    Slog.w(TAG, msg);</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">switch</span> (action) &#123;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_UID_REMOVED:</span><br><span class="line">                        <span class="keyword">final</span> Bundle intentExtras = intent.getExtras();</span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">int</span> uid = intentExtras != <span class="keyword">null</span></span><br><span class="line">                                ? intentExtras.getInt(Intent.EXTRA_UID) : -<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">if</span> (uid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                            mBatteryStatsService.removeUid(uid);</span><br><span class="line">                            mAppOpsService.uidRemoved(uid);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_UNAVAILABLE:</span><br><span class="line">                        <span class="comment">// If resources are unavailable just force stop all those packages</span></span><br><span class="line">                        <span class="comment">// and flush the attribute cache as well.</span></span><br><span class="line">                        String list[] =</span><br><span class="line">                                intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">                        <span class="keyword">if</span> (list != <span class="keyword">null</span> &amp;&amp; list.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; list.length; i++) &#123;</span><br><span class="line">                                forceStopPackageLocked(list[i], -<span class="number">1</span>, <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>,</span><br><span class="line">                                        <span class="keyword">false</span>, <span class="keyword">false</span>, userId, <span class="string">"storage unmount"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                            sendPackageBroadcastLocked(</span><br><span class="line">                                    IApplicationThread.EXTERNAL_STORAGE_UNAVAILABLE, list,</span><br><span class="line">                                    userId);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE:</span><br><span class="line">                        mRecentTasks.cleanupLocked(UserHandle.USER_ALL);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_REMOVED:</span><br><span class="line">                    <span class="keyword">case</span> Intent.ACTION_PACKAGE_CHANGED:</span><br><span class="line">                        Uri data = intent.getData();</span><br><span class="line">                        String ssp;</span><br><span class="line">                        <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp=data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> removed = Intent.ACTION_PACKAGE_REMOVED.equals(action);</span><br><span class="line">                            <span class="keyword">boolean</span> fullUninstall = removed &amp;&amp;</span><br><span class="line">                                    !intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                            <span class="keyword">if</span> (!intent.getBooleanExtra(Intent.EXTRA_DONT_KILL_APP, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                                forceStopPackageLocked(ssp, UserHandle.getAppId(</span><br><span class="line">                                        intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>)),</span><br><span class="line">                                        <span class="keyword">false</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>, fullUninstall, userId,</span><br><span class="line">                                        removed ? <span class="string">"pkg removed"</span> : <span class="string">"pkg changed"</span>);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (removed) &#123;</span><br><span class="line">                                sendPackageBroadcastLocked(IApplicationThread.PACKAGE_REMOVED,</span><br><span class="line">                                        <span class="keyword">new</span> String[] &#123;ssp&#125;, userId);</span><br><span class="line">                                <span class="keyword">if</span> (fullUninstall) &#123;</span><br><span class="line">                                    mAppOpsService.packageRemoved(</span><br><span class="line">                                            intent.getIntExtra(Intent.EXTRA_UID, -<span class="number">1</span>), ssp);</span><br><span class="line"></span><br><span class="line">                                    <span class="comment">// Remove all permissions granted from/to this package</span></span><br><span class="line">                                    removeUriPermissionsForPackageLocked(ssp, userId, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">                                    removeTasksByPackageNameLocked(ssp, userId);</span><br><span class="line">                                    mBatteryStatsService.notePackageUninstalled(ssp);</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                                cleanupDisabledPackageComponentsLocked(ssp, userId,</span><br><span class="line">                                        intent.getStringArrayExtra(</span><br><span class="line">                                                Intent.EXTRA_CHANGED_COMPONENT_NAME_LIST));</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_PACKAGE_ADDED:</span><br><span class="line">                <span class="comment">// Special case for adding a package: by default turn on compatibility mode.</span></span><br><span class="line">                Uri data = intent.getData();</span><br><span class="line">                String ssp;</span><br><span class="line">                <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; (ssp = data.getSchemeSpecificPart()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> replacing =</span><br><span class="line">                            intent.getBooleanExtra(Intent.EXTRA_REPLACING, <span class="keyword">false</span>);</span><br><span class="line">                    mCompatModePackages.handlePackageAddedLocked(ssp, replacing);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        ApplicationInfo ai = AppGlobals.getPackageManager().</span><br><span class="line">                                getApplicationInfo(ssp, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                        mBatteryStatsService.notePackageInstalled(ssp,</span><br><span class="line">                                ai != <span class="keyword">null</span> ? ai.versionCode : <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIMEZONE_CHANGED:</span><br><span class="line">                <span class="comment">// If this is the time zone changed action, queue up a message that will reset</span></span><br><span class="line">                <span class="comment">// the timezone of all currently running processes. This message will get</span></span><br><span class="line">                <span class="comment">// queued up before the broadcast happens.</span></span><br><span class="line">                mHandler.sendEmptyMessage(UPDATE_TIME_ZONE);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_TIME_CHANGED:</span><br><span class="line">                <span class="comment">// If the user set the time, let all running processes know.</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> is24Hour =</span><br><span class="line">                        intent.getBooleanExtra(Intent.EXTRA_TIME_PREF_24_HOUR_FORMAT, <span class="keyword">false</span>) ? <span class="number">1</span></span><br><span class="line">                                : <span class="number">0</span>;</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_TIME, is24Hour, <span class="number">0</span>));</span><br><span class="line">                BatteryStatsImpl stats = mBatteryStatsService.getActiveStatistics();</span><br><span class="line">                <span class="keyword">synchronized</span> (stats) &#123;</span><br><span class="line">                    stats.noteCurrentTimeChangedLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Intent.ACTION_CLEAR_DNS_CACHE:</span><br><span class="line">                mHandler.sendEmptyMessage(CLEAR_DNS_CACHE_MSG);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> Proxy.PROXY_CHANGE_ACTION:</span><br><span class="line">                ProxyInfo proxy = intent.getParcelableExtra(Proxy.EXTRA_PROXY_INFO);</span><br><span class="line">                mHandler.sendMessage(mHandler.obtainMessage(UPDATE_HTTP_PROXY_MSG, proxy));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add to the sticky list if requested.</span></span><br><span class="line">    <span class="keyword">if</span> (sticky) &#123;</span><br><span class="line">        <span class="keyword">if</span> (checkPermission(android.Manifest.permission.BROADCAST_STICKY,</span><br><span class="line">                callingPid, callingUid)</span><br><span class="line">                != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            String msg = <span class="string">"Permission Denial: broadcastIntent() requesting a sticky broadcast from pid="</span></span><br><span class="line">                    + callingPid + <span class="string">", uid="</span> + callingUid</span><br><span class="line">                    + <span class="string">" requires "</span> + android.Manifest.permission.BROADCAST_STICKY;</span><br><span class="line">            Slog.w(TAG, msg);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(msg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requiredPermissions != <span class="keyword">null</span> &amp;&amp; requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Can't broadcast sticky intent "</span> + intent</span><br><span class="line">                    + <span class="string">" and enforce permissions "</span> + Arrays.toString(requiredPermissions));</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.BROADCAST_STICKY_CANT_HAVE_PERMISSION;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (intent.getComponent() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Sticky broadcasts can't target a specific component"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We use userId directly here, since the "all" target is maintained</span></span><br><span class="line">        <span class="comment">// as a separate set of sticky broadcasts.</span></span><br><span class="line">        <span class="keyword">if</span> (userId != UserHandle.USER_ALL) &#123;</span><br><span class="line">            <span class="comment">// But first, if this is not a broadcast to all users, then</span></span><br><span class="line">            <span class="comment">// make sure it doesn't conflict with an existing broadcast to</span></span><br><span class="line">            <span class="comment">// all users.</span></span><br><span class="line">            ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(</span><br><span class="line">                    UserHandle.USER_ALL);</span><br><span class="line">            <span class="keyword">if</span> (stickies != <span class="keyword">null</span>) &#123;</span><br><span class="line">                ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">                <span class="keyword">if</span> (list != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> N = list.size();</span><br><span class="line">                    <span class="keyword">int</span> i;</span><br><span class="line">                    <span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                                    <span class="string">"Sticky broadcast "</span> + intent + <span class="string">" for user "</span></span><br><span class="line">                                    + userId + <span class="string">" conflicts with existing global broadcast"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayMap&lt;String, ArrayList&lt;Intent&gt;&gt; stickies = mStickyBroadcasts.get(userId);</span><br><span class="line">        <span class="keyword">if</span> (stickies == <span class="keyword">null</span>) &#123;</span><br><span class="line">            stickies = <span class="keyword">new</span> ArrayMap&lt;&gt;();</span><br><span class="line">            mStickyBroadcasts.put(userId, stickies);</span><br><span class="line">        &#125;</span><br><span class="line">        ArrayList&lt;Intent&gt; list = stickies.get(intent.getAction());</span><br><span class="line">        <span class="keyword">if</span> (list == <span class="keyword">null</span>) &#123;</span><br><span class="line">            list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            stickies.put(intent.getAction(), list);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> stickiesCount = list.size();</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; stickiesCount; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intent.filterEquals(list.get(i))) &#123;</span><br><span class="line">                <span class="comment">// This sticky already exists, replace it.</span></span><br><span class="line">                list.set(i, <span class="keyword">new</span> Intent(intent));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= stickiesCount) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> Intent(intent));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span>[] users;</span><br><span class="line">    <span class="keyword">if</span> (userId == UserHandle.USER_ALL) &#123;</span><br><span class="line">        <span class="comment">// Caller wants broadcast to go to all started users.</span></span><br><span class="line">        users = mStartedUserArray;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Caller wants broadcast to go to one specific user.</span></span><br><span class="line">        users = <span class="keyword">new</span> <span class="keyword">int</span>[] &#123;userId&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Figure out who all will receive this broadcast.</span></span><br><span class="line">    List receivers = <span class="keyword">null</span>;</span><br><span class="line">    List&lt;BroadcastFilter&gt; registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// Need to resolve the intent to interested receivers...</span></span><br><span class="line">    <span class="keyword">if</span> ((intent.getFlags()&amp;Intent.FLAG_RECEIVER_REGISTERED_ONLY)</span><br><span class="line">             == <span class="number">0</span>) &#123;</span><br><span class="line">        receivers = collectReceiverComponents(intent, resolvedType, callingUid, users);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userId == UserHandle.USER_ALL &amp;&amp; callingUid == Process.SHELL_UID) &#123;</span><br><span class="line">            <span class="comment">// Query one target user at a time, excluding shell-restricted users</span></span><br><span class="line">            UserManagerService ums = getUserManagerLocked();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; users.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (ums.hasUserRestriction(</span><br><span class="line">                        UserManager.DISALLOW_DEBUGGING_FEATURES, users[i])) &#123;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                List&lt;BroadcastFilter&gt; registeredReceiversForUser =</span><br><span class="line">                        mReceiverResolver.queryIntent(intent,</span><br><span class="line">                                resolvedType, <span class="keyword">false</span>, users[i]);</span><br><span class="line">                <span class="keyword">if</span> (registeredReceivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers = registeredReceiversForUser;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (registeredReceiversForUser != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    registeredReceivers.addAll(registeredReceiversForUser);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registeredReceivers = mReceiverResolver.queryIntent(intent,</span><br><span class="line">                    resolvedType, <span class="keyword">false</span>, userId);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> replacePending =</span><br><span class="line">            (intent.getFlags()&amp;Intent.FLAG_RECEIVER_REPLACE_PENDING) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueing broadcast: "</span> + intent.getAction()</span><br><span class="line">            + <span class="string">" replacePending="</span> + replacePending);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> NR = registeredReceivers != <span class="keyword">null</span> ? registeredReceivers.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!ordered &amp;&amp; NR &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If we are not serializing this broadcast, then send the</span></span><br><span class="line">        <span class="comment">// registered receivers separately so they don't wait for the</span></span><br><span class="line">        <span class="comment">// components to be launched.</span></span><br><span class="line">        <span class="keyword">final</span> BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType, requiredPermissions,</span><br><span class="line">                appOp, brOptions, registeredReceivers, resultTo, resultCode, resultData,</span><br><span class="line">                resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing parallel broadcast "</span> + r);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceParallelBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            queue.enqueueParallelBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        registeredReceivers = <span class="keyword">null</span>;</span><br><span class="line">        NR = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge into one list.</span></span><br><span class="line">    <span class="keyword">int</span> ir = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (receivers != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// A special case for PACKAGE_ADDED: do not allow the package</span></span><br><span class="line">        <span class="comment">// being added to see this broadcast.  This prevents them from</span></span><br><span class="line">        <span class="comment">// using this as a back door to get run as soon as they are</span></span><br><span class="line">        <span class="comment">// installed.  Maybe in the future we want to have a special install</span></span><br><span class="line">        <span class="comment">// broadcast or such for apps, but we'd like to deliberately make</span></span><br><span class="line">        <span class="comment">// this decision.</span></span><br><span class="line">        String skipPackages[] = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (Intent.ACTION_PACKAGE_ADDED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_RESTARTED.equals(intent.getAction())</span><br><span class="line">                || Intent.ACTION_PACKAGE_DATA_CLEARED.equals(intent.getAction())) &#123;</span><br><span class="line">            Uri data = intent.getData();</span><br><span class="line">            <span class="keyword">if</span> (data != <span class="keyword">null</span>) &#123;</span><br><span class="line">                String pkgName = data.getSchemeSpecificPart();</span><br><span class="line">                <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    skipPackages = <span class="keyword">new</span> String[] &#123; pkgName &#125;;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Intent.ACTION_EXTERNAL_APPLICATIONS_AVAILABLE.equals(intent.getAction())) &#123;</span><br><span class="line">            skipPackages = intent.getStringArrayExtra(Intent.EXTRA_CHANGED_PACKAGE_LIST);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (skipPackages != <span class="keyword">null</span> &amp;&amp; (skipPackages.length &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String skipPackage : skipPackages) &#123;</span><br><span class="line">                <span class="keyword">if</span> (skipPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">int</span> NT = receivers.size();</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> it=<span class="number">0</span>; it&lt;NT; it++) &#123;</span><br><span class="line">                        ResolveInfo curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">                        <span class="keyword">if</span> (curt.activityInfo.packageName.equals(skipPackage)) &#123;</span><br><span class="line">                            receivers.remove(it);</span><br><span class="line">                            it--;</span><br><span class="line">                            NT--;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> NT = receivers != <span class="keyword">null</span> ? receivers.size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> it = <span class="number">0</span>;</span><br><span class="line">        ResolveInfo curt = <span class="keyword">null</span>;</span><br><span class="line">        BroadcastFilter curr = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">while</span> (it &lt; NT &amp;&amp; ir &lt; NR) &#123;</span><br><span class="line">            <span class="keyword">if</span> (curt == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curt = (ResolveInfo)receivers.get(it);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr == <span class="keyword">null</span>) &#123;</span><br><span class="line">                curr = registeredReceivers.get(ir);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (curr.getPriority() &gt;= curt.priority) &#123;</span><br><span class="line">                <span class="comment">// Insert this broadcast record into the final list.</span></span><br><span class="line">                receivers.add(it, curr);</span><br><span class="line">                ir++;</span><br><span class="line">                curr = <span class="keyword">null</span>;</span><br><span class="line">                it++;</span><br><span class="line">                NT++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Skip to the next ResolveInfo in the final list.</span></span><br><span class="line">                it++;</span><br><span class="line">                curt = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (ir &lt; NR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (receivers == <span class="keyword">null</span>) &#123;</span><br><span class="line">            receivers = <span class="keyword">new</span> ArrayList();</span><br><span class="line">        &#125;</span><br><span class="line">        receivers.add(registeredReceivers.get(ir));</span><br><span class="line">        ir++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((receivers != <span class="keyword">null</span> &amp;&amp; receivers.size() &gt; <span class="number">0</span>)</span><br><span class="line">            || resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        BroadcastQueue queue = broadcastQueueForIntent(intent);</span><br><span class="line">        BroadcastRecord r = <span class="keyword">new</span> BroadcastRecord(queue, intent, callerApp,</span><br><span class="line">                callerPackage, callingPid, callingUid, resolvedType,</span><br><span class="line">                requiredPermissions, appOp, brOptions, receivers, resultTo, resultCode,</span><br><span class="line">                resultData, resultExtras, ordered, sticky, <span class="keyword">false</span>, userId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Enqueueing ordered broadcast "</span> + r</span><br><span class="line">                + <span class="string">": prev had "</span> + queue.mOrderedBroadcasts.size());</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Enqueueing broadcast "</span> + r.intent.getAction());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> replaced = replacePending &amp;&amp; queue.replaceOrderedBroadcastLocked(r);</span><br><span class="line">        <span class="keyword">if</span> (!replaced) &#123;</span><br><span class="line">            queue.enqueueOrderedBroadcastLocked(r);</span><br><span class="line">            queue.scheduleBroadcastsLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> ActivityManager.BROADCAST_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u5904_u7406_u5E7F_u64AD"><a href="#u5904_u7406_u5E7F_u64AD" class="headerlink" title="处理广播"></a>处理广播</h1><h2 id="BroadcastQueue"><a href="#BroadcastQueue" class="headerlink" title="BroadcastQueue"></a>BroadcastQueue</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleBroadcastsLocked</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Schedule broadcasts ["</span></span><br><span class="line">            + mQueueName + <span class="string">"]: current="</span></span><br><span class="line">            + mBroadcastsScheduled);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBroadcastsScheduled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandler.sendMessage(mHandler.obtainMessage(BROADCAST_INTENT_MSG, <span class="keyword">this</span>));</span><br><span class="line">    mBroadcastsScheduled = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="BroadcastHandler"><a href="#BroadcastHandler" class="headerlink" title="BroadcastHandler"></a>BroadcastHandler</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br><span class="line">469</span><br><span class="line">470</span><br><span class="line">471</span><br><span class="line">472</span><br><span class="line">473</span><br><span class="line">474</span><br><span class="line">475</span><br><span class="line">476</span><br><span class="line">477</span><br><span class="line">478</span><br><span class="line">479</span><br><span class="line">480</span><br><span class="line">481</span><br><span class="line">482</span><br><span class="line">483</span><br><span class="line">484</span><br><span class="line">485</span><br><span class="line">486</span><br><span class="line">487</span><br><span class="line">488</span><br><span class="line">489</span><br><span class="line">490</span><br><span class="line">491</span><br><span class="line">492</span><br><span class="line">493</span><br><span class="line">494</span><br><span class="line">495</span><br><span class="line">496</span><br><span class="line">497</span><br><span class="line">498</span><br><span class="line">499</span><br><span class="line">500</span><br><span class="line">501</span><br><span class="line">502</span><br><span class="line">503</span><br><span class="line">504</span><br><span class="line">505</span><br><span class="line">506</span><br><span class="line">507</span><br><span class="line">508</span><br><span class="line">509</span><br><span class="line">510</span><br><span class="line">511</span><br><span class="line">512</span><br><span class="line">513</span><br><span class="line">514</span><br><span class="line">515</span><br><span class="line">516</span><br><span class="line">517</span><br><span class="line">518</span><br><span class="line">519</span><br><span class="line">520</span><br><span class="line">521</span><br><span class="line">522</span><br><span class="line">523</span><br><span class="line">524</span><br><span class="line">525</span><br><span class="line">526</span><br><span class="line">527</span><br><span class="line">528</span><br><span class="line">529</span><br><span class="line">530</span><br><span class="line">531</span><br><span class="line">532</span><br><span class="line">533</span><br><span class="line">534</span><br><span class="line">535</span><br><span class="line">536</span><br><span class="line">537</span><br><span class="line">538</span><br><span class="line">539</span><br><span class="line">540</span><br><span class="line">541</span><br><span class="line">542</span><br><span class="line">543</span><br><span class="line">544</span><br><span class="line">545</span><br><span class="line">546</span><br><span class="line">547</span><br><span class="line">548</span><br><span class="line">549</span><br><span class="line">550</span><br><span class="line">551</span><br><span class="line">552</span><br><span class="line">553</span><br><span class="line">554</span><br><span class="line">555</span><br><span class="line">556</span><br><span class="line">557</span><br><span class="line">558</span><br><span class="line">559</span><br><span class="line">560</span><br><span class="line">561</span><br><span class="line">562</span><br><span class="line">563</span><br><span class="line">564</span><br><span class="line">565</span><br><span class="line">566</span><br><span class="line">567</span><br><span class="line">568</span><br><span class="line">569</span><br><span class="line">570</span><br><span class="line">571</span><br><span class="line">572</span><br><span class="line">573</span><br><span class="line">574</span><br><span class="line">575</span><br><span class="line">576</span><br><span class="line">577</span><br><span class="line">578</span><br><span class="line">579</span><br><span class="line">580</span><br><span class="line">581</span><br><span class="line">582</span><br><span class="line">583</span><br><span class="line">584</span><br><span class="line">585</span><br><span class="line">586</span><br><span class="line">587</span><br><span class="line">588</span><br><span class="line">589</span><br><span class="line">590</span><br><span class="line">591</span><br><span class="line">592</span><br><span class="line">593</span><br><span class="line">594</span><br><span class="line">595</span><br><span class="line">596</span><br><span class="line">597</span><br><span class="line">598</span><br><span class="line">599</span><br><span class="line">600</span><br><span class="line">601</span><br><span class="line">602</span><br><span class="line">603</span><br><span class="line">604</span><br><span class="line">605</span><br><span class="line">606</span><br><span class="line">607</span><br><span class="line">608</span><br><span class="line">609</span><br><span class="line">610</span><br><span class="line">611</span><br><span class="line">612</span><br><span class="line">613</span><br><span class="line">614</span><br><span class="line">615</span><br><span class="line">616</span><br><span class="line">617</span><br><span class="line">618</span><br><span class="line">619</span><br><span class="line">620</span><br><span class="line">621</span><br><span class="line">622</span><br><span class="line">623</span><br><span class="line">624</span><br><span class="line">625</span><br><span class="line">626</span><br><span class="line">627</span><br><span class="line">628</span><br><span class="line">629</span><br><span class="line">630</span><br><span class="line">631</span><br><span class="line">632</span><br><span class="line">633</span><br><span class="line">634</span><br><span class="line">635</span><br><span class="line">636</span><br><span class="line">637</span><br><span class="line">638</span><br><span class="line">639</span><br><span class="line">640</span><br><span class="line">641</span><br><span class="line">642</span><br><span class="line">643</span><br><span class="line">644</span><br><span class="line">645</span><br><span class="line">646</span><br><span class="line">647</span><br><span class="line">648</span><br><span class="line">649</span><br><span class="line">650</span><br><span class="line">651</span><br><span class="line">652</span><br><span class="line">653</span><br><span class="line">654</span><br><span class="line">655</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BroadcastHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BroadcastHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_INTENT_MSG: &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(</span><br><span class="line">                        TAG_BROADCAST, <span class="string">"Received BROADCAST_INTENT_MSG"</span>);</span><br><span class="line">                processNextBroadcast(<span class="keyword">true</span>);</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> BROADCAST_TIMEOUT_MSG: &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> SCHEDULE_TEMP_WHITELIST_MSG: &#123;</span><br><span class="line">                DeviceIdleController.LocalService dic = mService.mLocalDeviceIdleController;</span><br><span class="line">                <span class="keyword">if</span> (dic != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    dic.addPowerSaveTempWhitelistAppDirect(UserHandle.getAppId(msg.arg1),</span><br><span class="line">                            msg.arg2, <span class="keyword">true</span>, (String)msg.obj);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">processNextBroadcast</span><span class="params">(<span class="keyword">boolean</span> fromMsg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mService) &#123;</span><br><span class="line">        BroadcastRecord r;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"processNextBroadcast ["</span></span><br><span class="line">                + mQueueName + <span class="string">"]: "</span></span><br><span class="line">                + mParallelBroadcasts.size() + <span class="string">" broadcasts, "</span></span><br><span class="line">                + mOrderedBroadcasts.size() + <span class="string">" ordered broadcasts"</span>);</span><br><span class="line"></span><br><span class="line">        mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (fromMsg) &#123;</span><br><span class="line">            mBroadcastsScheduled = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// First, deliver any non-serialized broadcasts right away.</span></span><br><span class="line">        <span class="keyword">while</span> (mParallelBroadcasts.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            r = mParallelBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">            r.dispatchTime = SystemClock.uptimeMillis();</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = r.receivers.size();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                Object target = r.receivers.get(i);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Delivering non-ordered on ["</span> + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                        + target + <span class="string">": "</span> + r);</span><br><span class="line">                deliverToRegisteredReceiverLocked(r, (BroadcastFilter)target, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            addBroadcastToHistoryLocked(r);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Done with parallel broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now take care of the next serialized one...</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// If we are waiting for a process to come up to handle the next</span></span><br><span class="line">        <span class="comment">// broadcast, then do nothing at this point.  Just in case, we</span></span><br><span class="line">        <span class="comment">// check that the process we're waiting for still exists.</span></span><br><span class="line">        <span class="keyword">if</span> (mPendingBroadcast != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"processNextBroadcast ["</span> + mQueueName + <span class="string">"]: waiting for "</span></span><br><span class="line">                    + mPendingBroadcast.curApp);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">boolean</span> isDead;</span><br><span class="line">            <span class="keyword">synchronized</span> (mService.mPidsSelfLocked) &#123;</span><br><span class="line">                ProcessRecord proc = mService.mPidsSelfLocked.get(mPendingBroadcast.curApp.pid);</span><br><span class="line">                isDead = proc == <span class="keyword">null</span> || proc.crashing;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isDead) &#123;</span><br><span class="line">                <span class="comment">// It's still alive, so keep waiting</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"pending app  ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]"</span> + mPendingBroadcast.curApp</span><br><span class="line">                        + <span class="string">" died before responding to broadcast"</span>);</span><br><span class="line">                mPendingBroadcast.state = BroadcastRecord.IDLE;</span><br><span class="line">                mPendingBroadcast.nextReceiver = mPendingBroadcastRecvIndex;</span><br><span class="line">                mPendingBroadcast = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> looped = <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        do &#123;</span><br><span class="line">            <span class="keyword">if</span> (mOrderedBroadcasts.size() == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// No more broadcasts pending, so all done!</span></span><br><span class="line">                mService.scheduleAppGcsLocked();</span><br><span class="line">                <span class="keyword">if</span> (looped) &#123;</span><br><span class="line">                    <span class="comment">// If we had finished the last ordered broadcast, then</span></span><br><span class="line">                    <span class="comment">// make sure all processes have correct oom and sched</span></span><br><span class="line">                    <span class="comment">// adjustments.</span></span><br><span class="line">                    mService.updateOomAdjLocked();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            r = mOrderedBroadcasts.get(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">boolean</span> forceReceive = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Ensure that even if something goes awry with the timeout</span></span><br><span class="line">            <span class="comment">// detection, we catch "hung" broadcasts here, discard them,</span></span><br><span class="line">            <span class="comment">// and continue to make progress.</span></span><br><span class="line">            <span class="comment">//</span></span><br><span class="line">            <span class="comment">// This is only done if the system is ready so that PRE_BOOT_COMPLETED</span></span><br><span class="line">            <span class="comment">// receivers don't get executed with timeouts. They're intended for</span></span><br><span class="line">            <span class="comment">// one time heavy lifting after system upgrades and can take</span></span><br><span class="line">            <span class="comment">// significant amounts of time.</span></span><br><span class="line">            <span class="keyword">int</span> numReceivers = (r.receivers != <span class="keyword">null</span>) ? r.receivers.size() : <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProcessesReady &amp;&amp; r.dispatchTime &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> now = SystemClock.uptimeMillis();</span><br><span class="line">                <span class="keyword">if</span> ((numReceivers &gt; <span class="number">0</span>) &amp;&amp;</span><br><span class="line">                        (now &gt; r.dispatchTime + (<span class="number">2</span>*mTimeoutPeriod*numReceivers))) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Hung broadcast ["</span></span><br><span class="line">                            + mQueueName + <span class="string">"] discarded after timeout failure:"</span></span><br><span class="line">                            + <span class="string">" now="</span> + now</span><br><span class="line">                            + <span class="string">" dispatchTime="</span> + r.dispatchTime</span><br><span class="line">                            + <span class="string">" startTime="</span> + r.receiverTime</span><br><span class="line">                            + <span class="string">" intent="</span> + r.intent</span><br><span class="line">                            + <span class="string">" numReceivers="</span> + numReceivers</span><br><span class="line">                            + <span class="string">" nextReceiver="</span> + r.nextReceiver</span><br><span class="line">                            + <span class="string">" state="</span> + r.state);</span><br><span class="line">                    broadcastTimeoutLocked(<span class="keyword">false</span>); <span class="comment">// forcibly finish this broadcast</span></span><br><span class="line">                    forceReceive = <span class="keyword">true</span>;</span><br><span class="line">                    r.state = BroadcastRecord.IDLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.state != BroadcastRecord.IDLE) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.d(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"processNextBroadcast("</span></span><br><span class="line">                        + mQueueName + <span class="string">") called when not idle (state="</span></span><br><span class="line">                        + r.state + <span class="string">")"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (r.receivers == <span class="keyword">null</span> || r.nextReceiver &gt;= numReceivers</span><br><span class="line">                    || r.resultAbort || forceReceive) &#123;</span><br><span class="line">                <span class="comment">// No more receivers for this broadcast!  Send the final</span></span><br><span class="line">                <span class="comment">// result if requested...</span></span><br><span class="line">                <span class="keyword">if</span> (r.resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.i(TAG_BROADCAST,</span><br><span class="line">                                <span class="string">"Finishing broadcast ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                                + r.intent.getAction() + <span class="string">" app="</span> + r.callerApp);</span><br><span class="line">                        performReceiveLocked(r.callerApp, r.resultTo,</span><br><span class="line">                            <span class="keyword">new</span> Intent(r.intent), r.resultCode,</span><br><span class="line">                            r.resultData, r.resultExtras, <span class="keyword">false</span>, <span class="keyword">false</span>, r.userId);</span><br><span class="line">                        <span class="comment">// Set this to null so that the reference</span></span><br><span class="line">                        <span class="comment">// (local and remote) isn't kept in the mBroadcastHistory.</span></span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                        r.resultTo = <span class="keyword">null</span>;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Failure ["</span></span><br><span class="line">                                + mQueueName + <span class="string">"] sending broadcast result of "</span></span><br><span class="line">                                + r.intent, e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Cancelling BROADCAST_TIMEOUT_MSG"</span>);</span><br><span class="line">                cancelBroadcastTimeoutLocked();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Finished with ordered broadcast "</span> + r);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// ... and on to the next...</span></span><br><span class="line">                addBroadcastToHistoryLocked(r);</span><br><span class="line">                mOrderedBroadcasts.remove(<span class="number">0</span>);</span><br><span class="line">                r = <span class="keyword">null</span>;</span><br><span class="line">                looped = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">while</span> (r == <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Get the next receiver...</span></span><br><span class="line">        <span class="keyword">int</span> recIdx = r.nextReceiver++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Keep track of when this receiver started, and make sure there</span></span><br><span class="line">        <span class="comment">// is a timeout message pending to kill it if need be.</span></span><br><span class="line">        r.receiverTime = SystemClock.uptimeMillis();</span><br><span class="line">        <span class="keyword">if</span> (recIdx == <span class="number">0</span>) &#123;</span><br><span class="line">            r.dispatchTime = r.receiverTime;</span><br><span class="line">            r.dispatchClockTime = System.currentTimeMillis();</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.v(TAG_BROADCAST, <span class="string">"Processing ordered broadcast ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] "</span> + r);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (! mPendingBroadcastTimeoutMessage) &#123;</span><br><span class="line">            <span class="keyword">long</span> timeoutTime = r.receiverTime + mTimeoutPeriod;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Submitting BROADCAST_TIMEOUT_MSG ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] for "</span> + r + <span class="string">" at "</span> + timeoutTime);</span><br><span class="line">            setBroadcastTimeoutLocked(timeoutTime);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> BroadcastOptions brOptions = r.options;</span><br><span class="line">        <span class="keyword">final</span> Object nextReceiver = r.receivers.get(recIdx);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (nextReceiver <span class="keyword">instanceof</span> BroadcastFilter) &#123;</span><br><span class="line">            <span class="comment">// Simple case: this is a registered receiver who gets</span></span><br><span class="line">            <span class="comment">// a direct call.</span></span><br><span class="line">            BroadcastFilter filter = (BroadcastFilter)nextReceiver;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Delivering ordered ["</span></span><br><span class="line">                    + mQueueName + <span class="string">"] to registered "</span></span><br><span class="line">                    + filter + <span class="string">": "</span> + r);</span><br><span class="line">            deliverToRegisteredReceiverLocked(r, filter, r.ordered);</span><br><span class="line">            <span class="keyword">if</span> (r.receiver == <span class="keyword">null</span> || !r.ordered) &#123;</span><br><span class="line">                <span class="comment">// The receiver has already finished, so schedule to</span></span><br><span class="line">                <span class="comment">// process the next one.</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST, <span class="string">"Quick finishing ["</span></span><br><span class="line">                        + mQueueName + <span class="string">"]: ordered="</span></span><br><span class="line">                        + r.ordered + <span class="string">" receiver="</span> + r.receiver);</span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    scheduleTempWhitelistLocked(filter.owningUid,</span><br><span class="line">                            brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Hard case: need to instantiate the receiver, possibly</span></span><br><span class="line">        <span class="comment">// starting its application process to host it.</span></span><br><span class="line"></span><br><span class="line">        ResolveInfo info =</span><br><span class="line">            (ResolveInfo)nextReceiver;</span><br><span class="line">        ComponentName component = <span class="keyword">new</span> ComponentName(</span><br><span class="line">                info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                info.activityInfo.name);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(info.activityInfo.permission,</span><br><span class="line">                r.callingPid, r.callingUid, info.activityInfo.applicationInfo.uid,</span><br><span class="line">                info.activityInfo.exported);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!info.activityInfo.exported) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" is not exported from uid "</span> + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span> + r.callingPid</span><br><span class="line">                        + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + info.activityInfo.permission</span><br><span class="line">                        + <span class="string">" due to receiver "</span> + component.flattenToShortString());</span><br><span class="line">            &#125;</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (info.activityInfo.permission != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(info.activityInfo.permission);</span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                info.activityInfo.permission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span></span><br><span class="line">                        + component.flattenToShortString());</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; info.activityInfo.applicationInfo.uid != Process.SYSTEM_UID &amp;&amp;</span><br><span class="line">            r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">                String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    perm = AppGlobals.getPackageManager().</span><br><span class="line">                            checkPermission(requiredPermission,</span><br><span class="line">                                    info.activityInfo.applicationInfo.packageName,</span><br><span class="line">                                    UserHandle</span><br><span class="line">                                            .getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">                &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    perm = PackageManager.PERMISSION_DENIED;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">                <span class="keyword">if</span> (appOp != AppOpsManager.OP_NONE &amp;&amp; appOp != r.appOp</span><br><span class="line">                        &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                        info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                        != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                    Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                            + r.intent + <span class="string">" to "</span></span><br><span class="line">                            + component.flattenToShortString()</span><br><span class="line">                            + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                            requiredPermission)</span><br><span class="line">                            + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                            + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                    skip = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">                &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, info.activityInfo.packageName)</span><br><span class="line">                != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                    + r.intent + <span class="string">" to "</span></span><br><span class="line">                    + component.flattenToShortString()</span><br><span class="line">                    + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            skip = !mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">                    r.callingPid, r.resolvedType, info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> isSingleton = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isSingleton = mService.isSingleton(info.activityInfo.processName,</span><br><span class="line">                    info.activityInfo.applicationInfo,</span><br><span class="line">                    info.activityInfo.name, info.activityInfo.flags);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SecurityException e) &#123;</span><br><span class="line">            Slog.w(TAG, e.getMessage());</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ((info.activityInfo.flags&amp;ActivityInfo.FLAG_SINGLE_USER) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityManager.checkUidPermission(</span><br><span class="line">                    android.Manifest.permission.INTERACT_ACROSS_USERS,</span><br><span class="line">                    info.activityInfo.applicationInfo.uid)</span><br><span class="line">                            != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: Receiver "</span> + component.flattenToShortString()</span><br><span class="line">                        + <span class="string">" requests FLAG_SINGLE_USER, but app does not hold "</span></span><br><span class="line">                        + android.Manifest.permission.INTERACT_ACROSS_USERS);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.curApp != <span class="keyword">null</span> &amp;&amp; r.curApp.crashing) &#123;</span><br><span class="line">            <span class="comment">// If the target process is crashing, just skip it.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Skipping deliver ordered ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                    + <span class="string">" to "</span> + r.curApp + <span class="string">": process crashing"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isAvailable = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                isAvailable = AppGlobals.getPackageManager().isPackageAvailable(</span><br><span class="line">                        info.activityInfo.packageName,</span><br><span class="line">                        UserHandle.getUserId(info.activityInfo.applicationInfo.uid));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// all such failures mean we skip this receiver</span></span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception getting recipient info for "</span></span><br><span class="line">                        + info.activityInfo.packageName, e);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!isAvailable) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_BROADCAST) Slog.v(TAG_BROADCAST,</span><br><span class="line">                        <span class="string">"Skipping delivery to "</span> + info.activityInfo.packageName + <span class="string">" / "</span></span><br><span class="line">                        + info.activityInfo.applicationInfo.uid</span><br><span class="line">                        + <span class="string">" : package no longer available"</span>);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (skip) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Skipping delivery of ordered ["</span> + mQueueName + <span class="string">"] "</span></span><br><span class="line">                    + r + <span class="string">" for whatever reason"</span>);</span><br><span class="line">            r.receiver = <span class="keyword">null</span>;</span><br><span class="line">            r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.state = BroadcastRecord.APP_RECEIVE;</span><br><span class="line">        String targetProcess = info.activityInfo.processName;</span><br><span class="line">        r.curComponent = component;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> receiverUid = info.activityInfo.applicationInfo.uid;</span><br><span class="line">        <span class="comment">// If it's a singleton, it needs to be the same app or a special app</span></span><br><span class="line">        <span class="keyword">if</span> (r.callingUid != Process.SYSTEM_UID &amp;&amp; isSingleton</span><br><span class="line">                &amp;&amp; mService.isValidSingletonCall(r.callingUid, receiverUid)) &#123;</span><br><span class="line">            info.activityInfo = mService.getActivityInfoForUser(info.activityInfo, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        r.curReceiver = info.activityInfo;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_MU &amp;&amp; r.callingUid &gt; UserHandle.PER_USER_RANGE) &#123;</span><br><span class="line">            Slog.v(TAG_MU, <span class="string">"Updated broadcast record activity info for secondary user, "</span></span><br><span class="line">                    + info.activityInfo + <span class="string">", callingUid = "</span> + r.callingUid + <span class="string">", uid = "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (brOptions != <span class="keyword">null</span> &amp;&amp; brOptions.getTemporaryAppWhitelistDuration() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            scheduleTempWhitelistLocked(receiverUid,</span><br><span class="line">                    brOptions.getTemporaryAppWhitelistDuration(), r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Broadcast is being executed, its package can't be stopped.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                    r.curComponent.getPackageName(), <span class="keyword">false</span>, UserHandle.getUserId(r.callingUid));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                    + r.curComponent.getPackageName() + <span class="string">": "</span> + e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Is this receiver's application already running?</span></span><br><span class="line">        ProcessRecord app = mService.getProcessRecordLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo.uid, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                app.addPackage(info.activityInfo.packageName,</span><br><span class="line">                        info.activityInfo.applicationInfo.versionCode, mService.mProcessStats);</span><br><span class="line">                processCurBroadcastLocked(r, app);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Exception when sending broadcast to "</span></span><br><span class="line">                      + r.curComponent, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">                Slog.wtf(TAG, <span class="string">"Failed sending broadcast to "</span></span><br><span class="line">                        + r.curComponent + <span class="string">" with "</span> + r.intent, e);</span><br><span class="line">                <span class="comment">// If some unexpected exception happened, just skip</span></span><br><span class="line">                <span class="comment">// this broadcast.  At this point we are not in the call</span></span><br><span class="line">                <span class="comment">// from a client, so throwing an exception out from here</span></span><br><span class="line">                <span class="comment">// will crash the entire system instead of just whoever</span></span><br><span class="line">                <span class="comment">// sent the broadcast.</span></span><br><span class="line">                logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">                finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                        r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">                scheduleBroadcastsLocked();</span><br><span class="line">                <span class="comment">// We need to reset the state if we failed to start the receiver.</span></span><br><span class="line">                r.state = BroadcastRecord.IDLE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">            <span class="comment">// restart the application.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Not running -- get it started, to be executed when the app comes up.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_BROADCAST)  Slog.v(TAG_BROADCAST,</span><br><span class="line">                <span class="string">"Need to start app ["</span></span><br><span class="line">                + mQueueName + <span class="string">"] "</span> + targetProcess + <span class="string">" for broadcast "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> ((r.curApp=mService.startProcessLocked(targetProcess,</span><br><span class="line">                info.activityInfo.applicationInfo, <span class="keyword">true</span>,</span><br><span class="line">                r.intent.getFlags() | Intent.FLAG_FROM_BACKGROUND,</span><br><span class="line">                <span class="string">"broadcast"</span>, r.curComponent,</span><br><span class="line">                (r.intent.getFlags()&amp;Intent.FLAG_RECEIVER_BOOT_UPGRADE) != <span class="number">0</span>, <span class="keyword">false</span>, <span class="keyword">false</span>))</span><br><span class="line">                        == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Ah, this recipient is unavailable.  Finish it if necessary,</span></span><br><span class="line">            <span class="comment">// and mark the broadcast record as ready for the next.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to launch app "</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.packageName + <span class="string">"/"</span></span><br><span class="line">                    + info.activityInfo.applicationInfo.uid + <span class="string">" for broadcast "</span></span><br><span class="line">                    + r.intent + <span class="string">": process is bad"</span>);</span><br><span class="line">            logBroadcastReceiverDiscardLocked(r);</span><br><span class="line">            finishReceiverLocked(r, r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.resultAbort, <span class="keyword">false</span>);</span><br><span class="line">            scheduleBroadcastsLocked();</span><br><span class="line">            r.state = BroadcastRecord.IDLE;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPendingBroadcast = r;</span><br><span class="line">        mPendingBroadcastRecvIndex = recIdx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deliverToRegisteredReceiverLocked</span><span class="params">(BroadcastRecord r,</span><br><span class="line">        BroadcastFilter filter, <span class="keyword">boolean</span> ordered)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> skip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (filter.requiredPermission != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(filter.requiredPermission,</span><br><span class="line">                r.callingPid, r.callingUid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: broadcasting "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                    + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" requires "</span> + filter.requiredPermission</span><br><span class="line">                    + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> opCode = AppOpsManager.permissionToOpCode(filter.requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (opCode != AppOpsManager.OP_NONE</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(opCode, r.callingUid,</span><br><span class="line">                            r.callerPackage) != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: broadcasting "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" from "</span> + r.callerPackage + <span class="string">" (pid="</span></span><br><span class="line">                        + r.callingPid + <span class="string">", uid="</span> + r.callingUid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                                filter.requiredPermission)</span><br><span class="line">                        + <span class="string">" due to registered receiver "</span> + filter);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.requiredPermissions != <span class="keyword">null</span> &amp;&amp; r.requiredPermissions.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; r.requiredPermissions.length; i++) &#123;</span><br><span class="line">            String requiredPermission = r.requiredPermissions[i];</span><br><span class="line">            <span class="keyword">int</span> perm = mService.checkComponentPermission(requiredPermission,</span><br><span class="line">                    filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Permission Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires "</span> + requiredPermission</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> appOp = AppOpsManager.permissionToOpCode(requiredPermission);</span><br><span class="line">            <span class="keyword">if</span> (appOp != r.appOp</span><br><span class="line">                    &amp;&amp; mService.mAppOpsService.noteOperation(appOp,</span><br><span class="line">                    filter.receiverList.uid, filter.packageName)</span><br><span class="line">                    != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                        + r.intent.toString()</span><br><span class="line">                        + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                        + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                        + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                        + <span class="string">" requires appop "</span> + AppOpsManager.permissionToOp(</span><br><span class="line">                        requiredPermission)</span><br><span class="line">                        + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                        + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">                skip = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; (r.requiredPermissions == <span class="keyword">null</span> || r.requiredPermissions.length == <span class="number">0</span>)) &#123;</span><br><span class="line">        <span class="keyword">int</span> perm = mService.checkComponentPermission(<span class="keyword">null</span>,</span><br><span class="line">                filter.receiverList.pid, filter.receiverList.uid, -<span class="number">1</span>, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (perm != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Permission Denial: security check failed when receiving "</span></span><br><span class="line">                    + r.intent.toString()</span><br><span class="line">                    + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                    + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                    + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                    + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                    + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">            skip = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!skip &amp;&amp; r.appOp != AppOpsManager.OP_NONE</span><br><span class="line">            &amp;&amp; mService.mAppOpsService.noteOperation(r.appOp,</span><br><span class="line">            filter.receiverList.uid, filter.packageName)</span><br><span class="line">            != AppOpsManager.MODE_ALLOWED) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Appop Denial: receiving "</span></span><br><span class="line">                + r.intent.toString()</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList.app</span><br><span class="line">                + <span class="string">" (pid="</span> + filter.receiverList.pid</span><br><span class="line">                + <span class="string">", uid="</span> + filter.receiverList.uid + <span class="string">")"</span></span><br><span class="line">                + <span class="string">" requires appop "</span> + AppOpsManager.opToName(r.appOp)</span><br><span class="line">                + <span class="string">" due to sender "</span> + r.callerPackage</span><br><span class="line">                + <span class="string">" (uid "</span> + r.callingUid + <span class="string">")"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mService.mIntentFirewall.checkBroadcast(r.intent, r.callingUid,</span><br><span class="line">            r.callingPid, r.resolvedType, filter.receiverList.uid)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (filter.receiverList.app == <span class="keyword">null</span> || filter.receiverList.app.crashing) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Skipping deliver ["</span> + mQueueName + <span class="string">"] "</span> + r</span><br><span class="line">                + <span class="string">" to "</span> + filter.receiverList + <span class="string">": process crashing"</span>);</span><br><span class="line">        skip = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!skip) &#123;</span><br><span class="line">        <span class="comment">// If this is not being sent as an ordered broadcast, then we</span></span><br><span class="line">        <span class="comment">// don't want to touch the fields that keep track of the current</span></span><br><span class="line">        <span class="comment">// state of ordered broadcasts.</span></span><br><span class="line">        <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">            r.receiver = filter.receiverList.receiver.asBinder();</span><br><span class="line">            r.curFilter = filter;</span><br><span class="line">            filter.receiverList.curBroadcast = r;</span><br><span class="line">            r.state = BroadcastRecord.CALL_IN_RECEIVE;</span><br><span class="line">            <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Bump hosting application to no longer be in background</span></span><br><span class="line">                <span class="comment">// scheduling class.  Note that we can't do that if there</span></span><br><span class="line">                <span class="comment">// isn't an app...  but we can only be in that case for</span></span><br><span class="line">                <span class="comment">// things that directly call the IActivityManager API, which</span></span><br><span class="line">                <span class="comment">// are already core system stuff so don't matter for this.</span></span><br><span class="line">                r.curApp = filter.receiverList.app;</span><br><span class="line">                filter.receiverList.app.curReceiver = r;</span><br><span class="line">                mService.updateOomAdjLocked(r.curApp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_BROADCAST_LIGHT) Slog.i(TAG_BROADCAST,</span><br><span class="line">                    <span class="string">"Delivering to "</span> + filter + <span class="string">" : "</span> + r);</span><br><span class="line">            performReceiveLocked(filter.receiverList.app, filter.receiverList.receiver,</span><br><span class="line">                    <span class="keyword">new</span> Intent(r.intent), r.resultCode, r.resultData,</span><br><span class="line">                    r.resultExtras, r.ordered, r.initialSticky, r.userId);</span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                r.state = BroadcastRecord.CALL_DONE_RECEIVE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failure sending broadcast "</span> + r.intent, e);</span><br><span class="line">            <span class="keyword">if</span> (ordered) &#123;</span><br><span class="line">                r.receiver = <span class="keyword">null</span>;</span><br><span class="line">                r.curFilter = <span class="keyword">null</span>;</span><br><span class="line">                filter.receiverList.curBroadcast = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (filter.receiverList.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    filter.receiverList.app.curReceiver = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">performReceiveLocked</span><span class="params">(ProcessRecord app, IIntentReceiver receiver,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> resultCode, String data, Bundle extras,</span><br><span class="line">        <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="comment">// Send the intent to the receiver asynchronously using one-way binder calls.</span></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we have an app thread, do the call through that so it is</span></span><br><span class="line">            <span class="comment">// correctly ordered with other one-way calls.</span></span><br><span class="line">            app.thread.scheduleRegisteredReceiver(receiver, intent, resultCode,</span><br><span class="line">                    data, extras, ordered, sticky, sendingUser, app.repProcState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Application has died. Receiver doesn't exist.</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException(<span class="string">"app.thread must not be null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        receiver.performReceive(intent, resultCode, data, extras, ordered,</span><br><span class="line">                sticky, sendingUser);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleRegisteredReceiver</span><span class="params">(IIntentReceiver receiver, Intent intent,</span><br><span class="line">        <span class="keyword">int</span> resultCode, String dataStr, Bundle extras, <span class="keyword">boolean</span> ordered,</span><br><span class="line">        <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser, <span class="keyword">int</span> processState)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    updateProcessState(processState, <span class="keyword">false</span>);</span><br><span class="line">    receiver.performReceive(intent, resultCode, dataStr, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="InnerReceiver"><a href="#InnerReceiver" class="headerlink" title="InnerReceiver"></a>InnerReceiver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span><br><span class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    LoadedApk.ReceiverDispatcher rd = mDispatcher.get();</span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Receiving broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</span><br><span class="line">                + <span class="string">" to "</span> + (rd != <span class="keyword">null</span> ? rd.mReceiver : <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (rd != <span class="keyword">null</span>) &#123;</span><br><span class="line">        rd.performReceive(intent, resultCode, data, extras,</span><br><span class="line">                ordered, sticky, sendingUser);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// The activity manager dispatched a broadcast to a registered</span></span><br><span class="line">        <span class="comment">// receiver in this process, but before it could be delivered the</span></span><br><span class="line">        <span class="comment">// receiver was unregistered.  Acknowledge the broadcast on its</span></span><br><span class="line">        <span class="comment">// behalf so that the system's broadcast sequence can continue.</span></span><br><span class="line">        <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                <span class="string">"Finishing broadcast to unregistered receiver"</span>);</span><br><span class="line">        IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">                extras.setAllowFds(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mgr.finishReceiver(<span class="keyword">this</span>, resultCode, data, extras, <span class="keyword">false</span>, intent.getFlags());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(ActivityThread.TAG, <span class="string">"Couldn't finish broadcast to unregistered receiver"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="ReceiverDispatcher-1"><a href="#ReceiverDispatcher-1" class="headerlink" title="ReceiverDispatcher"></a>ReceiverDispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">performReceive</span><span class="params">(Intent intent, <span class="keyword">int</span> resultCode, String data,</span><br><span class="line">        Bundle extras, <span class="keyword">boolean</span> ordered, <span class="keyword">boolean</span> sticky, <span class="keyword">int</span> sendingUser)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = intent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Enqueueing broadcast "</span> + intent.getAction() + <span class="string">" seq="</span> + seq</span><br><span class="line">                + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">    &#125;</span><br><span class="line">    Args args = <span class="keyword">new</span> Args(intent, resultCode, data, extras, ordered,</span><br><span class="line">            sticky, sendingUser);</span><br><span class="line">    <span class="keyword">if</span> (!mActivityThread.post(args)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing sync broadcast to "</span> + mReceiver);</span><br><span class="line">            args.sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Args"><a href="#Args" class="headerlink" title="Args"></a>Args</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> BroadcastReceiver receiver = mReceiver;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> ordered = mOrdered;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) &#123;</span><br><span class="line">        <span class="keyword">int</span> seq = mCurIntent.getIntExtra(<span class="string">"seq"</span>, -<span class="number">1</span>);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"Dispatching broadcast "</span> + mCurIntent.getAction()</span><br><span class="line">                + <span class="string">" seq="</span> + seq + <span class="string">" to "</span> + mReceiver);</span><br><span class="line">        Slog.i(ActivityThread.TAG, <span class="string">"  mRegistered="</span> + mRegistered</span><br><span class="line">                + <span class="string">" mOrderedHint="</span> + ordered);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">final</span> IActivityManager mgr = ActivityManagerNative.getDefault();</span><br><span class="line">    <span class="keyword">final</span> Intent intent = mCurIntent;</span><br><span class="line">    mCurIntent = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver == <span class="keyword">null</span> || mForgotten) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing null broadcast to "</span> + mReceiver);</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"broadcastReceiveReg"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ClassLoader cl =  mReceiver.getClass().getClassLoader();</span><br><span class="line">        intent.setExtrasClassLoader(cl);</span><br><span class="line">        setExtrasClassLoader(cl);</span><br><span class="line">        receiver.setPendingResult(<span class="keyword">this</span>);</span><br><span class="line">        receiver.onReceive(mContext, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRegistered &amp;&amp; ordered) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ActivityThread.DEBUG_BROADCAST) Slog.i(ActivityThread.TAG,</span><br><span class="line">                    <span class="string">"Finishing failed broadcast to "</span> + mReceiver);</span><br><span class="line">            sendFinished(mgr);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (mInstrumentation == <span class="keyword">null</span> ||</span><br><span class="line">                !mInstrumentation.onException(mReceiver, e)) &#123;</span><br><span class="line">            Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Error receiving broadcast "</span> + intent</span><br><span class="line">                + <span class="string">" in "</span> + mReceiver, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (receiver.getPendingResult() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6CE8_u518C_u5E7F_u64AD"><a href="#u6CE8_u518C_u5E7F_u64AD" class="headerlink" title="注册广播"></a>注册广播</h1><h2 id="ContextImpl"><a hre]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[DiskLruCache源码解析]]></title>
    <link href="http://yuqirong.github.io/2019/10/15/DiskLruCache%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.github.io/2019/10/15/DiskLruCache源码解析/</id>
    <published>2019-10-15T12:11:24.000Z</published>
    <updated>2019-10-15T14:45:14.052Z</updated>
    <content type="html"><![CDATA[<p>DiskLruCache : <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">https://github.com/JakeWharton/DiskLruCache</a></p>
<p>DiskLruCache 在 Android 开发中应用的非常广泛，比较常用的就是图片的三级缓存中。比如在 Glide 中，图片在硬盘上的缓存就是采用了 DiskLruCache 。</p>
<p>在 DiskLruCache 中有三种文件，</p>
<ul>
<li>journal 文件，里面是记录着我们的操作日志；</li>
<li>journal.tmp 文件，这个文件是临时文件；</li>
<li>journal.bkp 文件，这个文件是备份文件。</li>
</ul>
<p>在我们操作 DiskLruCache 过程中，在修改内存中的缓存的同时，也会在硬盘中的 journal 文件追加我们的操作记录，这样就是下次冷启动，就可以直接从 journal 文件中恢复缓存了。</p>
<p>journal 文件的格式，前几行是文件头，后面是操作记录</p>
<pre><code>libcore.io.DiskLruCache
1
100
2

CLEAN 3400330d1dfc7f3f7f4b8d4d803dfcf6 832 21054
DIRTY 335c4c6028171cfddfbaae1a9c313c52
CLEAN 335c4c6028171cfddfbaae1a9c313c52 3934 2342
REMOVE 335c4c6028171cfddfbaae1a9c313c52
DIRTY 1ab96a171faeeee38496d8b330771a7a
CLEAN 1ab96a171faeeee38496d8b330771a7a 1600 234
READ 335c4c6028171cfddfbaae1a9c313c52
</code></pre><p>其中1表示diskCache的版本，100表示应用的版本，2表示一个key对应多少个缓存文件。</p>
<p>接下来的每一行都代表着一次操作记录，如</p>
<p>跟上面日志里面看到的一样，DiskLruCache处理文件的过程中会有四种状态：</p>
<ul>
<li>DIRTY 创建或者修改一个缓存的时候，会有一条DIRTY记录，后面会跟一个CLEAN或REMOVE的记录。如果没有CLEAN或REMOVE，对应的缓存文件是无效的，会被删掉</li>
<li>CLEAN 表示对应的缓存操作成功了，后面会带上每个缓存文件的大小，比如上面例子中的 832 21054</li>
<li>REMOVE 表示对应的缓存被删除了</li>
<li>READ 表示对应的缓存被访问了</li>
</ul>
<h1 id="DiskLruCache_u6E90_u7801_u89E3_u6790"><a href="#DiskLruCache_u6E90_u7801_u89E3_u6790" class="headerlink" title="DiskLruCache源码解析"></a>DiskLruCache源码解析</h1><p>现在就来解析一下 DiskLruCache 内部的源码。</p>
<h2 id="u6210_u5458_u53D8_u91CF"><a href="#u6210_u5458_u53D8_u91CF" class="headerlink" title="成员变量"></a>成员变量</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File directory;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File journalFile;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File journalFileTmp;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> File journalFileBackup;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> appVersion;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> maxSize;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> valueCount;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> size = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">private</span> Writer journalWriter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> LinkedHashMap&lt;String, Entry&gt; lruEntries =</span><br><span class="line">    <span class="keyword">new</span> LinkedHashMap&lt;String, Entry&gt;(<span class="number">0</span>, <span class="number">0.75f</span>, <span class="keyword">true</span>);</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> redundantOpCount;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">long</span> nextSequenceNumber = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li>directory: 缓存对应的目录</li>
<li>journalFile: 日志文件</li>
<li>journalFileTmp: journal中间产生的临时文件</li>
<li>journalFileBackup: journal备份文件</li>
<li>appVersion: 外部传入的应用版本</li>
<li>maxSize: DiskLruCache缓存最大的容量</li>
<li>valueCount: 一个key对应着的文件数量</li>
<li>size: 当前缓存的总容量</li>
<li>journalWriter: 负责 journalFile文件的写入</li>
<li>lruEntries: 内存中对应着 LRU 的缓存实体</li>
<li>redundantOpCount: 操作次数，当这个值大于2000，会trimToSize，重新构建日志文件</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> ThreadPoolExecutor executorService =</span><br><span class="line">    <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, <span class="number">1</span>, <span class="number">60L</span>, TimeUnit.SECONDS, <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Callable&lt;Void&gt; cleanupCallable = <span class="keyword">new</span> Callable&lt;Void&gt;() &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> Void <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (journalWriter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Closed.</span></span><br><span class="line">      &#125;</span><br><span class="line">      trimToSize();</span><br><span class="line">      <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">        rebuildJournal();</span><br><span class="line">        redundantOpCount = <span class="number">0</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>executorService 是只有一个线程的线程池，专门负责清理工作。会清除过多的缓存以及根据 lruEntries 生成新的 journal 文件。</p>
<h1 id="Entry"><a href="#Entry" class="headerlink" title="Entry"></a>Entry</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> String key;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Lengths of this entry's files. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">long</span>[] lengths;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** True if this entry has ever been published. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> readable;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The ongoing edit or null if this entry is not being edited. */</span></span><br><span class="line">  <span class="keyword">private</span> Editor currentEditor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** The sequence number of the most recently committed edit to this entry. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">long</span> sequenceNumber;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Entry</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.key = key;</span><br><span class="line">    <span class="keyword">this</span>.lengths = <span class="keyword">new</span> <span class="keyword">long</span>[valueCount];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getLengths</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    StringBuilder result = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">long</span> size : lengths) &#123;</span><br><span class="line">      result.append(<span class="string">' '</span>).append(size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result.toString();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Set lengths using decimal numbers like "10123". */</span></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (strings.length != valueCount) &#123;</span><br><span class="line">      <span class="keyword">throw</span> invalidLengths(strings);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; strings.length; i++) &#123;</span><br><span class="line">        lengths[i] = Long.parseLong(strings[i]);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> invalidLengths(strings);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> IOException <span class="title">invalidLengths</span><span class="params">(String[] strings)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + java.util.Arrays.toString(strings));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> File <span class="title">getCleanFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> File <span class="title">getDirtyFile</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(directory, key + <span class="string">"."</span> + i + <span class="string">".tmp"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Entry 分为 CleanFile 和DirtyFile，当取操作的时候读取的是 CleanFile ，而写操作是先写到DirtyFile ，再重命名为 CleanFile 。这样就算写失败了，至少还有 CleanFile 可以读取，不会污染数据，做到读写分离。</p>
<h1 id="Editor"><a href="#Editor" class="headerlink" title="Editor"></a>Editor</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Editor</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Entry entry;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span>[] written;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> hasErrors;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">boolean</span> committed;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="title">Editor</span><span class="params">(Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.entry = entry;</span><br><span class="line">    <span class="keyword">this</span>.written = (entry.readable) ? <span class="keyword">null</span> : <span class="keyword">new</span> <span class="keyword">boolean</span>[valueCount];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Returns an unbuffered input stream to read the last committed value,</span><br><span class="line">   * or null if no value has been committed.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> InputStream <span class="title">newInputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FileInputStream(entry.getCleanFile(index));</span><br><span class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Returns the last committed value as a string, or null if no value</span><br><span class="line">   * has been committed.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getString</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream in = newInputStream(index);</span><br><span class="line">    <span class="keyword">return</span> in != <span class="keyword">null</span> ? inputStreamToString(in) : <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Returns a new unbuffered output stream to write the value at</span><br><span class="line">   * &#123;<span class="doctag">@code</span> index&#125;. If the underlying output stream encounters errors</span><br><span class="line">   * when writing to the filesystem, this edit will be aborted when</span><br><span class="line">   * &#123;<span class="doctag">@link</span> #commit&#125; is called. The returned output stream does not throw</span><br><span class="line">   * IOExceptions.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> OutputStream <span class="title">newOutputStream</span><span class="params">(<span class="keyword">int</span> index)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &lt; <span class="number">0</span> || index &gt;= valueCount) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Expected index "</span> + index + <span class="string">" to "</span></span><br><span class="line">              + <span class="string">"be greater than 0 and less than the maximum value count "</span></span><br><span class="line">              + <span class="string">"of "</span> + valueCount);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">synchronized</span> (DiskLruCache.<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">        written[index] = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      File dirtyFile = entry.getDirtyFile(index);</span><br><span class="line">      FileOutputStream outputStream;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">        <span class="comment">// Attempt to recreate the cache directory.</span></span><br><span class="line">        directory.mkdirs();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          outputStream = <span class="keyword">new</span> FileOutputStream(dirtyFile);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e2) &#123;</span><br><span class="line">          <span class="comment">// We are unable to recover. Silently eat the writes.</span></span><br><span class="line">          <span class="keyword">return</span> NULL_OUTPUT_STREAM;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> FaultHidingOutputStream(outputStream);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Sets the value at &#123;<span class="doctag">@code</span> index&#125; to &#123;<span class="doctag">@code</span> value&#125;. */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, String value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Writer writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      writer = <span class="keyword">new</span> OutputStreamWriter(newOutputStream(index), Util.UTF_8);</span><br><span class="line">      writer.write(value);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      Util.closeQuietly(writer);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Commits this edit so it is visible to readers.  This releases the</span><br><span class="line">   * edit lock so another edit may be started on the same key.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (hasErrors) &#123;</span><br><span class="line">      completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">      remove(entry.key); <span class="comment">// The previous entry is stale.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    committed = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span><br><span class="line">   * Aborts this edit. This releases the edit lock so another edit may be</span><br><span class="line">   * started on the same key.</span><br><span class="line">   */</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abort</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">abortUnlessCommitted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!committed) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        abort();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">FaultHidingOutputStream</span> <span class="keyword">extends</span> <span class="title">FilterOutputStream</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">FaultHidingOutputStream</span><span class="params">(OutputStream out)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">super</span>(out);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> oneByte)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.write(oneByte);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        hasErrors = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span>[] buffer, <span class="keyword">int</span> offset, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.write(buffer, offset, length);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        hasErrors = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.close();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        hasErrors = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        out.flush();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        hasErrors = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Editor 是对某个 Entry 编辑时的操作对象。DiskLruCache 想要写入缓存文件，需要获取DiskLruCache.Editor，由 Editor 生成 OutputStream，后续只需要将缓存数据写入 OutputStream 即可。</p>
<h1 id="open_28File_directory_2C_int_appVersion_2C_int_valueCount_2C_long_maxSize_29"><a href="#open_28File_directory_2C_int_appVersion_2C_int_valueCount_2C_long_maxSize_29" class="headerlink" title="open(File directory, int appVersion, int valueCount, long maxSize)"></a>open(File directory, int appVersion, int valueCount, long maxSize)</h1><p>通过调用 open 方法来获得 DiskLruCache 的实例。open 方法有四个参数：</p>
<ul>
<li>directory: 缓存文件的存放目录</li>
<li>appVersion: 应用程序的版本号</li>
<li>valueCount: 表示同一个 key 可以对应多少个缓存文件</li>
<li>maxSize: 表示最大可以缓存多少字节的数据</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DiskLruCache <span class="title">open</span><span class="params">(File directory, <span class="keyword">int</span> appVersion, <span class="keyword">int</span> valueCount, <span class="keyword">long</span> maxSize)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (maxSize &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxSize &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (valueCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"valueCount &lt;= 0"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If a bkp file exists, use it instead.</span></span><br><span class="line">  <span class="comment">// 流程：优先使用JOURNAL_FILE，删除JOURNAL_FILE_BACKUP备份文件，</span></span><br><span class="line">  <span class="comment">// 否则，JOURNAL_FILE_BACKUP备份文件重命名为JOURNAL_FILE</span></span><br><span class="line">  File backupFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE_BACKUP);</span><br><span class="line">  <span class="keyword">if</span> (backupFile.exists()) &#123;</span><br><span class="line">    File journalFile = <span class="keyword">new</span> File(directory, JOURNAL_FILE);</span><br><span class="line">    <span class="comment">// If journal file also exists just delete backup file.</span></span><br><span class="line">    <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">      backupFile.delete();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      renameTo(backupFile, journalFile, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Prefer to pick up where we left off.</span></span><br><span class="line">  DiskLruCache cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  <span class="keyword">if</span> (cache.journalFile.exists()) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 读取Jonrnal文件,恢复记录到内存 lruEntries 中</span></span><br><span class="line">      cache.readJournal();</span><br><span class="line">      <span class="comment">// 根据 lruEntries 内存中的数据简化 Journal 文件</span></span><br><span class="line">      cache.processJournal();</span><br><span class="line">      <span class="keyword">return</span> cache;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException journalIsCorrupt) &#123;</span><br><span class="line">      System.out</span><br><span class="line">          .println(<span class="string">"DiskLruCache "</span></span><br><span class="line">              + directory</span><br><span class="line">              + <span class="string">" is corrupt: "</span></span><br><span class="line">              + journalIsCorrupt.getMessage()</span><br><span class="line">              + <span class="string">", removing"</span>);</span><br><span class="line">      cache.delete();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Create a new empty cache.</span></span><br><span class="line">  directory.mkdirs();</span><br><span class="line">  cache = <span class="keyword">new</span> DiskLruCache(directory, appVersion, valueCount, maxSize);</span><br><span class="line">  <span class="comment">// 创建一个 journal.tmp 文件，并写入文件头</span></span><br><span class="line">  cache.rebuildJournal();</span><br><span class="line">  <span class="keyword">return</span> cache;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法的一开始，会检查 journal.bkp 文件是否存在。如果 journal 文件和 journal.bkp 文件同时存在，会删除 journal.bkp 文件。否则会把 journal.bkp 文件转化成 journal 文件。</p>
<p>接着，如果 journal 文件存在的话，会调用 readJournal() 读取每一行的 journal 文件的记录，把数据恢复到 lruEntries 中。然后 processJournal() 负责将清除掉 journal.tmp 中间文件，清除掉 journal 文件中冗余的记录。并且会计算出当前 DiskLruCache 总文件的大小。</p>
<p>我们来看看 readJournal() 方法和 processJournal() 方法的源码。</p>
<h2 id="readJournal_28_29"><a href="#readJournal_28_29" class="headerlink" title="readJournal()"></a>readJournal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  StrictLineReader reader = <span class="keyword">new</span> StrictLineReader(<span class="keyword">new</span> FileInputStream(journalFile), Util.US_ASCII);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 先校验一下文件头的各式和数据是否正确</span></span><br><span class="line">    String magic = reader.readLine();</span><br><span class="line">    String version = reader.readLine();</span><br><span class="line">    String appVersionString = reader.readLine();</span><br><span class="line">    String valueCountString = reader.readLine();</span><br><span class="line">    String blank = reader.readLine();</span><br><span class="line">    <span class="keyword">if</span> (!MAGIC.equals(magic)</span><br><span class="line">        || !VERSION_1.equals(version)</span><br><span class="line">        || !Integer.toString(appVersion).equals(appVersionString)</span><br><span class="line">        || !Integer.toString(valueCount).equals(valueCountString)</span><br><span class="line">        || !<span class="string">""</span>.equals(blank)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal header: ["</span> + magic + <span class="string">", "</span> + version + <span class="string">", "</span></span><br><span class="line">          + valueCountString + <span class="string">", "</span> + blank + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> lineCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 读取每一行，进行恢复数据</span></span><br><span class="line">        readJournalLine(reader.readLine());</span><br><span class="line">        lineCount++;</span><br><span class="line">      &#125; <span class="keyword">catch</span> (EOFException endOfJournal) &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    redundantOpCount = lineCount - lruEntries.size();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we ended on a truncated line, rebuild the journal before appending to it.</span></span><br><span class="line">    <span class="keyword">if</span> (reader.hasUnterminatedLine()) &#123;</span><br><span class="line">      rebuildJournal();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      journalWriter = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> OutputStreamWriter(</span><br><span class="line">          <span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    Util.closeQuietly(reader);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readJournal 方法中，每一行恢复数据的操作是在 readJournalLine 中进行的。</p>
<h2 id="readJournalLine_28String_line_29"><a href="#readJournalLine_28String_line_29" class="headerlink" title="readJournalLine(String line)"></a>readJournalLine(String line)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readJournalLine</span><span class="params">(String line)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> firstSpace = line.indexOf(<span class="string">' '</span>);</span><br><span class="line">  <span class="keyword">if</span> (firstSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> keyBegin = firstSpace + <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">int</span> secondSpace = line.indexOf(<span class="string">' '</span>, keyBegin);</span><br><span class="line">  <span class="keyword">final</span> String key;</span><br><span class="line">  <span class="keyword">if</span> (secondSpace == -<span class="number">1</span>) &#123;</span><br><span class="line">    key = line.substring(keyBegin);</span><br><span class="line">    <span class="keyword">if</span> (firstSpace == REMOVE.length() &amp;&amp; line.startsWith(REMOVE)) &#123;</span><br><span class="line">      lruEntries.remove(key);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    key = line.substring(keyBegin, secondSpace);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (secondSpace != -<span class="number">1</span> &amp;&amp; firstSpace == CLEAN.length() &amp;&amp; line.startsWith(CLEAN)) &#123;</span><br><span class="line">    String[] parts = line.substring(secondSpace + <span class="number">1</span>).split(<span class="string">" "</span>);</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">    entry.setLengths(parts);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == DIRTY.length() &amp;&amp; line.startsWith(DIRTY)) &#123;</span><br><span class="line">    entry.currentEditor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (secondSpace == -<span class="number">1</span> &amp;&amp; firstSpace == READ.length() &amp;&amp; line.startsWith(READ)) &#123;</span><br><span class="line">    <span class="comment">// This work was already done by calling lruEntries.get().</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"unexpected journal line: "</span> + line);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>readJournalLine 方法中，会判断每一行开头是 CLEAN DIRTY REMOVE READ 中的哪一种，然后分别进行不同的操作。具体在这里就不详细讲了。</p>
<p>然后我们再来看看 processJournal 。</p>
<h2 id="processJournal_28_29"><a href="#processJournal_28_29" class="headerlink" title="processJournal()"></a>processJournal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// 删除 journal.tmp 文件</span></span><br><span class="line">  deleteIfExists(journalFileTmp);</span><br><span class="line">  <span class="keyword">for</span> (Iterator&lt;Entry&gt; i = lruEntries.values().iterator(); i.hasNext(); ) &#123;</span><br><span class="line">    Entry entry = i.next();</span><br><span class="line">    <span class="keyword">if</span> (entry.currentEditor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        <span class="comment">// 计算 DiskLruCache 缓存的总大小</span></span><br><span class="line">        size += entry.lengths[t];</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果是冗余的数据，直接删除</span></span><br><span class="line">      entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">int</span> t = <span class="number">0</span>; t &lt; valueCount; t++) &#123;</span><br><span class="line">        deleteIfExists(entry.getCleanFile(t));</span><br><span class="line">        deleteIfExists(entry.getDirtyFile(t));</span><br><span class="line">      &#125;</span><br><span class="line">      i.remove();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外需要注意的是，当我们首次调用 DiskLruCache.open 方法时，磁盘上是没有任何 journal 文件的，因此会执行 rebuildJournal() 来创建 journal 文件。</p>
<h2 id="rebuildJournal_28_29"><a href="#rebuildJournal_28_29" class="headerlink" title="rebuildJournal()"></a>rebuildJournal()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">rebuildJournal</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (journalWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">    journalWriter.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Writer writer = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFileTmp), Util.US_ASCII));</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 写入文件头</span></span><br><span class="line">    writer.write(MAGIC);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(VERSION_1);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(appVersion));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(Integer.toString(valueCount));</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line">    writer.write(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Entry entry : lruEntries.values()) &#123;</span><br><span class="line">      <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        writer.write(DIRTY + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        writer.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    writer.close();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalFile.exists()) &#123;</span><br><span class="line">    renameTo(journalFile, journalFileBackup, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  renameTo(journalFileTmp, journalFile, <span class="keyword">false</span>);</span><br><span class="line">  journalFileBackup.delete();</span><br><span class="line"></span><br><span class="line">  journalWriter = <span class="keyword">new</span> BufferedWriter(</span><br><span class="line">      <span class="keyword">new</span> OutputStreamWriter(<span class="keyword">new</span> FileOutputStream(journalFile, <span class="keyword">true</span>), Util.US_ASCII));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="get_28_29"><a href="#get_28_29" class="headerlink" title="get()"></a>get()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Snapshot <span class="title">get</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  validateKey(key);</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!entry.readable) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Open all streams eagerly to guarantee that we see a single published</span></span><br><span class="line">  <span class="comment">// snapshot. If we opened streams lazily then the streams could come</span></span><br><span class="line">  <span class="comment">// from different edits.</span></span><br><span class="line">  InputStream[] ins = <span class="keyword">new</span> InputStream[valueCount];</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      ins[i] = <span class="keyword">new</span> FileInputStream(entry.getCleanFile(i));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">    <span class="comment">// A file must have been deleted manually!</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (ins[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Util.closeQuietly(ins[i]);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(READ + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Snapshot(key, entry.sequenceNumber, ins, entry.lengths);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get()的方法内部就是获取到指定的 Entry，拿着 Entry 的 cleanFile 生成 InputStream ，封装到Snapshot 返回。</p>
<p>journalRebuildRequired() 表示是否要清理日志，如果需要就利用 cleanupCallable 清理。</p>
<h1 id="edit_28_29"><a href="#edit_28_29" class="headerlink" title="edit()"></a>edit()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Editor <span class="title">edit</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> edit(key, ANY_SEQUENCE_NUMBER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> Editor <span class="title">edit</span><span class="params">(String key, <span class="keyword">long</span> expectedSequenceNumber)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  validateKey(key);</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (expectedSequenceNumber != ANY_SEQUENCE_NUMBER &amp;&amp; (entry == <span class="keyword">null</span></span><br><span class="line">      || entry.sequenceNumber != expectedSequenceNumber)) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Snapshot is stale.</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">    entry = <span class="keyword">new</span> Entry(key);</span><br><span class="line">    lruEntries.put(key, entry);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>; <span class="comment">// Another edit is in progress.</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Editor editor = <span class="keyword">new</span> Editor(entry);</span><br><span class="line">  entry.currentEditor = editor;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Flush the journal before creating files to prevent file leaks.</span></span><br><span class="line">  journalWriter.write(DIRTY + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">  <span class="keyword">return</span> editor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>edit 方法的逻辑也是十分清晰的，加入 lruEntries ，生成Editor，向 journal 文件写入 DIRTY 记录。</p>
<p>后续 Editor 会获取 Entry 的 DirtyFile 生成一个 OutputStream 提供给外部写入。</p>
<h1 id="remove_28String_key_29"><a href="#remove_28String_key_29" class="headerlink" title="remove(String key)"></a>remove(String key)</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(String key)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  checkNotClosed();</span><br><span class="line">  validateKey(key);</span><br><span class="line">  Entry entry = lruEntries.get(key);</span><br><span class="line">  <span class="keyword">if</span> (entry == <span class="keyword">null</span> || entry.currentEditor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File file = entry.getCleanFile(i);</span><br><span class="line">    <span class="keyword">if</span> (file.exists() &amp;&amp; !file.delete()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to delete "</span> + file);</span><br><span class="line">    &#125;</span><br><span class="line">    size -= entry.lengths[i];</span><br><span class="line">    entry.lengths[i] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  journalWriter.append(REMOVE + <span class="string">' '</span> + key + <span class="string">'\n'</span>);</span><br><span class="line">  lruEntries.remove(key);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>删除 key 对应的所有文件，然后把操作记录到 journal 文件中。</p>
<h1 id="commit_28_29"><a href="#commit_28_29" class="headerlink" title="commit()"></a>commit()</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">commit</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (hasErrors) &#123;</span><br><span class="line">    completeEdit(<span class="keyword">this</span>, <span class="keyword">false</span>);</span><br><span class="line">    remove(entry.key); <span class="comment">// The previous entry is stale.</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    completeEdit(<span class="keyword">this</span>, <span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  committed = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">completeEdit</span><span class="params">(Editor editor, <span class="keyword">boolean</span> success)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Entry entry = editor.entry;</span><br><span class="line">  <span class="keyword">if</span> (entry.currentEditor != editor) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If this edit is creating the entry for the first time, every index must have a value.</span></span><br><span class="line">  <span class="comment">// 下面是editor和entry的dirtyFile做检查</span></span><br><span class="line">  <span class="keyword">if</span> (success &amp;&amp; !entry.readable) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!editor.written[i]) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Newly created entry didn't create value for index "</span> + i);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!entry.getDirtyFile(i).exists()) &#123;</span><br><span class="line">        editor.abort();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 将entry的DirtyFile重命名为CleanFile，计算总的size大小，表示写成功</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; valueCount; i++) &#123;</span><br><span class="line">    File dirty = entry.getDirtyFile(i);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      <span class="keyword">if</span> (dirty.exists()) &#123;</span><br><span class="line">        File clean = entry.getCleanFile(i);</span><br><span class="line">        dirty.renameTo(clean);</span><br><span class="line">        <span class="keyword">long</span> oldLength = entry.lengths[i];</span><br><span class="line">        <span class="keyword">long</span> newLength = clean.length();</span><br><span class="line">        entry.lengths[i] = newLength;</span><br><span class="line">        size = size - oldLength + newLength;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      deleteIfExists(dirty);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  redundantOpCount++;</span><br><span class="line">  <span class="comment">// 将entry.currentEditor 赋空，表示写完成了。不处于写状态</span></span><br><span class="line">  entry.currentEditor = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">// 成功则将entry设置可读，增加一个CLEAN记录，否则失败了就移除掉entry，增加一个REMOVE记录</span></span><br><span class="line">  <span class="keyword">if</span> (entry.readable | success) &#123;</span><br><span class="line">    entry.readable = <span class="keyword">true</span>;</span><br><span class="line">    journalWriter.write(CLEAN + <span class="string">' '</span> + entry.key + entry.getLengths() + <span class="string">'\n'</span>);</span><br><span class="line">    <span class="keyword">if</span> (success) &#123;</span><br><span class="line">      entry.sequenceNumber = nextSequenceNumber++;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    lruEntries.remove(entry.key);</span><br><span class="line">    journalWriter.write(REMOVE + <span class="string">' '</span> + entry.key + <span class="string">'\n'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  journalWriter.flush();</span><br><span class="line">	<span class="comment">// 如果超过了容量限制，走清理工作</span></span><br><span class="line">  <span class="keyword">if</span> (size &gt; maxSize || journalRebuildRequired()) &#123;</span><br><span class="line">    executorService.submit(cleanupCallable);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>DiskLruCache 核心思想就是利用 LinkedHashMap 来做到 LRU，然后每个 Entry 中做到读写分离，互不影响。最后就是把操作的记录完整地写入文件中，进行持久化，做到下次使用时恢复数据到内存中。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>DiskLruCache : <a href="https://github.com/JakeWharton/DiskLruCache" target="_blank" rel="external">https://github.com/JakeWharton/DiskLr]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="算法" scheme="http://yuqirong.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Glide源码解析(三)]]></title>
    <link href="http://yuqirong.github.io/2019/08/07/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)/"/>
    <id>http://yuqirong.github.io/2019/08/07/Glide源码解析(三)/</id>
    <published>2019-08-07T09:12:29.000Z</published>
    <updated>2019-08-07T16:36:36.775Z</updated>
    <content type="html"><![CDATA[<p>本篇是 Glide 系列的最后一篇，主要讲一下 into 方法里面的逻辑。into 的逻辑也是最多最复杂的，可能需要反复阅读源码才能搞清楚。</p>
<p>Glide : <a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a></p>
<p>version : v4.9.0</p>
<h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="keyword">public</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(@NonNull Y target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, <span class="comment">/*targetListener=*/</span> <span class="keyword">null</span>, Executors.mainThreadExecutor());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@Synthetic</span></span><br><span class="line">&lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span><br><span class="line">    @NonNull Y target,</span><br><span class="line">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> into(target, targetListener, <span class="comment">/*options=*/</span> <span class="keyword">this</span>, callbackExecutor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>into 方法最后都会调用 <code>into(@NonNull Y target, @Nullable RequestListener&lt;TranscodeType&gt; targetListener, BaseRequestOptions&lt;?&gt; options,  Executor callbackExecutor)</code></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Y extends Target&lt;TranscodeType&gt;&gt; <span class="function">Y <span class="title">into</span><span class="params">(</span><br><span class="line">    @NonNull Y target,</span><br><span class="line">    @Nullable RequestListener&lt;TranscodeType&gt; targetListener,</span><br><span class="line">    BaseRequestOptions&lt;?&gt; options,</span><br><span class="line">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(target);</span><br><span class="line">  <span class="comment">// 判断有没有调用过 load 方法</span></span><br><span class="line">  <span class="keyword">if</span> (!isModelSet) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You must call #load() before calling #into()"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 这里根据一堆参数会去构造图片请求 SingleRequest</span></span><br><span class="line">  Request request = buildRequest(target, targetListener, options, callbackExecutor);</span><br><span class="line"></span><br><span class="line">  Request previous = target.getRequest();</span><br><span class="line">  <span class="keyword">if</span> (request.isEquivalentTo(previous)</span><br><span class="line">      &amp;&amp; !isSkipMemoryCacheWithCompletePreviousRequest(options, previous)) &#123;</span><br><span class="line">    request.recycle();</span><br><span class="line">    <span class="comment">// If the request is completed, beginning again will ensure the result is re-delivered,</span></span><br><span class="line">    <span class="comment">// triggering RequestListeners and Targets. If the request is failed, beginning again will</span></span><br><span class="line">    <span class="comment">// restart the request, giving it another chance to complete. If the request is already</span></span><br><span class="line">    <span class="comment">// running, we can let it continue running without interruption.</span></span><br><span class="line">    <span class="keyword">if</span> (!Preconditions.checkNotNull(previous).isRunning()) &#123;</span><br><span class="line">      <span class="comment">// Use the previous request rather than the new one to allow for optimizations like skipping</span></span><br><span class="line">      <span class="comment">// setting placeholders, tracking and un-tracking Targets, and obtaining View dimensions</span></span><br><span class="line">      <span class="comment">// that are done in the individual Request.</span></span><br><span class="line">      previous.begin();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> target;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  requestManager.clear(target);</span><br><span class="line">  target.setRequest(request);</span><br><span class="line">  requestManager.track(target, request);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> target;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>构造出请求 request 后，重点关注下 requestManager.track 方法，由 requestManager 来执行这个请求。</p>
<h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">track</span><span class="params">(@NonNull Target&lt;?&gt; target, @NonNull Request request)</span> </span>&#123;</span><br><span class="line">  targetTracker.track(target);</span><br><span class="line">  requestTracker.runRequest(request);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>track 方法中调用了两个方法：</p>
<ol>
<li>TargetTracker.track() 方法会对当前 Target 的生命周期进行管理;</li>
<li>RequestTracker.runRequest() 方法对当前请求进行管理;</li>
</ol>
<h2 id="RequestTracker"><a href="#RequestTracker" class="headerlink" title="RequestTracker"></a>RequestTracker</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runRequest</span><span class="params">(@NonNull Request request)</span> </span>&#123;</span><br><span class="line">  requests.add(request);</span><br><span class="line">  <span class="keyword">if</span> (!isPaused) &#123;</span><br><span class="line">    request.begin();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    request.clear();</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Paused, delaying request"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pendingRequests.add(request);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当 Glide 未处于暂停状态的时候，会直接使用 Request.begin() 方法开启请求。</p>
<h2 id="SingleRequest"><a href="#SingleRequest" class="headerlink" title="SingleRequest"></a>SingleRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">begin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  assertNotCallingCallbacks();</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">if</span> (model == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">      width = overrideWidth;</span><br><span class="line">      height = overrideHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Only log at more verbose log levels if the user has set a fallback drawable, because</span></span><br><span class="line">    <span class="comment">// fallback Drawables indicate the user expects null models occasionally.</span></span><br><span class="line">    <span class="keyword">int</span> logLevel = getFallbackDrawable() == <span class="keyword">null</span> ? Log.WARN : Log.DEBUG;</span><br><span class="line">    onLoadFailed(<span class="keyword">new</span> GlideException(<span class="string">"Received null model"</span>), logLevel);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (status == Status.RUNNING) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot restart a running request"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If we're restarted after we're complete (usually via something like a notifyDataSetChanged</span></span><br><span class="line">  <span class="comment">// that starts an identical request into the same Target or View), we can simply use the</span></span><br><span class="line">  <span class="comment">// resource and size we retrieved the last time around and skip obtaining a new size, starting a</span></span><br><span class="line">  <span class="comment">// new load etc. This does mean that users who want to restart a load because they expect that</span></span><br><span class="line">  <span class="comment">// the view size has changed will need to explicitly clear the View or Target before starting</span></span><br><span class="line">  <span class="comment">// the new load.</span></span><br><span class="line">  <span class="keyword">if</span> (status == Status.COMPLETE) &#123;</span><br><span class="line">    onResourceReady(resource, DataSource.MEMORY_CACHE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Restarts for requests that are neither complete nor running can be treated as new requests</span></span><br><span class="line">  <span class="comment">// and can run again from the beginning.</span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 主要来看这里，之前的都是一些对请求的状态判断</span></span><br><span class="line">  status = Status.WAITING_FOR_SIZE;</span><br><span class="line">  <span class="keyword">if</span> (Util.isValidDimensions(overrideWidth, overrideHeight)) &#123;</span><br><span class="line">    onSizeReady(overrideWidth, overrideHeight);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    target.getSize(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> ((status == Status.RUNNING || status == Status.WAITING_FOR_SIZE)</span><br><span class="line">      &amp;&amp; canNotifyStatusChanged()) &#123;</span><br><span class="line">    target.onLoadStarted(getPlaceholderDrawable());</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"finished run method in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 begin 方法中，重点关注下 </p>
<pre><code>if (Util.isValidDimensions(overrideWidth, overrideHeight)) {
  onSizeReady(overrideWidth, overrideHeight);
} else {
  target.getSize(this);
}
</code></pre><p>这里会根据有没有强制设置图片宽度来分为两部分：</p>
<ul>
<li>设置了，直接调用 onSizeReady</li>
<li>没设置，会去调用 target.getSize 。做的事情就是给 view 添加 addOnPreDrawListener 。这样的话，在绘制之前获取到了 view 的宽高，然后再回调 onSizeReady</li>
</ul>
<p>所以，说到底，最后都是会调用 onSizeReady 的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onSizeReady</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height)</span> </span>&#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"Got onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (status != Status.WAITING_FOR_SIZE) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  status = Status.RUNNING;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">float</span> sizeMultiplier = requestOptions.getSizeMultiplier();</span><br><span class="line">  <span class="keyword">this</span>.width = maybeApplySizeMultiplier(width, sizeMultiplier);</span><br><span class="line">  <span class="keyword">this</span>.height = maybeApplySizeMultiplier(height, sizeMultiplier);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"finished setup for calling load in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">  loadStatus =</span><br><span class="line">      engine.load(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          requestOptions.getSignature(),</span><br><span class="line">          <span class="keyword">this</span>.width,</span><br><span class="line">          <span class="keyword">this</span>.height,</span><br><span class="line">          requestOptions.getResourceClass(),</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          requestOptions.getDiskCacheStrategy(),</span><br><span class="line">          requestOptions.getTransformations(),</span><br><span class="line">          requestOptions.isTransformationRequired(),</span><br><span class="line">          requestOptions.isScaleOnlyOrNoTransform(),</span><br><span class="line">          requestOptions.getOptions(),</span><br><span class="line">          requestOptions.isMemoryCacheable(),</span><br><span class="line">          requestOptions.getUseUnlimitedSourceGeneratorsPool(),</span><br><span class="line">          requestOptions.getUseAnimationPool(),</span><br><span class="line">          requestOptions.getOnlyRetrieveFromCache(),</span><br><span class="line">          <span class="keyword">this</span>,</span><br><span class="line">          callbackExecutor);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This is a hack that's only useful for testing right now where loads complete synchronously</span></span><br><span class="line">  <span class="comment">// even though under any executor running on any thread but the main thread, the load would</span></span><br><span class="line">  <span class="comment">// have completed asynchronously.</span></span><br><span class="line">  <span class="keyword">if</span> (status != Status.RUNNING) &#123;</span><br><span class="line">    loadStatus = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (IS_VERBOSE_LOGGABLE) &#123;</span><br><span class="line">    logV(<span class="string">"finished onSizeReady in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 onSizeReady 中将状态更改为 Status.RUNNING ，并调用 engine 的 load() 方法。</p>
<h2 id="Engine"><a href="#Engine" class="headerlink" title="Engine"></a>Engine</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">load</span><span class="params">(</span><br><span class="line">    GlideContext glideContext,</span><br><span class="line">    Object model,</span><br><span class="line">    Key signature,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    Class&lt;?&gt; resourceClass,</span><br><span class="line">    Class&lt;R&gt; transcodeClass,</span><br><span class="line">    Priority priority,</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">    <span class="keyword">boolean</span> isTransformationRequired,</span><br><span class="line">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span><br><span class="line">    Options options,</span><br><span class="line">    <span class="keyword">boolean</span> isMemoryCacheable,</span><br><span class="line">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span><br><span class="line">    <span class="keyword">boolean</span> useAnimationPool,</span><br><span class="line">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span><br><span class="line">    ResourceCallback cb,</span><br><span class="line">    Executor callbackExecutor)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = VERBOSE_IS_LOGGABLE ? LogTime.getLogTime() : <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 构造此图片的缓存 key</span></span><br><span class="line">  EngineKey key =</span><br><span class="line">      keyFactory.buildKey(</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          transformations,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          options);</span><br><span class="line"></span><br><span class="line">  EngineResource&lt;?&gt; memoryResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    memoryResource = loadFromMemory(key, isMemoryCacheable, startTime);</span><br><span class="line">    <span class="comment">// 查看有没有图片缓存，如果没有的话就开启新的任务加载</span></span><br><span class="line">    <span class="keyword">if</span> (memoryResource == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> waitForExistingOrStartNewJob(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          options,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          cb,</span><br><span class="line">          callbackExecutor,</span><br><span class="line">          key,</span><br><span class="line">          startTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Avoid calling back while holding the engine lock, doing so makes it easier for callers to</span></span><br><span class="line">  <span class="comment">// deadlock.</span></span><br><span class="line">  <span class="comment">// 如果有的话，直接回调 SingleRequest 的 onResourceReady 方法</span></span><br><span class="line">  cb.onResourceReady(memoryResource, DataSource.MEMORY_CACHE);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 load 中，Glide 会先去取缓存，当缓存中不存在的时候就准备使用新创建一个任务来加载图片。我们这里就当作是第一次加载图片了，所以跟进 waitForExistingOrStartNewJob 方法中看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;R&gt; <span class="function">LoadStatus <span class="title">waitForExistingOrStartNewJob</span><span class="params">(</span><br><span class="line">    GlideContext glideContext,</span><br><span class="line">    Object model,</span><br><span class="line">    Key signature,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    Class&lt;?&gt; resourceClass,</span><br><span class="line">    Class&lt;R&gt; transcodeClass,</span><br><span class="line">    Priority priority,</span><br><span class="line">    DiskCacheStrategy diskCacheStrategy,</span><br><span class="line">    Map&lt;Class&lt;?&gt;, Transformation&lt;?&gt;&gt; transformations,</span><br><span class="line">    <span class="keyword">boolean</span> isTransformationRequired,</span><br><span class="line">    <span class="keyword">boolean</span> isScaleOnlyOrNoTransform,</span><br><span class="line">    Options options,</span><br><span class="line">    <span class="keyword">boolean</span> isMemoryCacheable,</span><br><span class="line">    <span class="keyword">boolean</span> useUnlimitedSourceExecutorPool,</span><br><span class="line">    <span class="keyword">boolean</span> useAnimationPool,</span><br><span class="line">    <span class="keyword">boolean</span> onlyRetrieveFromCache,</span><br><span class="line">    ResourceCallback cb,</span><br><span class="line">    Executor callbackExecutor,</span><br><span class="line">    EngineKey key,</span><br><span class="line">    <span class="keyword">long</span> startTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;?&gt; current = jobs.get(key, onlyRetrieveFromCache);</span><br><span class="line">  <span class="keyword">if</span> (current != <span class="keyword">null</span>) &#123;</span><br><span class="line">    current.addCallback(cb, callbackExecutor);</span><br><span class="line">    <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Added to existing load"</span>, startTime, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, current);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  EngineJob&lt;R&gt; engineJob =</span><br><span class="line">      engineJobFactory.build(</span><br><span class="line">          key,</span><br><span class="line">          isMemoryCacheable,</span><br><span class="line">          useUnlimitedSourceExecutorPool,</span><br><span class="line">          useAnimationPool,</span><br><span class="line">          onlyRetrieveFromCache);</span><br><span class="line"></span><br><span class="line">  DecodeJob&lt;R&gt; decodeJob =</span><br><span class="line">      decodeJobFactory.build(</span><br><span class="line">          glideContext,</span><br><span class="line">          model,</span><br><span class="line">          key,</span><br><span class="line">          signature,</span><br><span class="line">          width,</span><br><span class="line">          height,</span><br><span class="line">          resourceClass,</span><br><span class="line">          transcodeClass,</span><br><span class="line">          priority,</span><br><span class="line">          diskCacheStrategy,</span><br><span class="line">          transformations,</span><br><span class="line">          isTransformationRequired,</span><br><span class="line">          isScaleOnlyOrNoTransform,</span><br><span class="line">          onlyRetrieveFromCache,</span><br><span class="line">          options,</span><br><span class="line">          engineJob);</span><br><span class="line"></span><br><span class="line">  jobs.put(key, engineJob);</span><br><span class="line"></span><br><span class="line">  engineJob.addCallback(cb, callbackExecutor);</span><br><span class="line">  engineJob.start(decodeJob);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (VERBOSE_IS_LOGGABLE) &#123;</span><br><span class="line">    logWithTimeAndKey(<span class="string">"Started new load"</span>, startTime, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LoadStatus(cb, engineJob);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面方法中创建了两个对象，一个是 DecodeJob、一个是 EngineJob。它们之间的关系是，EngineJob 内部维护了线程池，用来管理资源加载，已经当资源加载完毕的时候通知回调。 DecodeJob 继承了 Runnable，是线程池当中的一个任务。就像上面那样，我们通过调用 engineJob.start(decodeJob) 来开始执行图片加载的任务。</p>
<h2 id="EngineJob"><a href="#EngineJob" class="headerlink" title="EngineJob"></a>EngineJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">(DecodeJob&lt;R&gt; decodeJob)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.decodeJob = decodeJob;</span><br><span class="line">  GlideExecutor executor =</span><br><span class="line">      decodeJob.willDecodeFromCache() ? diskCacheExecutor : getActiveSourceExecutor();</span><br><span class="line">  executor.execute(decodeJob);</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">执行 decodeJob 。所以直接看 DecodeJob 的 run 方法。</span><br><span class="line"></span><br><span class="line">DecodeJob</span><br><span class="line">----</span><br><span class="line">``` java</span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This should be much more fine grained, but since Java's thread pool implementation silently</span></span><br><span class="line">  <span class="comment">// swallows all otherwise fatal exceptions, this will at least make it obvious to developers</span></span><br><span class="line">  <span class="comment">// that something is failing.</span></span><br><span class="line">  GlideTrace.beginSectionFormat(<span class="string">"DecodeJob#run(model=%s)"</span>, model);</span><br><span class="line">  <span class="comment">// Methods in the try statement can invalidate currentFetcher, so set a local variable here to</span></span><br><span class="line">  <span class="comment">// ensure that the fetcher is cleaned up either way.</span></span><br><span class="line">  DataFetcher&lt;?&gt; localFetcher = currentFetcher;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      notifyFailed();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    runWrapped();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (CallbackException e) &#123;</span><br><span class="line">    <span class="comment">// If a callback not controlled by Glide throws an exception, we should avoid the Glide</span></span><br><span class="line">    <span class="comment">// specific debug logic below.</span></span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="comment">// Catch Throwable and not Exception to handle OOMs. Throwables are swallowed by our</span></span><br><span class="line">    <span class="comment">// usage of .submit() in GlideExecutor so we're not silently hiding crashes by doing this. We</span></span><br><span class="line">    <span class="comment">// are however ensuring that our callbacks are always notified when a load fails. Without this</span></span><br><span class="line">    <span class="comment">// notification, uncaught throwables never notify the corresponding callbacks, which can cause</span></span><br><span class="line">    <span class="comment">// loads to silently hang forever, a case that's especially bad for users using Futures on</span></span><br><span class="line">    <span class="comment">// background threads.</span></span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(</span><br><span class="line">          TAG,</span><br><span class="line">          <span class="string">"DecodeJob threw unexpectedly"</span> + <span class="string">", isCancelled: "</span> + isCancelled + <span class="string">", stage: "</span> + stage,</span><br><span class="line">          t);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// When we're encoding we've already notified our callback and it isn't safe to do so again.</span></span><br><span class="line">    <span class="keyword">if</span> (stage != Stage.ENCODE) &#123;</span><br><span class="line">      throwables.add(t);</span><br><span class="line">      notifyFailed();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isCancelled) &#123;</span><br><span class="line">      <span class="keyword">throw</span> t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> t;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="comment">// Keeping track of the fetcher here and calling cleanup is excessively paranoid, we call</span></span><br><span class="line">    <span class="comment">// close in all cases anyway.</span></span><br><span class="line">    <span class="keyword">if</span> (localFetcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">      localFetcher.cleanup();</span><br><span class="line">    &#125;</span><br><span class="line">    GlideTrace.endSection();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 run 方法中，当前任务没有被取消的话，会进入到 runWrapped() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE: <span class="comment">// 一进来是 INITIALIZE 状态的</span></span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE); <span class="comment">// 获取 Stage.INITIALIZE 的下一步</span></span><br><span class="line">      currentGenerator = getNextGenerator(); <span class="comment">// 根据获取到的 stage 来选择不同的 Generator</span></span><br><span class="line">      runGenerators(); <span class="comment">// 运行 Generator</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">这里一开始进入的时候，runReason 是 INITIALIZE 状态的。在 getNextStage 中，因为没有图片缓存所以得到是的 Stage.SOURCE 。那么就接着到了 getNextGenerator 。</span><br><span class="line"></span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">private</span> DataFetcherGenerator <span class="title">getNextGenerator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (stage) &#123;</span><br><span class="line">    <span class="keyword">case</span> RESOURCE_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ResourceCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> DATA_CACHE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> DataCacheGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> SOURCE:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SourceGenerator(decodeHelper, <span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">case</span> FINISHED:</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized stage: "</span> + stage);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stage 是 SOURCE ，所以获取到的就是 SourceGenerator 。接着就调用 runGenerators() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123; <span class="comment">// 这里执行 currentGenerator.startNext</span></span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We've run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class="line">  <span class="comment">// onDataFetcherReady.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>会先去执行 currentGenerator.startNext() 。所以接着就跳转到 SourceGenerator.startNext() 。</p>
<h2 id="SourceGenerator"><a href="#SourceGenerator" class="headerlink" title="SourceGenerator"></a>SourceGenerator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 一开始肯定没有数据来缓存的，所以往下走</span></span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    <span class="comment">// 使用 DecodeHelper 的 getLoadData() 方法从注册的映射表中找出当前的图片类型对应的 ModelLoader；</span></span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      <span class="comment">// 这里调用 ModelLoader 中的 fetcher 去加载数据</span></span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为之前我们的想法是加载网络上的 url 图片，所以这里的 loadData 就对应着 HttpGlideUrlLoader<br>， fetcher 就是 HttpUrlFetcher 。</p>
<h2 id="HttpUrlFetcher"><a href="#HttpUrlFetcher" class="headerlink" title="HttpUrlFetcher"></a>HttpUrlFetcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span><br><span class="line">    @NonNull Priority priority, @NonNull DataCallback&lt;? <span class="keyword">super</span> InputStream&gt; callback)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 在这里获取网络上的图片数据</span></span><br><span class="line">    InputStream result = loadDataWithRedirects(glideUrl.toURL(), <span class="number">0</span>, <span class="keyword">null</span>, glideUrl.getHeaders());</span><br><span class="line">    <span class="comment">// 回调 onDataReady</span></span><br><span class="line">    callback.onDataReady(result);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to load data for url"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(TAG, <span class="string">"Finished http url fetcher fetch in "</span> + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadDataWithRedirects 中会去调用 HttpURLConnection 加载网络上的图片数据。</p>
<p>加载完之后，会回调 onDataReady 方法。这个回调一直从 HttpUrlFetcher 中一直回调到 SourceGenerator 中。所以下面就来看看 SourceGenerator.onDataReady</p>
<h2 id="SourceGenerator-1"><a href="#SourceGenerator-1" class="headerlink" title="SourceGenerator"></a>SourceGenerator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">  DiskCacheStrategy diskCacheStrategy = helper.getDiskCacheStrategy();</span><br><span class="line">  <span class="keyword">if</span> (data != <span class="keyword">null</span> &amp;&amp; diskCacheStrategy.isDataCacheable(loadData.fetcher.getDataSource())) &#123;</span><br><span class="line">    dataToCache = data;</span><br><span class="line">    <span class="comment">// We might be being called back on someone else's thread. Before doing anything, we should</span></span><br><span class="line">    <span class="comment">// reschedule to get back onto Glide's thread.</span></span><br><span class="line">    cb.reschedule();</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    cb.onDataFetcherReady(</span><br><span class="line">        loadData.sourceKey,</span><br><span class="line">        data,</span><br><span class="line">        loadData.fetcher,</span><br><span class="line">        loadData.fetcher.getDataSource(),</span><br><span class="line">        originalKey);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 onDataReady 中，会去判断如果 data 不为空并且磁盘缓存可以缓存的情况下，会调用 cb.reschedule(); 。这其实是调用了 DecodeJob 的 reschedule 方法。</p>
<h2 id="DecodeJob"><a href="#DecodeJob" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  runReason = RunReason.SWITCH_TO_SOURCE_SERVICE;</span><br><span class="line">  callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，设置 runReason 为 RunReason.SWITCH_TO_SOURCE_SERVICE ，这很关键，在下面代码中会用到。然后再调用 callback.reschedule(this) 。其实就是调用了 EngineJob 的 reschedule 方法。</p>
<h2 id="EngineJob-1"><a href="#EngineJob-1" class="headerlink" title="EngineJob"></a>EngineJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reschedule</span><span class="params">(DecodeJob&lt;?&gt; job)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Even if the job is cancelled here, it still needs to be scheduled so that it can clean itself</span></span><br><span class="line">  <span class="comment">// up.</span></span><br><span class="line">  getActiveSourceExecutor().execute(job);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>reschedule 方法摆明了就是让 DecodeJob 把 run 方法再跑一遍。之前说过，DecodeJob 的 run 方法里面大部分的逻辑其实是在 runWrapped 中的。</p>
<h2 id="DecodeJob-1"><a href="#DecodeJob-1" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runWrapped</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (runReason) &#123;</span><br><span class="line">    <span class="keyword">case</span> INITIALIZE:</span><br><span class="line">      stage = getNextStage(Stage.INITIALIZE);</span><br><span class="line">      currentGenerator = getNextGenerator();</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> SWITCH_TO_SOURCE_SERVICE:</span><br><span class="line">      runGenerators();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> DECODE_DATA:</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unrecognized run reason: "</span> + runReason);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码很熟悉，之前我们的流程到过这里。不同的是，之前的 runReason 是 INITIALIZE 。而现在的 runReason 是 SWITCH_TO_SOURCE_SERVICE 。</p>
<p>接着 SWITCH_TO_SOURCE_SERVICE 的逻辑是直接调用 runGenerators 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">runGenerators</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  currentThread = Thread.currentThread();</span><br><span class="line">  startFetchTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">boolean</span> isStarted = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!isCancelled</span><br><span class="line">      &amp;&amp; currentGenerator != <span class="keyword">null</span></span><br><span class="line">      &amp;&amp; !(isStarted = currentGenerator.startNext())) &#123;</span><br><span class="line">    stage = getNextStage(stage);</span><br><span class="line">    currentGenerator = getNextGenerator();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (stage == Stage.SOURCE) &#123;</span><br><span class="line">      reschedule();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We've run out of stages and generators, give up.</span></span><br><span class="line">  <span class="keyword">if</span> ((stage == Stage.FINISHED || isCancelled) &amp;&amp; !isStarted) &#123;</span><br><span class="line">    notifyFailed();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Otherwise a generator started a new load and we expect to be called back in</span></span><br><span class="line">  <span class="comment">// onDataFetcherReady.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 currentGenerator 还是之前的 SourceGenerator ，所以还是调用 SourceGenerator.startNext 。</p>
<h2 id="SourceGenerator-2"><a href="#SourceGenerator-2" class="headerlink" title="SourceGenerator"></a>SourceGenerator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">startNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 不同的是，这里的 dataToCache 不再是空的了，而是之前从网络上下载获取到的 InputStream</span></span><br><span class="line">  <span class="comment">// 所以这里会去走创建缓存的逻辑</span></span><br><span class="line">  <span class="keyword">if</span> (dataToCache != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Object data = dataToCache;</span><br><span class="line">    dataToCache = <span class="keyword">null</span>;</span><br><span class="line">    cacheData(data);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (sourceCacheGenerator != <span class="keyword">null</span> &amp;&amp; sourceCacheGenerator.startNext()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  sourceCacheGenerator = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">  loadData = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">boolean</span> started = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">while</span> (!started &amp;&amp; hasNextModelLoader()) &#123;</span><br><span class="line">    loadData = helper.getLoadData().get(loadDataListIndex++);</span><br><span class="line">    <span class="keyword">if</span> (loadData != <span class="keyword">null</span></span><br><span class="line">        &amp;&amp; (helper.getDiskCacheStrategy().isDataCacheable(loadData.fetcher.getDataSource())</span><br><span class="line">            || helper.hasLoadPath(loadData.fetcher.getDataClass()))) &#123;</span><br><span class="line">      started = <span class="keyword">true</span>;</span><br><span class="line">      loadData.fetcher.loadData(helper.getPriority(), <span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> started;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这次调用 SourceGenerator.startNext 其实是建立磁盘缓存，直接来看 cacheData 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cacheData</span><span class="params">(Object dataToCache)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 建立缓存</span></span><br><span class="line">    Encoder&lt;Object&gt; encoder = helper.getSourceEncoder(dataToCache);</span><br><span class="line">    DataCacheWriter&lt;Object&gt; writer =</span><br><span class="line">        <span class="keyword">new</span> DataCacheWriter&lt;&gt;(encoder, dataToCache, helper.getOptions());</span><br><span class="line">    originalKey = <span class="keyword">new</span> DataCacheKey(loadData.sourceKey, helper.getSignature());</span><br><span class="line">    helper.getDiskCache().put(originalKey, writer);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      Log.v(</span><br><span class="line">          TAG,</span><br><span class="line">          <span class="string">"Finished encoding source to cache"</span></span><br><span class="line">              + <span class="string">", key: "</span></span><br><span class="line">              + originalKey</span><br><span class="line">              + <span class="string">", data: "</span></span><br><span class="line">              + dataToCache</span><br><span class="line">              + <span class="string">", encoder: "</span></span><br><span class="line">              + encoder</span><br><span class="line">              + <span class="string">", duration: "</span></span><br><span class="line">              + LogTime.getElapsedMillis(startTime));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    loadData.fetcher.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 注意，这里 sourceCacheGenerator 创建一个对象，所以 sourceCacheGenerator 不再是 null </span></span><br><span class="line">  sourceCacheGenerator =</span><br><span class="line">      <span class="keyword">new</span> DataCacheGenerator(Collections.singletonList(loadData.sourceKey), helper, <span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的主要逻辑是构建一个用于将数据缓存到磁盘上面的 DataCacheGenerator。DataCacheGenerator 的流程基本与 SourceGenerator 一致，也就是根据资源文件的类型找到 ModelLoader，然后使用 DataFetcher 加载缓存的资源。与之前不同的是，这次是用 DataFecher 来加载 File 类型的资源。也就是说，当我们从网络中拿到了数据之后 Glide 会先将其缓存到磁盘上面，然后再从磁盘上面读取图片并将其显示到控件上面。所以，当从网络打开了输入流之后 SourceGenerator 的任务基本结束了，而后的显示的任务都由 DataCacheGenerator 来完成。</p>
<p>再回过头来看看 SourceGenerator.startNext 方法，在 cacheData 后面会对 sourceCacheGenerator 进行判断。由于上面已经把 sourceCacheGenerator 对象 new 出来了。所以接着就直接走 DataCacheGenerator 的 startNext 方法了。所以上面这段话就很好理解了。</p>
<pre><code>if (sourceCacheGenerator != null &amp;&amp; sourceCacheGenerator.startNext()) {
  return true;
}
</code></pre><p>那么，这里我们对 DataCacheGenerator 的逻辑就省略了。DataCacheGenerator 中的流程最终会走到<br>ByteBufferFetcher 。</p>
<p>之前的 SourceGenerator 对应着 HttpUrlFetcher ，而 DataCacheGenerator 对应着 ByteBufferFetcher 。</p>
<h2 id="ByteBufferFetcher"><a href="#ByteBufferFetcher" class="headerlink" title="ByteBufferFetcher"></a>ByteBufferFetcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadData</span><span class="params">(</span><br><span class="line">    @NonNull Priority priority, @NonNull DataCallback&lt;? <span class="keyword">super</span> ByteBuffer&gt; callback)</span> </span>&#123;</span><br><span class="line">  ByteBuffer result;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 把图片的字节流再从磁盘缓存中读取出来</span></span><br><span class="line">    result = ByteBufferUtil.fromFile(file);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.DEBUG)) &#123;</span><br><span class="line">      Log.d(TAG, <span class="string">"Failed to obtain ByteBuffer for file"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    callback.onLoadFailed(e);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 回调给 DataCacheGenerator 的 onDataReady 方法</span></span><br><span class="line">  callback.onDataReady(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>磁盘缓存好之后，再从文件中读取图片的字节流。回调给 DataCacheGenerator</p>
<h2 id="DataCacheGenerator"><a href="#DataCacheGenerator" class="headerlink" title="DataCacheGenerator"></a>DataCacheGenerator</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataReady</span><span class="params">(Object data)</span> </span>&#123;</span><br><span class="line">  cb.onDataFetcherReady(sourceKey, data, loadData.fetcher, DataSource.DATA_DISK_CACHE, sourceKey);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DataCacheGenerator 会回调 DecodeJob 的 onDataFetcherReady 方法。</p>
<h2 id="DecodeJob-2"><a href="#DecodeJob-2" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDataFetcherReady</span><span class="params">(</span><br><span class="line">    Key sourceKey, Object data, DataFetcher&lt;?&gt; fetcher, DataSource dataSource, Key attemptedKey)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.currentSourceKey = sourceKey;</span><br><span class="line">  <span class="keyword">this</span>.currentData = data;</span><br><span class="line">  <span class="keyword">this</span>.currentFetcher = fetcher;</span><br><span class="line">  <span class="keyword">this</span>.currentDataSource = dataSource;</span><br><span class="line">  <span class="keyword">this</span>.currentAttemptingKey = attemptedKey;</span><br><span class="line">  <span class="keyword">if</span> (Thread.currentThread() != currentThread) &#123;</span><br><span class="line">    runReason = RunReason.DECODE_DATA;</span><br><span class="line">    callback.reschedule(<span class="keyword">this</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    GlideTrace.beginSection(<span class="string">"DecodeJob.decodeFromRetrievedData"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      decodeFromRetrievedData();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      GlideTrace.endSection();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">runReason 已经改成 RunReason.DECODE_DATA ，说明已经进行到解码图片数据的环节了。</span><br><span class="line"></span><br><span class="line">接着调用 decodeFromRetrievedData 。</span><br><span class="line"></span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">decodeFromRetrievedData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">    logWithTimeAndKey(</span><br><span class="line">        <span class="string">"Retrieved data"</span>,</span><br><span class="line">        startFetchTime,</span><br><span class="line">        <span class="string">"data: "</span></span><br><span class="line">            + currentData</span><br><span class="line">            + <span class="string">", cache key: "</span></span><br><span class="line">            + currentSourceKey</span><br><span class="line">            + <span class="string">", fetcher: "</span></span><br><span class="line">            + currentFetcher);</span><br><span class="line">  &#125;</span><br><span class="line">  Resource&lt;R&gt; resource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    resource = decodeFromData(currentFetcher, currentData, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">    e.setLoggingDetails(currentAttemptingKey, currentDataSource);</span><br><span class="line">    throwables.add(e);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 图片资源获取到后，通知已经任务完成</span></span><br><span class="line">  <span class="keyword">if</span> (resource != <span class="keyword">null</span>) &#123;</span><br><span class="line">    notifyEncodeAndRelease(resource, currentDataSource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    runGenerators();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里我们可以看下，当 resource 最终获取到后，是通过 notifyEncodeAndRelease 来通知任务完成的。这在后面的代码解析中会讲到。</p>
<p>现在，我们就来看看关键的逻辑，接着调用 decodeFromData 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromData</span><span class="params">(</span><br><span class="line">    DataFetcher&lt;?&gt; fetcher, Data data, DataSource dataSource)</span> <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (data == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> startTime = LogTime.getLogTime();</span><br><span class="line">    Resource&lt;R&gt; result = decodeFromFetcher(data, dataSource);</span><br><span class="line">    <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">      logWithTimeAndKey(<span class="string">"Decoded result "</span> + result, startTime);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    fetcher.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用 decodeFromFetcher 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line"><span class="keyword">private</span> &lt;Data&gt; <span class="function">Resource&lt;R&gt; <span class="title">decodeFromFetcher</span><span class="params">(Data data, DataSource dataSource)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  LoadPath&lt;Data, ?, R&gt; path = decodeHelper.getLoadPath((Class&lt;Data&gt;) data.getClass());</span><br><span class="line">  <span class="keyword">return</span> runLoadPath(data, dataSource, path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了 runLoadPath 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> &lt;Data, ResourceType&gt; <span class="function">Resource&lt;R&gt; <span class="title">runLoadPath</span><span class="params">(</span><br><span class="line">    Data data, DataSource dataSource, LoadPath&lt;Data, ResourceType, R&gt; path)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Options options = getOptionsWithHardwareConfig(dataSource);</span><br><span class="line">  DataRewinder&lt;Data&gt; rewinder = glideContext.getRegistry().getRewinder(data);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// ResourceType in DecodeCallback below is required for compilation to work with gradle.</span></span><br><span class="line">    <span class="keyword">return</span> path.load(</span><br><span class="line">        rewinder, options, width, height, <span class="keyword">new</span> DecodeCallback&lt;ResourceType&gt;(dataSource));</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    rewinder.cleanup();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">调用 path.load 方法。</span><br><span class="line"></span><br><span class="line">LoadPath</span><br><span class="line">----</span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">load</span><span class="params">(</span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder,</span><br><span class="line">    @NonNull Options options,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  List&lt;Throwable&gt; throwables = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> loadWithExceptionList(rewinder, options, width, height, decodeCallback, throwables);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    listPool.release(throwables);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">直接调用 loadWithExceptionList 方法。</span><br><span class="line"></span><br><span class="line">``` <span class="function">java</span><br><span class="line"><span class="keyword">private</span> Resource&lt;Transcode&gt; <span class="title">loadWithExceptionList</span><span class="params">(</span><br><span class="line">    DataRewinder&lt;Data&gt; rewinder,</span><br><span class="line">    @NonNull Options options,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    DecodePath.DecodeCallback&lt;ResourceType&gt; decodeCallback,</span><br><span class="line">    List&lt;Throwable&gt; exceptions)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Resource&lt;Transcode&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decodePaths.size(); i &lt; size; i++) &#123;</span><br><span class="line">    DecodePath&lt;Data, ResourceType, Transcode&gt; path = decodePaths.get(i);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      result = path.decode(rewinder, width, height, options, decodeCallback);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (GlideException e) &#123;</span><br><span class="line">      exceptions.add(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GlideException(failureMessage, <span class="keyword">new</span> ArrayList&lt;&gt;(exceptions));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后会调用 DecodePath 的 decode 方法。</p>
<h2 id="DecodePath"><a href="#DecodePath" class="headerlink" title="DecodePath"></a>DecodePath</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Transcode&gt; <span class="title">decode</span><span class="params">(</span><br><span class="line">    DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    @NonNull Options options,</span><br><span class="line">    DecodeCallback&lt;ResourceType&gt; callback)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Resource&lt;ResourceType&gt; decoded = decodeResource(rewinder, width, height, options);</span><br><span class="line">  Resource&lt;ResourceType&gt; transformed = callback.onResourceDecoded(decoded);</span><br><span class="line">  <span class="keyword">return</span> transcoder.transcode(transformed, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 decode 中做了三件事：</p>
<ol>
<li>decodeResource 将原始数据转换成我们原始图片的过程;</li>
<li>callback.onResourceDecoded 是当得到了原始图片之后对图片继续处理过程;</li>
<li>transcoder.transcode 会使用 BitmapDrawableTranscoder 包装一层，即对 Drawable 进行延迟初始化处理。</li>
</ol>
<p>那么我们接着跟进 decodeResource 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResource</span><span class="params">(</span><br><span class="line">    DataRewinder&lt;DataType&gt; rewinder, <span class="keyword">int</span> width, <span class="keyword">int</span> height, @NonNull Options options)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  List&lt;Throwable&gt; exceptions = Preconditions.checkNotNull(listPool.acquire());</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> decodeResourceWithList(rewinder, width, height, options, exceptions);</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    listPool.release(exceptions);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要逻辑在 decodeResourceWithList 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Resource&lt;ResourceType&gt; <span class="title">decodeResourceWithList</span><span class="params">(</span><br><span class="line">    DataRewinder&lt;DataType&gt; rewinder,</span><br><span class="line">    <span class="keyword">int</span> width,</span><br><span class="line">    <span class="keyword">int</span> height,</span><br><span class="line">    @NonNull Options options,</span><br><span class="line">    List&lt;Throwable&gt; exceptions)</span></span><br><span class="line">    <span class="keyword">throws</span> GlideException </span>&#123;</span><br><span class="line">  Resource&lt;ResourceType&gt; result = <span class="keyword">null</span>;</span><br><span class="line">  <span class="comment">//noinspection ForLoopReplaceableByForEach to improve perf</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, size = decoders.size(); i &lt; size; i++) &#123;</span><br><span class="line">    ResourceDecoder&lt;DataType, ResourceType&gt; decoder = decoders.get(i);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      DataType data = rewinder.rewindAndGet();</span><br><span class="line">      <span class="keyword">if</span> (decoder.handles(data, options)) &#123;</span><br><span class="line">        data = rewinder.rewindAndGet();</span><br><span class="line">        result = decoder.decode(data, width, height, options);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Some decoders throw unexpectedly. If they do, we shouldn't fail the entire load path, but</span></span><br><span class="line">      <span class="comment">// instead log and continue. See #2406 for an example.</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException | RuntimeException | OutOfMemoryError e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (Log.isLoggable(TAG, Log.VERBOSE)) &#123;</span><br><span class="line">        Log.v(TAG, <span class="string">"Failed to decode data for "</span> + decoder, e);</span><br><span class="line">      &#125;</span><br><span class="line">      exceptions.add(e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> GlideException(failureMessage, <span class="keyword">new</span> ArrayList&lt;&gt;(exceptions));</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResourceDecoder 具有多个实现类，比如 BitmapDrawableDecoder、ByteBufferBitmapDecoder等。从名字也可以看出来是用来将一个类型转换成另一个类型的。</p>
<p>在这里会使用 ByteBufferBitmapDecoder 来将 ByteBuffer 专成 Bitmap 。</p>
<h2 id="ByteBufferBitmapDecoder"><a href="#ByteBufferBitmapDecoder" class="headerlink" title="ByteBufferBitmapDecoder"></a>ByteBufferBitmapDecoder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Resource&lt;Bitmap&gt; <span class="title">decode</span><span class="params">(</span><br><span class="line">    @NonNull ByteBuffer source, <span class="keyword">int</span> width, <span class="keyword">int</span> height, @NonNull Options options)</span></span><br><span class="line">    <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  InputStream is = ByteBufferUtil.toStream(source);</span><br><span class="line">  <span class="keyword">return</span> downsampler.decode(is, width, height, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它最终会在 Downsampler 的 decodeStream() 方法中调用 BitmapFactory 的 decodeStream() 方法来从输入流中得到 Bitmap。</p>
<p>在 Downsampler 内部还会维持一个 BitmapPool ，用来复用 Bitmap 。有兴趣的同学可以看下这一块的代码，这里就不过多展示了。</p>
<p>接下来，就来看看上面 callback.onResourceDecoded 的逻辑。callback.onResourceDecoded 会调用 DecodeJob.onResourceDecoded 方法。</p>
<h2 id="DecodeJob-3"><a href="#DecodeJob-3" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Synthetic</span></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line">&lt;Z&gt; <span class="function">Resource&lt;Z&gt; <span class="title">onResourceDecoded</span><span class="params">(DataSource dataSource, @NonNull Resource&lt;Z&gt; decoded)</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">  Class&lt;Z&gt; resourceSubClass = (Class&lt;Z&gt;) decoded.get().getClass();</span><br><span class="line">  Transformation&lt;Z&gt; appliedTransformation = <span class="keyword">null</span>;</span><br><span class="line">  Resource&lt;Z&gt; transformed = decoded;</span><br><span class="line">  <span class="keyword">if</span> (dataSource != DataSource.RESOURCE_DISK_CACHE) &#123;</span><br><span class="line">    appliedTransformation = decodeHelper.getTransformation(resourceSubClass);</span><br><span class="line">    transformed = appliedTransformation.transform(glideContext, decoded, width, height);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> Make this the responsibility of the Transformation.</span></span><br><span class="line">  <span class="keyword">if</span> (!decoded.equals(transformed)) &#123;</span><br><span class="line">    decoded.recycle();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">final</span> EncodeStrategy encodeStrategy;</span><br><span class="line">  <span class="keyword">final</span> ResourceEncoder&lt;Z&gt; encoder;</span><br><span class="line">  <span class="keyword">if</span> (decodeHelper.isResourceEncoderAvailable(transformed)) &#123;</span><br><span class="line">    encoder = decodeHelper.getResultEncoder(transformed);</span><br><span class="line">    encodeStrategy = encoder.getEncodeStrategy(options);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    encoder = <span class="keyword">null</span>;</span><br><span class="line">    encodeStrategy = EncodeStrategy.NONE;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Resource&lt;Z&gt; result = transformed;</span><br><span class="line">  <span class="keyword">boolean</span> isFromAlternateCacheKey = !decodeHelper.isSourceKey(currentSourceKey);</span><br><span class="line">  <span class="keyword">if</span> (diskCacheStrategy.isResourceCacheable(</span><br><span class="line">      isFromAlternateCacheKey, dataSource, encodeStrategy)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (encoder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Registry.NoResultEncoderAvailableException(transformed.get().getClass());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">final</span> Key key;</span><br><span class="line">    <span class="keyword">switch</span> (encodeStrategy) &#123;</span><br><span class="line">      <span class="keyword">case</span> SOURCE:</span><br><span class="line">        key = <span class="keyword">new</span> DataCacheKey(currentSourceKey, signature);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">case</span> TRANSFORMED:</span><br><span class="line">        key =</span><br><span class="line">            <span class="keyword">new</span> ResourceCacheKey(</span><br><span class="line">                decodeHelper.getArrayPool(),</span><br><span class="line">                currentSourceKey,</span><br><span class="line">                signature,</span><br><span class="line">                width,</span><br><span class="line">                height,</span><br><span class="line">                appliedTransformation,</span><br><span class="line">                resourceSubClass,</span><br><span class="line">                options);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unknown strategy: "</span> + encodeStrategy);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LockedResource&lt;Z&gt; lockedResult = LockedResource.obtain(transformed);</span><br><span class="line">    deferredEncodeManager.init(key, encoder, lockedResult);</span><br><span class="line">    result = lockedResult;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的逻辑是根据我们设置的参数进行变化。也就是说，如果我们使用了 centerCrop 等参数，那么这里将会对其进行处理。这里的 Transformation 是一个接口，它的一系列的实现都是对应于 scaleType 等参数的。</p>
<p>到了这里， Glide 所有加载图片、处理图片的逻辑都讲完了。剩下的，就是将图片显示到 ImageView 上面了。</p>
<p>我们再回过头来看之前讲到 DecodeJob.notifyEncodeAndRelease 方法</p>
<h2 id="DecodeJob-4"><a href="#DecodeJob-4" class="headerlink" title="DecodeJob"></a>DecodeJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyEncodeAndRelease</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (resource <span class="keyword">instanceof</span> Initializable) &#123;</span><br><span class="line">    ((Initializable) resource).initialize();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Resource&lt;R&gt; result = resource;</span><br><span class="line">  LockedResource&lt;R&gt; lockedResource = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">    lockedResource = LockedResource.obtain(resource);</span><br><span class="line">    result = lockedResource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyComplete(result, dataSource);</span><br><span class="line"></span><br><span class="line">  stage = Stage.ENCODE;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (deferredEncodeManager.hasResourceToEncode()) &#123;</span><br><span class="line">      deferredEncodeManager.encode(diskCacheProvider, options);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (lockedResource != <span class="keyword">null</span>) &#123;</span><br><span class="line">      lockedResource.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Call onEncodeComplete outside the finally block so that it's not called if the encode process</span></span><br><span class="line">  <span class="comment">// throws.</span></span><br><span class="line">  onEncodeComplete();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看   notifyComplete(result, dataSource); 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">notifyComplete</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  setNotifiedOrThrow();</span><br><span class="line">  callback.onResourceReady(resource, dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回调 EngineJob 的 onResourceReady 方法。</p>
<h2 id="EngineJob-2"><a href="#EngineJob-2" class="headerlink" title="EngineJob"></a>EngineJob</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.resource = resource;</span><br><span class="line">    <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">  &#125;</span><br><span class="line">  notifyCallbacksOfResult();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键在 notifyCallbacksOfResult 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Synthetic</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">notifyCallbacksOfResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  ResourceCallbacksAndExecutors copy;</span><br><span class="line">  Key localKey;</span><br><span class="line">  EngineResource&lt;?&gt; localResource;</span><br><span class="line">  <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">    stateVerifier.throwIfRecycled();</span><br><span class="line">    <span class="keyword">if</span> (isCancelled) &#123;</span><br><span class="line">      <span class="comment">// <span class="doctag">TODO:</span> Seems like we might as well put this in the memory cache instead of just recycling</span></span><br><span class="line">      <span class="comment">// it since we've gotten this far...</span></span><br><span class="line">      resource.recycle();</span><br><span class="line">      release();</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cbs.isEmpty()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Received a resource without any callbacks to notify"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasResource) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already have resource"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    engineResource = engineResourceFactory.build(resource, isCacheable, key, resourceListener);</span><br><span class="line">    <span class="comment">// Hold on to resource for duration of our callbacks below so we don't recycle it in the</span></span><br><span class="line">    <span class="comment">// middle of notifying if it synchronously released by one of the callbacks. Acquire it under</span></span><br><span class="line">    <span class="comment">// a lock here so that any newly added callback that executes before the next locked section</span></span><br><span class="line">    <span class="comment">// below can't recycle the resource before we call the callbacks.</span></span><br><span class="line">    hasResource = <span class="keyword">true</span>;</span><br><span class="line">    copy = cbs.copy();</span><br><span class="line">    incrementPendingCallbacks(copy.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    localKey = key;</span><br><span class="line">    localResource = engineResource;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  engineJobListener.onEngineJobComplete(<span class="keyword">this</span>, localKey, localResource);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">final</span> ResourceCallbackAndExecutor entry : copy) &#123;</span><br><span class="line">    entry.executor.execute(<span class="keyword">new</span> CallResourceReady(entry.cb));</span><br><span class="line">  &#125;</span><br><span class="line">  decrementPendingCallbacks();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码的最后，</p>
<pre><code>   for (final ResourceCallbackAndExecutor entry : copy) {
  entry.executor.execute(new CallResourceReady(entry.cb));
}
</code></pre><p>可以看到这里会执行 CallResourceReady 。</p>
<h2 id="CallResourceReady"><a href="#CallResourceReady" class="headerlink" title="CallResourceReady"></a>CallResourceReady</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">CallResourceReady</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> ResourceCallback cb;</span><br><span class="line"></span><br><span class="line">  CallResourceReady(ResourceCallback cb) &#123;</span><br><span class="line">    <span class="keyword">this</span>.cb = cb;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we always acquire the request lock, then the EngineJob lock to avoid deadlock</span></span><br><span class="line">    <span class="comment">// (b/136032534).</span></span><br><span class="line">    <span class="keyword">synchronized</span> (cb) &#123;</span><br><span class="line">      <span class="keyword">synchronized</span> (EngineJob.<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cbs.contains(cb)) &#123;</span><br><span class="line">          <span class="comment">// Acquire for this particular callback.</span></span><br><span class="line">          engineResource.acquire();</span><br><span class="line">          callCallbackOnResourceReady(cb);</span><br><span class="line">          removeCallback(cb);</span><br><span class="line">        &#125;</span><br><span class="line">        decrementPendingCallbacks();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Synthetic</span></span><br><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"this"</span>)</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callCallbackOnResourceReady</span><span class="params">(ResourceCallback cb)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// This is overly broad, some Glide code is actually called here, but it's much</span></span><br><span class="line">    <span class="comment">// simpler to encapsulate here than to do so at the actual call point in the</span></span><br><span class="line">    <span class="comment">// Request implementation.</span></span><br><span class="line">    cb.onResourceReady(engineResource, dataSource);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> CallbackException(t);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还是用回调调用了 SingleRequest 的 onResourceReady 方法。</p>
<h2 id="SingleRequest-1"><a href="#SingleRequest-1" class="headerlink" title="SingleRequest"></a>SingleRequest</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;?&gt; resource, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  stateVerifier.throwIfRecycled();</span><br><span class="line">  loadStatus = <span class="keyword">null</span>;</span><br><span class="line">  <span class="keyword">if</span> (resource == <span class="keyword">null</span>) &#123;</span><br><span class="line">    GlideException exception =</span><br><span class="line">        <span class="keyword">new</span> GlideException(</span><br><span class="line">            <span class="string">"Expected to receive a Resource&lt;R&gt; with an "</span></span><br><span class="line">                + <span class="string">"object of "</span></span><br><span class="line">                + transcodeClass</span><br><span class="line">                + <span class="string">" inside, but instead got null."</span>);</span><br><span class="line">    onLoadFailed(exception);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  Object received = resource.get();</span><br><span class="line">  <span class="keyword">if</span> (received == <span class="keyword">null</span> || !transcodeClass.isAssignableFrom(received.getClass())) &#123;</span><br><span class="line">    releaseResource(resource);</span><br><span class="line">    GlideException exception =</span><br><span class="line">        <span class="keyword">new</span> GlideException(</span><br><span class="line">            <span class="string">"Expected to receive an object of "</span></span><br><span class="line">                + transcodeClass</span><br><span class="line">                + <span class="string">" but instead"</span></span><br><span class="line">                + <span class="string">" got "</span></span><br><span class="line">                + (received != <span class="keyword">null</span> ? received.getClass() : <span class="string">""</span>)</span><br><span class="line">                + <span class="string">"&#123;"</span></span><br><span class="line">                + received</span><br><span class="line">                + <span class="string">"&#125; inside"</span></span><br><span class="line">                + <span class="string">" "</span></span><br><span class="line">                + <span class="string">"Resource&#123;"</span></span><br><span class="line">                + resource</span><br><span class="line">                + <span class="string">"&#125;."</span></span><br><span class="line">                + (received != <span class="keyword">null</span></span><br><span class="line">                    ? <span class="string">""</span></span><br><span class="line">                    : <span class="string">" "</span></span><br><span class="line">                        + <span class="string">"To indicate failure return a null Resource "</span></span><br><span class="line">                        + <span class="string">"object, rather than a Resource object containing null data."</span>));</span><br><span class="line">    onLoadFailed(exception);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!canSetResource()) &#123;</span><br><span class="line">    releaseResource(resource);</span><br><span class="line">    <span class="comment">// We can't put the status to complete before asking canSetResource().</span></span><br><span class="line">    status = Status.COMPLETE;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  onResourceReady((Resource&lt;R&gt;) resource, (R) received, dataSource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后调用 onResourceReady((Resource<r>) resource, (R) received, dataSource);</r></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(Resource&lt;R&gt; resource, R result, DataSource dataSource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// We must call isFirstReadyResource before setting status.</span></span><br><span class="line">  <span class="keyword">boolean</span> isFirstResource = isFirstReadyResource();</span><br><span class="line">  status = Status.COMPLETE;</span><br><span class="line">  <span class="keyword">this</span>.resource = resource;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (glideContext.getLogLevel() &lt;= Log.DEBUG) &#123;</span><br><span class="line">    Log.d(</span><br><span class="line">        GLIDE_TAG,</span><br><span class="line">        <span class="string">"Finished loading "</span></span><br><span class="line">            + result.getClass().getSimpleName()</span><br><span class="line">            + <span class="string">" from "</span></span><br><span class="line">            + dataSource</span><br><span class="line">            + <span class="string">" for "</span></span><br><span class="line">            + model</span><br><span class="line">            + <span class="string">" with size ["</span></span><br><span class="line">            + width</span><br><span class="line">            + <span class="string">"x"</span></span><br><span class="line">            + height</span><br><span class="line">            + <span class="string">"] in "</span></span><br><span class="line">            + LogTime.getElapsedMillis(startTime)</span><br><span class="line">            + <span class="string">" ms"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  isCallingCallbacks = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">boolean</span> anyListenerHandledUpdatingTarget = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (requestListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (RequestListener&lt;R&gt; listener : requestListeners) &#123;</span><br><span class="line">        anyListenerHandledUpdatingTarget |=</span><br><span class="line">            listener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    anyListenerHandledUpdatingTarget |=</span><br><span class="line">        targetListener != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; targetListener.onResourceReady(result, model, target, dataSource, isFirstResource);</span><br><span class="line">    <span class="comment">// 重点在这里！！！！</span></span><br><span class="line">    <span class="keyword">if</span> (!anyListenerHandledUpdatingTarget) &#123;</span><br><span class="line">      Transition&lt;? <span class="keyword">super</span> R&gt; animation = animationFactory.build(dataSource, isFirstResource);</span><br><span class="line">      target.onResourceReady(result, animation);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    isCallingCallbacks = <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  notifyLoadSuccess();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现上面的代码调用了 target.onResourceReady(result, animation);</p>
<p>这里的 target 一般都是 ImageViewTarget 。ImageViewTarget 是个抽象类。</p>
<h2 id="ImageViewTarget"><a href="#ImageViewTarget" class="headerlink" title="ImageViewTarget"></a>ImageViewTarget</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResourceReady</span><span class="params">(@NonNull Z resource, @Nullable Transition&lt;? <span class="keyword">super</span> Z&gt; transition)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (transition == <span class="keyword">null</span> || !transition.transition(resource, <span class="keyword">this</span>)) &#123;</span><br><span class="line">    setResourceInternal(resource);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    maybeUpdateAnimatable(resource);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setResourceInternal</span><span class="params">(@Nullable Z resource)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Order matters here. Set the resource first to make sure that the Drawable has a valid and</span></span><br><span class="line">  <span class="comment">// non-null Callback before starting it.</span></span><br><span class="line">  setResource(resource);</span><br><span class="line">  maybeUpdateAnimatable(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>setResource(resource) 是抽象方法，我们到子类中看看。我们挑 DrawableImageViewTarget 来看看吧。</p>
<h2 id="DrawableImageViewTarget"><a href="#DrawableImageViewTarget" class="headerlink" title="DrawableImageViewTarget"></a>DrawableImageViewTarget</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setResource</span><span class="params">(@Nullable Drawable resource)</span> </span>&#123;</span><br><span class="line">  view.setImageDrawable(resource);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>终于，我们看到了 ImageView.setImageDrawable 来显示图片了，不容易啊。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>真的没想到，短短的一句 Glide.with(context).load(“<a href="http://www.xxxx.com/xx.jpg&quot;).into(imageView" target="_blank" rel="external">http://www.xxxx.com/xx.jpg&quot;).into(imageView</a>) 代码内部竟然隐藏着如此庞大的逻辑。相信你看完这一系列的文章，对 Glide 会刮目相看吧。</p>
<p>当然，本系列还有很多 Glide 中没讲到的知识点，比如缓存具体的应用等，如果想了解的同学可以自行去阅读下源码。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本篇是 Glide 系列的最后一篇，主要讲一下 into 方法里面的逻辑。into 的逻辑也是最多最复杂的，可能需要反复阅读源码才能搞清楚。</p>
<p>Glide : <a href="https://github.com/bumptech/glide" target=]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Glide" scheme="http://yuqirong.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Glide源码解析(二)]]></title>
    <link href="http://yuqirong.github.io/2019/08/06/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yuqirong.github.io/2019/08/06/Glide源码解析(二)/</id>
    <published>2019-08-06T13:56:46.000Z</published>
    <updated>2019-08-07T16:33:49.233Z</updated>
    <content type="html"><![CDATA[<p>之前已经讲过 Glide.with 了，那么今天就来讲讲 load 方法。</p>
<p>Glide : <a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a></p>
<p>version : v4.9.0</p>
<h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><p>load 重载的方法有很多，这里就挑一个看了。来看看 load(String string) 内部的代码。</p>
<h2 id="RequestManager"><a href="#RequestManager" class="headerlink" title="RequestManager"></a>RequestManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> asDrawable().load(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部先调用了 asDrawable() 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;Drawable&gt; <span class="title">asDrawable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> as(Drawable.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 as 方法中，回去新建一个 RequestBuilder 对象，资源类型为 Drawable 。</p>
<p>一眼就可以看出，这是使用构造者模式来创建 Request 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="keyword">public</span> &lt;ResourceType&gt; <span class="function">RequestBuilder&lt;ResourceType&gt; <span class="title">as</span><span class="params">(</span><br><span class="line">    @NonNull Class&lt;ResourceType&gt; resourceClass)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RequestBuilder&lt;&gt;(glide, <span class="keyword">this</span>, resourceClass, context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>去 RequestBuilder 的构造方法中看看。</p>
<h2 id="RequestBuilder"><a href="#RequestBuilder" class="headerlink" title="RequestBuilder"></a>RequestBuilder</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressLint</span>(<span class="string">"CheckResult"</span>)</span><br><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"PMD.ConstructorCallsOverridableMethod"</span>)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">RequestBuilder</span><span class="params">(</span><br><span class="line">    @NonNull Glide glide,</span><br><span class="line">    RequestManager requestManager,</span><br><span class="line">    Class&lt;TranscodeType&gt; transcodeClass,</span><br><span class="line">    Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.glide = glide;</span><br><span class="line">  <span class="keyword">this</span>.requestManager = requestManager;</span><br><span class="line">  <span class="keyword">this</span>.transcodeClass = transcodeClass;</span><br><span class="line">  <span class="keyword">this</span>.context = context;</span><br><span class="line">  <span class="keyword">this</span>.transitionOptions = requestManager.getDefaultTransitionOptions(transcodeClass);</span><br><span class="line">  <span class="keyword">this</span>.glideContext = glide.getGlideContext();</span><br><span class="line"></span><br><span class="line">  initRequestListeners(requestManager.getDefaultRequestListeners());</span><br><span class="line">  apply(requestManager.getDefaultRequestOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意一下，这里调用了 apply 方法。apply 方法是用来对当前请求应用配置选项的。这里传入的是默认的配置选项。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">apply</span><span class="params">(@NonNull BaseRequestOptions&lt;?&gt; requestOptions)</span> </span>&#123;</span><br><span class="line">  Preconditions.checkNotNull(requestOptions);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">super</span>.apply(requestOptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RequestBuilder.apply 方法内部会去调用父类的 apply 方法。</p>
<h2 id="BaseRequestOptions"><a href="#BaseRequestOptions" class="headerlink" title="BaseRequestOptions"></a>BaseRequestOptions</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">apply</span><span class="params">(@NonNull BaseRequestOptions&lt;?&gt; o)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (isAutoCloneEnabled) &#123;</span><br><span class="line">    <span class="keyword">return</span> clone().apply(o);</span><br><span class="line">  &#125;</span><br><span class="line">  BaseRequestOptions&lt;?&gt; other = o;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, SIZE_MULTIPLIER)) &#123;</span><br><span class="line">    sizeMultiplier = other.sizeMultiplier;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, USE_UNLIMITED_SOURCE_GENERATORS_POOL)) &#123;</span><br><span class="line">    useUnlimitedSourceGeneratorsPool = other.useUnlimitedSourceGeneratorsPool;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, USE_ANIMATION_POOL)) &#123;</span><br><span class="line">    useAnimationPool = other.useAnimationPool;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, DISK_CACHE_STRATEGY)) &#123;</span><br><span class="line">    diskCacheStrategy = other.diskCacheStrategy;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PRIORITY)) &#123;</span><br><span class="line">    priority = other.priority;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ERROR_PLACEHOLDER)) &#123;</span><br><span class="line">    errorPlaceholder = other.errorPlaceholder;</span><br><span class="line">    errorId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~ERROR_ID;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ERROR_ID)) &#123;</span><br><span class="line">    errorId = other.errorId;</span><br><span class="line">    errorPlaceholder = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~ERROR_PLACEHOLDER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PLACEHOLDER)) &#123;</span><br><span class="line">    placeholderDrawable = other.placeholderDrawable;</span><br><span class="line">    placeholderId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~PLACEHOLDER_ID;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, PLACEHOLDER_ID)) &#123;</span><br><span class="line">    placeholderId = other.placeholderId;</span><br><span class="line">    placeholderDrawable = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~PLACEHOLDER;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, IS_CACHEABLE)) &#123;</span><br><span class="line">    isCacheable = other.isCacheable;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, OVERRIDE)) &#123;</span><br><span class="line">    overrideWidth = other.overrideWidth;</span><br><span class="line">    overrideHeight = other.overrideHeight;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, SIGNATURE)) &#123;</span><br><span class="line">    signature = other.signature;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, RESOURCE_CLASS)) &#123;</span><br><span class="line">    resourceClass = other.resourceClass;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, FALLBACK)) &#123;</span><br><span class="line">    fallbackDrawable = other.fallbackDrawable;</span><br><span class="line">    fallbackId = <span class="number">0</span>;</span><br><span class="line">    fields &amp;= ~FALLBACK_ID;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, FALLBACK_ID)) &#123;</span><br><span class="line">    fallbackId = other.fallbackId;</span><br><span class="line">    fallbackDrawable = <span class="keyword">null</span>;</span><br><span class="line">    fields &amp;= ~FALLBACK;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, THEME)) &#123;</span><br><span class="line">    theme = other.theme;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION_ALLOWED)) &#123;</span><br><span class="line">    isTransformationAllowed = other.isTransformationAllowed;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION_REQUIRED)) &#123;</span><br><span class="line">    isTransformationRequired = other.isTransformationRequired;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, TRANSFORMATION)) &#123;</span><br><span class="line">    transformations.putAll(other.transformations);</span><br><span class="line">    isScaleOnlyOrNoTransform = other.isScaleOnlyOrNoTransform;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isSet(other.fields, ONLY_RETRIEVE_FROM_CACHE)) &#123;</span><br><span class="line">    onlyRetrieveFromCache = other.onlyRetrieveFromCache;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Applying options with dontTransform() is expected to clear our transformations.</span></span><br><span class="line">  <span class="keyword">if</span> (!isTransformationAllowed) &#123;</span><br><span class="line">    transformations.clear();</span><br><span class="line">    fields &amp;= ~TRANSFORMATION;</span><br><span class="line">    isTransformationRequired = <span class="keyword">false</span>;</span><br><span class="line">    fields &amp;= ~TRANSFORMATION_REQUIRED;</span><br><span class="line">    isScaleOnlyOrNoTransform = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  fields |= other.fields;</span><br><span class="line">  options.putAll(other.options);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> selfOrThrowIfLocked();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，配置选项有一大堆。其中不乏有我们很常用的：</p>
<ul>
<li>diskCacheStrategy 磁盘缓存策略</li>
<li>errorPlaceholder 出错时的占位图</li>
<li>placeholderDrawable 加载时候的占位图</li>
<li>overrideWidth、overrideHeight 加载图片固定宽高</li>
</ul>
<p>等等，都是在 apply 中应用的。</p>
<p>看完了 asDrawable() 方法，接下来就回过头来看看 load 方法。</p>
<h2 id="RequestManager-1"><a href="#RequestManager-1" class="headerlink" title="RequestManager"></a>RequestManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="annotation">@CheckResult</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">load</span><span class="params">(@Nullable String string)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> loadGeneric(string);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所有的 load 方法内部都是去调用 loadGeneric 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestBuilder&lt;TranscodeType&gt; <span class="title">loadGeneric</span><span class="params">(@Nullable Object model)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.model = model;</span><br><span class="line">  isModelSet = <span class="keyword">true</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 loadGeneric 中，把 model 赋值给 this.model 全局变量。然后把 isModelSet 设置为 true ，标记已经调用过 load 方法了。并且返回了当前 RequestBuilder 对象。</p>
<p>以上就是 load 方法内部所有的逻辑了，其实 load 方法内部并没有什么复杂的东西。真正复杂的是接下来的 into 方法。关于 into 方法在下一篇中会给大家讲解。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前已经讲过 Glide.with 了，那么今天就来讲讲 load 方法。</p>
<p>Glide : <a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://g]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Glide" scheme="http://yuqirong.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Glide源码解析(一)]]></title>
    <link href="http://yuqirong.github.io/2019/08/04/Glide%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yuqirong.github.io/2019/08/04/Glide源码解析(一)/</id>
    <published>2019-08-04T08:13:51.000Z</published>
    <updated>2019-08-05T14:25:10.294Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性能、可扩展的图片解码管道（decode pipeline），以及自动的资源池技术。</p>
<p>Glide 充分考虑了Android图片加载性能的两个关键方面：</p>
<ul>
<li>图片解码速度</li>
<li>解码图片带来的资源压力</li>
</ul>
<p>为了让用户拥有良好的App使用体验，图片不仅要快速加载，而且还不能因为过多的主线程I/O或频繁的垃圾回收导致页面的闪烁和抖动现象。</p>
<p>Glide使用了多个步骤来确保在Android上加载图片尽可能的快速和平滑：</p>
<ul>
<li>自动、智能地下采样(downsampling)和缓存(caching)，以最小化存储开销和解码次数；</li>
<li>积极的资源重用，例如字节数组和Bitmap，以最小化昂贵的垃圾回收和堆碎片影响；</li>
<li>深度的生命周期集成，以确保仅优先处理活跃的Fragment和Activity的请求，并有利于应用在必要时释放资源以避免在后台时被杀掉。</li>
</ul>
<p>目前，在 Android 开发中 Glide 算得上是图片加载框架中的佼佼者了。其巧妙的设计和卓越的性能令人赞叹不已。</p>
<p>那么本系列给大家带来的就是解析 Glide 的源码，看看背后的 Glide 是什么样子的？</p>
<p>Glide : <a href="https://github.com/bumptech/glide" target="_blank" rel="external">https://github.com/bumptech/glide</a></p>
<p>version : v4.9.0</p>
<h1 id="Glide_u4F7F_u7528_u65B9_u6CD5"><a href="#Glide_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Glide使用方法"></a>Glide使用方法</h1><p>Glide 的 API 有很多，但是我们这里就挑最简单的讲：</p>
<pre><code>Glide.with(fragment)
    .load(url)
    .into(imageView);
</code></pre><p>可以看到基本上分为三个步骤：</p>
<ol>
<li>with</li>
<li>load</li>
<li>into</li>
</ol>
<p>在本篇文章，我们就讲讲第一步：Glide.with</p>
<h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><h2 id="Glide"><a href="#Glide" class="headerlink" title="Glide"></a>Glide</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(context).get(context);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Activity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(activity).get(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getContext()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line"><span class="annotation">@Deprecated</span></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull android.app.Fragment fragment)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(fragment.getActivity()).get(fragment);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestManager <span class="title">with</span><span class="params">(@NonNull View view)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> getRetriever(view.getContext()).get(view);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，with 重载的方法非常多，但是代码内部的逻辑基本上都是一致的。都是先调用了 getRetriever 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> RequestManagerRetriever <span class="title">getRetriever</span><span class="params">(@Nullable Context context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Context could be null for other reasons (ie the user passes in null), but in practice it will</span></span><br><span class="line">  <span class="comment">// only occur due to errors with the Fragment lifecycle.</span></span><br><span class="line">  Preconditions.checkNotNull(</span><br><span class="line">      context,</span><br><span class="line">      <span class="string">"You cannot start a load on a not yet attached View or a Fragment where getActivity() "</span></span><br><span class="line">          + <span class="string">"returns null (which usually occurs when getActivity() is called before the Fragment "</span></span><br><span class="line">          + <span class="string">"is attached or after the Fragment is destroyed)."</span>);</span><br><span class="line">  <span class="keyword">return</span> Glide.get(context).getRequestManagerRetriever();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>Glide.get(context)</code> 就是获取了 Glide 单例，然后再 <code>getRequestManagerRetriever()</code> 。其实 Glide 创建单例的代码中有一堆变量初始化的代码，在这里就不详细展示出来了，后面有用到再讲。所以接下来的逻辑就到 RequestManagerRetriever 中去了。</p>
<h2 id="RequestManagerRetriever"><a href="#RequestManagerRetriever" class="headerlink" title="RequestManagerRetriever"></a>RequestManagerRetriever</h2><p>通过上面一堆 with 重载的方法可以看出，get 方法是和 with 一样也有一堆重载的，并且和 with 是一一对应的。</p>
<p>在这里，就主要顺着 <code>get(@NonNull FragmentActivity activity)</code> 来讲吧，其他的 get 方法里的逻辑也是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (Util.isOnBackgroundThread()) &#123;</span><br><span class="line">    <span class="keyword">return</span> get(activity.getApplicationContext());</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    assertNotDestroyed(activity);</span><br><span class="line">    FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">    <span class="keyword">return</span> supportFragmentGet(activity, fm, <span class="comment">/*parentHint=*/</span> <span class="keyword">null</span>, isActivityVisible(activity));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get 方法主要逻辑分为两块：</p>
<ol>
<li>如果不是主线程，就调用 get(Context context) </li>
<li>否则调用 supportFragmentGet()</li>
</ol>
<p>我们先来看第一块逻辑吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RequestManager <span class="title">get</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (context == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"You cannot start a load on a null Context"</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Util.isOnMainThread() &amp;&amp; !(context <span class="keyword">instanceof</span> Application)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (context <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((FragmentActivity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">      <span class="keyword">return</span> get((Activity) context);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (context <span class="keyword">instanceof</span> ContextWrapper</span><br><span class="line">        <span class="comment">// Only unwrap a ContextWrapper if the baseContext has a non-null application context.</span></span><br><span class="line">        <span class="comment">// Context#createPackageContext may return a Context without an Application instance,</span></span><br><span class="line">        <span class="comment">// in which case a ContextWrapper may be used to attach one.</span></span><br><span class="line">        &amp;&amp; ((ContextWrapper) context).getBaseContext().getApplicationContext() != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> get(((ContextWrapper) context).getBaseContext());</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> getApplicationManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>前面会判断 Context ，然后再走不同的 get ，这些我们都跳过，来看最后的 getApplicationManager 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">getApplicationManager</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Either an application context or we're on a background thread.</span></span><br><span class="line">  <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (applicationManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Normally pause/resume is taken care of by the fragment we add to the fragment or</span></span><br><span class="line">        <span class="comment">// activity. However, in this case since the manager attached to the application will not</span></span><br><span class="line">        <span class="comment">// receive lifecycle events, we must force the manager to start resumed using</span></span><br><span class="line">        <span class="comment">// ApplicationLifecycle.</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">        Glide glide = Glide.get(context.getApplicationContext());</span><br><span class="line">        applicationManager =</span><br><span class="line">            factory.build(</span><br><span class="line">                glide,</span><br><span class="line">                <span class="keyword">new</span> ApplicationLifecycle(),</span><br><span class="line">                <span class="keyword">new</span> EmptyRequestManagerTreeNode(),</span><br><span class="line">                context.getApplicationContext());</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> applicationManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 getApplicationManager 会获取到一个 applicationManager 对象。需要注意的是，这个 applicationManager 的生命周期是和 Application 保持一致的。</p>
<p>接下来，来看看第二块逻辑 supportFragmentGet 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> RequestManager <span class="title">supportFragmentGet</span><span class="params">(</span><br><span class="line">    @NonNull Context context,</span><br><span class="line">    @NonNull FragmentManager fm,</span><br><span class="line">    @Nullable Fragment parentHint,</span><br><span class="line">    <span class="keyword">boolean</span> isParentVisible)</span> </span>&#123;</span><br><span class="line">  SupportRequestManagerFragment current =</span><br><span class="line">      getSupportRequestManagerFragment(fm, parentHint, isParentVisible);</span><br><span class="line">  RequestManager requestManager = current.getRequestManager();</span><br><span class="line">  <span class="keyword">if</span> (requestManager == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">// TODO(b/27524013): Factor out this Glide.get() call.</span></span><br><span class="line">    Glide glide = Glide.get(context);</span><br><span class="line">    requestManager =</span><br><span class="line">        factory.build(</span><br><span class="line">            glide, current.getGlideLifecycle(), current.getRequestManagerTreeNode(), context);</span><br><span class="line">    current.setRequestManager(requestManager);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> requestManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 supportFragmentGet 中新建了一个没有 UI 的 SupportRequestManagerFragment ，然后把 fragment 添加到 Activity 中，这样 fragment 就和 Activity 的生命周期同步了。而在 fragment 中，有着 onStart() onStop() 的生命周期监听。因此，Glide 就实现了在 Fragment 和 Activity 的图片加载请求的生命周期管理。</p>
<p>我们可以看出，supportFragmentGet 中返回的 requestManager 是和当前 fragment 生命周期绑定在一起的。</p>
<h1 id="u7ED3_u675F_u8BED"><a href="#u7ED3_u675F_u8BED" class="headerlink" title="结束语"></a>结束语</h1><p>综上所述，Glide.with 中，主要做的事情有两件：</p>
<ul>
<li>Glide 单例的初始化过程</li>
<li>Glide 请求的生命周期管理</li>
</ul>
<p>如果传入的是 ApplicationContext ，得到的就是 applicationManager ，生命周期和 Application 一致；否则得到的 requestManager 生命周期就是和 Activity/Fragment 一致了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>Glide是一个快速高效的Android图片加载库，注重于平滑的滚动。Glide提供了易用的API，高性]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Glide" scheme="http://yuqirong.github.io/tags/Glide/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲聊MultiDex]]></title>
    <link href="http://yuqirong.github.io/2019/07/09/%E9%97%B2%E8%81%8AMultiDex/"/>
    <id>http://yuqirong.github.io/2019/07/09/闲聊MultiDex/</id>
    <published>2019-07-08T16:14:20.000Z</published>
    <updated>2019-07-08T16:15:01.055Z</updated>
    <content type="html"><![CDATA[<h1 id="MultiDex__u662F_u4EC0_u4E48_uFF1F"><a href="#MultiDex__u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="MultiDex 是什么？"></a>MultiDex 是什么？</h1><p>当Android系统安装一个应用的时候，有一步是对Dex进行优化，这个过程有一个专门的工具来处理，叫DexOpt。DexOpt的执行过程是在第一次加载Dex文件的时候执行的。这个过程会生成一个ODEX文件，即Optimised Dex。执行ODex的效率会比直接执行Dex文件的效率要高很多。</p>
<p>但是在早期的Android系统中，DexOpt有一个问题，DexOpt会把每一个类的方法id检索起来，存在一个链表结构里面。但是这个链表的长度是用一个short类型来保存的，导致了方法id的数目不能够超过65536个。当一个项目足够大的时候，显然这个方法数的上限是不够的。尽管在新版本的Android系统中，DexOpt修复了这个问题，但是我们仍然需要对低版本的Android系统做兼容。</p>
<p>在Android 5.0之前，为了解决这个问题，Google官方推出了这个类似于补丁一样的 support-library, MultiDex。而在 Android 5.0及以后，使用了 ART 虚拟机，原生支持从 APK 文件加载多个 dex 文件。</p>
<h1 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h1><p>以下是在 minSdkVersion &lt; 21 的使用方法。</p>
<ol>
<li><p>配置build.gradle</p>
<pre><code>android {

    compileSdkVersion 21
    buildToolsVersion &quot;21.1.0&quot;

    defaultConfig {
        ...

        // Enabling multidex support.
        multiDexEnabled true
    }
    ...
}

dependencies {
  compile &apos;com.android.support:multidex:1.0.3&apos;
}
</code></pre></li>
<li><p>继承 MultiDexApplication</p>
<pre><code>public class MyApplication extends MultiDexApplication {
  // ...........
}
</code></pre></li>
<li><p>如果不想继承 MultiDexApplication ，可以重写 attachBaseContext 方法</p>
<pre><code>@Override
protected void attachBaseContext(Context base) {
   super.attachBaseContext(base);
   MultiDex.install(this);
}
</code></pre></li>
</ol>
<p>反之，如果 minSdkVersion &gt;= 21 ，只需要以下配置即可。 </p>
<pre><code>android {
    defaultConfig {
        ...
        minSdkVersion 21 
        targetSdkVersion 28
        multiDexEnabled true
    }
    ...
}
</code></pre><h1 id="MultiDex__u539F_u7406"><a href="#MultiDex__u539F_u7406" class="headerlink" title="MultiDex 原理"></a>MultiDex 原理</h1><ul>
<li><a href="https://juejin.im/entry/5a3a21fcf265da430d58294e" target="_blank" rel="external">类加载机制系列3——MultiDex原理解析</a></li>
<li><a href="https://www.jianshu.com/p/33968db4b08d" target="_blank" rel="external">Android使用Multidex突破64K方法数限制原理解析</a></li>
</ul>
<p>简单地来说，MultiDex 做的事情就是：</p>
<ol>
<li>解压得到 dex 并进行 dexOpt ;</li>
<li>把主dex文件除外的 dex 文件都追加到 PathClassLoader 中 DexPathListde Element[] 数组中</li>
</ol>
<p>熟悉组件化、热修复的同学肯定对这些已经了如指掌了吧。  </p>
<h1 id="MultiDex__u7684_u5C40_u9650_u6027"><a href="#MultiDex__u7684_u5C40_u9650_u6027" class="headerlink" title="MultiDex 的局限性"></a>MultiDex 的局限性</h1><p>Dalvik 可执行文件分包支持库具有一些已知的局限性，将其纳入您的应用构建配置之中时，您应该注意这些局限性并进行针对性的测试：</p>
<p>•    启动期间在设备数据分区中安装 DEX 文件的过程相当复杂，如果辅助 DEX 文件较大，可能会导致应用无响应 (ANR) 错误。在此情况下，您应该通过 ProGuard 应用代码压缩以尽量减小 DEX 文件的大小，并移除未使用的那部分代码。</p>
<p>•    由于存在 Dalvik linearAlloc 错误（问题 22586），使用 Dalvik 可执行文件分包的应用可能无法在运行的平台版本早于 Android 4.0（API 级别 14）的设备上启动。如果您的目标 API 级别低于 14，请务必针对这些版本的平台进行测试，因为您的应用可能会在启动时或加载特定类群时出现问题。代码压缩可以减少甚至有可能消除这些潜在问题。</p>
<p>•    由于存在 Dalvik linearAlloc 限制（问题 78035），因此，如果使用 Dalvik 可执行文件分包配置的应用发出非常庞大的内存分配请求，则可能会在运行期间发生崩溃。尽管 Android 4.0（API 级别 14）提高了分配限制，但在 Android 5.0（API 级别 21）之前的 Android 版本上，应用仍有可能遭遇这一限制。</p>
<p><strong>第一个问题的解决方法</strong></p>
<p>Facebook 提出一种加载方案：将 MultiDex.install() 操作放在另外一个经常进行的。</p>
<p>让 Launcher Activity 在另外一个进程启动，但是 Multidex.install 还是在 Main Process 中开启，虽然逻辑上已经不承担 dexopt 的任务。<br> 这个 Launcher Activity 就是用来异步触发 dexopt 的 ，load 完成就启动 Main Activity；如果已经loaded，则直接启动Main Process。<br> Multidex.install所引发的合并耗时操作，是在前台进程的异步任务中执行的，所以没有 ANR 的风险。</p>
<p>在 Facebook 的这个方案基础上，<a href="https://www.jianshu.com/p/a5353748159f" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a> 给出了一个优化后的方案。</p>
<p><img src="/uploads/20190709/20190709001043.png" alt="优化后的方案流程图"></p>
<p>另外，还有美团、微信的解决方案，详见 <a href="https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/89880046" target="_blank" rel="external">Android Dex分包最全总结：含Facebook解决方案</a></p>
<p><strong>第二个问题的解决方法</strong></p>
<p>现在开发的应用 minSdkVersion 一般都设置为 Android 4.1 。所以 API 低于 14 的不需要考虑了。</p>
<p>现在应该不存在哪个应用丧心病狂地向下兼容适配到 Android 2.X 了吧？ </p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://developer.android.com/studio/build/multidex?hl=zh-cn" target="_blank" rel="external">配置方法数超过 64K 的应用</a></li>
<li><a href="https://juejin.im/entry/5a3a21fcf265da430d58294e" target="_blank" rel="external">类加载机制系列3——MultiDex原理解析</a></li>
<li><a href="https://www.jianshu.com/p/33968db4b08d" target="_blank" rel="external">Android使用Multidex突破64K方法数限制原理解析</a></li>
<li><a href="https://www.jianshu.com/p/a5353748159f" target="_blank" rel="external">其实你不知道MultiDex到底有多坑</a></li>
<li><a href="https://blog.csdn.net/xJ032w2j4cCjhOW8s8/article/details/89880046" target="_blank" rel="external">Android Dex分包最全总结：含Facebook解决方案</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="MultiDex__u662F_u4EC0_u4E48_uFF1F"><a href="#MultiDex__u662F_u4EC0_u4E48_uFF1F" class="headerlink" title="MultiDex 是什么？"></a>MultiDe]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="multiDex" scheme="http://yuqirong.github.io/tags/multiDex/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[LeakCanary源码解析]]></title>
    <link href="http://yuqirong.github.io/2019/07/06/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.github.io/2019/07/06/LeakCanary源码解析/</id>
    <published>2019-07-06T07:35:25.000Z</published>
    <updated>2019-07-06T09:40:34.012Z</updated>
    <content type="html"><![CDATA[<p>LeakCanary : <a href="https://github.com/square/leakcanary" target="_blank" rel="external">https://github.com/square/leakcanary</a></p>
<p>version : 1.6.3</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>LeakCanary 是一款专门用来侦测 Android 内存泄漏的类库。使用方式简单，代码侵入性低，基本上算是 Android 开发必备工具了。</p>
<p>今天就主要来分析一下 LeakCanary 的实现原理。在开头就简单地讲讲它的实现思路：LeakCanary 将检测的对象(一般是 Activity 或 Fragment)放入弱引用中，并且弱引用关联到引用队列中，触发 GC 之后，查看引用队列中是否存在该弱引用,如果发现没有，那么有可能发生内存泄漏了,dump 出堆内存快照进行分析。分析出泄漏实例后再查找到它的引用链，最后发送通知给开发者。</p>
<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>这里先简单讲解一下 WeakReference 的知识。</p>
<p>Q: 如何检测一个对象是否被回收？<br>A: 采用 WeakReference + ReferenceQueue 的方案检测</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference 把内存分为 4 种状态，Active 、 Pending 、 Enqueued 、 Inactive。</p>
<ul>
<li>Active ：一般说来 Reference 被创建出来分配的状态都是 Active</li>
<li>Pending ：马上要放入队列（ReferenceQueue）的状态，也就是马上要回收的对象</li>
<li>Enqueued ：Reference 对象已经进入队列，即 Reference 对象已经被回收</li>
<li>Inactive ：Reference 从队列中取出后的最终状态，无法变成其他的状态。</li>
</ul>
<h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>引用队列，在 Reference 被回收的时候，Reference 会被添加到 ReferenceQueue 中。<br>作用：用来检测 Reference 是否被回收。</p>
<h2 id="u4EE3_u7801_u89E3_u91CA"><a href="#u4EE3_u7801_u89E3_u91CA" class="headerlink" title="代码解释"></a>代码解释</h2><p>下面这段代码来自于 <a href="https://www.jianshu.com/p/9cc0db9f7c52" target="_blank" rel="external">「Leakcanary 源码分析」看这一篇就够了</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个引用队列  </span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();  </span><br><span class="line">	</span><br><span class="line"><span class="comment">// 创建弱引用，此时状态为Active，并且Reference.pending为空，</span></span><br><span class="line"><span class="comment">// 当前Reference.queue = 上面创建的queue，并且next=null  </span></span><br><span class="line"><span class="comment">// reference 创建并关联 queue</span></span><br><span class="line">WeakReference reference = <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> Object(), queue);  </span><br><span class="line">	</span><br><span class="line"><span class="comment">// 当GC执行后，由于是弱引用，所以回收该object对象，并且置于pending上，此时reference的状态为PENDING  </span></span><br><span class="line">System.gc();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ReferenceHandler从 pending 中取下该元素，并且将该元素放入到queue中，</span></span><br><span class="line"><span class="comment">//此时Reference状态为ENQUEUED，Reference.queue = Reference.ENQUEUED </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 当从queue里面取出该元素，则变为INACTIVE，Reference.queue = Reference.NULL  </span></span><br><span class="line">Reference reference1 = queue.remove();</span><br></pre></td></tr></table></figure>
<p>在 Reference 类加载的时候，Java 虚拟机会会创建一个最大优先级的后台线程，这个线程的工作就是不断检测 pending 是否为 null，如果不为 null，那么就将它放到 ReferenceQueue。因为 pending 不为 null，就说明引用所指向的对象已经被 GC，变成了不也达。</p>
<h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><p>LeakCanary 初始化的代码就一句 <code>LeakCanary.install(application)</code> 。所以我们就从入口开始看吧。</p>
<h2 id="LeakCanary-install"><a href="#LeakCanary-install" class="headerlink" title="LeakCanary.install"></a>LeakCanary.install</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@NonNull</span> <span class="function">RefWatcher <span class="title">install</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">      .buildAndInstall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@NonNull</span> <span class="function">AndroidRefWatcherBuilder <span class="title">refWatcher</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AndroidRefWatcherBuilder(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 install 方法中，使用了构造者模式来创建 RefWatcher 。我们直接看 AndroidRefWatcherBuilder 的 buildAndInstall 模式。</p>
<h2 id="AndroidRefWatcherBuilder-buildAndInstall"><a href="#AndroidRefWatcherBuilder-buildAndInstall" class="headerlink" title="AndroidRefWatcherBuilder.buildAndInstall"></a>AndroidRefWatcherBuilder.buildAndInstall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="annotation">@NonNull</span> <span class="function">RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LeakCanaryInternals.installedRefWatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"buildAndInstall() should only be called once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建出 RefWatcher</span></span><br><span class="line">  RefWatcher refWatcher = build();</span><br><span class="line">  <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class="line">      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 侦测 Activity</span></span><br><span class="line">    <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">      ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 侦测 Fragment</span></span><br><span class="line">    <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">      FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">  <span class="keyword">return</span> refWatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来看 <code>ActivityRefWatcher.install(context, refWatcher);</code> 在这里我们就只看 ActivityRefWatcher 了，因为 FragmentRefWatcher 的原理也是差不多。</p>
<h2 id="AndroidRefWatcher-install"><a href="#AndroidRefWatcher-install" class="headerlink" title="AndroidRefWatcher.install"></a>AndroidRefWatcher.install</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">  Application application = (Application) context.getApplicationContext();</span><br><span class="line">  ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line"></span><br><span class="line">  application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;</span><br><span class="line">      <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        refWatcher.watch(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在 AndroidRefWatcher 中，只是去注册了 ActivityLifecycleCallbacks 接口。在 onActivityDestroyed 方法中调用 refWatcher 去观察该 Activity 有没有内存泄漏。这样，就不需要开发者手动地去写代码监听每一个 Activity 了。</p>
<h2 id="RefWatcher-watch"><a href="#RefWatcher-watch" class="headerlink" title="RefWatcher.watch"></a>RefWatcher.watch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference)</span> </span>&#123;</span><br><span class="line">  watch(watchedReference, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</span><br><span class="line">  checkNotNull(referenceName, <span class="string">"referenceName"</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="comment">// 创建出唯一的 key ，用来标示该 WeakReference</span></span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  <span class="comment">// 把该 key 加入到 Set 集合中</span></span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="comment">// 创建弱引用，把 activity 传入</span></span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line">  <span class="comment">// 观察该 Activity 有没有被GC回收</span></span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里会调用 IdleHandler 等待主线程空闲的时候再执行</span></span><br><span class="line">  watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="keyword">public</span> Retryable.<span class="function">Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 确认 Activity 有没有被回收</span></span><br><span class="line">      <span class="keyword">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建出一个有唯一标示的 WeakReference ，然后调用 ensureGone 来看看 Activity 有没有被回收。</p>
<h2 id="RefWatcher-ensureGone"><a href="#RefWatcher-ensureGone" class="headerlink" title="RefWatcher.ensureGone"></a>RefWatcher.ensureGone</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"ReferenceEquality"</span>) <span class="comment">// Explicitly checking for named null.</span></span><br><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">  <span class="comment">//把 referenceQueue 中已经入列的弱引用取出</span></span><br><span class="line">  <span class="comment">//然后从 set 集合中把对应的 retainedKeys 移除</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="comment">// The debugger can create false leaks.</span></span><br><span class="line">    <span class="keyword">return</span> RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 set 中没有对应的key ，那就说明没有内存泄漏</span></span><br><span class="line">  <span class="keyword">if</span> (gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 GC </span></span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  <span class="comment">// 再检查一遍</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line">  <span class="comment">// 如果在 set 中还有这个key，说明内存泄漏了</span></span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">    <span class="comment">// 调用 Debug.dumpHprofData dump出内存快照</span></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="comment">// Could not dump the heap.</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line"></span><br><span class="line">    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 分析内存, 这里的 heapdumpListener 实现类是 ServiceHeapDumpListener</span></span><br><span class="line">    heapdumpListener.analyze(heapDump);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureGone 中逻辑就是反复地确认 Set 集合中还有没有 key ，如果没有的话就代表没有内存泄漏；反之，就很有可能发生了内存泄漏。</p>
<h2 id="ServiceHeapDumpListener-analyze"><a href="#ServiceHeapDumpListener-analyze" class="headerlink" title="ServiceHeapDumpListener.analyze"></a>ServiceHeapDumpListener.analyze</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHeapDumpListener</span> <span class="keyword">implements</span> <span class="title">HeapDump</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServiceHeapDumpListener</span><span class="params">(@NonNull <span class="keyword">final</span> Context context,</span><br><span class="line">      @NonNull <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerServiceClass = checkNotNull(listenerServiceClass, <span class="string">"listenerServiceClass"</span>);</span><br><span class="line">    <span class="keyword">this</span>.context = checkNotNull(context, <span class="string">"context"</span>).getApplicationContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(@NonNull HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">    checkNotNull(heapDump, <span class="string">"heapDump"</span>);</span><br><span class="line">    <span class="comment">// HeapAnalyzerService 将运行在另外一个独立的进程中</span></span><br><span class="line">    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceHeapDumpListener 这里主要调用了 HeapAnalyzerService 来分析内存。注意，HeapAnalyzerService 是运行在另外一个进程中的，不是主进程。</p>
<h2 id="HeapAnalyzerService-runAnalysis"><a href="#HeapAnalyzerService-runAnalysis" class="headerlink" title="HeapAnalyzerService.runAnalysis"></a>HeapAnalyzerService.runAnalysis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAnalysis</span><span class="params">(Context context, HeapDump heapDump,</span><br><span class="line">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">  setEnabledBlocking(context, HeapAnalyzerService.class, <span class="keyword">true</span>);</span><br><span class="line">  setEnabledBlocking(context, listenerServiceClass, <span class="keyword">true</span>);</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(context, HeapAnalyzerService.class);</span><br><span class="line">  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</span><br><span class="line">  intent.putExtra(HEAPDUMP_EXTRA, heapDump);</span><br><span class="line">  ContextCompat.startForegroundService(context, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeapAnalyzerService 其实是继承了 IntentService 的。所以只要看 onHandleIntent 中的内容就好了，对应着也就是 onHandleIntentInForeground 方法。</p>
<h2 id="HeapAnalyzerService-onHandleIntentInForeground"><a href="#HeapAnalyzerService-onHandleIntentInForeground" class="headerlink" title="HeapAnalyzerService.onHandleIntentInForeground"></a>HeapAnalyzerService.onHandleIntentInForeground</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntentInForeground</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">  HeapAnalyzer heapAnalyzer =</span><br><span class="line">      <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs, <span class="keyword">this</span>, heapDump.reachabilityInspectorClasses);</span><br><span class="line">  <span class="comment">// 分析内存，查找内存泄漏点以及引用链</span></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">      heapDump.computeRetainedHeapSize);</span><br><span class="line">  <span class="comment">// 找到后，发送通知给开发者    </span></span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析内存的步骤主要在 HeapAnalyzer 中。</p>
<h2 id="HeapAnalyzer-checkForLeak"><a href="#HeapAnalyzer-checkForLeak" class="headerlink" title="HeapAnalyzer.checkForLeak"></a>HeapAnalyzer.checkForLeak</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="annotation">@NonNull</span> <span class="function">AnalysisResult <span class="title">checkForLeak</span><span class="params">(@NonNull File heapDumpFile,</span><br><span class="line">    @NonNull String referenceKey,</span><br><span class="line">    <span class="keyword">boolean</span> computeRetainedSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> analysisStartNanoTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</span><br><span class="line">    Exception exception = <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File does not exist: "</span> + heapDumpFile);</span><br><span class="line">    <span class="keyword">return</span> failure(exception, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);</span><br><span class="line">    HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">    HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);</span><br><span class="line">    listener.onProgressUpdate(PARSING_HEAP_DUMP);</span><br><span class="line">    Snapshot snapshot = parser.parse();</span><br><span class="line">    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);</span><br><span class="line">    deduplicateGcRoots(snapshot);</span><br><span class="line">    listener.onProgressUpdate(FINDING_LEAKING_REF);</span><br><span class="line">    <span class="comment">// 发现内存泄漏的实例</span></span><br><span class="line">    Instance leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></span><br><span class="line">    <span class="comment">// 如果实例不存在，那就说明没有内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">      String className = leakingRef.getClassObj().getClassName();</span><br><span class="line">      <span class="keyword">return</span> noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分析出对应的引用链</span></span><br><span class="line">    <span class="keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要有两个方法的看点：</p>
<ul>
<li>findLeakingReference</li>
<li>findLeakTrace</li>
</ul>
<p>我们先来看第一个 findLeakingReference 。</p>
<h2 id="HeapAnalyzer-findLeakingReference"><a href="#HeapAnalyzer-findLeakingReference" class="headerlink" title="HeapAnalyzer.findLeakingReference"></a>HeapAnalyzer.findLeakingReference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Instance <span class="title">findLeakingReference</span><span class="params">(String key, Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">  ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());</span><br><span class="line">  <span class="keyword">if</span> (refClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Could not find the "</span> + KeyedWeakReference.class.getName() + <span class="string">" class in the heap dump."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;String&gt; keysFound = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Instance instance : refClass.getInstancesList()) &#123;</span><br><span class="line">    List&lt;ClassInstance.FieldValue&gt; values = classInstanceValues(instance);</span><br><span class="line">    Object keyFieldValue = fieldValue(values, <span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyFieldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      keysFound.add(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String keyCandidate = asString(keyFieldValue);</span><br><span class="line">    <span class="keyword">if</span> (keyCandidate.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> fieldValue(values, <span class="string">"referent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    keysFound.add(keyCandidate);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">"Could not find weak reference with key "</span> + key + <span class="string">" in "</span> + keysFound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得之前 KeyedWeakReference 中的那个唯一标示 key 吗？对，这里找内存泄漏的实例也是靠它。</p>
<p>通过那个 key 可以找出 KeyedWeakReference 实例，然后 KeyedWeakReference 实例中 referent 全局变量就是我们要找的内存泄漏实例。也就是我们的 Activity/Fragment 对象。</p>
<p>这样，就完成了内存泄漏的实例查找。然后我们再来看第二个点 findLeakTrace 方法。</p>
<h2 id="HeapAnalyzer-findLeakTrace"><a href="#HeapAnalyzer-findLeakTrace" class="headerlink" title="HeapAnalyzer.findLeakTrace"></a>HeapAnalyzer.findLeakTrace</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AnalysisResult <span class="title">findLeakTrace</span><span class="params">(<span class="keyword">long</span> analysisStartNanoTime, Snapshot snapshot,</span><br><span class="line">    Instance leakingRef, <span class="keyword">boolean</span> computeRetainedSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  listener.onProgressUpdate(FINDING_SHORTEST_PATH);</span><br><span class="line">  ShortestPathFinder pathFinder = <span class="keyword">new</span> ShortestPathFinder(excludedRefs);</span><br><span class="line">  ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);</span><br><span class="line"></span><br><span class="line">  String className = leakingRef.getClassObj().getClassName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// False alarm, no strong reference path to GC Roots.</span></span><br><span class="line">  <span class="keyword">if</span> (result.leakingNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listener.onProgressUpdate(BUILDING_LEAK_TRACE);</span><br><span class="line">  LeakTrace leakTrace = buildLeakTrace(result.leakingNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> retainedSize;</span><br><span class="line">  <span class="keyword">if</span> (computeRetainedSize) &#123;</span><br><span class="line"></span><br><span class="line">    listener.onProgressUpdate(COMPUTING_DOMINATORS);</span><br><span class="line">    <span class="comment">// Side effect: computes retained size.</span></span><br><span class="line">    snapshot.computeDominators();</span><br><span class="line"></span><br><span class="line">    Instance leakingInstance = result.leakingNode.instance;</span><br><span class="line"></span><br><span class="line">    retainedSize = leakingInstance.getTotalRetainedSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check O sources and see what happened to android.graphics.Bitmap.mBuffer</span></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &lt;= N_MR1) &#123;</span><br><span class="line">      listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);</span><br><span class="line">      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,</span><br><span class="line">      since(analysisStartNanoTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findLeakTrace 方法总体的逻辑就是</p>
<ul>
<li>建立内存泄漏点到 GC Roots 的最短引用链</li>
<li>计算整个内存泄漏的大小 retained size</li>
</ul>
<p>这里的在内存快照中引用链建立等都是在 haha 库中完成的。haha 是 square 出品一款 Android Heap 分析库。</p>
<p>具体可以看这里 ：<a href="https://github.com/square/haha" target="_blank" rel="external">https://github.com/square/haha</a></p>
<p>到这里，LeakCanary 整体的逻辑分析就讲完了。下面再给出一张流程图。</p>
<h1 id="u6D41_u7A0B_u56FE"><a href="#u6D41_u7A0B_u56FE" class="headerlink" title="流程图"></a>流程图</h1><p><img src="/uploads/20190706/20190706173423.png" alt="LeakCanary流程图"></p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>其实 LeakCanary 整体的代码流程很清晰，阅读起来也比较易懂，也给我们好好地上了一课。</p>
<p>Read the fucking source code!</p>
<h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.jianshu.com/p/9cc0db9f7c52" target="_blank" rel="external">「Leakcanary 源码分析」看这一篇就够了</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>LeakCanary : <a href="https://github.com/square/leakcanary" target="_blank" rel="external">https://github.com/square/leakcanary</a></p>
<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="内存泄漏" scheme="http://yuqirong.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲谈Android中的内存泄漏]]></title>
    <link href="http://yuqirong.github.io/2019/06/28/%E9%97%B2%E8%B0%88Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yuqirong.github.io/2019/06/28/闲谈Android中的内存泄漏/</id>
    <published>2019-06-28T15:42:44.000Z</published>
    <updated>2019-06-29T06:05:09.225Z</updated>
    <content type="html"><![CDATA[<h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><p>在长久以来的 Android 开发过程中，内存泄漏一直是一个比较头疼的问题。内存泄漏会导致应用卡顿，用户体验不佳，甚至会造成应用崩溃的严重后果。所以如何科学地进行内存管理一直是大家探讨的话题，从一开始主动使用 MAT 分析 hprof 文件，到后来 LeakCanary “被动”的接收内存泄漏消息。应用中发现内存泄漏的手段越来越多了，操作也越来越便捷，但内存泄漏的问题还是不能轻易忽视的，提高应用的体验和质量也是迫在眉睫。</p>
<p>那今天，就从最基本的开始聊聊内存泄漏。</p>
<h1 id="Part_2"><a href="#Part_2" class="headerlink" title="Part 2"></a>Part 2</h1><p>内存泄漏简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。我们所说的内存泄露是针对于堆内存而言，堆内存中存放的就是引用指向的对象实体。</p>
<p>在这里先科普下内存分配的三种策略。（以下这段讲解来自于 <a href="https://segmentfault.com/a/1190000003984512" target="_blank" rel="external">《内存泄露从入门到精通三部曲之基础知识篇》</a>）</p>
<ul>
<li>静态的，使用的内存空间是静态存储区</li>
<li>栈式的，使用的内存空间是栈区</li>
<li>堆式的，使用的内存空间是堆区</li>
</ul>
<p>静态存储区（方法区）：内存在程序编译的时候就已经分配好，这块内存在程序整个运行期间都存在。它主要存放静态数据、全局static数据和常量。 </p>
<p>栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 </p>
<p>堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存（Java则依赖垃圾回收器）。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉。<br> 接下来我们集中说下堆和栈的区别：</p>
<p>在函数中（说明是局部变量）定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。<br> <br>堆内存用于存放所有由new创建的对象（内容包括该对象其中的所有成员变量）和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。<br> <br>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定，VC中可设置）。<br> <br>对于堆，频繁的new/delete会造成大量内存碎片，使程序效率降低。对于栈，它是先进后出的队列，进出一一对应，不产生碎片，运行效率稳定高。</p>
<p>说了这么多了，我们来看一个例子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> School school = <span class="keyword">new</span> School();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Book book = <span class="keyword">new</span> Book();</span><br><span class="line">		<span class="keyword">int</span> pageNo = <span class="number">15</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>s 自己存放在栈中，而 s 指向的对象实体存放在堆中；</p>
<p>其中 s 这个对象实体中的全局变量 age 和 school 都是存放在堆中（包括基本数据类型、引用和引用的对象实体）</p>
<p>doHomework 中的引用变量 book 和局部变量 pageNo 是存放在栈中的，而引用变量 book 指向的对象是存放在堆中的。</p>
<p><strong>结论</strong>：（以下结论来自于<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=401527654&amp;idx=1&amp;sn=eb91bf358b28ede2b7a984c08e5cdab0#rd" target="_blank" rel="external">《Android 内存泄漏探讨》</a>）</p>
<p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。<br>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p>
<h1 id="Part_3"><a href="#Part_3" class="headerlink" title="Part 3"></a>Part 3</h1><p>那么有没有想过，内存为什么会泄露？</p>
<p>Java的内存垃圾回收机制是从程序的主要运行对象(如静态对象/寄存器/栈上指向的堆内存对象等)开始检查引用链，当遍历一遍后得到上述这些无法回收的对象和他们所引用的对象链，组成无法回收的对象集合，而其他孤立对象（集）就作为垃圾回收。GC为了能够正确释放对象，必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>
<p>在Java中，这些无用的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。虽然，我们有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义，该函数不保证JVM的垃圾收集器一定会执行。因为不同的JVM实现者可能使用不同的算法管理GC。通常GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。</p>
<p>GC过程与对象的引用类型是严重相关的，我们来看看Java对引用的分类Strong reference, SoftReference, WeakReference, PhatomReference<br> <img src="/uploads/20190629/20190629134830.png" alt="java引用"></p>
<p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p>
<p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<p><strong>结论</strong>：<br> 堆内存中的长生命周期的对象持有短生命周期对象的强/软引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的根本原因。</p>
<h1 id="Part_4"><a href="#Part_4" class="headerlink" title="Part 4"></a>Part 4</h1><p>Android中常见的内存泄漏问题：</p>
<ul>
<li>单例造成的内存泄露</li>
<li>InnerClass匿名内部类</li>
<li>Activity Context 的不正确使用</li>
<li>Handler引起的内存泄漏</li>
<li>注册监听器的泄漏</li>
<li>Cursor，Stream没有close，View没有recyle</li>
<li>集合中对象没清理造成的内存泄漏</li>
<li>WebView造成的泄露</li>
<li>构造Adapter时，没有使用缓存的ConvertView</li>
</ul>
<p>具体可以参考  <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=1116PDhSmvxU6YwfbJuVCEJx#rd" target="_blank" rel="external">Android内存泄漏分析心得</a></p>
<h1 id="Part_5"><a href="#Part_5" class="headerlink" title="Part 5"></a>Part 5</h1><p>Android 中检测内存泄漏的工具</p>
<ul>
<li>MAT</li>
<li>Android Profiler</li>
<li>LeakCanary</li>
</ul>
<h1 id="Part_6"><a href="#Part_6" class="headerlink" title="Part 6"></a>Part 6</h1><p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=401527654&amp;idx=1&amp;sn=eb91bf358b28ede2b7a984c08e5cdab0#rd" target="_blank" rel="external">Android 内存泄漏探讨</a></li>
<li><a href="https://segmentfault.com/a/1190000003984512" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=1116PDhSmvxU6YwfbJuVCEJx#rd" target="_blank" rel="external">Android内存泄漏分析心得</a></li>
<li><a href="https://droidyue.com/blog/2016/11/23/memory-leaks-in-android/" target="_blank" rel="external">系统剖析Android中的内存泄漏</a>
 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><p>在长久以来的 Android 开发过程中，内存泄漏一直是一个比较头疼的问题。内存泄漏会导致应用卡顿，用户体验]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="内存泄漏" scheme="http://yuqirong.github.io/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Binder]]></title>
    <link href="http://yuqirong.github.io/2019/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder/"/>
    <id>http://yuqirong.github.io/2019/05/21/深入理解Binder/</id>
    <published>2019-05-21T15:26:43.000Z</published>
    <updated>2019-06-04T14:42:41.681Z</updated>
    <content type="html"><![CDATA[<p>之前一直对 Binder 理解不够透彻，仅仅知道一些皮毛，所以最近抽空深入理解一下，并在这里做个小结。</p>
<h1 id="Binder_u662F_u4EC0_u4E48"><a href="#Binder_u662F_u4EC0_u4E48" class="headerlink" title="Binder是什么"></a>Binder是什么</h1><p>Binder 是 Android 系统中实现 IPC (进程间通信)的一种机制。Binder 原意是“胶水、粘合剂”，所以可以想象它的用途就是像胶水一样把两个进程紧紧“粘”在一起，从而可以方便地实现 IPC 。</p>
<h1 id="u8FDB_u7A0B_u901A_u4FE1"><a href="#u8FDB_u7A0B_u901A_u4FE1" class="headerlink" title="进程通信"></a>进程通信</h1><p>那么为什么会有进程通信呢？这是因为在 Linux 中进程之间是隔离的，也就是说 A 进程不知道有 B 进程的存在，相应的 B 进程也不知道 A 进程的存在。A 、B 两进程的内存是不共享的，所以 A 进程的数据想要传给 B 进程就需要用到 IPC 。</p>
<p>在这里再科普一下进程空间的知识点：进程空间可以分为用户空间和内核空间。简单的说，用户空间是用户程序运行的空间，而内核空间就是内核运行的空间了。因为像内核这么底层、至关重要的东西肯定是不会简单地让用户程序随便调用的，所以需要把内核保护起来，就创造了内核空间，让内核运行在内核空间中，这样就不会被用户空间随便干扰到了。两个进程之间的用户空间是不共享的，但是内核空间是共享的。</p>
<p>所以到这里，有些同学会有个大胆的想法，两个进程间的通信可以利用内核空间来实现啊，因为它们的内核空间是共享的，这样数据不就传过去了嘛。但是接着又来了一个问题：为了保证安全性，用户空间和内核空间也是隔离的。那么如何把数据从发送方的用户空间传到内核空间呢？</p>
<p>针对这个问题提供了<strong>系统调用</strong>来解决，可以让用户程序调用内核资源。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性(这段话来自<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)。我们平时的网络、I/O操作其实都是通过系统调用在内核空间中运行的（也就是<strong>内核态</strong>）。</p>
<p>至此，关于 IPC 我们有了一个大概的实现方案：A 进程的数据通过系统调用把数据传输到内核空间（即copy_from_user），内核空间再利用系统调用把数据传输到 B 进程（即 copy_to_user）。这也正是目前 Linux 中传统 IPC 通信的实现原理，可以看到这其中会有两次数据拷贝。</p>
<p><img src="/uploads/20190521/20190521235434.jpg" alt="IPC原理"></p>
<p>(图片来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<p>Linux 中的一些 IPC 方式：</p>
<ol>
<li>管道（Pipe）</li>
<li>信号（Signal）</li>
<li>报文（Message）队列（消息队列）</li>
<li>共享内存</li>
<li>信号量（semaphore）</li>
<li>套接字（Socket）</li>
</ol>
<h1 id="Binder_IPC__u539F_u7406"><a href="#Binder_IPC__u539F_u7406" class="headerlink" title="Binder IPC 原理"></a>Binder IPC 原理</h1><p>通过上面的讲解我们可以知道，IPC 是需要内核空间来支持的。Linux 中的管道、socket 等都是在内核中的。但是在 Linux 系统里面是没有 Binder 的。那么 Android 中是如何利用 Binder 来实现 IPC 的呢？</p>
<p>这就要讲到 Linux 中的<strong>动态内核可加载模块</strong>。动态内核可加载模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。（这段话来自<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>）在 Android 中，这个内核模块也就是 Binder 驱动。</p>
<p>另外，Binder IPC 原理相比较上面传统的 Linux IPC 而言，只需要一次数据拷贝就可以完成了。那么究竟是怎么做到的呢？</p>
<p>其实 Binder 是借助于 mmap （内存映射）来实现的。mmap 用于文件或者其它对象映射进内存，通常是用在有物理介质的文件系统上的。mmap 简单的来说就是可以把用户空间的内存区域和内核空间的内存区域之间建立映射关系，这样就减少了数据拷贝的次数，任何一方的对内存区域的改动都将被反应给另一方。</p>
<p>所以，Binder 的做法就是建立一个虚拟设备（设备驱动是/dev/binder），然后在内核空间创建一块数据接收的缓存区，这个缓存区会和内存缓存区以及接收数据进程的用户空间建立映射，这样发送数据进程把数据发送到内存缓存区，该数据就会被间接映射到接收进程的用户空间中，减少了一次数据拷贝。具体可以看下图理解</p>
<p><img src="/uploads/20190521/20190522105623.jpg" alt="Binder IPC原理"></p>
<p>(图片来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<h1 id="u4E3A_u4EC0_u4E48_u9009_u62E9Binder"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Binder" class="headerlink" title="为什么选择Binder"></a>为什么选择Binder</h1><p>Binder 的优点</p>
<ol>
<li><strong>效率高，性能好</strong>：传统的 Linux 下 IPC 通信都需要两次数据拷贝，即一次 copy_from_user 和一次 copy_to_user ，而 binder 只需要一次拷贝；</li>
<li><strong>安全性高</strong>：Binder 可以做安全校验，如果没有相应权限可以拒绝提供连接。在底层为每个 app 添加UID/PID，鉴别进程身份；</li>
<li><strong>稳定性高</strong>：Binder 是 C/S 架构，Client 端和 Server 端分工明确，互不干扰。并且 Client 端可以设置死亡通知，及时监听 Server 端的存活情况；</li>
<li><strong>使用简单，对开发者友好</strong>：Binder 封装了底层 IPC 通信，让开发者无需关心底层细节，也无需关心 Server 端的实现细节。只需要面向 binder 对象就可以完成 IPC 通信，简单无脑。</li>
</ol>
<h1 id="Binder_u901A_u4FE1_u8FC7_u7A0B"><a href="#Binder_u901A_u4FE1_u8FC7_u7A0B" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h1><p>在整个 Binder 通信过程中，可以分为四个部分：</p>
<ul>
<li>Client : 即客户端进程；</li>
<li>Server : 即服务端进程；</li>
<li>Binder 驱动 : 驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持；(来自<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Android Binder 设计与实现》</a>)</li>
<li>ServiceManager : 作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。(来自<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Android Binder 设计与实现》</a>)</li>
</ul>
<p>其中 Client 和 Server 是应用层实现的，而 Binder 驱动和 ServiceManager 是 Android 系统底层实现的。</p>
<p>具体流程如下：</p>
<ol>
<li>首先由一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册为 ServiceManager 。</li>
<li>Server 进程向 Binder 驱动发起 Binder 注册的请求，驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过服务名称，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
<li>然后 Binder 驱动为跨进程通信做准备，Binder 驱动在内核中创建接收缓存区，并将接收缓存区与内核缓存区、接收进程的用户空间做内存映射。</li>
<li>Client 进程调用 copy_from_user 将数据发送到内核缓存区（Client 进程中当前的线程将被挂起），因为之前做了内存映射，所以这就相当于把数据间接发送到了 Server 端。然后 Binder 驱动通知 Server 解包；</li>
<li>收到 Binder 驱动的通知后，Server 进程从线程池中取出线程，进行数据解包并调用相关的目标方法，最后将方法执行的返回值写入到内存中；</li>
<li>又因为之前做了内存映射，所以方法的返回值就间接地发送到了内核缓存区中，最后 Binder 驱动通知 Client 进程获取方法的返回值（此时 Client 进程被唤醒），然后 Client 进程调用 copy_to_user 将返回值发送到自己的用户空间中。</li>
</ol>
<p><img src="/uploads/20190521/20190530122134.jpg" alt="Binder通信过程"></p>
<p>(Binder通信过程示意图来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<h1 id="Binder_u539F_u7406_u8BE6_u89E3"><a href="#Binder_u539F_u7406_u8BE6_u89E3" class="headerlink" title="Binder原理详解"></a>Binder原理详解</h1><ul>
<li><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="external">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></li>
</ul>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">写给 Android 应用工程师的 Binder 原理剖析</a></li>
<li><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
<li><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder设计与实现 - 设计篇</a></li>
<li><a href="https://www.jianshu.com/p/af2993526daf" target="_blank" rel="external">Binder学习指南</a></li>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="external">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前一直对 Binder 理解不够透彻，仅仅知道一些皮毛，所以最近抽空深入理解一下，并在这里做个小结。</p>
<h1 id="Binder_u662F_u4EC0_u4E48"><a href="#Binder_u662F_u4EC0_u4E48" class="head]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Binder" scheme="http://yuqirong.github.io/tags/Binder/"/>
    
      <category term="IPC" scheme="http://yuqirong.github.io/tags/IPC/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Activity生命周期调用流程]]></title>
    <link href="http://yuqirong.github.io/2019/04/09/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.github.io/2019/04/09/Activity生命周期调用流程/</id>
    <published>2019-04-09T14:26:55.000Z</published>
    <updated>2019-04-11T16:08:58.470Z</updated>
    <content type="html"><![CDATA[<p>注：源码分析基于 Android SDK API 28 </p>
<p>在前一篇中，我们分析了 startActivity 的整个流程，并且也讲到了何时调用了 onCreate() 。</p>
<p>那么就会有一个疑问，其他的生命周期方法是在哪里被调用的呢？今天就来揭开这个谜底。</p>
<p>我们知道，Activity A 启动 Activity B ，其生命周期方法调用如下：</p>
<ol>
<li>Activity A onPause()</li>
<li>Activity B onCreate()</li>
<li>Activity B onStart()</li>
<li>Activity B onResume()</li>
<li>Activity A onStop()</li>
</ol>
<p>那首先我们来看看 Activity A 的 onPause() 是什么地方调用的？</p>
<h1 id="onPause_28_29"><a href="#onPause_28_29" class="headerlink" title="onPause()"></a>onPause()</h1><p>在前一篇文章中讲到，startActivity 的流程中有一步是 resumeTopActivityInnerLocked 。</p>
<p>我们来看一下其中的源码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">            <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">    pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 startPausingLocked 方法的名字上来看，这就是去调用 onPause 方法的入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span><br><span class="line">        ActivityRecord resuming, <span class="keyword">boolean</span> pauseImmediately)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Going to pause when pause is already pending for "</span> + mPausingActivity</span><br><span class="line">                + <span class="string">" state="</span> + mPausingActivity.getState());</span><br><span class="line">        <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">            <span class="comment">// Avoid recursion among check for sleep and complete pause during sleeping.</span></span><br><span class="line">            <span class="comment">// Because activity will be paused immediately after resume, just let pause</span></span><br><span class="line">            <span class="comment">// be completed by the order of activity paused from clients.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Trying to pause when nothing is resumed"</span>);</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == resuming) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Trying to pause activity that is in process of being resumed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to PAUSING: "</span> + prev);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Start pausing: "</span> + prev);</span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">            || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span> ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">"startPausingLocked"</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.getLaunchTimeTracker().stopFullyDrawnTraceIfNeeded(getWindowingMode());</span><br><span class="line"></span><br><span class="line">    mService.updateCpuStats();</span><br><span class="line">    <span class="comment">// 这里开始调用 onPause</span></span><br><span class="line">    <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> &amp;&amp; prev.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Enqueueing pending pause: "</span> + prev);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class="line">                    prev.shortComponentName, <span class="string">"userLeaving="</span> + userLeaving);</span><br><span class="line">            mService.updateUsageStats(prev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class="line">                    PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are not going to sleep, we want to ensure the device is</span></span><br><span class="line">    <span class="comment">// awake until the next activity is started.</span></span><br><span class="line">    <span class="keyword">if</span> (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">        mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Have the window manager pause its key dispatching until the new</span></span><br><span class="line">        <span class="comment">// activity has started.  If we're pausing the activity just because</span></span><br><span class="line">        <span class="comment">// the screen is being turned off and the UI is sleeping, don't interrupt</span></span><br><span class="line">        <span class="comment">// key dispatch; the same activity will pick it up again on wakeup.</span></span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) &#123;</span><br><span class="line">             Slog.v(TAG_PAUSE, <span class="string">"Key dispatch not paused for screen off"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123;</span><br><span class="line">            <span class="comment">// If the caller said they don't want to wait for the pause, then complete</span></span><br><span class="line">            <span class="comment">// the pause now.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            schedulePauseTimeout(prev);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity failed to schedule the</span></span><br><span class="line">        <span class="comment">// pause, so just treat it as being paused now.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Activity not running, resuming next."</span>);</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和调用 onCreate 一样，onPause 也是利用 Transaction 来完成的。不过这里的是 PauseActivityItem 。</p>
<p>追踪到 PauseActivityItem 的 execute 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityPause"</span>);</span><br><span class="line">    <span class="comment">// 调用 ActivityThread 的 handlePauseActivity 方法</span></span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现还是一个套路，最终还是要去 ActivityThread 中找答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span><br><span class="line">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userLeaving) &#123;</span><br><span class="line">            performUserLeavingActivity(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注 performPauseActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">            <span class="comment">// If we are finishing, we won't call onResume() in certain cases.</span></span><br><span class="line">            <span class="comment">// So here we likewise don't want to call onPause() if the activity</span></span><br><span class="line">            <span class="comment">// isn't resumed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Performing pause of activity that is not resumed: "</span></span><br><span class="line">                + r.intent.getComponent().toShortString());</span><br><span class="line">        Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-Honeycomb apps always save their state before pausing</span></span><br><span class="line">    <span class="comment">// 调用 Activity 的 OnSaveInstanceState 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 onPause</span></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify any outstanding on paused listeners</span></span><br><span class="line">    ArrayList&lt;OnActivityPausedListener&gt; listeners;</span><br><span class="line">    <span class="keyword">synchronized</span> (mOnPauseListeners) &#123;</span><br><span class="line">        listeners = mOnPauseListeners.remove(r.activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = (listeners != <span class="keyword">null</span> ? listeners.size() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        listeners.get(i).onPaused(r.activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Bundle oldState = pendingActions != <span class="keyword">null</span> ? pendingActions.getOldState() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to keep around the original state, in case we need to be created again.</span></span><br><span class="line">        <span class="comment">// But we only do this for pre-Honeycomb apps, which always save their state when</span></span><br><span class="line">        <span class="comment">// pausing, so we can not have them save their state when restarting from a paused</span></span><br><span class="line">        <span class="comment">// state. For HC and later, we want to (and can) let the state be saved as the</span></span><br><span class="line">        <span class="comment">// normal part of stopping the activity.</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            r.state = oldState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 调用 Activity.onPause</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to pause activity "</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终由 mInstrumentation 内部调用 Activity.performPause 。而 performPause 方法内部又调用了 onPause 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity.performPause</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onPause();</span><br><span class="line">    writeEventLog(LOG_AM_ON_PAUSE_CALLED, <span class="string">"performPause"</span>);</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onCreate_28_29"><a href="#onCreate_28_29" class="headerlink" title="onCreate()"></a>onCreate()</h1><p>onCreate 的生命周期调用在前一篇中已经分析过了，所以在这里就不讲了。</p>
<p>如果有需要的话可以看前一篇博客。</p>
<h1 id="onResume_28_29"><a href="#onResume_28_29" class="headerlink" title="onResume()"></a>onResume()</h1><p>在前一篇中讲到，<code>resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)</code> 方法中有一段代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">transaction</span><span class="class">.setLifecycleStateRequest</span>(</span><br><span class="line">                        <span class="tag">ResumeActivityItem</span><span class="class">.obtain</span>(<span class="tag">next</span><span class="class">.app</span><span class="class">.repProcState</span>,</span><br><span class="line">                                <span class="tag">mService</span><span class="class">.isNextTransitionForward</span>()));</span><br><span class="line"><span class="tag">mService</span><span class="class">.getLifecycleManager</span>()<span class="class">.scheduleTransaction</span>(<span class="tag">transaction</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 transaction 将最后的生命周期状态设置为了 resume 。</p>
<p>根据前一篇博客的分析，代码最后会执行 ResumeActivityItem.execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityResume"</span>);</span><br><span class="line">    client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">            <span class="string">"RESUME_ACTIVITY"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 execute 中调用了 ActivityThread 的 handleResumeActivity 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span><br><span class="line">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="comment">// 请关注这里</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We didn't actually resume the activity, so skipping any follow-up actions.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Resume "</span> + r + <span class="string">" started activity: "</span> + a.mStartedActivity</span><br><span class="line">                + <span class="string">", hideForNow: "</span> + r.hideForNow + <span class="string">", finished: "</span> + a.mFinished);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">            <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">            <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">            <span class="comment">// callbacks may have changed.</span></span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class="line">                <span class="comment">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class="line">                <span class="comment">// in this method), so no action will be taken. This call ensures the</span></span><br><span class="line">                <span class="comment">// callback occurs with the decor set.</span></span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">        <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">        <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">    cleanUpPendingRemoveWindows(r, <span class="keyword">false</span> <span class="comment">/* force */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"Resuming activity "</span> + r.activityInfo.name + <span class="string">" with newConfig "</span></span><br><span class="line">                        + r.activity.mCurrentConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            r.newConfig = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Resuming "</span> + r + <span class="string">" with isForward="</span> + isForward);</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                != forwardBit) &#123;</span><br><span class="line">            l.softInputMode = (l.softInputMode</span><br><span class="line">                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                    | forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                wm.updateViewLayout(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Scheduling idle handler for "</span> + r);</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 handleResumeActivity 中调用了 performResumeActivity 来完成 Activity 的 resume 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span><br><span class="line">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Performing resume of "</span> + r + <span class="string">" finished="</span> + r.activity.mFinished);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.activity.mFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.getLifecycleState() == ON_RESUME) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!finalStateRequest) &#123;</span><br><span class="line">            <span class="keyword">final</span> RuntimeException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Trying to resume activity which is already resumed"</span>);</span><br><span class="line">            Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">            Slog.e(TAG, r.getStateString());</span><br><span class="line">            <span class="comment">// TODO(lifecycler): A double resume request is possible when an activity</span></span><br><span class="line">            <span class="comment">// receives two consequent transactions with relaunch requests and "resumed"</span></span><br><span class="line">            <span class="comment">// final state requests and the second relaunch is omitted. We still try to</span></span><br><span class="line">            <span class="comment">// handle two resume requests for the final state. For cases other than this</span></span><br><span class="line">            <span class="comment">// one, we don't expect it to happen.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finalStateRequest) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">false</span>;</span><br><span class="line">        r.activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.onStateNotSaved();</span><br><span class="line">        r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">        checkAndBlockForNetworkAccess();</span><br><span class="line">        <span class="keyword">if</span> (r.pendingIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">            r.pendingIntents = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.pendingResults != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverResults(r, r.pendingResults, reason);</span><br><span class="line">            r.pendingResults = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 Activity 的 performResume 方法</span></span><br><span class="line">        r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">        r.state = <span class="keyword">null</span>;</span><br><span class="line">        r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">        r.setState(ON_RESUME);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to resume activity "</span></span><br><span class="line">                    + r.intent.getComponent().toShortString() + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activity.performResume 的内部将 onResume 回调的操作交给了 mInstrumentation 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">(<span class="keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    performRestart(<span class="keyword">true</span> <span class="comment">/* start */</span>, reason);</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        <span class="comment">// When Activity is destroyed in paused state, and relaunch activity, there will be</span></span><br><span class="line">        <span class="comment">// extra onResume and onPause event,  ignore the first onResume and onPause.</span></span><br><span class="line">        <span class="comment">// see ActivityThread.handleRelaunchActivity()</span></span><br><span class="line">        mAutoFillIgnoreFirstResumePause = followedByPause;</span><br><span class="line">        <span class="keyword">if</span> (mAutoFillIgnoreFirstResumePause &amp;&amp; DEBUG_LIFECYCLE) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"autofill will ignore first pause when relaunching "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// mResumed is set by the instrumentation</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">    writeEventLog(LOG_AM_ON_RESUME_CALLED, reason);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invisible activities must be finished before onResume() completes</span></span><br><span class="line">    <span class="keyword">if</span> (!mVisibleFromClient &amp;&amp; !mFinished) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"An activity without a UI must call finish() before onResume() completes"</span>);</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt; android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                    <span class="string">" did not call finish() prior to onResume() completing"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now really resume, and install the current status bar and menu.</span></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    onPostResume();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onPostResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 mInstrumentation.callActivityOnResume 内部调用了 Activity 的 onResume 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnResume</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.mResumed = <span class="keyword">true</span>;</span><br><span class="line">    activity.onResume();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                am.match(activity, activity, activity.getIntent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onStart_28_29"><a href="#onStart_28_29" class="headerlink" title="onStart()"></a>onStart()</h1><p>可能有些同学会觉得奇怪，怎么从 onCreate 直接跳到 onResume 了？不是应该还有一个 onStart 么？</p>
<p>那接下来，我们就来看看 onStart 是哪里被调用的。</p>
<p>话还要从 transaction 开始说起。</p>
<p>一开始 transaction 设置了 LaunchActivityItem ，然后又设置了生命周期状态 ResumeActivityItem 。</p>
<p>所以可以简单地看出，onCreate -&gt; onResume ，中间并没有加 onStart 。那么 onStart 是哪里在调用呢？</p>
<p>我们来看下 TransactionExecutor.execute 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(<span class="string">"Start resolving transaction for client: "</span> + mTransactionHandler + <span class="string">", token: "</span> + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(<span class="string">"End resolving transaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上一篇中分析，我们知道执行 <code>executeCallbacks(transaction);</code> 之后，Activity 就完成了 onCreate 的调用，所以此时 Activity 的状态应该是 ON_CREATE 。</p>
<p>然后来看看 executeLifecycleState 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"Resolving lifecycle state: "</span> + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">    <span class="comment">// 这里的 lifecycleItem.getTargetState() 正是 ResumeActivityItem.ON_RESUME</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来关注下 cycleToPath 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish,</span><br><span class="line">        <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">    log(<span class="string">"Cycle from: "</span> + start + <span class="string">" to: "</span> + finish + <span class="string">" excludeLastState:"</span> + excludeLastState);</span><br><span class="line">    <span class="comment">// 这里需要我们重点来关注</span></span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">    <span class="comment">// 去执行 path 中的生命周期</span></span><br><span class="line">    performLifecycleSequence(r, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ActivityThread 中对应的生命周期方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">        state = path.get(i);</span><br><span class="line">        log(<span class="string">"Transitioning to state: "</span> + state);</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                mTransactionHandler.handleResumeActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        r.isForward, <span class="string">"LIFECYCLER_RESUME_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                mTransactionHandler.handlePauseActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions,</span><br><span class="line">                        <span class="string">"LIFECYCLER_PAUSE_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                mTransactionHandler.handleStopActivity(r.token, <span class="keyword">false</span> <span class="comment">/* show */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        <span class="string">"LIFECYCLER_STOP_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                mTransactionHandler.handleDestroyActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                        <span class="string">"performLifecycleSequence. cycling to:"</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                mTransactionHandler.performRestartActivity(r.token, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected lifecycle state: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 mHelper.getLifecyclePath 返回的 path 直接传入到 performLifecycleSequence 方法中。</p>
<p>而 performLifecycleSequence 方法里面一堆 switch case 正是去调用生命周期的，可以看到有 ON_START 的身影。我们的可以猜想到，在 mHelper.getLifecyclePath 方法中应该会返回 ON_START 。这样在 performLifecycleSequence 中就会去调用 <code>mTransactionHandler.handleStartActivity(r, mPendingActions)</code> 了。</p>
<p>那么我们来看看 mHelper.getLifecyclePath 中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == UNDEFINED || finish == UNDEFINED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't resolve lifecycle path for undefined state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == ON_RESTART || finish == ON_RESTART) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Can't start or finish in intermittent RESTART state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finish == PRE_ON_CREATE &amp;&amp; start != finish) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only start in pre-onCreate state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLifecycleSequence.clear();</span><br><span class="line">    <span class="keyword">if</span> (finish &gt;= start) &#123;</span><br><span class="line">        <span class="comment">// just go there</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">            mLifecycleSequence.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// finish &lt; start, can't just cycle down</span></span><br><span class="line">        <span class="keyword">if</span> (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123;</span><br><span class="line">            <span class="comment">// Special case when we can just directly go to resumed state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESUME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123;</span><br><span class="line">            <span class="comment">// Restart and go to required state.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to stopped state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_STOP; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Restart</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESTART);</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_START; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Relaunch and go to required state</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to destroyed state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_DESTROY; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_CREATE; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class="line">    <span class="keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面这一段代码，相信你已经大致的明白了吧。上面这段代码中主要做的就是把“中间路径”给计算出来。</p>
<p>比如起点是 ON_CREATE , 终点是 ON_RESUME 。所以“中间路径”就是 [ON_START, ON_RESUME] 。但是之前传入的 excludeLastState 参数是 true 。所以还要减掉最后一个终点，因为“中间路径”就是 [ON_START] 了。</p>
<p>这样一连贯起来，我们就明白了 onStart 是怎么调用了的吧！</p>
<p>那么接着看吧。有了 ON_START 后，会调用 ActivityThread.handleStartActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Activity activity = r.activity;</span><br><span class="line">    <span class="keyword">if</span> (r.activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): What do we do in this case?</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't start activity that is not stopped."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): How can this happen?</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start</span></span><br><span class="line">    <span class="comment">// 调用 performStart</span></span><br><span class="line">    activity.performStart(<span class="string">"handleStartActivity"</span>);</span><br><span class="line">    r.setState(ON_START);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No more work to do.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore instance state</span></span><br><span class="line">    <span class="comment">// 调用 OnRestoreInstanceState</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call postOnCreate()</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 handleStartActivity 里面调用了 Activity.performStart</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line">    <span class="comment">// 调用 Instrumentation 的 callActivityOnStart</span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    writeEventLog(LOG_AM_ON_START_CALLED, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onStart()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isAppDebuggable =</span><br><span class="line">            (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This property is set for all non-user builds except final release</span></span><br><span class="line">    <span class="keyword">boolean</span> isDlwarningEnabled = SystemProperties.getInt(<span class="string">"ro.bionic.ld.warning"</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isDlwarningEnabled) &#123;</span><br><span class="line">        String dlwarning = getDlWarning();</span><br><span class="line">        <span class="keyword">if</span> (dlwarning != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String appName = getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            String warning = <span class="string">"Detected problems with app native libraries\n"</span> +</span><br><span class="line">                             <span class="string">"(please consult log for detail):\n"</span> + dlwarning;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                  <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).</span><br><span class="line">                      setTitle(appName).</span><br><span class="line">                      setMessage(warning).</span><br><span class="line">                      setPositiveButton(android.R.string.ok, <span class="keyword">null</span>).</span><br><span class="line">                      setCancelable(<span class="keyword">false</span>).</span><br><span class="line">                      show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, appName + <span class="string">"\n"</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This property is set for all non-user builds except final release</span></span><br><span class="line">    <span class="keyword">boolean</span> isApiWarningEnabled = SystemProperties.getInt(<span class="string">"ro.art.hiddenapi.warning"</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isApiWarningEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mMainThread.mHiddenApiWarningShown &amp;&amp; VMRuntime.getRuntime().hasUsedHiddenApi()) &#123;</span><br><span class="line">            <span class="comment">// Only show the warning once per process.</span></span><br><span class="line">            mMainThread.mHiddenApiWarningShown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            String appName = getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            String warning = <span class="string">"Detected problems with API compatibility\n"</span></span><br><span class="line">                             + <span class="string">"(visit g.co/dev/appcompat for more info)"</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(appName)</span><br><span class="line">                    .setMessage(warning)</span><br><span class="line">                    .setPositiveButton(android.R.string.ok, <span class="keyword">null</span>)</span><br><span class="line">                    .setCancelable(<span class="keyword">false</span>)</span><br><span class="line">                    .show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, appName + <span class="string">"\n"</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActivityTransitionState.enterReady(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出所料，performStart 中又调用了 mInstrumentation.callActivityOnStart(this)</p>
<p>在 callActivityOnStart 中直接调用 activity.onStart</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.onStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onStop_28_29"><a href="#onStop_28_29" class="headerlink" title="onStop()"></a>onStop()</h1><p>最后，我们来看一下 onStop 。</p>
<p>在 ActivityThread 的 handleResumeActivity 方法中，末尾有一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.nextIdle = mNewActivities;</span><br><span class="line">mNewActivities = r;</span><br><span class="line"><span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Scheduling idle handler for "</span> + r);</span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br></pre></td></tr></table></figure>
<p>重点来关注下 Idler 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        <span class="keyword">boolean</span> stopProfiling = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBoundApplication != <span class="keyword">null</span> &amp;&amp; mProfiler.profileFd != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">            stopProfiling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityManager am = ActivityManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Reporting idle of "</span> + a +</span><br><span class="line">                    <span class="string">" finished="</span> +</span><br><span class="line">                    (a.activity != <span class="keyword">null</span> &amp;&amp; a.activity.mFinished));</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 调用 AMS 来处理 activity 的 onStop</span></span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">            mProfiler.stopProfiling();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureJitEnabled();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其中有一句 <code>am.activityIdle(a.token, a.createdConfig, stopProfiling);</code> 。</p>
<p>而 am 就是 AMS 了，所以我们需要去 AMS 里面看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ActivityRecord r =</span><br><span class="line">                    mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    clearProfilerLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 mStackSupervisor 来处理 Activity 任务栈的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span><br><span class="line">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"Activity idle: "</span> + token);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; finishes = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;UserState&gt; startingUsers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> NF = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> booting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_IDLE) Slog.d(TAG_IDLE, <span class="string">"activityIdleInternalLocked: Callers="</span></span><br><span class="line">                + Debug.getCallers(<span class="number">4</span>));</span><br><span class="line">        mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);</span><br><span class="line">        r.finishLaunchTickingLocked();</span><br><span class="line">        <span class="keyword">if</span> (fromTimeout) &#123;</span><br><span class="line">            reportActivityLaunchedLocked(fromTimeout, r, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is a hack to semi-deal with a race condition</span></span><br><span class="line">        <span class="comment">// in the client where it can be constructed with a</span></span><br><span class="line">        <span class="comment">// newer configuration from when we asked it to launch.</span></span><br><span class="line">        <span class="comment">// We'll update with whatever configuration it now says</span></span><br><span class="line">        <span class="comment">// it used to launch.</span></span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.setLastReportedGlobalConfiguration(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are now idle.  If someone is waiting for a thumbnail from</span></span><br><span class="line">        <span class="comment">// us, we can now deliver.</span></span><br><span class="line">        r.idle = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Slog.i(TAG, "IDLE: mBooted=" + mBooted + ", fromTimeout=" + fromTimeout);</span></span><br><span class="line">        <span class="keyword">if</span> (isFocusedStack(r.getStack()) || fromTimeout) &#123;</span><br><span class="line">            booting = checkFinishBootingLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allResumedActivitiesIdle()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.scheduleAppGcsLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLaunchingActivity.isHeld()) &#123;</span><br><span class="line">            mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);</span><br><span class="line">            <span class="keyword">if</span> (VALIDATE_WAKE_LOCK_CALLER &amp;&amp;</span><br><span class="line">                    Binder.getCallingUid() != Process.myUid()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling must be system uid"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLaunchingActivity.release();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* remove */</span>, processPausingActivities);</span><br><span class="line">    NS = stops != <span class="keyword">null</span> ? stops.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((NF = mFinishingActivities.size()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finishes = <span class="keyword">new</span> ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">        mFinishingActivities.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartingUsers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        startingUsers = <span class="keyword">new</span> ArrayList&lt;&gt;(mStartingUsers);</span><br><span class="line">        mStartingUsers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">        r = stops.get(i);</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="keyword">false</span>,</span><br><span class="line">                        <span class="string">"activityIdleInternalLocked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.stopActivityLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NF; i++) &#123;</span><br><span class="line">        r = finishes.get(i);</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityRemoved |= stack.destroyActivityLocked(r, <span class="keyword">true</span>, <span class="string">"finish-idle"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!booting) &#123;</span><br><span class="line">        <span class="comment">// Complete user switch</span></span><br><span class="line">        <span class="keyword">if</span> (startingUsers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startingUsers.size(); i++) &#123;</span><br><span class="line">                mService.mUserController.finishUserSwitch(startingUsers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.trimApplications();</span><br><span class="line">    <span class="comment">//dump();</span></span><br><span class="line">    <span class="comment">//mWindowManager.dump();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activityRemoved) &#123;</span><br><span class="line">        resumeFocusedStackTopActivityLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有点长，其实我们只要关注以下这段代码就好了</p>
<pre><code>// Stop any activities that are scheduled to do so but have been
// waiting for the next one to start.
for (int i = 0; i &lt; NS; i++) {
   r = stops.get(i);
   final ActivityStack stack = r.getStack();
   if (stack != null) {
       if (r.finishing) {
           stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,
                   &quot;activityIdleInternalLocked&quot;);
       } else {
           stack.stopActivityLocked(r);
       }
   }
}
</code></pre><p>发现如果 ActivityRecord 没有 finish 的话，就会调用 <code>stack.stopActivityLocked(r);</code></p>
<p>那我们去 ActivityStack 中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SWITCH) Slog.d(TAG_SWITCH, <span class="string">"Stopping: "</span> + r);</span><br><span class="line">    <span class="keyword">if</span> ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">            || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"no-history finish of "</span> + r);</span><br><span class="line">                <span class="keyword">if</span> (requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="string">"stop-no-history"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If &#123;@link requestFinishActivityLocked&#125; returns &#123;@code true&#125;,</span></span><br><span class="line">                    <span class="comment">// &#123;@link adjustFocusedActivityStack&#125; would have been already called.</span></span><br><span class="line">                    r.resumeKeyDispatchingLocked();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"Not finishing noHistory "</span> + r</span><br><span class="line">                        + <span class="string">" on stop because we're just sleeping"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adjustFocusedActivityStack(r, <span class="string">"stopActivity"</span>);</span><br><span class="line">        r.resumeKeyDispatchingLocked();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                    <span class="string">"Moving to STOPPING: "</span> + r + <span class="string">" (stop requested)"</span>);</span><br><span class="line">            r.setState(STOPPING, <span class="string">"stopActivityLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,</span><br><span class="line">                    <span class="string">"Stopping visible="</span> + r.visible + <span class="string">" for "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (!r.visible) &#123;</span><br><span class="line">                r.setVisible(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            EventLogTags.writeAmStopActivity(</span><br><span class="line">                    r.userId, System.identityHashCode(r), r.shortComponentName);</span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class="line">                    StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class="line">            <span class="keyword">if</span> (shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                r.setSleeping(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);</span><br><span class="line">            mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Maybe just ignore exceptions here...  if the process</span></span><br><span class="line">            <span class="comment">// has crashed, our death notification will clean things</span></span><br><span class="line">            <span class="comment">// up.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</span><br><span class="line">            <span class="comment">// Just in case, assume it to be stopped.</span></span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Stop failed; moving to STOPPED: "</span> + r);</span><br><span class="line">            r.setState(STOPPED, <span class="string">"stopActivityLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (r.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                destroyActivityLocked(r, <span class="keyword">true</span>, <span class="string">"stop-except"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一眼就看到了 onStop 调用的入口啦：</p>
<pre><code>mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,
    StopActivityItem.obtain(r.visible, r.configChangeFlags));
</code></pre><p>经过上面这么多的分析，相信已经不用说这句代码意味着什么了吧！</p>
<p>我们直接看 StopActivityItem 的 execute 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStop"</span>);</span><br><span class="line">    client.handleStopActivity(token, mShowWindow, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, <span class="string">"STOP_ACTIVITY_ITEM"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和其他的一样，也是调用了 ActivityThread 的 handleStopActivity 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges,</span><br><span class="line">        PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">    performStopActivityInner(r, stopInfo, show, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">            reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Finishing stop of "</span> + r + <span class="string">": show="</span> + show</span><br><span class="line">        + <span class="string">" win="</span> + r.window);</span><br><span class="line"></span><br><span class="line">    updateVisibility(r, show);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopInfo.setActivity(r);</span><br><span class="line">    stopInfo.setState(r.state);</span><br><span class="line">    stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">    pendingActions.setStopInfo(stopInfo);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 performStopActivityInner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r, StopInfo info, <span class="keyword">boolean</span> keepShown,</span><br><span class="line">        <span class="keyword">boolean</span> saveState, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing stop of "</span> + r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">// If we are finishing, we won't call onResume() in certain</span></span><br><span class="line">                <span class="comment">// cases.  So here we likewise don't want to call onStop()</span></span><br><span class="line">                <span class="comment">// if the activity isn't resumed.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!finalStateRequest) &#123;</span><br><span class="line">                <span class="keyword">final</span> RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Performing stop of activity that is already stopped: "</span></span><br><span class="line">                                + r.intent.getComponent().toShortString());</span><br><span class="line">                Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">                Slog.e(TAG, r.getStateString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">        performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// First create a thumbnail for the activity...</span></span><br><span class="line">                <span class="comment">// For now, don't create the thumbnail here; we are</span></span><br><span class="line">                <span class="comment">// doing that by doing a screen snapshot.</span></span><br><span class="line">                info.setDescription(r.activity.onCreateDescription());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to save state of activity "</span></span><br><span class="line">                            + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keepShown) &#123;</span><br><span class="line">            callActivityOnStop(r, saveState, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部会调用 performPauseActivityIfNeeded</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to pause activity "</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，还是利用 mInstrumentation 来调用 onStop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity.performPause</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onPause();</span><br><span class="line">    writeEventLog(LOG_AM_ON_PAUSE_CALLED, <span class="string">"performPause"</span>);</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到这里就把整个 Activity 启动的生命周期回调流程都走了一遍，回去好好理解下吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：源码分析基于 Android SDK API 28 </p>
<p>在前一篇中，我们分析了 startActivity 的整个流程，并且也讲到了何时调用了 onCreate() 。</p>
<p>那么就会有一个疑问，其他的生命周期方法是在哪里被调用的呢？今天就来揭开这个]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[startActivity启动流程]]></title>
    <link href="http://yuqirong.github.io/2019/04/03/startActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.github.io/2019/04/03/startActivity启动流程/</id>
    <published>2019-04-03T13:56:50.000Z</published>
    <updated>2019-04-02T16:24:26.425Z</updated>
    <content type="html"><![CDATA[<p>注：源码分析基于 Android SDK API 28</p>
<p>对于 Activity 大家都已经很熟悉很亲切了吧，在这就不过多介绍了。</p>
<p>直接进入正题，走起！</p>
<p>一般我们启动 Activity 的入口都是 startActivity ，所以这也成为了我们分析整个流程的切入口。</p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="startActivity_28Intent_intent_29"><a href="#startActivity_28Intent_intent_29" class="headerlink" title="startActivity(Intent intent)"></a>startActivity(Intent intent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">        <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    startActivityForResult(intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最后都是调用 startActivityForResult 这个方法。</p>
<h2 id="startActivityForResult_28@RequiresPermission_Intent_intent_2C_int_requestCode_2C_@Nullable_Bundle_options_29"><a href="#startActivityForResult_28@RequiresPermission_Intent_intent_2C_int_requestCode_2C_@Nullable_Bundle_options_29" class="headerlink" title="startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)"></a>startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span><br><span class="line">        @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">            <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">            <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">            <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">            <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">            <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">            <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">        <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">            <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 mParent 为空的情况下，直接调用 mInstrumentation.execStartActivity 来启动 Activity 。 </p>
<p>这里的 mParent 其实是指 ActivityGroup ，用来嵌套多个 Activity ，是早已废弃的 API 了。</p>
<p>所以一般情况下，mParent 都是为空的。那我们跟进到 Instrumentation 中的 execStartActivity 方法去看。</p>
<h1 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><h2 id="execStartActivity"><a href="#execStartActivity" class="headerlink" title="execStartActivity"></a>execStartActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                    result = am.onStartActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">// 调用 ActivityManagerService 启动 Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options); </span><br><span class="line">        <span class="comment">// 在 checkStartActivityResult 中会检查 Activity 启动的结果</span></span><br><span class="line">        <span class="comment">// 比如没有在 AndroidManifest.xml 中注册的异常就是在这里抛出来的</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                    <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to start activity "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                    <span class="string">"FORWARD_RESULT_FLAG used while also requesting a result"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"PendingIntent is not an activity"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Starting under voice control not allowed for: "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startVoiceActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start voice activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startAssistantActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start assistant activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Activity could not be started for "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Unknown error code "</span></span><br><span class="line">                    + res + <span class="string">" when starting "</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，调用了 ActivityManager.getService() 。其实实质上就是获取了 ActivityManagerService 。之后就会在 AMS 中去执行 Activity 的启动流程。</p>
<p>另外，返回的结果 result 会在 checkStartActivityResult 中去检查。比如 Activity 没有在 AndroidManifest.xml 中注册，就会抛出异常。</p>
<p>那我们来看看 AMS 中的实现。</p>
<h1 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h1><h2 id="getService_28_29"><a href="#getService_28_29" class="headerlink" title="getService()"></a>getService()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到 ActivityManager.getService() 获取的就是 AMS 对象。那么接着来看 AMS 的 startActivity 方法。</p>
<h1 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h1><h2 id="startActivity_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_29"><a href="#startActivity_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_29" class="headerlink" title="startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions)"></a>startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用的是 startActivityAsUser 方法。</p>
<h2 id="startActivityAsUser_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_2C_int_userId_2C_boolean_validateIncomingUser_29"><a href="#startActivityAsUser_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_2C_int_userId_2C_boolean_validateIncomingUser_29" class="headerlink" title="startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser)"></a>startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span><br><span class="line">        <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mActivityStartController.obtainStarter 就是创建了一个 ActivityStarter 对象。</p>
<p>ActivityStarter 是什么东西呢？</p>
<pre><code>This class collects all the logic for determining how an intent and flags should be turned into an activity and associated task and stack.
</code></pre><p>官方的解释是把 activity 启动过程中处理 intent 和 flags 的逻辑以及任务栈等操作都被封装在 ActivityStarter 中了。</p>
<p>而 startActivityAsUser 干的事就是把参数传进去，用 builder 模式构造出一个 ActivityStarter 对象。然后调用他的 execute 方法去执行。</p>
<p>所以我们直接来看 execute 方法。</p>
<h1 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h1><h2 id="execute_28_29"><a href="#execute_28_29" class="headerlink" title="execute()"></a>execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">        <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一步构造 ActivityStarter 的过程中，有一句 setMayWait(userId) 代码。这句代码内部会将 mayWait 设置为 true 。所以我们要深入到 startActivityMayWait 方法中去。</p>
<h2 id="startActivityMayWait_28IApplicationThread_caller_2C_int_callingUid_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_WaitResult_outResult_2C_Configuration_globalConfig_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_int_userId_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivityMayWait_28IApplicationThread_caller_2C_int_callingUid_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_WaitResult_outResult_2C_Configuration_globalConfig_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_int_userId_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">        Configuration globalConfig, SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity,</span><br><span class="line">        <span class="keyword">int</span> userId, TaskRecord inTask, String reason,</span><br><span class="line">        <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.getActivityMetricsLogger().notifyActivityLaunching();</span><br><span class="line">    <span class="keyword">boolean</span> componentSpecified = intent.getComponent() != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">if</span> (callingUid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        callingPid = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callingPid = realCallingPid;</span><br><span class="line">        callingUid = realCallingUid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callingPid = callingUid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save a copy in case ephemeral needs it</span></span><br><span class="line">    <span class="keyword">final</span> Intent ephemeralIntent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="comment">// Don't modify the client's object!</span></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="keyword">if</span> (componentSpecified</span><br><span class="line">            &amp;&amp; !(Intent.ACTION_VIEW.equals(intent.getAction()) &amp;&amp; intent.getData() == <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; !Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">            &amp;&amp; !Intent.ACTION_RESOLVE_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">            &amp;&amp; mService.getPackageManagerInternalLocked()</span><br><span class="line">                    .isInstantAppInstallerComponent(intent.getComponent())) &#123;</span><br><span class="line">        <span class="comment">// intercept intents targeted directly to the ephemeral installer the</span></span><br><span class="line">        <span class="comment">// ephemeral installer should never be started with a raw Intent; instead</span></span><br><span class="line">        <span class="comment">// adjust the intent so it looks like a "normal" instant app launch</span></span><br><span class="line">        intent.setComponent(<span class="keyword">null</span> <span class="comment">/*component*/</span>);</span><br><span class="line">        componentSpecified = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* matchFlags */</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">    <span class="keyword">if</span> (rInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        UserInfo userInfo = mSupervisor.getUserInfo(userId);</span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span> &amp;&amp; userInfo.isManagedProfile()) &#123;</span><br><span class="line">            <span class="comment">// Special case for managed profiles, if attempting to launch non-cryto aware</span></span><br><span class="line">            <span class="comment">// app in a locked managed profile from an unlocked parent allow it to resolve</span></span><br><span class="line">            <span class="comment">// as user will be sent via confirm credentials to unlock the profile.</span></span><br><span class="line">            UserManager userManager = UserManager.get(mService.mContext);</span><br><span class="line">            <span class="keyword">boolean</span> profileLockedAndParentUnlockingOrUnlocked = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UserInfo parent = userManager.getProfileParent(userId);</span><br><span class="line">                profileLockedAndParentUnlockingOrUnlocked = (parent != <span class="keyword">null</span>)</span><br><span class="line">                        &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id)</span><br><span class="line">                        &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (profileLockedAndParentUnlockingOrUnlocked) &#123;</span><br><span class="line">                rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">                        PackageManager.MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,</span><br><span class="line">                        computeResolveFilterUid(</span><br><span class="line">                                callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line">        stack.mConfigWillChange = globalConfig != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mService.getGlobalConfiguration().diff(globalConfig) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                <span class="string">"Starting activity when config will change = "</span> + stack.mConfigWillChange);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aInfo != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (aInfo.applicationInfo.privateFlags</span><br><span class="line">                        &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">            <span class="comment">// This may be a heavy-weight process!  Check to see if we already</span></span><br><span class="line">            <span class="comment">// have another, different heavy-weight process running.</span></span><br><span class="line">            <span class="keyword">if</span> (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> ProcessRecord heavy = mService.mHeavyWeightProcess;</span><br><span class="line">                <span class="keyword">if</span> (heavy != <span class="keyword">null</span> &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid</span><br><span class="line">                        || !heavy.processName.equals(aInfo.processName))) &#123;</span><br><span class="line">                    <span class="keyword">int</span> appCallingUid = callingUid;</span><br><span class="line">                    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ProcessRecord callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">                        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appCallingUid = callerApp.info.uid;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                                    + <span class="string">" (pid="</span> + callingPid + <span class="string">") when starting: "</span></span><br><span class="line">                                    + intent.toString());</span><br><span class="line">                            SafeActivityOptions.abort(options);</span><br><span class="line">                            <span class="keyword">return</span> ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                            ActivityManager.INTENT_SENDER_ACTIVITY, <span class="string">"android"</span>,</span><br><span class="line">                            appCallingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[] &#123; intent &#125;,</span><br><span class="line">                            <span class="keyword">new</span> String[] &#123; resolvedType &#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                                    | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">                    <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// Caller is requesting a result.</span></span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,</span><br><span class="line">                            <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">                    <span class="keyword">if</span> (heavy.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ActivityRecord hist = heavy.activities.get(<span class="number">0</span>);</span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,</span><br><span class="line">                                hist.packageName);</span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,</span><br><span class="line">                                hist.getTask().taskId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,</span><br><span class="line">                            aInfo.packageName);</span><br><span class="line">                    newIntent.setFlags(intent.getFlags());</span><br><span class="line">                    newIntent.setClassName(<span class="string">"android"</span>,</span><br><span class="line">                            HeavyWeightSwitcherActivity.class.getName());</span><br><span class="line">                    intent = newIntent;</span><br><span class="line">                    resolvedType = <span class="keyword">null</span>;</span><br><span class="line">                    caller = <span class="keyword">null</span>;</span><br><span class="line">                    callingUid = Binder.getCallingUid();</span><br><span class="line">                    callingPid = Binder.getCallingPid();</span><br><span class="line">                    componentSpecified = <span class="keyword">true</span>;</span><br><span class="line">                    rInfo = mSupervisor.resolveIntent(intent, <span class="keyword">null</span> <span class="comment">/*resolvedType*/</span>, userId,</span><br><span class="line">                            <span class="number">0</span> <span class="comment">/* matchFlags */</span>, computeResolveFilterUid(</span><br><span class="line">                                    callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">                    aInfo = rInfo != <span class="keyword">null</span> ? rInfo.activityInfo : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        aInfo = mService.getActivityInfoForUser(aInfo, userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.mConfigWillChange) &#123;</span><br><span class="line">            <span class="comment">// If the caller also wants to switch to a new configuration,</span></span><br><span class="line">            <span class="comment">// do so now.  This allows a clean switch, as we are waiting</span></span><br><span class="line">            <span class="comment">// for the current activity to pause (so we will not destroy</span></span><br><span class="line">            <span class="comment">// it), and have not yet started the next activity.</span></span><br><span class="line">            mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,</span><br><span class="line">                    <span class="string">"updateConfiguration()"</span>);</span><br><span class="line">            stack.mConfigWillChange = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                    <span class="string">"Updating to new configuration after starting activity."</span>);</span><br><span class="line">            mService.updateConfigurationLocked(globalConfig, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outResult.result = res;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = outRecord[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(res) &#123;</span><br><span class="line">                <span class="keyword">case</span> START_SUCCESS: &#123;</span><br><span class="line">                    mSupervisor.mWaitingActivityLaunched.add(outResult);</span><br><span class="line">                    do &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mService.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (outResult.result != START_TASK_TO_FRONT</span><br><span class="line">                            &amp;&amp; !outResult.timeout &amp;&amp; outResult.who == <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (outResult.result == START_TASK_TO_FRONT) &#123;</span><br><span class="line">                        res = START_TASK_TO_FRONT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> START_DELIVERED_TO_TOP: &#123;</span><br><span class="line">                    outResult.timeout = <span class="keyword">false</span>;</span><br><span class="line">                    outResult.who = r.realActivity;</span><br><span class="line">                    outResult.totalTime = <span class="number">0</span>;</span><br><span class="line">                    outResult.thisTime = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> START_TASK_TO_FRONT: &#123;</span><br><span class="line">                    <span class="comment">// ActivityRecord may represent a different activity, but it should not be</span></span><br><span class="line">                    <span class="comment">// in the resumed state.</span></span><br><span class="line">                    <span class="keyword">if</span> (r.nowVisible &amp;&amp; r.isState(RESUMED)) &#123;</span><br><span class="line">                        outResult.timeout = <span class="keyword">false</span>;</span><br><span class="line">                        outResult.who = r.realActivity;</span><br><span class="line">                        outResult.totalTime = <span class="number">0</span>;</span><br><span class="line">                        outResult.thisTime = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        outResult.thisTime = SystemClock.uptimeMillis();</span><br><span class="line">                        mSupervisor.waitActivityVisible(r.realActivity, outResult);</span><br><span class="line">                        <span class="comment">// Note: the timeout variable is not currently not ever set.</span></span><br><span class="line">                        do &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mService.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (!outResult.timeout &amp;&amp; outResult.who == <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，获取 Activity 的 intent 信息，解析得到 ResolveInfo 和 ActivityInfo ，另外获取 callingPid 和 callingUid 。</p>
<p>这个方法的代码很多，看得头疼。但是我们就关心其中的关键代码：</p>
<pre><code>final ActivityRecord[] outRecord = new ActivityRecord[1];
int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,
            voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,
            callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,
            ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,
            allowPendingRemoteAnimationRegistryLookup);
</code></pre><p>startActivityMayWait 内部调用 startActivity 来启动 Activity 。所以我们还是要追踪到 startActivity 方法中。</p>
<h2 id="startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags,  SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags,  SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span><br><span class="line">        SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">        <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span></span><br><span class="line">        outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getExternalResult(mLastStartActivityResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部又调用了另一个 startActivity 的重载方法。</p>
<h2 id="startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span><br><span class="line">        SafeActivityOptions options,</span><br><span class="line">        <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">        TaskRecord inTask, <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle</span><br><span class="line">            = options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + callingPid + <span class="string">") when starting: "</span></span><br><span class="line">                    + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = aInfo != <span class="keyword">null</span> &amp;&amp; aInfo.applicationInfo != <span class="keyword">null</span></span><br><span class="line">            ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</span><br><span class="line">                + <span class="string">"&#125; from uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Transfer the result target from the source activity to the new</span></span><br><span class="line">        <span class="comment">// one being started, including any failures.</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            SafeActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">        &#125;</span><br><span class="line">        resultRecord = sourceRecord.resultTo;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">            resultRecord = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resultWho = sourceRecord.resultWho;</span><br><span class="line">        requestCode = sourceRecord.requestCode;</span><br><span class="line">        sourceRecord.resultTo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">            <span class="comment">// The new activity is being launched from the same uid as the previous</span></span><br><span class="line">            <span class="comment">// activity in the flow, and asking to forward its result back to the</span></span><br><span class="line">            <span class="comment">// previous.  In this case the activity is serving as a trampoline between</span></span><br><span class="line">            <span class="comment">// the two, so we also want to update its launchedFromPackage to be the</span></span><br><span class="line">            <span class="comment">// same as the previous activity.  Note that this is safe, since we know</span></span><br><span class="line">            <span class="comment">// these two packages come from the same uid; the caller could just as</span></span><br><span class="line">            <span class="comment">// well have supplied that same package name itself.  This specifially</span></span><br><span class="line">            <span class="comment">// deals with the case of an intent picker/chooser being launched in the app</span></span><br><span class="line">            <span class="comment">// flow to redirect to an activity picked by the user, where we want the final</span></span><br><span class="line">            <span class="comment">// activity to consider it to have been launched by the previous app activity.</span></span><br><span class="line">            callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find a class that can handle the given Intent.</span></span><br><span class="line">        <span class="comment">// That's the end of that!</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If this activity is being launched as part of a voice session, we need</span></span><br><span class="line">        <span class="comment">// to ensure that it is safe to do so.  If the upcoming activity will also</span></span><br><span class="line">        <span class="comment">// be part of the voice session, we can only launch it if it has explicitly</span></span><br><span class="line">        <span class="comment">// said it supports the VOICE category, or it is a part of the calling app.</span></span><br><span class="line">        <span class="keyword">if</span> ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                intent.addCategory(Intent.CATEGORY_VOICE);</span><br><span class="line">                <span class="keyword">if</span> (!mService.getPackageManager().activitySupportsIntent(</span><br><span class="line">                        intent.getComponent(), intent, resolvedType)) &#123;</span><br><span class="line">                    Slog.w(TAG,</span><br><span class="line">                            <span class="string">"Activity being started in current voice task does not support voice: "</span></span><br><span class="line">                                    + intent);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failure checking voice capabilities"</span>, e);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller is starting a new voice session, just make sure the target</span></span><br><span class="line">        <span class="comment">// is actually allowing it to run this way.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mService.getPackageManager().activitySupportsIntent(intent.getComponent(),</span><br><span class="line">                    intent, resolvedType)) &#123;</span><br><span class="line">                Slog.w(TAG,</span><br><span class="line">                        <span class="string">"Activity being started in new voice task does not support: "</span></span><br><span class="line">                                + intent);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failure checking voice capabilities"</span>, e);</span><br><span class="line">            err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span> ? <span class="keyword">null</span> : resultRecord.getStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultStack.sendActivityResultLocked(</span><br><span class="line">                    -<span class="number">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">            inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two options bundles, while realCallerOptions takes precedence.</span></span><br><span class="line">    ActivityOptions checkedOptions = options != <span class="keyword">null</span></span><br><span class="line">            ? options.getOptions(intent, aInfo, callerApp, mSupervisor)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        checkedOptions = mService.getActivityStartController()</span><br><span class="line">                .getPendingRemoteAnimationRegistry()</span><br><span class="line">                .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// The Intent we give to the watcher has the extra data</span></span><br><span class="line">            <span class="comment">// stripped off, since it can contain private information.</span></span><br><span class="line">            Intent watchIntent = intent.cloneFilter();</span><br><span class="line">            abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                    aInfo.applicationInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            mService.mController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity start was intercepted, e.g. because the target user is currently in quiet</span></span><br><span class="line">        <span class="comment">// mode (turn off work) or the target application is suspended</span></span><br><span class="line">        intent = mInterceptor.mIntent;</span><br><span class="line">        rInfo = mInterceptor.mRInfo;</span><br><span class="line">        aInfo = mInterceptor.mAInfo;</span><br><span class="line">        resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">        inTask = mInterceptor.mInTask;</span><br><span class="line">        callingPid = mInterceptor.mCallingPid;</span><br><span class="line">        callingUid = mInterceptor.mCallingUid;</span><br><span class="line">        checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultStack.sendActivityResultLocked(-<span class="number">1</span>, resultRecord, resultWho, requestCode,</span><br><span class="line">                    RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We pretend to the caller that it was really started, but</span></span><br><span class="line">        <span class="comment">// they will just get a cancel result.</span></span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run, we</span></span><br><span class="line">    <span class="comment">// launch the review activity and pass a pending intent to start the activity</span></span><br><span class="line">    <span class="comment">// we are to launching now after the review is completed.</span></span><br><span class="line">    <span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,</span><br><span class="line">                    callingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> flags = intent.getFlags();</span><br><span class="line">            Intent newIntent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">            newIntent.setFlags(flags</span><br><span class="line">                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>,</span><br><span class="line">                        <span class="keyword">true</span>, <span class="keyword">false</span>) + <span class="string">"&#125; from uid "</span> + callingUid + <span class="string">" on display "</span></span><br><span class="line">                        + (mSupervisor.mFocusedStack == <span class="keyword">null</span></span><br><span class="line">                        ? DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have an ephemeral app, abort the process of launching the resolved intent.</span></span><br><span class="line">    <span class="comment">// Instead, launch the ephemeral installer. Once the installer is finished, it</span></span><br><span class="line">    <span class="comment">// starts either the intent we resolved here [on install error] or the ephemeral</span></span><br><span class="line">    <span class="comment">// app [on install success].</span></span><br><span class="line">    <span class="keyword">if</span> (rInfo != <span class="keyword">null</span> &amp;&amp; rInfo.auxiliaryInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent = createLaunchIntent(rInfo.auxiliaryInfo, ephemeralIntent,</span><br><span class="line">                callingPackage, verificationBundle, resolvedType, userId);</span><br><span class="line">        resolvedType = <span class="keyword">null</span>;</span><br><span class="line">        callingUid = realCallingUid;</span><br><span class="line">        callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">        aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>,</span><br><span class="line">            mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.appTimeTracker == <span class="keyword">null</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller didn't specify an explicit time tracker, we want to continue</span></span><br><span class="line">        <span class="comment">// tracking under any it has.</span></span><br><span class="line">        r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are starting an activity that is not from the same uid as the currently resumed</span></span><br><span class="line">    <span class="comment">// one, check whether app switches are allowed.</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">            mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                    sourceRecord, startFlags, stack, callerApp));</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mDidAppSwitch) &#123;</span><br><span class="line">        <span class="comment">// This is the second allowed switch since we stopped switches,</span></span><br><span class="line">        <span class="comment">// so now just generally allow switches.  Use case: user presses</span></span><br><span class="line">        <span class="comment">// home (switches disabled, switch to home, mDidAppSwitch now true);</span></span><br><span class="line">        <span class="comment">// user taps a home icon (coming from home so allowed, we hit here</span></span><br><span class="line">        <span class="comment">// and now allow anyone to switch again).</span></span><br><span class="line">        mService.mAppSwitchesAllowedTime = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mService.mDidAppSwitch = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，主要创建一个 ActivityRecord 。重点关注最后一句代码：</p>
<pre><code>return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity);
</code></pre><p>所以又又又跳转到另外一个 startActivity 的重载方法中了。。</p>
<h2 id="startActivity_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29"><a href="#startActivity_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29" class="headerlink" title="startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)"></a>startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        <span class="comment">// 重点看这里</span></span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we are not able to proceed, disassociate the activity from the task. Leaving an</span></span><br><span class="line">        <span class="comment">// activity in an incomplete state can lead to issues, such as performing operations</span></span><br><span class="line">        <span class="comment">// without a window container.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* intentResultData */</span>, <span class="string">"startActivity"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法内部，把操作交给了 startActivityUnchecked 方法。</p>
<h2 id="startActivityUnchecked_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29"><a href="#startActivityUnchecked_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29" class="headerlink" title="startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)"></a>startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line"></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line"></span><br><span class="line">    computeSourceStack();</span><br><span class="line"></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preferredWindowingMode = WINDOWING_MODE_UNDEFINED;</span><br><span class="line">    <span class="keyword">int</span> preferredLaunchDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preferredWindowingMode = mOptions.getLaunchWindowingMode();</span><br><span class="line">        preferredLaunchDisplayId = mOptions.getLaunchDisplayId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windowing mode and preferred launch display values from &#123;@link LaunchParams&#125; take</span></span><br><span class="line">    <span class="comment">// priority over those specified in &#123;@link ActivityOptions&#125;.</span></span><br><span class="line">    <span class="keyword">if</span> (!mLaunchParams.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLaunchParams.hasPreferredDisplay()) &#123;</span><br><span class="line">            preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLaunchParams.hasWindowingMode()) &#123;</span><br><span class="line">            preferredWindowingMode = mLaunchParams.mWindowingMode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but</span></span><br><span class="line">        <span class="comment">// still needs to be a lock task mode violation since the task gets cleared out and</span></span><br><span class="line">        <span class="comment">// the device would otherwise leave the locked task.</span></span><br><span class="line">        <span class="keyword">if</span> (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(),</span><br><span class="line">                (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                        == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"startActivityUnchecked: Attempt to violate Lock Task Mode"</span>);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// True if we are clearing top and resetting of a standard (default) launch mode</span></span><br><span class="line">        <span class="comment">// (&#123;@code LAUNCH_MULTIPLE&#125;) activity. The existing activity will be finished.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> clearTopAndResetStandardLaunchMode =</span><br><span class="line">                (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED))</span><br><span class="line">                        == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)</span><br><span class="line">                &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If mStartActivity does not have a task associated with it, associate it with the</span></span><br><span class="line">        <span class="comment">// reused activity's task. Do not do so if we're clearing top and resetting for a</span></span><br><span class="line">        <span class="comment">// standard launchMode activity.</span></span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.getTask() == <span class="keyword">null</span> &amp;&amp; !clearTopAndResetStandardLaunchMode) &#123;</span><br><span class="line">            mStartActivity.setTask(reusedActivity.getTask());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reusedActivity.getTask().intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This task was started because of movement of the activity based on affinity...</span></span><br><span class="line">            <span class="comment">// Now that we are actually launching it, we can assign the base intent.</span></span><br><span class="line">            reusedActivity.getTask().setIntent(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This code path leads to delivering a new intent, we want to make sure we schedule it</span></span><br><span class="line">        <span class="comment">// as the first operation, in case the activity will be resumed as a result of later</span></span><br><span class="line">        <span class="comment">// operations.</span></span><br><span class="line">        <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">                || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">                || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = reusedActivity.getTask();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In this situation we want to remove all activities from the task up to the one</span></span><br><span class="line">            <span class="comment">// being started. In most cases this means we are resetting the task to its initial</span></span><br><span class="line">            <span class="comment">// state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">                    mLaunchFlags);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the</span></span><br><span class="line">            <span class="comment">// the &#123;@code ActivityRecord&#125; removing its reference to the &#123;@code TaskRecord&#125;. The</span></span><br><span class="line">            <span class="comment">// task reference is needed in the call below to</span></span><br><span class="line">            <span class="comment">// &#123;@link setTargetStackAndMoveToFrontIfNeeded&#125;.</span></span><br><span class="line">            <span class="keyword">if</span> (reusedActivity.getTask() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                reusedActivity.setTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (top.frontOfTask) &#123;</span><br><span class="line">                    <span class="comment">// Activity aliases may mean we use different intents for the top activity,</span></span><br><span class="line">                    <span class="comment">// so make sure the task now has the identity of the new intent.</span></span><br><span class="line">                    top.getTask().setIntent(mStartActivity);</span><br><span class="line">                &#125;</span><br><span class="line">                deliverNewIntent(top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSupervisor.sendPowerHintForLaunchStartIfNeeded(<span class="keyword">false</span> <span class="comment">/* forceSend */</span>, reusedActivity);</span><br><span class="line"></span><br><span class="line">        reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord outResult =</span><br><span class="line">                outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span> ? outActivity[<span class="number">0</span>] : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When there is a reused activity and the current result is a trampoline activity,</span></span><br><span class="line">        <span class="comment">// set the reused activity as the result.</span></span><br><span class="line">        <span class="keyword">if</span> (outResult != <span class="keyword">null</span> &amp;&amp; (outResult.finishing || outResult.noDisplay)) &#123;</span><br><span class="line">            outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do anything</span></span><br><span class="line">            <span class="comment">// if that is the case, so this is it!  And for paranoia, make sure we have</span></span><br><span class="line">            <span class="comment">// correctly resumed the top activity.</span></span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setTaskFromIntentActivity(reusedActivity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client don't use that</span></span><br><span class="line">                <span class="comment">// intent!)  And for paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line"></span><br><span class="line">                resumeTargetStackIfNeeded();</span><br><span class="line">                <span class="keyword">if</span> (outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack sourceStack = mStartActivity.resultTo != <span class="keyword">null</span></span><br><span class="line">                ? mStartActivity.resultTo.getStack() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (sourceStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sourceStack.sendActivityResultLocked(-<span class="number">1</span> <span class="comment">/* callingUid */</span>, mStartActivity.resultTo,</span><br><span class="line">                    mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">return</span> START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mSupervisor.mFocusedStack;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord topFocused = topStack.getTopActivity();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dontStart = top != <span class="keyword">null</span> &amp;&amp; mStartActivity.resultTo == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">            &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">            &amp;&amp; top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">            || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK));</span><br><span class="line">    <span class="keyword">if</span> (dontStart) &#123;</span><br><span class="line">        <span class="comment">// For paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">        topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do</span></span><br><span class="line">            <span class="comment">// anything if that is the case, so this is it!</span></span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't use mStartActivity.task to show the toast. We're not starting a new activity</span></span><br><span class="line">        <span class="comment">// but reusing 'top'. Fields in mStartActivity may not be fully initialized.</span></span><br><span class="line">        mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode,</span><br><span class="line">                preferredLaunchDisplayId, topStack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">            ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">int</span> result = START_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part of a new task...</span></span><br><span class="line">        <span class="comment">// just put it in the top task, though these days this case should never happen.</span></span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName,</span><br><span class="line">            mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);</span><br><span class="line">    mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent,</span><br><span class="line">            mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));</span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId,</span><br><span class="line">                mStartActivity.getTask().taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityStack.logStartActivity(</span><br><span class="line">            EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask());</span><br><span class="line">    mTargetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mSupervisor.sendPowerHintForLaunchStartIfNeeded(<span class="keyword">false</span> <span class="comment">/* forceSend */</span>, mStartActivity);</span><br><span class="line"></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,</span><br><span class="line">            mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// If the activity is not focusable, we can't resume it, but still would like to</span></span><br><span class="line">            <span class="comment">// make sure it becomes visible as it starts (this will also trigger entry</span></span><br><span class="line">            <span class="comment">// animation). An example of this are PIP activities.</span></span><br><span class="line">            <span class="comment">// Also, we don't want to resume activities in a task that currently has an overlay</span></span><br><span class="line">            <span class="comment">// as the starting activity just needs to be in the visible paused state until the</span></span><br><span class="line">            <span class="comment">// over is removed.</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// Go ahead and tell window manager to execute app transition for this activity</span></span><br><span class="line">            <span class="comment">// since the app transition will not be triggered through the resume channel.</span></span><br><span class="line">            mService.mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">            <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">            <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">            <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">            <span class="comment">// accordingly.</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityUnchecked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mStartActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode,</span><br><span class="line">            preferredLaunchDisplayId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 startActivityUnchecked 中，给 Activity 设置了 TaskRecord , 完成后执行ActivityStackSupervisor.resumeFocusedStackTopActivityLocked 方法。</p>
<h1 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h1><h2 id="resumeFocusedStackTopActivityLocked_28ActivityStack_targetStack_2C_ActivityRecord_target_2C_ActivityOptions_targetOptions_29"><a href="#resumeFocusedStackTopActivityLocked_28ActivityStack_targetStack_2C_ActivityRecord_target_2C_ActivityOptions_targetOptions_29" class="headerlink" title="resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)"></a>resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || !r.isState(RESUMED)) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.isState(RESUMED)) &#123;</span><br><span class="line">        <span class="comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span></span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 resumeFocusedStackTopActivityLocked 中，跳转到 ActivityStack 的 resumeTopActivityUncheckedLocked 方法中去执行了。</p>
<h1 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h1><h2 id="resumeTopActivityUncheckedLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29"><a href="#resumeTopActivityUncheckedLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29" class="headerlink" title="resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options)"></a>resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">        <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">        <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">        <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">        <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">        <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">        <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码中的 result 是 resumeTopActivityInnerLocked 方法的返回值。所以还要跳到 resumeTopActivityInnerLocked 方法中去看。</p>
<h2 id="resumeTopActivityInnerLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29"><a href="#resumeTopActivityInnerLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29" class="headerlink" title="resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)"></a>resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Maybe this entire condition can get removed?</span></span><br><span class="line">    <span class="keyword">if</span> (hasRunningActivity &amp;&amp; !isAttached()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.cancelInitializingActivities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember how we'll process this pause/resume situation, and ensure</span></span><br><span class="line">    <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">    <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">    mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let's look somewhere else.</span></span><br><span class="line">        <span class="keyword">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class="string">"noMoreActivities"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Top activity resumed "</span> + next);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are sleeping, and there is no resumed activity, and the top</span></span><br><span class="line">    <span class="comment">// activity is paused, well that is the state we want.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSleepOrShutDownActivities()</span><br><span class="line">            &amp;&amp; mLastPausedActivity == next</span><br><span class="line">            &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Going to sleep and all paused"</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line">    <span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line">    <span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Skipping resume of top activity "</span> + next</span><br><span class="line">                + <span class="string">": user "</span> + next.userId + <span class="string">" is stopped"</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">    <span class="comment">// appropriate for it.</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">    mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">    next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">    mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resuming "</span> + next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Skip resume: some activity pausing."</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> lastResumedCanPip = <span class="keyword">false</span>;</span><br><span class="line">    ActivityRecord lastResumed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class="line">    <span class="keyword">if</span> (lastFocusedStack != <span class="keyword">null</span> &amp;&amp; lastFocusedStack != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// So, why aren't we using prev here??? See the param comment on the method. prev doesn't</span></span><br><span class="line">        <span class="comment">// represent the last resumed activity. However, the last focus stack does if it isn't null.</span></span><br><span class="line">        lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">        <span class="keyword">if</span> (userLeaving &amp;&amp; inMultiWindowMode() &amp;&amp; lastFocusedStack.shouldBeVisible(next)) &#123;</span><br><span class="line">            <span class="comment">// The user isn't leaving if this stack is the multi-window mode and the last</span></span><br><span class="line">            <span class="comment">// focused stack should still be visible.</span></span><br><span class="line">            <span class="keyword">if</span>(DEBUG_USER_LEAVING) Slog.i(TAG_USER_LEAVING, <span class="string">"Overriding userLeaving to false"</span></span><br><span class="line">                    + <span class="string">" next="</span> + next + <span class="string">" lastResumed="</span> + lastResumed);</span><br><span class="line">            userLeaving = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastResumedCanPip = lastResumed != <span class="keyword">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class="line">                <span class="string">"resumeTopActivity"</span>, userLeaving <span class="comment">/* beforeStopping */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the flag RESUME_WHILE_PAUSING is set, then continue to schedule the previous activity</span></span><br><span class="line">    <span class="comment">// to be paused, while at the same time resuming the new resume activity only if the</span></span><br><span class="line">    <span class="comment">// previous activity can't go into Pip since we want to give Pip activities a chance to</span></span><br><span class="line">    <span class="comment">// enter Pip before resuming the next activity.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; !lastResumedCanPip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Skip resume: need to start pausing"</span>);</span><br><span class="line">        <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">        <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">        <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">        <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">if</span> (lastResumed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastResumed.setWillCloseOrEnterPip(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">        <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">        <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Top activity resumed (dontWaitForPause) "</span> + next);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the most recent activity was noHistory but was only stopped rather</span></span><br><span class="line">    <span class="comment">// than stopped+finished because the device went to sleep, we need to make</span></span><br><span class="line">    <span class="comment">// sure to finish it as we're making a new activity topmost.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSleepActivities() &amp;&amp; mLastNoHistoryActivity != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !mLastNoHistoryActivity.finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"no-history finish of "</span> + mLastNoHistoryActivity + <span class="string">" on new resume"</span>);</span><br><span class="line">        requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class="line">                <span class="keyword">null</span>, <span class="string">"resume-no-history"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev != next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                &amp;&amp; next != <span class="keyword">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class="line">            mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                    <span class="string">"Resuming top, waiting visible to hide: "</span> + prev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The next activity is already visible, so hide the previous</span></span><br><span class="line">            <span class="comment">// activity's windows right now so we can show the new one ASAP.</span></span><br><span class="line">            <span class="comment">// We only do this if the previous is finishing, which should mean</span></span><br><span class="line">            <span class="comment">// it is on top of the one being resumed so hiding it quickly</span></span><br><span class="line">            <span class="comment">// is good.  Otherwise, we want to do the normal route of allowing</span></span><br><span class="line">            <span class="comment">// the resumed activity to be shown so we can decide if the</span></span><br><span class="line">            <span class="comment">// previous should actually be hidden depending on whether the</span></span><br><span class="line">            <span class="comment">// new one is found to be full-screen or not.</span></span><br><span class="line">            <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">                prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                        <span class="string">"Not waiting for visible to hide: "</span> + prev + <span class="string">", waitingVisible="</span></span><br><span class="line">                        + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                        + <span class="string">", nowVisible="</span> + next.nowVisible);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                        <span class="string">"Previous already visible but still waiting to hide: "</span> + prev</span><br><span class="line">                        + <span class="string">", waitingVisible="</span></span><br><span class="line">                        + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                        + <span class="string">", nowVisible="</span> + next.nowVisible);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launching this app's activity, make sure the app is no longer</span></span><br><span class="line">    <span class="comment">// considered stopped.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                next.packageName, <span class="keyword">false</span>, next.userId); <span class="comment">/* <span class="doctag">TODO:</span> Verify if correct userid */</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + next.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are starting up the next activity, so tell the window manager</span></span><br><span class="line">    <span class="comment">// that the previous one will be hidden soon.  This way it can know</span></span><br><span class="line">    <span class="comment">// to ignore it when computing the desired screen orientation.</span></span><br><span class="line">    <span class="keyword">boolean</span> anim = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                    <span class="string">"Prepare close transition: prev="</span> + prev);</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(prev)) &#123;</span><br><span class="line">                anim = <span class="keyword">false</span>;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                        ? TRANSIT_ACTIVITY_CLOSE</span><br><span class="line">                        : TRANSIT_TASK_CLOSE, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                    <span class="string">"Prepare open transition: prev="</span> + prev);</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">                anim = <span class="keyword">false</span>;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                        ? TRANSIT_ACTIVITY_OPEN</span><br><span class="line">                        : next.mLaunchTaskBehind</span><br><span class="line">                                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                : TRANSIT_TASK_OPEN, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, <span class="string">"Prepare open transition: no previous"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">            anim = <span class="keyword">false</span>;</span><br><span class="line">            mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anim) &#123;</span><br><span class="line">        next.applyOptionsLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.clearOptionsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.mNoAnimActivities.clear();</span><br><span class="line"></span><br><span class="line">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resume running: "</span> + next</span><br><span class="line">                + <span class="string">" stopped="</span> + next.stopped + <span class="string">" visible="</span> + next.visible);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the previous activity is translucent, force a visibility update of</span></span><br><span class="line">        <span class="comment">// the next activity, so that it's added to WM's opening app list, and</span></span><br><span class="line">        <span class="comment">// transition animation can be set up properly.</span></span><br><span class="line">        <span class="comment">// For example, pressing Home button with a translucent activity in focus.</span></span><br><span class="line">        <span class="comment">// Launcher is already visible in this case. If we don't add it to opening</span></span><br><span class="line">        <span class="comment">// apps, maybeUpdateTransitToWallpaper() will fail to identify this as a</span></span><br><span class="line">        <span class="comment">// TRANSIT_WALLPAPER_OPEN animation, and run some funny animation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> lastActivityTranslucent = lastStack != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (lastStack.inMultiWindowMode()</span><br><span class="line">                || (lastStack.mLastPausedActivity != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The contained logic must be synchronized, since we are both changing the visibility</span></span><br><span class="line">        <span class="comment">// and updating the &#123;@link Configuration&#125;. &#123;@link ActivityRecord#setVisibility&#125; will</span></span><br><span class="line">        <span class="comment">// ultimately cause the client code to schedule a layout. Since layouts retrieve the</span></span><br><span class="line">        <span class="comment">// current &#123;@link Configuration&#125;, we must ensure that the below code updates it before</span></span><br><span class="line">        <span class="comment">// the layout can occur.</span></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowManager.getWindowManagerLock()) &#123;</span><br><span class="line">            <span class="comment">// This activity is now becoming visible.</span></span><br><span class="line">            <span class="keyword">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class="line">                next.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">            next.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">            ActivityRecord lastResumedActivity =</span><br><span class="line">                    lastStack == <span class="keyword">null</span> ? <span class="keyword">null</span> :lastStack.mResumedActivity;</span><br><span class="line">            <span class="keyword">final</span> ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">            mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to RESUMED: "</span> + next</span><br><span class="line">                    + <span class="string">" (in existing)"</span>);</span><br><span class="line"></span><br><span class="line">            next.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            updateLRUListLocked(next);</span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Have the window manager re-evaluate the orientation of</span></span><br><span class="line">            <span class="comment">// the screen based on the new activity order.</span></span><br><span class="line">            <span class="keyword">boolean</span> notUpdated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.isFocusedStack(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="comment">// We have special rotation behavior when here is some active activity that</span></span><br><span class="line">                <span class="comment">// requests specific orientation or Keyguard is locked. Make sure all activity</span></span><br><span class="line">                <span class="comment">// visibilities are set correctly as well as the transition is updated if needed</span></span><br><span class="line">                <span class="comment">// to get the correct rotation behavior. Otherwise the following call to update</span></span><br><span class="line">                <span class="comment">// the orientation may cause incorrect configurations delivered to client as a</span></span><br><span class="line">                <span class="comment">// result of invisible window resize.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Remove this once visibilities are set correctly immediately when</span></span><br><span class="line">                <span class="comment">// starting an activity.</span></span><br><span class="line">                notUpdated = !mStackSupervisor.ensureVisibilityAndConfig(next, mDisplayId,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">false</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (notUpdated) &#123;</span><br><span class="line">                <span class="comment">// The configuration update wasn't able to keep the existing</span></span><br><span class="line">                <span class="comment">// instance of the activity, and instead started a new one.</span></span><br><span class="line">                <span class="comment">// We should be all done, but let's just make sure our activity</span></span><br><span class="line">                <span class="comment">// is still at the top and schedule another run if something</span></span><br><span class="line">                <span class="comment">// weird happened.</span></span><br><span class="line">                ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG_STATES,</span><br><span class="line">                        <span class="string">"Activity config changed during resume: "</span> + next</span><br><span class="line">                                + <span class="string">", new next: "</span> + nextNext);</span><br><span class="line">                <span class="keyword">if</span> (nextNext != next) &#123;</span><br><span class="line">                    <span class="comment">// Do over!</span></span><br><span class="line">                    mStackSupervisor.scheduleResumeTopActivities();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!next.visible || next.stopped) &#123;</span><br><span class="line">                    next.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                next.completeResumeLocked();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> ClientTransaction transaction = ClientTransaction.obtain(next.app.thread,</span><br><span class="line">                        next.appToken);</span><br><span class="line">                <span class="comment">// Deliver all pending results.</span></span><br><span class="line">                ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">                <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                    <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                                <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                        transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    transaction.addCallback(NewIntentItem.obtain(next.newIntents,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* andPause */</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">                <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">                next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,</span><br><span class="line">                        System.identityHashCode(next), next.getTask().taskId,</span><br><span class="line">                        next.shortComponentName);</span><br><span class="line"></span><br><span class="line">                next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">                mService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">                mService.showAskCompatModeDialogLocked(next);</span><br><span class="line">                next.app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">                next.app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">                next.clearOptionsLocked();</span><br><span class="line">                transaction.setLifecycleStateRequest(</span><br><span class="line">                        ResumeActivityItem.obtain(next.app.repProcState,</span><br><span class="line">                                mService.isNextTransitionForward()));</span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span></span><br><span class="line">                        + next);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Resume failed; resetting state to "</span></span><br><span class="line">                        + lastState + <span class="string">": "</span> + next);</span><br><span class="line">                next.setState(lastState, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// lastResumedActivity being non-null implies there is a lastStack present.</span></span><br><span class="line">                <span class="keyword">if</span> (lastResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lastResumedActivity.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Slog.i(TAG, <span class="string">"Restarting because process died: "</span> + next);</span><br><span class="line">                <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">                    next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; lastStack != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; lastStack.isTopStackOnDisplay()) &#123;</span><br><span class="line">                    next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* taskSwitch */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// From this point on, if something goes wrong there is no way</span></span><br><span class="line">        <span class="comment">// to recover the activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            next.completeResumeLocked();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If any exception gets thrown, toss away this</span></span><br><span class="line">            <span class="comment">// activity and try the next one.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</span><br><span class="line">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"resume-exception"</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Restarting: "</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Restarting "</span> + next);</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中的代码很长，可以看到最后都是调用了 mStackSupervisor.startSpecificActivityLocked</p>
<p>所以还是要到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法中去看。</p>
<h1 id="ActivityStackSupervisor-1"><a href="#ActivityStackSupervisor-1" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h1><h2 id="startSpecificActivityLocked_28ActivityRecord_r_2C_boolean_andResume_2C_boolean_checkConfig_29"><a href="#startSpecificActivityLocked_28ActivityRecord_r_2C_boolean_andResume_2C_boolean_checkConfig_29" class="headerlink" title="startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig)"></a>startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 startSpecificActivityLocked 中会判断进程是否存在，因为我们分析的是 startActivity 的逻辑，所以肯定是已经存在了进程的，所以会调用 realStartActivityLocked()方法。</p>
<h2 id="realStartActivityLocked_28ActivityRecord_r_2C_ProcessRecord_app_2C_boolean_andResume_2C_boolean_checkConfig_29"><a href="#realStartActivityLocked_28ActivityRecord_r_2C_ProcessRecord_app_2C_boolean_andResume_2C_boolean_checkConfig_29" class="headerlink" title="realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig)"></a>realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// While there are activities pausing we skipping starting any new activities until</span></span><br><span class="line">        <span class="comment">// pauses are complete. <span class="doctag">NOTE:</span> that we also do this for activities that are starting in</span></span><br><span class="line">        <span class="comment">// the paused state because they will first be resumed then paused on the client side.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                <span class="string">"realStartActivityLocked: Skipping start of r="</span> + r</span><br><span class="line">                + <span class="string">" some activities pausing..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> TaskRecord task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">    beginDeferResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        r.setProcess(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getKeyguardController().isKeyguardLocked()) &#123;</span><br><span class="line">            r.notifyUnknownVisibilityLaunched();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of the screen based on the new</span></span><br><span class="line">        <span class="comment">// activity order.  Note that as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that, because the activity is</span></span><br><span class="line">        <span class="comment">// not currently running so we are just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            <span class="comment">// Deferring resume here because we're going to launch new activity shortly.</span></span><br><span class="line">            <span class="comment">// We don't want to perform a redundant launch of the same record while ensuring</span></span><br><span class="line">            <span class="comment">// configurations and trying to resume top activity of focused stack.</span></span><br><span class="line">            ensureVisibilityAndConfig(r, r.getDisplayId(),</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.getStack().checkKeyguardVisibility(r, <span class="keyword">true</span> <span class="comment">/* shouldBeVisible */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* isTop */</span>)) &#123;</span><br><span class="line">            <span class="comment">// We only set the visibility to true if the activity is allowed to be visible</span></span><br><span class="line">            <span class="comment">// based on</span></span><br><span class="line">            <span class="comment">// keyguard state. This avoids setting this into motion in window manager that is</span></span><br><span class="line">            <span class="comment">// later cancelled due to later calls to ensure visible activities that set</span></span><br><span class="line">            <span class="comment">// visibility back to false.</span></span><br><span class="line">            r.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> applicationInfoUid =</span><br><span class="line">                (r.info.applicationInfo != <span class="keyword">null</span>) ? r.info.applicationInfo.uid : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((r.userId != app.userId) || (r.appInfo.uid != applicationInfoUid)) &#123;</span><br><span class="line">            Slog.wtf(TAG,</span><br><span class="line">                    <span class="string">"User ID for activity changing for "</span> + r</span><br><span class="line">                            + <span class="string">" appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                            + <span class="string">" info.ai.uid="</span> + applicationInfoUid</span><br><span class="line">                            + <span class="string">" old="</span> + r.app + <span class="string">" new="</span> + app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"Launching: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = app.activities.indexOf(r);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            app.activities.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LockTaskController lockTaskController = mService.getLockTaskController();</span><br><span class="line">        <span class="keyword">if</span> (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE</span><br><span class="line">                || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV</span><br><span class="line">                || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED</span><br><span class="line">                        &amp;&amp; lockTaskController.getLockTaskModeState()</span><br><span class="line">                                == LOCK_TASK_MODE_LOCKED)) &#123;</span><br><span class="line">            lockTaskController.startLockTaskMode(task, <span class="keyword">false</span>, <span class="number">0</span> <span class="comment">/* blank UID */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;ReferrerIntent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                <span class="comment">// We don't need to deliver new intents and/or set results if activity is going</span></span><br><span class="line">                <span class="comment">// to pause immediately after launch.</span></span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                    <span class="string">"Launching: "</span> + r + <span class="string">" icicle="</span> + r.icicle + <span class="string">" with results="</span> + results</span><br><span class="line">                            + <span class="string">" newIntents="</span> + newIntents + <span class="string">" andResume="</span> + andResume);</span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY, r.userId,</span><br><span class="line">                    System.identityHashCode(r), task.taskId, r.shortComponentName);</span><br><span class="line">            <span class="keyword">if</span> (r.isActivityTypeHome()) &#123;</span><br><span class="line">                <span class="comment">// Home process is the root process of the task.</span></span><br><span class="line">                mService.mHomeProcess = task.mActivities.get(<span class="number">0</span>).app;</span><br><span class="line">            &#125;</span><br><span class="line">            mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            r.sleeping = <span class="keyword">false</span>;</span><br><span class="line">            r.forceNewConfig = <span class="keyword">false</span>;</span><br><span class="line">            mService.getAppWarningsLocked().onStartActivity(r);</span><br><span class="line">            mService.showAskCompatModeDialogLocked(r);</span><br><span class="line">            r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);</span><br><span class="line">            ProfilerInfo profilerInfo = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProfileApp != <span class="keyword">null</span> &amp;&amp; mService.mProfileApp.equals(app.processName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mService.mProfileProc == <span class="keyword">null</span> || mService.mProfileProc == app) &#123;</span><br><span class="line">                    mService.mProfileProc = app;</span><br><span class="line">                    ProfilerInfo profilerInfoSvc = mService.mProfilerInfo;</span><br><span class="line">                    <span class="keyword">if</span> (profilerInfoSvc != <span class="keyword">null</span> &amp;&amp; profilerInfoSvc.profileFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (profilerInfoSvc.profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                profilerInfoSvc.profileFd = profilerInfoSvc.profileFd.dup();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                profilerInfoSvc.closeFd();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        profilerInfo = <span class="keyword">new</span> ProfilerInfo(profilerInfoSvc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.hasShownUi = <span class="keyword">true</span>;</span><br><span class="line">            app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">            app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">            <span class="comment">// Because we could be starting an Activity in the system process this may not go</span></span><br><span class="line">            <span class="comment">// across a Binder interface which would create a new Configuration. Consequently</span></span><br><span class="line">            <span class="comment">// we have to always create a new Configuration here.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">                    mService.getGlobalConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">            r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line">            logIfTransactionTooLarge(r.intent, r.icicle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                    r.appToken);</span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                    profilerInfo));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set desired final state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule transaction.</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((app.info.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">                <span class="comment">// This may be a heavy-weight process!  Note that the package</span></span><br><span class="line">                <span class="comment">// manager will ensure that only activity can run in the main</span></span><br><span class="line">                <span class="comment">// process of the .apk, which is the only thing that will be</span></span><br><span class="line">                <span class="comment">// considered heavy-weight.</span></span><br><span class="line">                <span class="keyword">if</span> (app.processName.equals(app.info.packageName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mService.mHeavyWeightProcess != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; mService.mHeavyWeightProcess != app) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Starting new heavy weight process "</span> + app</span><br><span class="line">                                + <span class="string">" when already running "</span></span><br><span class="line">                                + mService.mHeavyWeightProcess);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mService.mHeavyWeightProcess = app;</span><br><span class="line">                    Message msg = mService.mHandler.obtainMessage(</span><br><span class="line">                            ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">                    msg.obj = r;</span><br><span class="line">                    mService.mHandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.launchFailed) &#123;</span><br><span class="line">                <span class="comment">// This is the second time we failed -- finish activity</span></span><br><span class="line">                <span class="comment">// and give up.</span></span><br><span class="line">                Slog.e(TAG, <span class="string">"Second failure launching "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString()</span><br><span class="line">                        + <span class="string">", giving up"</span>, e);</span><br><span class="line">                mService.appDiedLocked(app);</span><br><span class="line">                stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="string">"2nd-crash"</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the first time we failed -- restart process and</span></span><br><span class="line">            <span class="comment">// retry.</span></span><br><span class="line">            r.launchFailed = <span class="keyword">true</span>;</span><br><span class="line">            app.activities.remove(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.launchFailed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (stack.updateLRUListLocked(r)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Activity "</span> + r + <span class="string">" being launched, but already in LRU list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(lifecycler): Resume or pause requests are done as part of launch transaction,</span></span><br><span class="line">    <span class="comment">// so updating the state should be done accordingly.</span></span><br><span class="line">    <span class="keyword">if</span> (andResume &amp;&amp; readyToResume()) &#123;</span><br><span class="line">        <span class="comment">// As part of the process of launching, ActivityThread also performs</span></span><br><span class="line">        <span class="comment">// a resume.</span></span><br><span class="line">        stack.minimalResumeActivityLocked(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity is not starting in the resumed state... which should look like we asked</span></span><br><span class="line">        <span class="comment">// it to pause+stop (but remain visible), and it has done so and reported back the</span></span><br><span class="line">        <span class="comment">// current icicle and other state.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                <span class="string">"Moving to PAUSED: "</span> + r + <span class="string">" (starting in paused state)"</span>);</span><br><span class="line">        r.setState(PAUSED, <span class="string">"realStartActivityLocked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></span><br><span class="line">    <span class="comment">// launching the initial activity (that is, home), so that it can have</span></span><br><span class="line">    <span class="comment">// a chance to initialize itself while in the background, making the</span></span><br><span class="line">    <span class="comment">// switch back to it faster and look better.</span></span><br><span class="line">    <span class="keyword">if</span> (isFocusedStack(stack)) &#123;</span><br><span class="line">        mService.getActivityStartController().startSetupActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">    <span class="comment">// their client may have activities.</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面又是一段贼长的代码，看的费劲。我们就直接来关注重点：</p>
<pre><code>// Create activity launch transaction.
final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,
        r.appToken);
clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
        System.identityHashCode(r), r.info,
        // TODO: Have this take the merged configuration instead of separate global
        // and override configs.
        mergedConfiguration.getGlobalConfiguration(),
        mergedConfiguration.getOverrideConfiguration(), r.compat,
        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
        r.persistentState, results, newIntents, mService.isNextTransitionForward(),
        profilerInfo));

// Set desired final state.
final ActivityLifecycleItem lifecycleItem;
if (andResume) {
    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());
} else {
    lifecycleItem = PauseActivityItem.obtain();
}
clientTransaction.setLifecycleStateRequest(lifecycleItem);

// Schedule transaction.
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
</code></pre><ol>
<li>首先创建了一个 ClientTransaction ，那什么是 ClientTransaction 呢？ClientTransaction 可以理解为内部包含了一系列的 Activity 生命周期状态的事务，这些事务会最终交给 ActiivtyThread 来处理，然后 ActiivtyThread 再回调相应的 Activity 生命周期。</li>
<li>ClientTransaction 添加了 LaunchActivityItem ，LaunchActivityItem 简单的说就是用来启动 Activity 的。</li>
<li>设置了最终的生命周期状态，这里是添加了 ResumeActivityItem 。即 Activity 最终生命周期的状态是 resumed 。</li>
<li>调用 LifecycleManager 来启动 clientTransaction 。mService.getLifecycleManager() 其实是一个 ClientLifecycleManager 对象。</li>
</ol>
<p>那么就来看看 ClientLifecycleManager.scheduleTransaction 方法</p>
<h1 id="ClientLifecycleManager"><a href="#ClientLifecycleManager" class="headerlink" title="ClientLifecycleManager"></a>ClientLifecycleManager</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29"><a href="#scheduleTransaction_28ClientTransaction_transaction_29" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transaction.getClient() 方法主要获取了需要启动 Activity 进程的代理对象 IApplicationThread </p>
<p>然后内部直接调用了 ClientTransaction 的 schedule 方法。</p>
<h1 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a>ClientTransaction</h1><h2 id="schedule_28_29"><a href="#schedule_28_29" class="headerlink" title="schedule()"></a>schedule()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>schedule 又调用了 mClient.scheduleTransaction 。mClient 就是与 ActivityThread 通讯的代理对象 IApplicationThread ，所以这里其实是调用 ActivityThread 类中 ApplicationThread 内部类    </p>
<h1 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29-1"><a href="#scheduleTransaction_28ClientTransaction_transaction_29-1" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用的是 ActivityThread 的 scheduleTransaction 方法。</p>
<p>有些同学可能会纳闷，ActivityThread 里面没有找到 scheduleTransaction 这个方法啊？别着急，我们来看 ActivityThread 是继承 ClientTransactionHandler 的。所以 scheduleTransaction 这个方法在 ClientTransactionHandler 里面。</p>
<h1 id="ClientTransactionHandler"><a href="#ClientTransactionHandler" class="headerlink" title="ClientTransactionHandler"></a>ClientTransactionHandler</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29-2"><a href="#scheduleTransaction_28ClientTransaction_transaction_29-2" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了 ActivityThread 的 sendMessage() 方法。</p>
<h1 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><h2 id="handleMessage_28Message_msg_29"><a href="#handleMessage_28Message_msg_29" class="headerlink" title="handleMessage(Message msg)"></a>handleMessage(Message msg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, arg1, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, arg1, arg2, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</span><br><span class="line">        + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessage 方法其实就是将 ClientTransaction 参数通过 Handler 机制切换至主线程进行处理。这里的 Handler 就是 H 。相应的，sendMessage 之后，我们就要追踪到 H 的 handleMessage 方法中看了。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="handleMessage_28Message_msg_29-1"><a href="#handleMessage_28Message_msg_29-1" class="headerlink" title="handleMessage(Message msg)"></a>handleMessage(Message msg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    	...</span><br><span class="line">		<span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">		    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">		    mTransactionExecutor.execute(transaction);</span><br><span class="line">		    <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">		        <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">		        <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">		        <span class="comment">// message is handled.</span></span><br><span class="line">		        transaction.recycle();</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handleMessage 的代码有点长，我们只关注 EXECUTE_TRANSACTION 部分。</p>
<p>发现利用了 mTransactionExecutor 来处理 transaction 。mTransactionExecutor 其实是 TransactionExecutor 的一个对象，所以要到 TransactionExecutor 中去追踪。</p>
<h1 id="TransactionExecutor"><a href="#TransactionExecutor" class="headerlink" title="TransactionExecutor"></a>TransactionExecutor</h1><h2 id="execute_28ClientTransaction_transaction_29"><a href="#execute_28ClientTransaction_transaction_29" class="headerlink" title="execute(ClientTransaction transaction)"></a>execute(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(<span class="string">"Start resolving transaction for client: "</span> + mTransactionHandler + <span class="string">", token: "</span> + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(<span class="string">"End resolving transaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要看这两行代码：</p>
<ol>
<li>executeCallbacks(transaction) 在这里面会去执行 LaunchActivityItem 。也就是会去创建 Activity 并回调 onCreate 生命周期方法；</li>
<li>executeLifecycleState(transaction) 在这里会执行 ResumeActivityItem 。之前创建出来的 Activity 的也会回调 onStart 、onResume 生命周期方法。</li>
</ol>
<p>那我们慢慢看吧，先来看 executeCallbacks(transaction)</p>
<h2 id="executeCallbacks_28ClientTransaction_transaction_29"><a href="#executeCallbacks_28ClientTransaction_transaction_29" class="headerlink" title="executeCallbacks(ClientTransaction transaction)"></a>executeCallbacks(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No callbacks to execute, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"Resolving callbacks"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case when post-execution state of the last callback matches the final state requested</span></span><br><span class="line">    <span class="comment">// for the activity in this transaction, we won't do the last transition here and do it when</span></span><br><span class="line">    <span class="comment">// moving to final state instead (because it may contain additional parameters from server).</span></span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> finalState = finalStateRequest != <span class="keyword">null</span> ? finalStateRequest.getTargetState()</span><br><span class="line">            : UNDEFINED;</span><br><span class="line">    <span class="comment">// Index of the last callback that requests some post-execution state.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lastCallbackRequestingState = lastCallbackRequestingState(transaction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">        log(<span class="string">"Resolving callback: "</span> + item);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> postExecutionState = item.getPostExecutionState();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> closestPreExecutionState = mHelper.getClosestPreExecutionState(r,</span><br><span class="line">                item.getPostExecutionState());</span><br><span class="line">        <span class="keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;</span><br><span class="line">            cycleToPath(r, closestPreExecutionState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Launch activity request will create an activity record.</span></span><br><span class="line">            r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip the very last transition and perform it by explicit state request instead.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> shouldExcludeLastTransition =</span><br><span class="line">                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;</span><br><span class="line">            cycleToPath(r, postExecutionState, shouldExcludeLastTransition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要干的事情就是先获取 ClientTransaction 中的 ClientTransactionItem 对象。然后调用 ClientTransactionItem.execute 。</p>
<p>别看上面代码一大串的，其实最重要的就是 <code>item.execute(mTransactionHandler, token, mPendingActions);</code> 这句代码了。</p>
<p>说明了 TransactionExecutor 内部是交给每个 item 来处理对应的操作的。而上面分析可以知道，这个 item 就是 LaunchActivityItem 。</p>
<h1 id="LaunchActivityItem"><a href="#LaunchActivityItem" class="headerlink" title="LaunchActivityItem"></a>LaunchActivityItem</h1><h2 id="execute_28ClientTransactionHandler_client_2C_IBinder_token_2C_PendingTransactionActions_pendingActions_29"><a href="#execute_28ClientTransactionHandler_client_2C_IBinder_token_2C_PendingTransactionActions_pendingActions_29" class="headerlink" title="execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)"></a>execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LaunchActivityItem 的 execute 内部，调用了 client.handleLaunchActivity 来执行。而 client 就是 ActivityThread 。所以我们要继续追踪到 ActivityThread.handleLaunchActivity 。</p>
<h1 id="ActivityThread-1"><a href="#ActivityThread-1" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><h2 id="handleLaunchActivity_28ActivityClientRecord_r_2C_PendingTransactionActions_pendingActions_2C_Intent_customIntent_29"><a href="#handleLaunchActivity_28ActivityClientRecord_r_2C_PendingTransactionActions_pendingActions_2C_Intent_customIntent_29" class="headerlink" title="handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)"></a>handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来一句关键的代码</p>
<pre><code>final Activity a = performLaunchActivity(r, customIntent);
</code></pre><p>最终可以看到，Activity 就是 performLaunchActivity 方法创建出来的。</p>
<h2 id="performLaunchActivity_28ActivityClientRecord_r_2C_Intent_customIntent_29"><a href="#performLaunchActivity_28ActivityClientRecord_r_2C_Intent_customIntent_29" class="headerlink" title="performLaunchActivity(ActivityClientRecord r, Intent customIntent)"></a>performLaunchActivity(ActivityClientRecord r, Intent customIntent) </h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing launch of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">": app="</span> + app</span><br><span class="line">                + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">", pkg="</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">", comp="</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">", dir="</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把上面这段代码整理一下（以下总结来自《Android开发艺术探索》）：</p>
<ol>
<li>从 ActivityClientRecord 中获取待启动的 Activity 的组件信息；</li>
<li>通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象；</li>
<li>通过 LoadedApk 的 makeApplication 方法来尝试创建 Application 对象；</li>
<li>创建 ContextImpl 对象并通过 Activity 的 attach 方法来完成一些重要数据的初始化；</li>
<li>调用 Activity 的 onCreate 方法</li>
</ol>
<p>在这里，1-4点详细的分析就不展开了，我们重点来看一下第5小点。</p>
<p>即</p>
<pre><code>if (r.isPersistable()) {
     mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
} else {
     mInstrumentation.callActivityOnCreate(activity, r.state);
}
</code></pre><h1 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><h2 id="callActivityOnCreate"><a href="#callActivityOnCreate" class="headerlink" title="callActivityOnCreate"></a>callActivityOnCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这，有一种豁然开朗的感觉。原来 Activity 的生命周期调用都是通过 Instrumentation 调用来完成的。</p>
<h1 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h1><h2 id="performCreate_28Bundle_icicle_29"><a href="#performCreate_28Bundle_icicle_29" class="headerlink" title="performCreate(Bundle icicle)"></a>performCreate(Bundle icicle)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="comment">// 回调 activity 的 onCreate 生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, <span class="string">"performCreate"</span>);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析到这里，基本上把 Activity 创建和回调 onCreate 生命周期讲完了。</p>
<p>前面还留了一个坑，就是 Activity 是怎么回调 onStart 和 onResume 的呢？我们只能到下一篇再讲了。</p>
<p>bye bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：源码分析基于 Android SDK API 28</p>
<p>对于 Activity 大家都已经很熟悉很亲切了吧，在这就不过多介绍了。</p>
<p>直接进入正题，走起！</p>
<p>一般我们启动 Activity 的入口都是 startActivity ，所以这]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(七):dex合成流程]]></title>
    <link href="http://yuqirong.github.io/2019/03/20/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%83)/"/>
    <id>http://yuqirong.github.io/2019/03/20/Tinker源码分析(七)/</id>
    <published>2019-03-20T15:36:31.000Z</published>
    <updated>2019-03-23T13:04:01.781Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前面讲到了 Tinker 安装补丁的流程，现在就详细地来看下 dex 合成的代码。代码入口就在 DexDiffPatchInternal.tryRecoverDexFiles 中。</p>
<h1 id="UpgradePatch"><a href="#UpgradePatch" class="headerlink" title="UpgradePatch"></a>UpgradePatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch dex failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了 DexDiffPatchInternal.tryRecoverDexFiles 方法。</p>
<h1 id="tryRecoverDexFiles"><a href="#tryRecoverDexFiles" class="headerlink" title="tryRecoverDexFiles"></a>tryRecoverDexFiles</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryRecoverDexFiles</span><span class="params">(Tinker manager, ShareSecurityCheck checker, Context context,</span><br><span class="line">                                            String patchVersionDirectory, File patchFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否开启支持dex补丁开关                                        </span></span><br><span class="line">    <span class="keyword">if</span> (!manager.isEnabledForDex()) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, dex is not enabled"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查补丁包中的 dex_meta.txt 是否存在</span></span><br><span class="line">    String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexMeta == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, dex is not contained"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">// 到这个方法中执行具体的操作</span></span><br><span class="line">    <span class="keyword">boolean</span> result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</span><br><span class="line">    <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"recover dex result:%b, cost:%d"</span>, result, cost);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryRecoverDexFiles 方法开头做了些校验，最后又到 patchDexExtractViaDexDiff 中。</p>
<h1 id="patchDexExtractViaDexDiff"><a href="#patchDexExtractViaDexDiff" class="headerlink" title="patchDexExtractViaDexDiff"></a>patchDexExtractViaDexDiff</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">patchDexExtractViaDexDiff</span><span class="params">(Context context, String patchVersionDirectory, String meta, <span class="keyword">final</span> File patchFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dex补丁合成的路径</span></span><br><span class="line">    String dir = patchVersionDirectory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</span><br><span class="line">    <span class="comment">// extractDexDiffInternals 这个方法是重点！！！</span></span><br><span class="line">    <span class="keyword">if</span> (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, extractDiffInternals fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 tinker/patch-xxxxx/dex/ 下面的文件校验下，看看是否是合法的dex文件</span></span><br><span class="line">    File dexFiles = <span class="keyword">new</span> File(dir);</span><br><span class="line">    File[] files = dexFiles.listFiles();</span><br><span class="line">    List&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// may have directory in android o</span></span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">final</span> String fileName = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()</span><br><span class="line">                &amp;&amp;  (fileName.endsWith(ShareConstants.DEX_SUFFIX)</span><br><span class="line">                  || fileName.endsWith(ShareConstants.JAR_SUFFIX)</span><br><span class="line">                  || fileName.endsWith(ShareConstants.PATCH_SUFFIX))</span><br><span class="line">            ) &#123;</span><br><span class="line">                legalFiles.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"legal files to do dexopt: "</span> + legalFiles);</span><br><span class="line">    <span class="comment">// 对 dex 做 opt 优化</span></span><br><span class="line">    <span class="keyword">final</span> String optimizeDexDirectory = patchVersionDirectory + <span class="string">"/"</span> + DEX_OPTIMIZE_PATH + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">return</span> dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 patchDexExtractViaDexDiff 中可以看到， dex 文件合成之后，会对其做 opt 优化。而合成的代码就在 extractDexDiffInternals 里面。</p>
<p>extractDexDiffInternals 方法有点长。按照老规矩，我们分段来看。</p>
<h1 id="extractDexDiffInternals"><a href="#extractDexDiffInternals" class="headerlink" title="extractDexDiffInternals"></a>extractDexDiffInternals</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">extractDexDiffInternals</span><span class="params">(Context context, String dir, String meta, File patchFile, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 dex_meta.txt 中的信息</span></span><br><span class="line">    patchList.clear();</span><br><span class="line">    ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patchList.isEmpty()) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"extract patch list is empty! type:%s:"</span>, ShareTinkerInternals.getTypeString(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先读取 dex_meta.txt 中的信息，用“,”分割，保存到 patchList 中。</p>
<p>下面贴出一份 dex_meta.txt 的示例：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classes.dex,,<span class="number">1</span>a6e6d6a40eff95aa33ab06e07acd413,<span class="number">1</span>a6e6d6a40eff95aa33ab06e07acd413,d865f383455abd6e3f70096109543644,<span class="number">2999635299</span>,<span class="number">712828526</span>,jar</span><br><span class="line">test.dex,,<span class="number">56900442</span>eb5b7e1de45449d0685e6e00,<span class="number">56900442</span>eb5b7e1de45449d0685e6e00,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,jar</span><br></pre></td></tr></table></figure>
<p>dex_meta.txt 记录着</p>
<ul>
<li>name ：补丁 dex 名字</li>
<li>path ：补丁 dex 路径</li>
<li>destMd5InDvm ：合成新 dex 在 dvm 中的 md5 值</li>
<li>destMd5InArt ：合成新 dex 在 art 中的 md5 值</li>
<li>dexDiffMd5 ：补丁包 dex 文件的 md5 值</li>
<li>oldDexCrc ：基准包中对应 dex 的 crc 值</li>
<li>newDexCrc ：合成新 dex 的 crc 值</li>
<li>dexMode ：dex 类型，为 jar 类型</li>
</ul>
<p>接着往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">File directory = <span class="keyword">new</span> File(dir);</span><br><span class="line"><span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">   directory.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//I think it is better to extract the raw files from apk</span></span><br><span class="line">Tinker manager = Tinker.with(context);</span><br><span class="line">ZipFile apk = <span class="keyword">null</span>;</span><br><span class="line">ZipFile patch = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ApplicationInfo applicationInfo = context.getApplicationInfo();</span><br><span class="line">   <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// Looks like running on a test Context, so just return without patching.</span></span><br><span class="line">       TinkerLog.w(TAG, <span class="string">"applicationInfo == null!!!!"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取到基准包apk的路径</span></span><br><span class="line">   String apkPath = applicationInfo.sourceDir;</span><br><span class="line">   <span class="comment">// 基准包文件</span></span><br><span class="line">   apk = <span class="keyword">new</span> ZipFile(apkPath);</span><br><span class="line">   <span class="comment">// 补丁包文件</span></span><br><span class="line">   patch = <span class="keyword">new</span> ZipFile(patchFile);</span><br><span class="line">   <span class="keyword">if</span> (checkClassNDexFiles(dir)) &#123;</span><br><span class="line">       TinkerLog.w(TAG, <span class="string">"class n dex file %s is already exist, and md5 match, just continue"</span>, ShareConstants.CLASS_N_APK_NAME);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后获取基本包和补丁包的路径，为下面合成做准备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 ShareDexDiffPatchInfo</span></span><br><span class="line"><span class="keyword">for</span> (ShareDexDiffPatchInfo info : patchList) &#123;</span><br><span class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 补丁dex文件路径</span></span><br><span class="line">  <span class="keyword">final</span> String infoPath = info.path;</span><br><span class="line">  String patchRealPath;</span><br><span class="line">  <span class="keyword">if</span> (infoPath.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      patchRealPath = info.rawName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patchRealPath = info.path + <span class="string">"/"</span> + info.rawName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String dexDiffMd5 = info.dexDiffMd5;</span><br><span class="line">  String oldDexCrc = info.oldDexCrC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是 dvm 虚拟机环境，但是补丁dex是art环境的，就跳过</span></span><br><span class="line">  <span class="keyword">if</span> (!isVmArt &amp;&amp; info.destMd5InDvm.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"patch dex %s is only for art, just continue"</span>, patchRealPath);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;</span><br><span class="line">  <span class="comment">// 检查 md5 值</span></span><br><span class="line">  <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) &#123;</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"meta file md5 invalid, type:%s, name: %s, md5: %s"</span>, ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);</span><br><span class="line">      manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  File extractedFile = <span class="keyword">new</span> File(dir + info.realName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果合成的dex文件已经存在了</span></span><br><span class="line">  <span class="keyword">if</span> (extractedFile.exists()) &#123;</span><br><span class="line">      <span class="comment">// 就校验合成的 dex 文件md5值，如果通过就跳过</span></span><br><span class="line">      <span class="keyword">if</span> (SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">          <span class="comment">//it is ok, just continue</span></span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"dex file %s is already exist, and md5 match, just continue"</span>, extractedFile.getPath());</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"have a mismatch corrupted dex "</span> + extractedFile.getPath());</span><br><span class="line">          <span class="comment">// 否则删除文件</span></span><br><span class="line">          extractedFile.delete();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      extractedFile.getParentFile().mkdirs();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，就是遍历 patchList 中的记录，进行一个个 dex 文件合成了。一开头会去校验合成的文件是否存在，存在的话就跳过，进行下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZipEntry patchFileEntry = patch.getEntry(patchRealPath);</span><br><span class="line">ZipEntry rawApkFileEntry = apk.getEntry(patchRealPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldDexCrc.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patchFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch entry is null. path:"</span> + patchRealPath);</span><br><span class="line">        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//it is a new file, but maybe we need to repack the dex file</span></span><br><span class="line">    <span class="keyword">if</span> (!extractDexFile(patch, patchFileEntry, extractedFile, info)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"Failed to extract raw patch file "</span> + extractedFile.getPath());</span><br><span class="line">        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 oldDexCrc 为0，就说明基准包中对应的 oldDex 文件不存在，直接按照 patch 信息重新打包 dex 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 dexDiffMd5 为 0， 就说明补丁包中没有这个dex，但是基准包中存在</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dexDiffMd5.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">      <span class="comment">// skip process old dex for real dalvik vm</span></span><br><span class="line">      <span class="comment">// 如果是 dvm 环境的无须做处理</span></span><br><span class="line">      <span class="keyword">if</span> (!isVmArt) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查基准包中的 dex 是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (rawApkFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"apk entry is null. path:"</span> + patchRealPath);</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//check source crc instead of md5 for faster</span></span><br><span class="line">      <span class="comment">// 检查基准包中的 dex 的 crc 值和 dex_meta.txt 中是否一致</span></span><br><span class="line">      String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">      <span class="keyword">if</span> (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">          TinkerLog.e(TAG, <span class="string">"apk entry %s crc is not equal, expect crc: %s, got crc: %s"</span>, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Small patched dex generating strategy was disabled, we copy full original dex directly now.</span></span><br><span class="line">      <span class="comment">//patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);</span></span><br><span class="line">      <span class="comment">// 直接复制 ：copy full original dex directly now.</span></span><br><span class="line">      extractDexFile(apk, rawApkFileEntry, extractedFile, info);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 复制完后校验一下md5值是否一致</span></span><br><span class="line">      <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"Failed to recover dex file when verify patched dex: "</span> + extractedFile.getPath());</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码用来处理基准包中有 oldDex ，但是补丁包中没有 dex 的情况。</p>
<p>如果是 dvm 环境就跳过不处理即可，如果是 art 环境就把 oldDex 复制过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 检查补丁包中 dex 是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (patchFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"patch entry is null. path:"</span> + patchRealPath);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查补丁包中的 dex md5值是否合法</span></span><br><span class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"meta file md5 invalid, type:%s, name: %s, md5: %s"</span>, ShareTinkerInternals.getTypeString(type), info.rawName, dexDiffMd5);</span><br><span class="line">                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查基准包中的 dex 是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (rawApkFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"apk entry is null. path:"</span> + patchRealPath);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查基准包中的 dex 的 crc 值是否一致</span></span><br><span class="line">                String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                <span class="keyword">if</span> (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                    TinkerLog.e(TAG, <span class="string">"apk entry %s crc is not equal, expect crc: %s, got crc: %s"</span>, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行合成操作</span></span><br><span class="line">                patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);</span><br><span class="line">                <span class="comment">// 检查合成出来的dex的 md5 值是否一致</span></span><br><span class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"Failed to recover dex file when verify patched dex: "</span> + extractedFile.getPath());</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TinkerLog.w(TAG, <span class="string">"success recover dex file: %s, size: %d, use time: %d"</span>,</span><br><span class="line">                    extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mergeClassNDexFiles(context, patchFile, dir)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"patch "</span> + ShareTinkerInternals.getTypeString(type) + <span class="string">" extract failed ("</span> + e.getMessage() + <span class="string">")."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SharePatchFileUtil.closeZip(apk);</span><br><span class="line">        SharePatchFileUtil.closeZip(patch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是基准包和补丁包中都存在对应 dex 的情况了。</p>
<p>代码一开始就是一堆的各种校验，都通过后，调用 patchDexFile 执行合成操作。合成完后再对合成的 dex 进行md5校验。</p>
<h1 id="patchDexFile"><a href="#patchDexFile" class="headerlink" title="patchDexFile"></a>patchDexFile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchDexFile</span><span class="params">(</span><br><span class="line">    ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,</span><br><span class="line">    ShareDexDiffPatchInfo patchInfo, File patchedDexFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream oldDexStream = <span class="keyword">null</span>;</span><br><span class="line">    InputStream patchFileStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 基准包 dex 文件输入流</span></span><br><span class="line">        oldDexStream = <span class="keyword">new</span> BufferedInputStream(baseApk.getInputStream(oldDexEntry));</span><br><span class="line">        <span class="comment">// 补丁包 dex 文件输入流</span></span><br><span class="line">        patchFileStream = (patchFileEntry != <span class="keyword">null</span> ? <span class="keyword">new</span> BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);</span><br><span class="line">        <span class="keyword">if</span> (!isRawDexFile || patchInfo.isJarMode) &#123;</span><br><span class="line">            ZipOutputStream zos = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 合成 dex 文件的输出流</span></span><br><span class="line">                zos = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(patchedDexFile)));</span><br><span class="line">                zos.putNextEntry(<span class="keyword">new</span> ZipEntry(ShareConstants.DEX_IN_JAR));</span><br><span class="line">                <span class="comment">// Old dex is not a raw dex file.</span></span><br><span class="line">                <span class="keyword">if</span> (!isRawDexFile) &#123;</span><br><span class="line">                    ZipInputStream zis = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        zis = <span class="keyword">new</span> ZipInputStream(oldDexStream);</span><br><span class="line">                        ZipEntry entry;</span><br><span class="line">                        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ShareConstants.DEX_IN_JAR.equals(entry.getName())) <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"can't recognize zip dex format file:"</span> + patchedDexFile.getAbsolutePath());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">new</span> DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        StreamUtil.closeQuietly(zis);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">new</span> DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">                &#125;</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                StreamUtil.closeQuietly(zos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        StreamUtil.closeQuietly(oldDexStream);</span><br><span class="line">        StreamUtil.closeQuietly(patchFileStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 patchDexFile 中，拿到基准包 dex 文件的 InputStream 和补丁包 dex 文件的 InputStream ，然后利用 DexPatchApplier 把这两个流合成一个 dex 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAndSaveTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Before executing, we should check if this patch can be applied to</span></span><br><span class="line">    <span class="comment">// old dex we passed in.</span></span><br><span class="line">    <span class="keyword">byte</span>[] oldDexSign = <span class="keyword">this</span>.oldDex.computeSignature(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (oldDexSign == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to compute old dex's signature."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.patchFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"patch file is null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] oldDexSignInPatchFile = <span class="keyword">this</span>.patchFile.getOldDexSignature();</span><br><span class="line">    <span class="keyword">if</span> (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">"old dex signature mismatch! expected: %s, actual: %s"</span>,</span><br><span class="line">                        Arrays.toString(oldDexSign),</span><br><span class="line">                        Arrays.toString(oldDexSignInPatchFile)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Firstly, set sections' offset after patched, sort according to their offset so that</span></span><br><span class="line">    <span class="comment">// the dex lib of aosp can calculate section size.</span></span><br><span class="line">    TableOfContents patchedToc = <span class="keyword">this</span>.patchedDex.getTableOfContents();</span><br><span class="line"></span><br><span class="line">    patchedToc.header.off = <span class="number">0</span>;</span><br><span class="line">    patchedToc.header.size = <span class="number">1</span>;</span><br><span class="line">    patchedToc.mapList.size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    patchedToc.stringIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedStringIdSectionOffset();</span><br><span class="line">    patchedToc.typeIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedTypeIdSectionOffset();</span><br><span class="line">    patchedToc.typeLists.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedTypeListSectionOffset();</span><br><span class="line">    patchedToc.protoIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedProtoIdSectionOffset();</span><br><span class="line">    patchedToc.fieldIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedFieldIdSectionOffset();</span><br><span class="line">    patchedToc.methodIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedMethodIdSectionOffset();</span><br><span class="line">    patchedToc.classDefs.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedClassDefSectionOffset();</span><br><span class="line">    patchedToc.mapList.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedMapListSectionOffset();</span><br><span class="line">    patchedToc.stringDatas.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedStringDataSectionOffset();</span><br><span class="line">    patchedToc.annotations.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSectionOffset();</span><br><span class="line">    patchedToc.annotationSets.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSetSectionOffset();</span><br><span class="line">    patchedToc.annotationSetRefLists.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSetRefListSectionOffset();</span><br><span class="line">    patchedToc.annotationsDirectories.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationsDirectorySectionOffset();</span><br><span class="line">    patchedToc.encodedArrays.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedEncodedArraySectionOffset();</span><br><span class="line">    patchedToc.debugInfos.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedDebugInfoSectionOffset();</span><br><span class="line">    patchedToc.codes.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedCodeSectionOffset();</span><br><span class="line">    patchedToc.classDatas.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedClassDataSectionOffset();</span><br><span class="line">    patchedToc.fileSize</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedDexSize();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(patchedToc.sections);</span><br><span class="line"></span><br><span class="line">    patchedToc.computeSizesFromOffsets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Secondly, run patch algorithms according to sections' dependencies.</span></span><br><span class="line">    <span class="keyword">this</span>.stringDataSectionPatchAlg = <span class="keyword">new</span> StringDataSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.typeIdSectionPatchAlg = <span class="keyword">new</span> TypeIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.protoIdSectionPatchAlg = <span class="keyword">new</span> ProtoIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.fieldIdSectionPatchAlg = <span class="keyword">new</span> FieldIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.methodIdSectionPatchAlg = <span class="keyword">new</span> MethodIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.classDefSectionPatchAlg = <span class="keyword">new</span> ClassDefSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.typeListSectionPatchAlg = <span class="keyword">new</span> TypeListSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSetRefListSectionPatchAlg = <span class="keyword">new</span> AnnotationSetRefListSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSetSectionPatchAlg = <span class="keyword">new</span> AnnotationSetSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.classDataSectionPatchAlg = <span class="keyword">new</span> ClassDataSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.codeSectionPatchAlg = <span class="keyword">new</span> CodeSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.debugInfoSectionPatchAlg = <span class="keyword">new</span> DebugInfoItemSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSectionPatchAlg = <span class="keyword">new</span> AnnotationSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.encodedArraySectionPatchAlg = <span class="keyword">new</span> StaticValueSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationsDirectorySectionPatchAlg = <span class="keyword">new</span> AnnotationsDirectorySectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.stringDataSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.typeIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.typeListSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.protoIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.fieldIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.methodIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSetSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSetRefListSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationsDirectorySectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.debugInfoSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.codeSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.classDataSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.encodedArraySectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.classDefSectionPatchAlg.execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thirdly, write header, mapList. Calculate and write patched dex's sign and checksum.</span></span><br><span class="line">    Dex.Section headerOut = <span class="keyword">this</span>.patchedDex.openSection(patchedToc.header.off);</span><br><span class="line">    patchedToc.writeHeader(headerOut);</span><br><span class="line"></span><br><span class="line">    Dex.Section mapListOut = <span class="keyword">this</span>.patchedDex.openSection(patchedToc.mapList.off);</span><br><span class="line">    patchedToc.writeMap(mapListOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.patchedDex.writeHashes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, write patched dex to file.</span></span><br><span class="line">    <span class="keyword">this</span>.patchedDex.writeTo(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 DexPatchApplier 里面合流操作的代码是需要根据 Tinker 的 DexDiff 算法来的。大致就是把两个 Dex 文件的每个分区做 merge 操作。</p>
<p>这里先留一个坑。等以后把 DexDiff 算法看明白了再补上。</p>
<p>另外，dodola 写了一篇 <a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a>，有需要的同学可以看下。</p>
<p>那么 dex 合成的流程就到这吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前面讲到了 Tinker 安装补丁的流程，现在就详细地来看下 dex 合成的代码。代码入口就在 DexDiffPatchInternal.tryRecoverDexFiles 中。</p>
<h]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apk安全之校验签名]]></title>
    <link href="http://yuqirong.github.io/2019/03/18/Apk%E5%AE%89%E5%85%A8%E4%B9%8B%E6%A0%A1%E9%AA%8C%E7%AD%BE%E5%90%8D/"/>
    <id>http://yuqirong.github.io/2019/03/18/Apk安全之校验签名/</id>
    <published>2019-03-18T15:17:31.000Z</published>
    <updated>2019-03-18T15:51:43.149Z</updated>
    <content type="html"><![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防护，比如代码混淆、加固等。</p>
<p>今天就来讲讲其中的一项：校验签名。</p>
<p>校验签名可以有效的防止二次打包，避免你的 app 被植入广告甚至破解等。而今天就从两个角度来讲签名的具体校验：</p>
<ul>
<li>Java 层</li>
<li>C/C++ 层</li>
</ul>
<p>那么就先开始讲 java 层好了。</p>
<h1 id="Java__u5C42"><a href="#Java__u5C42" class="headerlink" title="Java 层"></a>Java 层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateAppSignature</span><span class="params">(Context context, String apkSignature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">        PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">        <span class="keyword">for</span> (Signature signature : packageInfo.signatures) &#123;</span><br><span class="line">            String lowerCaseSignature = signature.toCharsString().toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (lowerCaseSignature.equals(apkSignature)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 层的签名校验核心代码就这些，传入的两个参数 ：</p>
<ul>
<li>Context context : 一般都是 Application</li>
<li>String apkSignature : 你的 apk 的正式签名</li>
</ul>
<p>Java 层的签名校验比较容易被攻破，因为别人可以反编译一下，然后在 smali 中把 validateAppSignature 方法的返回值改成 true 就大功告成了。</p>
<p>也正因为如此，所以需要在 C/C++ 层中也加入签名校验。</p>
<h1 id="C/C++__u5C42"><a href="#C/C++__u5C42" class="headerlink" title="C/C++ 层"></a>C/C++ 层</h1><p>在 so 文件加载的时候，会去调用 JNI_OnLoad 函数，所以我们可以在这里做签名校验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        LOGE(<span class="string">"no jni version 1.6"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkAppSignature(env) != JNI_TRUE) &#123;</span><br><span class="line">        LOGE(<span class="string">"the signature of apk is invalid"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>签名校验的代码主要在 checkAppSignature 函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">checkAppSignature</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass classNativeContext = (*env)-&gt;FindClass(env, <span class="string">"me/yuqirong/security/Security"</span>);</span><br><span class="line">    jmethodID midGetAppContext = (*env)-&gt;GetStaticMethodID(env, classNativeContext,</span><br><span class="line">                                                        <span class="string">"getContext"</span>,</span><br><span class="line">                                                        <span class="string">"()Landroid/content/Context;"</span>);</span><br><span class="line">    jobject appContext = (*env)-&gt;CallStaticObjectMethod(env, classNativeContext, midGetAppContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appContext != NULL) &#123;</span><br><span class="line">        jboolean signatureValid = Android_checkSignature(env, NULL, appContext);</span><br><span class="line">        <span class="keyword">return</span> signatureValid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"app context is null, please check the context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，checkAppSignature 主要是通过 C 的代码反射来获取 Context 。</p>
<p>对应的 Java 层代码如下，一般来说， <code>Security.setContext(application)</code> 会在 Application.onCreate 方法中调用 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Application application;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> application;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Application context)</span> </span>&#123;</span><br><span class="line">	    application = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到 Context 之后，就可以来比较签名了 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* APP_SIGNATURE = <span class="string">"input your signature of apk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">Android_checkSignature</span><span class="params">(</span><br><span class="line">        JNIEnv *env, jclass clazz, jobject context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jstring appSignature = loadSignature(env, context);</span><br><span class="line">    jstring releaseSignature = (*env)-&gt;NewStringUTF(env, APP_SIGNATURE);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charAppSignature = (*env)-&gt;GetStringUTFChars(env, appSignature, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charReleaseSignature = (*env)-&gt;GetStringUTFChars(env, releaseSignature, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jboolean result = JNI_FALSE;</span><br><span class="line">    <span class="keyword">if</span> (charAppSignature != <span class="literal">NULL</span> &amp;&amp; charReleaseSignature != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(charAppSignature, charReleaseSignature) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGI(<span class="string">"the signature of apk is valid, so pass it"</span>);</span><br><span class="line">            result = JNI_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, appSignature, charAppSignature);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, releaseSignature, charReleaseSignature);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 APP_SIGNATURE 就是正式版的签名字符串，而 loadSignature 函数需要反射安卓系统的 API 才能获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">loadSignature</span><span class="params">(JNIEnv *env, jobject context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得Context类</span></span><br><span class="line">    jclass cls = (*env)-&gt;GetObjectClass(env, context);</span><br><span class="line">    <span class="comment">// 得到getPackageManager方法的ID</span></span><br><span class="line">    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageManager"</span>, <span class="string">"()Landroid/content/pm/PackageManager;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得应用包的管理器</span></span><br><span class="line">    jobject pm = (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到getPackageName方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 获得当前应用包名</span></span><br><span class="line">    jstring packageName = (jstring) (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得PackageManager类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, pm);</span><br><span class="line">    <span class="comment">// 得到getPackageInfo方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageInfo"</span>, <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);</span><br><span class="line">    <span class="comment">// 获得应用包的信息</span></span><br><span class="line">    jobject packageInfo = (*env)-&gt;CallObjectMethod(env, pm, mid, packageName, <span class="number">0x40</span>); <span class="comment">//GET_SIGNATURES = 64;</span></span><br><span class="line">    <span class="comment">// 获得PackageInfo 类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, packageInfo);</span><br><span class="line">    <span class="comment">// 获得签名数组属性的ID</span></span><br><span class="line">    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</span><br><span class="line">    <span class="comment">// 得到签名数组</span></span><br><span class="line">    jobjectArray signatures = (jobjectArray) (*env)-&gt;GetObjectField(env, packageInfo, fid);</span><br><span class="line">    <span class="comment">// 得到签名</span></span><br><span class="line">    jobject signature = (*env)-&gt;GetObjectArrayElement(env, signatures, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Signature类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signature);</span><br><span class="line">    <span class="comment">// 得到toCharsString方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toCharsString"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 返回当前应用签名信息</span></span><br><span class="line">    jstring signatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signature, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toLowerCase</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signatureString);</span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toLowerCase"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring lowerCaseSignatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signatureString, mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowerCaseSignatureString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadSignature 函数可以说就是用 C 语言把上面 Java 的那段代码实现了一遍，并没有什么差别。</p>
<p>至此，有了 Java 和 C/C++ 的双重保护，app 的安全性又提升了一级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(六):补丁合成流程]]></title>
    <link href="http://yuqirong.github.io/2019/03/14/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)/"/>
    <id>http://yuqirong.github.io/2019/03/14/Tinker源码分析(六)/</id>
    <published>2019-03-14T15:05:56.000Z</published>
    <updated>2019-03-14T15:41:53.172Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="headerlink" title="补丁合成流程"></a>补丁合成流程</h1><p>下发的补丁包其实并不能直接加载，因为补丁包只是差异包，需要和本地的 dex 、资源等进行合成后，得到全量的 dex 才能被完整地使用。这样也就避免了热修复中 dex 的 pre-verify 问题，也减少了补丁包的体积，方便用户下载。</p>
<p>补丁合成的入口在 TinkerInstaller.onReceiveUpgradePatch 方法</p>
<h1 id="TinkerInstaller-onReceiveUpgradePatch"><a href="#TinkerInstaller-onReceiveUpgradePatch" class="headerlink" title="TinkerInstaller.onReceiveUpgradePatch"></a>TinkerInstaller.onReceiveUpgradePatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onReceiveUpgradePatch</span><span class="params">(Context context, String patchLocation)</span> </span>&#123;</span><br><span class="line">    Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 PatchListener 有默认实现类，即 DefaultPatchListener 。</p>
<h1 id="DefaultPatchListener-onPatchReceived"><a href="#DefaultPatchListener-onPatchReceived" class="headerlink" title="DefaultPatchListener.onPatchReceived"></a>DefaultPatchListener.onPatchReceived</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onPatchReceived</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="comment">// 对补丁进行校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PATCH_OK) &#123;</span><br><span class="line">        <span class="comment">// 通过的话就启动 :process 进程进行补丁合成    </span></span><br><span class="line">        TinkerPatchService.runPatchService(context, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 校验失败就回调 onLoadPatchListenerReceiveFail</span></span><br><span class="line">        Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(<span class="keyword">new</span> File(path), returnCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看 TinkerPatchService.runPatchService 方法</p>
<h1 id="TinkerPatchService-runPatchService"><a href="#TinkerPatchService-runPatchService" class="headerlink" title="TinkerPatchService.runPatchService"></a>TinkerPatchService.runPatchService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runPatchService</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"run patch service..."</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, TinkerPatchService.class);</span><br><span class="line">    <span class="comment">// path 就是补丁的路径</span></span><br><span class="line">    intent.putExtra(PATCH_PATH_EXTRA, path);</span><br><span class="line">    <span class="comment">// RESULT_CLASS_EXTRA 一般默认就是 DefaultTinkerResultService</span></span><br><span class="line">    intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        enqueueWork(context, TinkerPatchService.class, JOB_ID, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"run patch service fail, exception:"</span> + thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 runPatchService 中去启动了 TinkerPatchService 。TinkerPatchService 是跑在 :patch<br> 进程中的。</p>
<p>TinkerPatchService 主要做的事情都在 onHandleWork 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleWork</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提高优先级</span></span><br><span class="line">    increasingPriority();</span><br><span class="line">    <span class="comment">// 合成补丁</span></span><br><span class="line">    doApplyPatch(<span class="keyword">this</span>, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 increasingPriority 方法，目的就是提高 service 的优先级，具体的方案就是设置为前台服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increasingPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for system version &gt;= Android O, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash or toasts."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"ZUK"</span>.equals(Build.MANUFACTURER)) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for ZUK device, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"try to increase patch process priority"</span>);</span><br><span class="line">    <span class="comment">// 设置为前台服务，提高优先级</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">            <span class="comment">// start InnerService</span></span><br><span class="line">            startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"try to increase patch process priority error:"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是 doApplyPatch 方法，在这里做补丁合成的事</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doApplyPatch</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since we may retry with IntentService, we should prevent</span></span><br><span class="line">    <span class="comment">// racing here again.</span></span><br><span class="line">    <span class="keyword">if</span> (!sIsPatchApplying.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"TinkerPatchService doApplyPatch is running by another runner."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    tinker.getPatchReporter().onPatchServiceStart(intent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService received a null intent, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取补丁文件的路径</span></span><br><span class="line">    String path = getPatchPathExtra(intent);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService can't get the path extra, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">long</span> cost;</span><br><span class="line">    Throwable e = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PatchResult patchResult = <span class="keyword">new</span> PatchResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (upgradePatchProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"upgradePatchProcessor is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理补丁合成</span></span><br><span class="line">        result = upgradePatchProcessor.tryPatch(context, path, patchResult);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        e = throwable;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">        tinker.getPatchReporter().onPatchException(patchFile, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    tinker.getPatchReporter().</span><br><span class="line">        onPatchResult(patchFile, result, cost);</span><br><span class="line"></span><br><span class="line">    patchResult.isSuccess = result;</span><br><span class="line">    patchResult.rawPatchFilePath = path;</span><br><span class="line">    patchResult.costTime = cost;</span><br><span class="line">    patchResult.e = e;</span><br><span class="line">    <span class="comment">// 补丁合成的结果回调给 DefaultResultService</span></span><br><span class="line">    AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));</span><br><span class="line"></span><br><span class="line">    sIsPatchApplying.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upgradePatchProcessor 是一个接口，具体的实现类是 UpgradePatch 。</p>
<h1 id="UpgradePatch-tryPatch"><a href="#UpgradePatch-tryPatch" class="headerlink" title="UpgradePatch.tryPatch"></a>UpgradePatch.tryPatch</h1><p>那么来看看 UpgradePatch.tryPatch ，方法比较长，分段来看吧。</p>
<p>首先是对 Tinker 自身开关的校验，然后对补丁文件的合法性进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryPatch</span><span class="params">(Context context, String tempPatchPath, PatchResult patchResult)</span> </span>&#123;</span><br><span class="line">    Tinker manager = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File patchFile = <span class="keyword">new</span> File(tempPatchPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch is disabled, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchFile)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch file is not found, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后检查补丁包的签名以及 tinkerId , 这里的操作和加载补丁是一样的。</p>
<p>然后就是获取补丁文件的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check the signature, we should create a new checker</span></span><br><span class="line">ShareSecurityCheck signatureCheck = <span class="keyword">new</span> ShareSecurityCheck(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchPackageCheckFail"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取补丁文件的 md5</span></span><br><span class="line">String patchMd5 = SharePatchFileUtil.getMD5(patchFile);</span><br><span class="line"><span class="keyword">if</span> (patchMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch md5 is null, just return"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use md5 as version</span></span><br><span class="line"><span class="comment">// 用 md5 做版本号</span></span><br><span class="line">patchResult.patchVersion = patchMd5;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchMd5:%s"</span>, patchMd5);</span><br></pre></td></tr></table></figure>
<p>接着，校验完成后，我们就来构造一个新的 patch.info 文件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check ok, we can real recover a new patch</span></span><br><span class="line"><span class="keyword">final</span> String patchDirectory = manager.getPatchDirectory().getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// info.lock 文件</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);</span><br><span class="line"><span class="comment">// patch.info 文件</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取出老的 patch.info 文件，可能存在 可能不存在</span></span><br><span class="line">SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//it is a new patch, so we should not find a exist</span></span><br><span class="line">SharePatchInfo newInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有老的 patch.info 文件</span></span><br><span class="line"><span class="keyword">if</span> (oldInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldInfo.oldVersion == <span class="keyword">null</span> || oldInfo.newVersion == <span class="keyword">null</span> || oldInfo.oatDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchInfoCorrupted"</span>);</span><br><span class="line">        manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid"</span>, patchMd5);</span><br><span class="line">        manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if it is interpret now, use changing flag to wait main process</span></span><br><span class="line">    <span class="keyword">final</span> String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)</span><br><span class="line">        ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(oldInfo.oldVersion, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, finalOatDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(<span class="string">""</span>, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来，就是把补丁包复制到私有目录中</p>
<p>具体的路径也就是之前在加载补丁中遇到的 /data/data/应用包名/tinker/patch-xxxxxx/patch-xxxxxx.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//it is a new patch, we first delete if there is any files</span></span><br><span class="line"><span class="comment">//don't delete dir for faster retry</span></span><br><span class="line"><span class="comment">//        SharePatchFileUtil.deleteDir(patchVersionDirectory);</span></span><br><span class="line"><span class="keyword">final</span> String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String patchVersionDirectory = patchDirectory + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchVersionDirectory:%s"</span>, patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy file</span></span><br><span class="line">File destPatchFile = <span class="keyword">new</span> File(patchVersionDirectory + <span class="string">"/"</span> + SharePatchFileUtil.getPatchVersionFile(patchMd5));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// check md5 first</span></span><br><span class="line">  <span class="keyword">if</span> (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) &#123;</span><br><span class="line">      <span class="comment">// 复制补丁包到 /data/data/ 中</span></span><br><span class="line">      SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d"</span>, patchFile.getAbsolutePath(), patchFile.length(),</span><br><span class="line">          destPatchFile.getAbsolutePath(), destPatchFile.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">  TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:copy patch file fail from %s to %s"</span>, patchFile.getPath(), destPatchFile.getPath());</span><br><span class="line">  manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制好之后，就是把补丁包和基准包进行整合了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</span></span><br><span class="line"><span class="comment">// 合成 dex</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch dex failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成 so 文件</span></span><br><span class="line"><span class="keyword">if</span> (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch library failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成资源文件</span></span><br><span class="line"><span class="keyword">if</span> (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch resource failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的三个合成代码我们到后面的章节再分析，这里先跳过了。</p>
<p>合成完后，还要对 dex 进行opt优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, check dex opt file failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是把结果重新写入到 patch.info ，这样在加载补丁的流程中就能加载新补丁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, rewrite patch info failed"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TinkerLog.w(TAG, <span class="string">"UpgradePatch tryPatch: done, it is ok"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>over ，整个合成补丁的流程讲完了，这里还留了三个坑：</p>
<ul>
<li>dex 文件的合成</li>
<li>so 文件的合成</li>
<li>资源文件的合成</li>
</ul>
<p>到后面再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="h]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(五):加载so补丁流程]]></title>
    <link href="http://yuqirong.github.io/2019/03/10/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)/"/>
    <id>http://yuqirong.github.io/2019/03/10/Tinker源码分析(五)/</id>
    <published>2019-03-10T14:50:22.000Z</published>
    <updated>2019-03-10T16:33:02.144Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="校验so补丁流程"></a>校验so补丁流程</h1><p>与加载资源补丁类似，加载so补丁也要先从校验开始看起。</p>
<p>其实总体来说，Tinker 中加载 so 补丁文件的关键代码就一句：</p>
<p>System.load(String filePath)</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>从 assets/so_meta.txt 中读取 so 补丁信息，每一条 so 补丁信息都会被封装成一个 ShareBsDiffPatchInfo 对象，然后放入 libraryList 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String meta = securityCheck.getMetaContentMap().get(SO_MEAT_FILE);</span><br><span class="line"><span class="comment">//not found lib</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;ShareBsDiffPatchInfo&gt; libraryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ShareBsDiffPatchInfo.parseDiffPatchInfo(meta, libraryList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (libraryList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后遍历 libraryList ，去校验里面的 ShareBsDiffPatchInfo 对象中 md5 和 name 值是否合法。合法的 ShareBsDiffPatchInfo 对象再放入 libs 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker//patch-641e634c/lib</span></span><br><span class="line">String libraryPath = directory + <span class="string">"/"</span> + SO_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; libs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareBsDiffPatchInfo info : libraryList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ShareBsDiffPatchInfo.checkDiffPatchInfo(info)) &#123;</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String middle = info.path + <span class="string">"/"</span> + info.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlike dex, keep the original structure</span></span><br><span class="line">    libs.put(middle, info.md5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着会校验 so 补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File libraryDir = <span class="keyword">new</span> File(libraryPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!libraryDir.exists() || !libraryDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再校验上面的从 so_meta.txt 中获取到的 so 补丁文件路径是否真的存在并且 so 文件是可读的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fast check whether there is any dex files missing</span></span><br><span class="line"><span class="keyword">for</span> (String relative : libs.keySet()) &#123;</span><br><span class="line">    File libFile = <span class="keyword">new</span> File(libraryPath + relative);</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(libFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH, libFile.getAbsolutePath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都没问题的话，就通过校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if is ok, add to result intent</span></span><br><span class="line">intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_LIBS_PATH, libs);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载so补丁流程"></a>加载so补丁流程</h1><p>加载so补丁的入口：TinkerLoadLibrary.loadArmLibrary / TinkerLoadLibrary.loadArmV7Library ，区别就是前者用来加载 armeabi 平台的，后者是用来加载 armeabi-v7a 平台的。我们就来看 loadArmLibrary 方法吧。</p>
<h2 id="loadArmLibrary"><a href="#loadArmLibrary" class="headerlink" title="loadArmLibrary"></a>loadArmLibrary</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadArmLibrary</span><span class="params">(Context context, String libName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 libName 和 context 参数</span></span><br><span class="line">    <span class="keyword">if</span> (libName == <span class="keyword">null</span> || libName.isEmpty() || context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"libName or context is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要保证已经调用了 Tinker.install 方法 不然 Tinker 没安装的话会抛出异常</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tinker 支持 so 补丁，就加载外部的 so 文件</span></span><br><span class="line">    <span class="keyword">if</span> (tinker.isEnabledForNativeLib()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TinkerLoadLibrary.loadLibraryFromTinker(context, <span class="string">"lib/armeabi"</span>, libName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 tinker 不支持 so 补丁，就调用系统的加载方法</span></span><br><span class="line">    System.loadLibrary(libName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadLibraryFromTinker"><a href="#loadLibraryFromTinker" class="headerlink" title="loadLibraryFromTinker"></a>loadLibraryFromTinker</h2><p>loadLibraryFromTinker 一开始校验了 libName 的名字是否是 lib 开头、 .so 结尾的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    libName = libName.startsWith(<span class="string">"lib"</span>) ? libName : <span class="string">"lib"</span> + libName;</span><br><span class="line">    libName = libName.endsWith(<span class="string">".so"</span>) ? libName : libName + <span class="string">".so"</span>;</span><br><span class="line">    String relativeLibPath = relativePath + <span class="string">"/"</span> + libName;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后就是用 relativeLibPath 去和之前 so 校验得到的 libs 去一一匹配。</span><br><span class="line"></span><br><span class="line">如果匹配上了，就说明要加载的就是这个 so 文件，调用 System.load ，传入文件路径即可。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="comment">//TODO we should add cpu abi, and the real path later</span></span><br><span class="line"><span class="comment">// tinker 支持 so 补丁并且 tinker 完成加载补丁</span></span><br><span class="line"><span class="keyword">if</span> (tinker.isEnabledForNativeLib() &amp;&amp; tinker.isTinkerLoaded()) &#123;</span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="comment">// 获取上面校验得到的 libs</span></span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : loadResult.libs.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 如果名字对上了，就说明要加载的就是这个外部的so补丁</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(relativeLibPath)) &#123;</span><br><span class="line">                String patchLibraryPath = loadResult.libraryDirectory + <span class="string">"/"</span> + name;</span><br><span class="line">                File library = <span class="keyword">new</span> File(patchLibraryPath);</span><br><span class="line">                <span class="comment">// 确认 so 补丁文件存在</span></span><br><span class="line">                <span class="keyword">if</span> (library.exists()) &#123;</span><br><span class="line">                    <span class="comment">//whether we check md5 when load</span></span><br><span class="line">                    <span class="keyword">boolean</span> verifyMd5 = tinker.isTinkerLoadVerify();</span><br><span class="line">                    <span class="comment">// 如果需要校验md5值但是校验失败了，就回调 onLoadFileMd5Mismatch 方法</span></span><br><span class="line">                    <span class="keyword">if</span> (verifyMd5 &amp;&amp; !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) &#123;</span><br><span class="line">                        tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则就调用 System.load 方法，传入 so 补丁文件的路径即可</span></span><br><span class="line">                        System.load(patchLibraryPath);</span><br><span class="line">                        TinkerLog.i(TAG, <span class="string">"loadLibraryFromTinker success:"</span> + patchLibraryPath);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，Tinker 中关于 so 补丁加载的流程就讲完了。</p>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>大家有没有发现，一个个单独去调用 TinkerLoadLibrary.loadArmLibrary 会很麻烦，因为如果我的 so 补丁文件有很多个，就需要调用很多次。所以从 Tinker v1.7.7 之后，提供了一键反射的方案来加载 so 补丁文件。</p>
<p>具体方法 TinkerLoadLibrary.installNavitveLibraryABI</p>
<h2 id="installNavitveLibraryABI"><a href="#installNavitveLibraryABI" class="headerlink" title="installNavitveLibraryABI"></a>installNavitveLibraryABI</h2><p>来看一下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">installNavitveLibraryABI</span><span class="params">(Context context, String currentABI)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 tinker 有没有安装</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    <span class="keyword">if</span> (!tinker.isTinkerLoaded()) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker is not loaded, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 tinker 加载的结果</span></span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker libs is null, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查当前 ABI 的 so 文件夹是否存在</span></span><br><span class="line">    File soDir = <span class="keyword">new</span> File(loadResult.libraryDirectory, <span class="string">"lib/"</span> + currentABI);</span><br><span class="line">    <span class="keyword">if</span> (!soDir.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"current libraryABI folder is not exist, path: %s"</span>, soDir.getPath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 classloader</span></span><br><span class="line">    ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"before hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    <span class="comment">// 加载当前 ABI 的所有 so 补丁文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        installNativeLibraryPath(classLoader, soDir);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath fail:"</span> + throwable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"after hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在做了一堆的检查之后，具体 so 文件加载是在 installNativeLibraryPath 方法中。</p>
<h2 id="installNativeLibraryPath"><a href="#installNativeLibraryPath" class="headerlink" title="installNativeLibraryPath"></a>installNativeLibraryPath</h2><p>installNativeLibraryPath 中做的事情主要有两点：</p>
<ul>
<li>如果 classloader 中没有注入 so 补丁文件夹的路径的话，就执行注入；</li>
<li>如果 classloader 中已经有 so 补丁文件夹的路径了，就先删除，再进行注入；</li>
</ul>
<p>具体 hook 的代码根据 SDK 版本而定，这里就不展开讲了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installNativeLibraryPath</span><span class="params">(ClassLoader classLoader, File folder)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folder == <span class="keyword">null</span> || !folder.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, folder %s is illegal"</span>, folder);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// android o sdk_int 26</span></span><br><span class="line">    <span class="comment">// for android o preview sdk_int 25</span></span><br><span class="line">    <span class="keyword">if</span> ((Build.VERSION.SDK_INT == <span class="number">25</span> &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != <span class="number">0</span>)</span><br><span class="line">        || Build.VERSION.SDK_INT &gt; <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V25.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v23</span></span><br><span class="line">            <span class="comment">// some preview N version may go here</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23"</span>,</span><br><span class="line">                    Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v14</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14"</span>,</span><br><span class="line">                Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line"></span><br><span class="line">            V14.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        V14.install(classLoader, folder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V4.install(classLoader, folder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，有了 TinkerLoadLibrary.installNavitveLibraryABI 之后，你就只需要传入当前手机系统的 ABI ，就无需再对 so 的加载做任何的介入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" clas]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(四):加载资源补丁流程]]></title>
    <link href="http://yuqirong.github.io/2019/03/05/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)/"/>
    <id>http://yuqirong.github.io/2019/03/05/Tinker源码分析(四)/</id>
    <published>2019-03-05T15:54:26.000Z</published>
    <updated>2019-03-09T17:25:07.915Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载资源补丁流程"></a>加载资源补丁流程</h1><p>将到资源补丁的加载，首先还要回过头来先看资源补丁的校验和检查。</p>
<p>我们回到 TinkerLoader.tryLoadPatchFilesInternal 方法中来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的校验是在 TinkerResourceLoader.checkComplete 中完成的。这里为了校验的速度，所以只会校验资源补丁存不存在。</p>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>checkComplete 方法我们分段来看吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 assets/res_meta.txt </span></span><br><span class="line">String meta = securityCheck.getMetaContentMap().get(RESOURCE_META_FILE);</span><br><span class="line"><span class="comment">//not found resource</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//only parse first line for faster</span></span><br><span class="line">ShareResPatchInfo.parseResPatchInfoFirstLine(meta, resPatchInfo);</span><br></pre></td></tr></table></figure>
<p>为了校验的速度，只读取了 assets/res_meta.txt 的第一行，并存入到 resPatchInfo 中</p>
<p>res_meta.txt 的第一行主要是资源的 crc 值和 md5 值 ，在后面会做校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ShareResPatchInfo.checkResPatchInfo(resPatchInfo)) &#123;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验上面读取到的 md5 值是否为空以及 md5 值长度是否是 32 位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String resourcePath = directory + <span class="string">"/"</span> + RESOURCE_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">File resourceDir = <span class="keyword">new</span> File(resourcePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!resourceDir.exists() || !resourceDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件夹是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File resourceFile = <span class="keyword">new</span> File(resourcePath + RESOURCE_FILE);</span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(resourceFile)) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件是否存在及合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TinkerResourcePatcher.isResourceCanPatch(context);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"resource hook check failed."</span>, e);</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>通过 context 来检查当前环境是否支持加载资源补丁。方法里面做的事就是通过反射来获取各种系统的属性和方法。简单地举例以下几种：</p>
<ul>
<li>ActivityThread : 当前的 ActivityThread 实例，app主线程的入口。利用 ActivityThread 可以获取到 LoadedApk 对象；</li>
<li>LoadedApk : 通过 LoadedApk 可以获取 mResDir 属性；</li>
<li>mResDir : 这个值很关键，就是资源文件的路径。在后面会被 hook 成资源补丁的路径；</li>
<li>addAssetPath : 通过 addAssetPath 方法将资源补丁文件加载进新的 AssetManager 中；</li>
<li>mActiveResources : ResourcesManager 的 Resources 容器。里面会存储着每个 apk 对应的 Resources 对象。mActiveResources 是 ArrayMap 类型的，不同的 apk 都有一个不同的 key 来获取对应的 apk 的 Resource 对象；</li>
<li>mAssets : 即 Resources 类中的 mAssets 属性，其实就是一个 AssetManager 对象。在资源打补丁的时候，Resources 中原来的 mAssets 对象会被替换成新的 AssetManager 对象。</li>
</ul>
<p>这里就不详细讲了，总结起来就一句话：获取 Android 系统中与资源有关的一些属性和方法，为接下来的加载资源补丁做准备。如果在 isResourceCanPatch 方法中报出异常了，就认为当前环境不能加载资源补丁了。</p>
<h2 id="tryLoadPatchFilesInternal-1"><a href="#tryLoadPatchFilesInternal-1" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>然后我们再在 tryLoadPatchFilesInternal 中往下看。会看到资源补丁加载代码的入口，即 TinkerResourceLoader.loadTinkerResources 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadTinkerResources"><a href="#loadTinkerResources" class="headerlink" title="loadTinkerResources"></a>loadTinkerResources</h2><p>loadTinkerResources 方法我们分段来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  检查 res_meta.txt 中读取出来的 md5 值，如果 resPatchInfo 或者 md5 是空的，就说明补丁包中没有资源补丁，不需要加载</span></span><br><span class="line"><span class="keyword">if</span> (resPatchInfo == <span class="keyword">null</span> || resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">String resourceString = directory + <span class="string">"/"</span> + RESOURCE_PATH +  <span class="string">"/"</span> + RESOURCE_FILE;</span><br><span class="line">File resourceFile = <span class="keyword">new</span> File(resourceString);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 如果校验设置为 true ，就去校验资源补丁包 resources.apk 的 md5 值</span></span><br><span class="line"><span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Failed to load resource file, path: "</span> + resourceFile.getPath() + <span class="string">", expect md5: "</span> + resPatchInfo.resArscMd5);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify resource file:"</span> + resourceFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是加载资源补丁了，如果加载失败了，会把 dex 补丁卸载了。防止 dex 补丁代码中会引用到资源补丁中的资源文件，导致程序崩溃或报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载资源</span></span><br><span class="line">    TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);</span><br><span class="line">    Log.i(TAG, <span class="string">"monkeyPatchExistingResources resource file:"</span> + resourceString + <span class="string">", use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"install resources failed"</span>);</span><br><span class="line">    <span class="comment">//remove patch dex if resource is installed failed</span></span><br><span class="line">    <span class="comment">// 如果资源补丁加载失败的话，会移除 dex 补丁</span></span><br><span class="line">    <span class="comment">// 因为如果dex补丁代码中有引用到资源的话，会报错</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"uninstallPatchDex failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="monkeyPatchExistingResources"><a href="#monkeyPatchExistingResources" class="headerlink" title="monkeyPatchExistingResources"></a>monkeyPatchExistingResources</h2><p>monkeyPatchExistingResources 方法也一段一段来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查资源补丁apk是否为空</span></span><br><span class="line"><span class="keyword">if</span> (externalResourceFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ApplicationInfo appInfo = context.getApplicationInfo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Field[] packagesFields;</span><br><span class="line"><span class="comment">// 准备之前反射好的 packagesFiled 和 resourcePackagesFiled 字段</span></span><br><span class="line"><span class="comment">// 利用 packagesFiled 和 resourcePackagesFiled 可以获取 LoadedApk 对象</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">27</span>) &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled, resourcePackagesFiled&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 packagesFields ，获取对应的值</span></span><br><span class="line"><span class="keyword">for</span> (Field field : packagesFields) &#123;</span><br><span class="line">    <span class="comment">// 获取 ActivityThread 中 packagesFiled 或 resourcePackagesFiled</span></span><br><span class="line">    <span class="comment">// value 其实为 Map&lt;String, WeakReference&lt;LoadedApk&gt;&gt; 类型</span></span><br><span class="line">    <span class="keyword">final</span> Object value = field.get(currentActivityThread);</span><br><span class="line">    <span class="comment">// 再对 value 进行遍历，获取 LoadedApk 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry</span><br><span class="line">            : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object loadedApk = entry.getValue().get();</span><br><span class="line">        <span class="keyword">if</span> (loadedApk == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 LoadedApk 对象中获取 mResDir 属性，这个属性的意义在上面已经讲过了</span></span><br><span class="line">        <span class="keyword">final</span> String resDirPath = (String) resDir.get(loadedApk);</span><br><span class="line">        <span class="comment">// 将 mResDir 的值 hook 成资源补丁 apk 的路径</span></span><br><span class="line">        <span class="keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;</span><br><span class="line">            resDir.set(loadedApk, externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码基本上都有注释了，接着往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new AssetManager instance and point it to the resources installed under</span></span><br><span class="line"><span class="comment">// 创建一个新的 AssetManager 实例，并把资源补丁apk加载进 AssetManager 中</span></span><br><span class="line"><span class="keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm</span></span><br><span class="line"><span class="comment">// in L, so we do it unconditionally.</span></span><br><span class="line"><span class="comment">// 创建出 AssetManager 后，调用 ensureStringBlocks 来确保资源的字符串索引创建出来</span></span><br><span class="line"><span class="keyword">if</span> (stringBlocksField != <span class="keyword">null</span> &amp;&amp; ensureStringBlocksMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stringBlocksField.set(newAssetManager, <span class="keyword">null</span>);</span><br><span class="line">    ensureStringBlocksMethod.invoke(newAssetManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建出新的 AssetManager 之后，最后要做的事就是用新的 AssetManager 来替换旧的。下面代码中的 references 就是上面提到的 mActiveResources 的 value 集合。也就是每个 apk 的 Resources 资源集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources resources = wr.get();</span><br><span class="line">    <span class="keyword">if</span> (resources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the AssetManager of the Resources instance to our brand new one</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//pre-N</span></span><br><span class="line">        <span class="comment">// Android N 之前的方案</span></span><br><span class="line">        <span class="comment">// 把原来 resources 的 mAssets 属性替换成新的 AssetManager 对象</span></span><br><span class="line">        assetsFiled.set(resources, newAssetManager);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        <span class="comment">// N</span></span><br><span class="line">        <span class="comment">// Android N 之后， mAssets 属性被放在了 ResourcesImpl 中</span></span><br><span class="line">        <span class="comment">// 所以需要先获取 ResourcesImpl 对象再进行替换</span></span><br><span class="line">        <span class="keyword">final</span> Object resourceImpl = resourcesImplFiled.get(resources);</span><br><span class="line">        <span class="comment">// for Huawei HwResourcesImpl</span></span><br><span class="line">        <span class="keyword">final</span> Field implAssets = findField(resourceImpl, <span class="string">"mAssets"</span>);</span><br><span class="line">        implAssets.set(resourceImpl, newAssetManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 Resource 中会维护一个 mTypedArrayPool 资源池</span></span><br><span class="line">    <span class="comment">// 来减少频繁访问 AssetManager ，所以需要去释放这个资源池，否则取到的都是缓存</span></span><br><span class="line">    clearPreloadTypedArrayIssue(resources);</span><br><span class="line">    <span class="comment">// 最后调用 updateConfiguration 方法来确保资源更新了</span></span><br><span class="line">    resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle issues caused by WebView on Android N.</span></span><br><span class="line"><span class="comment">// Issue: On Android N, if an activity contains a webview, when screen rotates</span></span><br><span class="line"><span class="comment">// our resource patch may lost effects.</span></span><br><span class="line"><span class="comment">// for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicSourceDirField != <span class="keyword">null</span>) &#123;</span><br><span class="line">            publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是来确认一下资源补丁是否已经加载成功了。具体的方法就是在资源补丁Apk的 assets 中有一个 Tinker 的测试资源，名字叫 only_use_to_test_tinker_resource.txt ，如果可以正确读取到并且没报错的话，就证明资源补丁加载成功了。否则就抛出异常，会执行 dex 补丁卸载的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkResUpdate(context)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，资源补丁的加载流程就讲完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(三):加载dex补丁流程]]></title>
    <link href="http://yuqirong.github.io/2019/02/28/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)/"/>
    <id>http://yuqirong.github.io/2019/02/28/Tinker源码分析(三)/</id>
    <published>2019-02-28T11:23:19.000Z</published>
    <updated>2019-03-09T17:25:13.488Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载dex补丁流程"></a>加载dex补丁流程</h1><h2 id="TinkerDexLoader-loadTinkerJars"><a href="#TinkerDexLoader-loadTinkerJars" class="headerlink" title="TinkerDexLoader.loadTinkerJars"></a>TinkerDexLoader.loadTinkerJars</h2><p>判断一下 dexList 和 classLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadDexList.isEmpty() &amp;&amp; classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"there is no dex to load"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"classloader: "</span> + classLoader.toString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 TinkerLoadVerifyFlag 为 true 的话，会对每个 dex 进行 md5 校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String dexPath = directory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareDexDiffPatchInfo info : loadDexList) &#123;</span><br><span class="line">    <span class="comment">//for dalvik, ignore art support dex</span></span><br><span class="line">    <span class="comment">// 对于 dalvik 虚拟机，忽略 art support dex</span></span><br><span class="line">    <span class="keyword">if</span> (isJustArtSupportDex(info)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String path = dexPath + info.realName;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String checkMd5 = getInfoMd5(info);</span><br><span class="line">        <span class="comment">// 校验dex文件的 md5 值</span></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) &#123;</span><br><span class="line">            <span class="comment">//it is good to delete the mismatch file</span></span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"verify dex file:"</span> + file.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dex文件都通过的话，加入到 legalFiles 集合中 </span></span><br><span class="line">    legalFiles.add(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 art 虚拟机并且是 Android N 及以上的环境，会另外加上 tinker_classN.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// verify merge classN.apk</span></span><br><span class="line"><span class="keyword">if</span> (isVmArt &amp;&amp; !classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    File classNFile = <span class="keyword">new</span> File(dexPath + ShareConstants.CLASS_N_APK_NAME);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ShareDexDiffPatchInfo info : classNDexInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) &#123;</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                    classNFile.getAbsolutePath());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify dex file:"</span> + classNFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">    legalFiles.add(classNFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户是ART虚拟机并且做了OTA升级，那么在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍.这么做的原因是有些场景做了OTA后,oat的规则可能发生变化,在这种情况下去加载上个系统版本oat过的dex就会出现问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">File optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + oatDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span>[] parallelOTAResult = &#123;<span class="keyword">true</span>&#125;;</span><br><span class="line">            <span class="keyword">final</span> Throwable[] parallelOTAThrowable = <span class="keyword">new</span> Throwable[<span class="number">1</span>];</span><br><span class="line">            String targetISA;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetISA = ShareTinkerInternals.getCurrentInstructionSet();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"getCurrentInstructionSet fail:"</span> + throwable);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);</span></span><br><span class="line"><span class="comment">//                &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line">                <span class="comment">// don't ota on the front</span></span><br><span class="line">                deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">            Log.w(TAG, <span class="string">"systemOTA, try parallel oat dexes, targetISA:"</span> + targetISA);</span><br><span class="line">            <span class="comment">// change dir</span></span><br><span class="line">            optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 dex 文件作 odex 处理</span></span><br><span class="line">            TinkerDexOptimizer.optimizeAll(</span><br><span class="line">                legalFiles, optimizeDir, <span class="keyword">true</span>, targetISA,</span><br><span class="line">                <span class="keyword">new</span> TinkerDexOptimizer.ResultCallback() &#123;</span><br><span class="line">                    <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(File dexFile, File optimizedDir)</span> </span>&#123;</span><br><span class="line">                        start = System.currentTimeMillis();</span><br><span class="line">                        Log.i(TAG, <span class="string">"start to optimize dex:"</span> + dexFile.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File dexFile, File optimizedDir, File optimizedFile)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// Do nothing.</span></span><br><span class="line">                        Log.i(TAG, <span class="string">"success to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(File dexFile, File optimizedDir, Throwable thr)</span> </span>&#123;</span><br><span class="line">                        parallelOTAResult[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">                        parallelOTAThrowable[<span class="number">0</span>] = thr;</span><br><span class="line">                        Log.i(TAG, <span class="string">"fail to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!parallelOTAResult[<span class="number">0</span>]) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"parallel oat dexes failed"</span>);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable[<span class="number">0</span>]);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u52A0_u8F7Ddex"><a href="#u52A0_u8F7Ddex" class="headerlink" title="加载dex"></a>加载dex</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"install dexes failed"</span>);</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">       intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">       ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SystemClassLoaderAdder-installDexes"><a href="#SystemClassLoaderAdder-installDexes" class="headerlink" title="SystemClassLoaderAdder.installDexes"></a>SystemClassLoaderAdder.installDexes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"installDexes dexOptDir: "</span> + dexOptDir.getAbsolutePath() + <span class="string">", dex size:"</span> + files.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        files = createSortedAdditionalPathEntries(files);</span><br><span class="line">        ClassLoader classLoader = loader;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">            classLoader = AndroidNClassLoader.inject(loader, application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//because in dalvik, if inner class is not the same classloader with it wrapper class.</span></span><br><span class="line">        <span class="comment">//it won't fail at dex2opt</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            V23.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//install done</span></span><br><span class="line">        sPatchDexCount = files.size();</span><br><span class="line">        Log.i(TAG, <span class="string">"after loaded classloader: "</span> + classLoader + <span class="string">", dex size:"</span> + sPatchDexCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">            <span class="comment">//reset patch dex</span></span><br><span class="line">            SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在加载 dex 的时候，分别分成了四个版本：</p>
<ul>
<li>v4</li>
<li>v14</li>
<li>v19</li>
<li>v23</li>
</ul>
<p>其中如果是 SDK 24 及以上，需要改造一下 classloder</p>
<p>针对每个版本不同的源码，进行 dex 插入</p>
<p>我们就来看其中一个版本 v19</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                File optimizedDirectory)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">            suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A wrapper around</span><br><span class="line">     * &#123;<span class="doctag">@code</span> private static final dalvik.system.DexPathList#makeDexElements&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Method makeDexElements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class,</span><br><span class="line">                ArrayList.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure"</span>);</span><br><span class="line">            <span class="comment">// 对不同的 rom 做兼容，有的 rom 的 makeDexElements 方法参数类型是 List</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, List.class, File.class, List.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(List,File,List) failure"</span>);</span><br><span class="line">                <span class="keyword">throw</span> e1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先反射拿到反射得到 PathClassLoader 中的 pathList 对象,再将补丁文件通过反射调用makeDexElements 得到补丁文件的 Element[] ,再将补丁包的 Element[] 数组插入到 dexElements 中</p>
<p>另外，需要对 Android 7.0 及以上单独处理一下，具体看 <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a></p>
<p>加载补丁操作做好之后，最后还要检查一下，如果没加载成功就会执行卸载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">    <span class="comment">//reset patch dex</span></span><br><span class="line">    SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体验证补丁是否加载成功的方法就是判断 TinkerTestDexLoad.isPatch 的值。</p>
<p>在没有补丁加载的情况下都是返回 false 的, 在补丁中修改 isPatch 属性为 true 。所以只要反射拿到isPatch 的属性为 true 就说明补丁已经成功加载进来了。否则就调用 SystemClassLoaderAdder.uninstallPatchDex 执行卸载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninstallPatchDex</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPatchDexCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(classLoader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(classLoader);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(dexPathList, <span class="string">"dexElements"</span>, sPatchDexCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mPaths"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mFiles"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mZips"</span>, sPatchDexCount);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mDexs"</span>, sPatchDexCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卸载补丁可以说是加载补丁的逆向操作，具体操作可以分成 v4 和 v14 两个版本</p>
<p>具体的内容就是把 dexElements 中的头部 element 去除了。</p>
<p>到这，dex 补丁加载的流程结束了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" cl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(二):加载补丁流程]]></title>
    <link href="http://yuqirong.github.io/2019/02/27/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yuqirong.github.io/2019/02/27/Tinker源码分析(二)/</id>
    <published>2019-02-27T13:43:16.000Z</published>
    <updated>2019-03-14T15:54:09.840Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink" title="tryLoad"></a>tryLoad</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app)</span> </span>&#123;</span><br><span class="line">    Intent resultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">    <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</span><br><span class="line">    <span class="keyword">return</span> resultIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载的流程主要在 tryLoadPatchFilesInternal 里面。tryLoadPatchFilesInternal 方法很长，我们需要分段来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>一开始是各种校验</p>
<p>检查 tinker 是否开启</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tinkerFlag = app.getTinkerFlags();</span><br><span class="line"><span class="comment">// 检查 tinker 是否开启</span></span><br><span class="line"><span class="keyword">if</span> (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: tinker is disable, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前的进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前的进程，确保不是 :patch 进程</span></span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isInPatchProcess(app)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: we don't load patch with :patch process itself, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 tinker 目录，检查目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tinker 获取 tinker 目录，/data/data/tinker.sample.android/tinker</span></span><br><span class="line">File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</span><br><span class="line"><span class="keyword">if</span> (patchDirectoryFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:getPatchDirectory == null"</span>);</span><br><span class="line">    <span class="comment">//treat as not exist</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();</span><br><span class="line"><span class="comment">// 检查 tinker 目录是否存在</span></span><br><span class="line"><span class="comment">//check patch directory whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch dir not exist:"</span> + patchDirectoryPath);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 patch.info 文件是否存在, patch.info 是补丁信息文件，里面记录着新旧两个补丁版本的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件目录 /data/data/tinker.sample.android/tinker/patch.info</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch.info 补丁信息文件是否存在</span></span><br><span class="line"><span class="comment">//check patch info file whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchInfoFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch info not exist:"</span> + patchInfoFile.getAbsolutePath());</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取 patch.info 文件，并包装成一个 SharePatchInfo ，并检查 patchInfo 是否为空 (先加锁 file lock 再解锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//old = 641e634c5b8f1649c75caf73794acbdf</span></span><br><span class="line"><span class="comment">//new = 2c150d8560334966952678930ba67fa8</span></span><br><span class="line"><span class="comment">// tinker/info.lock</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch info 文件中的补丁版本信息</span></span><br><span class="line">patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"><span class="keyword">if</span> (patchInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查读取出来的 patchInfo 补丁版本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String oldVersion = patchInfo.oldVersion;</span><br><span class="line">String newVersion = patchInfo.newVersion;</span><br><span class="line">String oatDex = patchInfo.oatDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldVersion == <span class="keyword">null</span> || newVersion == <span class="keyword">null</span> || oatDex == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//it is nice to clean patch</span></span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchInfoCorrupted"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发现 patchInfo 中的 isRemoveNewVersion 为 true 并且在主进程中运行的话，就代表需要清除补丁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> mainProcess = ShareTinkerInternals.isInMainProcess(app);</span><br><span class="line"><span class="keyword">boolean</span> isRemoveNewVersion = patchInfo.isRemoveNewVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// So far new version is not loaded in main process and other processes.</span></span><br><span class="line"><span class="comment">// We can remove new version directory safely.</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; isRemoveNewVersion) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"found clean patch mark and we are in main process, delete patch file now."</span>);</span><br><span class="line">    <span class="comment">// 获取新的补丁文件夹，例如 patch-2c150d85</span></span><br><span class="line">    String patchName = SharePatchFileUtil.getPatchVersionDirectory(newVersion);</span><br><span class="line">    <span class="keyword">if</span> (patchName != <span class="keyword">null</span>) &#123;</span><br><span class="line">	     <span class="comment">// 删除新的补丁文件夹   </span></span><br><span class="line">        String patchVersionDirFullPath = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);</span><br><span class="line">        <span class="comment">// 如果旧版本和新版本一致，就把 oldVersion 和 newVersion 设置为空来清除补丁</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion.equals(newVersion)) &#123;</span><br><span class="line">            <span class="comment">// !oldVersion.equals(newVersion) means new patch is applied, just fall back to old one in that case.</span></span><br><span class="line">            <span class="comment">// Or we will set oldVersion and newVersion to empty string to clean patch.</span></span><br><span class="line">            oldVersion = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 !oldVersion.equals(newVersion) 意味着新补丁已经应用了，需要回退到原来的旧版本</span></span><br><span class="line">        newVersion = oldVersion;</span><br><span class="line">        patchInfo.oldVersion = oldVersion;</span><br><span class="line">        patchInfo.newVersion = newVersion;</span><br><span class="line">        <span class="comment">// 把数据重新写入 patchInfo 文件中</span></span><br><span class="line">        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);</span><br><span class="line">        <span class="comment">// 杀掉主进程以外的所有进程</span></span><br><span class="line">        ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</span><br></pre></td></tr></table></figure>
<p>根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> versionChanged = !(oldVersion.equals(newVersion));</span><br><span class="line"><span class="keyword">boolean</span> oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);</span><br><span class="line">oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);</span><br><span class="line"></span><br><span class="line">String version = oldVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</span></span><br><span class="line"><span class="keyword">if</span> (versionChanged &amp;&amp; mainProcess) &#123;</span><br><span class="line">    version = newVersion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isNullOrNil(version)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:version is blank, wait main process to restart"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前新版本补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//patch-641e634c</span></span><br><span class="line">String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</span><br><span class="line"><span class="keyword">if</span> (patchName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patchName is null"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c</span></span><br><span class="line">String patchVersionDirectory = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">File patchVersionDirectoryFile = <span class="keyword">new</span> File(patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!patchVersionDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionDirectoryNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件是否存在并且可读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</span></span><br><span class="line"><span class="keyword">final</span> String patchVersionFileRelPath = SharePatchFileUtil.getPatchVersionFile(version);</span><br><span class="line">File patchVersionFile = (patchVersionFileRelPath != <span class="keyword">null</span> ? <span class="keyword">new</span> File(patchVersionDirectoryFile.getAbsolutePath(), patchVersionFileRelPath) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionFileNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件签名以及补丁文件中的 tinker id 和基准包的 tinker id 是否一致。</p>
<p>注意，这里补丁文件的 tinker id 是当前补丁基准包的 tinker id ，也就是有 bug 的基准包 tinker id 。另外一个 new tinker id 是补丁加载完成后的 tinker id ，就是 bug 修复后的 tinker id 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ShareSecurityCheck securityCheck = <span class="keyword">new</span> ShareSecurityCheck(app);</span><br><span class="line"><span class="comment">// 1. 检查补丁包 apk 的签名</span></span><br><span class="line"><span class="comment">// 2. 检查基准包的 tinker id 与补丁包中是否一致</span></span><br><span class="line"><span class="comment">// 3. 检查 tinker 设置与补丁包中的类型是否符合</span></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkTinkerPackage"</span>);</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</span><br></pre></td></tr></table></figure>
<p>下面是 checkTinkerPackage 方法的具体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkTinkerPackage</span><span class="params">(Context context, <span class="keyword">int</span> tinkerFlag, File patchFile, ShareSecurityCheck securityCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查补丁文件签名和 tinker id 是否一致</span></span><br><span class="line">    <span class="comment">// 这里为了快速校验,就只检验补丁包内部以meta.txt结尾的文件的签名，而其他的文件的合法性则通过meta.txt文件内部记录的补丁文件Md5值来校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);</span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">        <span class="comment">// 检查配置的 tinker flag 和 meta.txt 是否匹配</span></span><br><span class="line">        <span class="comment">// 如果不匹配的话，中断接下来的流程</span></span><br><span class="line">        returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的情况,最多有四个文件是以meta.txt结尾的:</p>
<ul>
<li>package_meta.txt 补丁包的基本信息</li>
<li>dex_meta.txt dex补丁的信息</li>
<li>so_meta.txt so补丁的信息</li>
<li>res_meta.txt 资源补丁的信息</li>
</ul>
<p>如果开启了支持 dex 热修复，检查 dex_meta.txt 文件中记录的dex文件信息对应的dex文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/dex</span></span><br><span class="line">    <span class="comment">// 检查下发的meta文件中记录的dex信息中对应的dex文件是否存在</span></span><br><span class="line">    <span class="keyword">boolean</span> dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!dexCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:dex check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 so 热修复，检查 so_meta.txt 文件中记录的so文件信息对应的so文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 res 热修复，检查 res_meta.txt 文件中记录的res文件信息对应的res文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合条件的话就更新版本信息,并将最新的patch info更新入文件.在v1.7.5的版本开始有了isSystemOTA判断,</p>
<p>只要用户是ART环境并且做了OTA升级，则在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍重新生成odex，再加载dex补丁。否则会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//only work for art platform oat，because of interpret, refuse 4.4 art oat</span></span><br><span class="line"><span class="comment">//android o use quicken default, we don't need to use interpret mode</span></span><br><span class="line"><span class="keyword">boolean</span> isSystemOTA = ShareTinkerInternals.isVmArt()</span><br><span class="line">    &amp;&amp; ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)</span><br><span class="line">    &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">21</span> &amp;&amp; !ShareTinkerInternals.isAfterAndroidO();</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//we should first try rewrite patch info file, if there is a error, we can't load jar</span></span><br><span class="line"><span class="comment">// 把patch.info的旧版本的值更新为新版本的值，写入 patch.info 中</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; (versionChanged || oatModeChanged)) &#123;</span><br><span class="line">    patchInfo.oldVersion = version;</span><br><span class="line">    patchInfo.oatDir = oatDex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update old version to new</span></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"tryLoadPatchFiles:success to rewrite patch info, kill other process."</span>);</span><br><span class="line">    ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oatModeChanged) &#123;</span><br><span class="line">        <span class="comment">// delete interpret odex</span></span><br><span class="line">        <span class="comment">// for android o, directory change. Fortunately, we don't need to support android o interpret mode any more</span></span><br><span class="line">        Log.i(TAG, <span class="string">"tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files"</span>);</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirectory + <span class="string">"/"</span> + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁的安全次数最多三次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkSafeModeCount(app)) &#123;</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"checkSafeModeCount fail"</span>));</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkSafeModeCount fail"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁 jar ，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch jar</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</span><br><span class="line">    <span class="comment">// 如果是 ota 的话，更新 oat 的文件夹路径</span></span><br><span class="line">    <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">        <span class="comment">// update fingerprint after load success</span></span><br><span class="line">        patchInfo.fingerPrint = Build.FINGERPRINT;</span><br><span class="line">        patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;</span><br><span class="line">        <span class="comment">// reset to false</span></span><br><span class="line">        oatModeChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">            Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update oat dir</span></span><br><span class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerJars) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadDexesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁资源，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补丁加载流程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init component hotplug support.</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex &amp;&amp; isEnabledForResource) &#123;</span><br><span class="line">    ComponentHotplug.install(app, securityCheck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//all is ok!</span></span><br><span class="line">ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</span><br><span class="line">Log.i(TAG, <span class="string">"tryLoadPatchFiles: load end, ok!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink"]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(一):TinkerApplication]]></title>
    <link href="http://yuqirong.github.io/2019/02/24/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yuqirong.github.io/2019/02/24/Tinker源码分析(一)/</id>
    <published>2019-02-24T14:52:16.000Z</published>
    <updated>2019-03-09T17:25:02.046Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication" class="headerlink" title="自动生成TinkerApplication"></a>自动生成TinkerApplication</h1><p>接入 Tinker 第一步就是改造 Application 。官方推荐是利用 @DefaultLifeCycle 动态生成 Application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@DefaultLifeCycle</span>(application = <span class="string">"tinker.sample.android.app.SampleApplication"</span>,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们来解析一下 Tinker 是如何生成 Application 以及在 Application 中做了什么事？</p>
<p>看到 @DefaultLifeCycle 注解，我们可想而知应该是经过 processor 处理后动态生成了 Application 。</p>
<p>查看 Tinker 工程可以发现在 tinker-android-anno 下面有一个 AnnotationProcessor </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; supportedAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    supportedAnnotationTypes.add(DefaultLifeCycle.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> supportedAnnotationTypes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    processDefaultLifeCycle(roundEnv.getElementsAnnotatedWith(DefaultLifeCycle.class));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它正是处理 @DefaultLifeCycle 的。</p>
<p>下面重要看 processDefaultLifeCycle 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDefaultLifeCycle</span><span class="params">(Set&lt;? extends Element&gt; elements)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DefaultLifeCycle</span></span><br><span class="line">    <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">        DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);</span><br><span class="line"></span><br><span class="line">        String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();</span><br><span class="line">        String lifeCyclePackageName = lifeCycleClassName.substring(<span class="number">0</span>, lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String applicationClassName = ca.application();</span><br><span class="line">        <span class="keyword">if</span> (applicationClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            applicationClassName = lifeCyclePackageName + applicationClassName;</span><br><span class="line">        &#125;</span><br><span class="line">        String applicationPackageName = applicationClassName.substring(<span class="number">0</span>, applicationClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String loaderClassName = ca.loaderClass();</span><br><span class="line">        <span class="keyword">if</span> (loaderClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            loaderClassName = lifeCyclePackageName + loaderClassName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(is);</span><br><span class="line">        <span class="keyword">final</span> String template = scanner.useDelimiter(<span class="string">"\\A"</span>).next();</span><br><span class="line">        <span class="keyword">final</span> String fileContent = template</span><br><span class="line">            .replaceAll(<span class="string">"%PACKAGE%"</span>, applicationPackageName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION%"</span>, applicationClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION_LIFE_CYCLE%"</span>, lifeCyclePackageName + <span class="string">"."</span> + lifeCycleClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_FLAGS%"</span>, <span class="string">""</span> + ca.flags())</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOADER_CLASS%"</span>, <span class="string">""</span> + loaderClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOAD_VERIFY_FLAG%"</span>, <span class="string">""</span> + ca.loadVerifyFlag());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + <span class="string">"."</span> + applicationClassName);</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">"Creating "</span> + fileObject.toUri());</span><br><span class="line">            Writer writer = fileObject.openWriter();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(writer);</span><br><span class="line">                pw.print(fileContent);</span><br><span class="line">                pw.flush();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 processDefaultLifeCycle 方法看下来，其实主要在做的就是去读取一份模版，然后用注解中设置的值替换里面的一些占位符。这个模版就是 resouces/TinkerAnnoApplication.tmpl </p>
<pre><code>package %PACKAGE%;

import com.tencent.tinker.loader.app.TinkerApplication;

/**
 *
 * Generated application for tinker life cycle
 *
 */
public class %APPLICATION% extends TinkerApplication {

    public %APPLICATION%() {
        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%);
    }

}
</code></pre><p>最终生成的 SampleApplication 效果：</p>
<pre><code>/**
 *
 * Generated application for tinker life cycle
 *
 */
public class SampleApplication extends TinkerApplication {

    public SampleApplication() {
        super(7, &quot;tinker.sample.android.app.SampleApplicationLike&quot;, &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);
    }

}
</code></pre><h1 id="u89E3_u6790_TinkerApplication"><a href="#u89E3_u6790_TinkerApplication" class="headerlink" title="解析 TinkerApplication"></a>解析 TinkerApplication</h1><p>想要知道 TinkerApplication 里面干了什么？</p>
<p>一起看看 TinkerApplication.onCreate </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComponentHotplug.ensureComponentHotplugInstalled(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEnvironmentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"failed to make sure that ComponentHotplug logic is fine."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        invokeAppLikeOnCreate(applicationLike);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步，调用 ensureDelegate 创建 application 代理，即 applicationLike</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationLike == <span class="keyword">null</span>) &#123;</span><br><span class="line">        applicationLike = createDelegate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Use reflection to create the delegate so it doesn't need to go into the primary dex.</span></span><br><span class="line">        <span class="comment">// And we can also patch it</span></span><br><span class="line">        Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class,</span><br><span class="line">            <span class="keyword">long</span>.class, <span class="keyword">long</span>.class, Intent.class);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(<span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag,</span><br><span class="line">            applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"createDelegate failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用 invokeAppLikeOnCreate(applicationLike) 去回调 applicationLike 的 onCreate 方法。这样，applicationLike 和 application 的生命周期方法就做到同步了。另外，其余的生命周期方法也是如此来实现同步的，这里就不详细讲解了。</p>
<p>那么 Tinker 是什么时候加载的呢？</p>
<p>答案就在 attachBaseContext 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> TinkerUncaughtHandler(<span class="keyword">this</span>));</span><br><span class="line">    onBaseContextAttached(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class="line">        applicationStartMillisTime = System.currentTimeMillis();</span><br><span class="line">        loadTinker();</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        invokeAppLikeOnBaseContextAttached(applicationLike, base);</span><br><span class="line">        <span class="comment">//reset save mode</span></span><br><span class="line">        <span class="keyword">if</span> (useSafeMode) &#123;</span><br><span class="line">            ShareTinkerInternals.setSafeModeCount(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了 loadTinker 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></span><br><span class="line">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</span><br><span class="line">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">//has exception, put exception error code</span></span><br><span class="line">        tinkerResultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</span><br><span class="line">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 loaderClassName 就是上面 @DefaultLifeCycle 中定义的 loaderClass 。默认的是 com.tencent.tinker.loader.TinkerLoader ，也支持用户自定义 TinkerLoader 。</p>
<p>所以 loadTinker 中干的事就是利用反射执行了 TinkerLoader.tryLoad 方法。</p>
<p>至于在 tryLoad 方法中到底做了什么事，我们等到下一篇再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.github.io/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.github.io/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.github.io/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.github.io/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
