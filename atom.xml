<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[俞其荣的博客 | Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2019-07-06T09:40:34.012Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[LeakCanary源码解析]]></title>
    <link href="http://yuqirong.me/2019/07/06/LeakCanary%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2019/07/06/LeakCanary源码解析/</id>
    <published>2019-07-06T07:35:25.000Z</published>
    <updated>2019-07-06T09:40:34.012Z</updated>
    <content type="html"><![CDATA[<p>LeakCanary : <a href="https://github.com/square/leakcanary" target="_blank" rel="external">https://github.com/square/leakcanary</a></p>
<p>version : 1.6.3</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>LeakCanary 是一款专门用来侦测 Android 内存泄漏的类库。使用方式简单，代码侵入性低，基本上算是 Android 开发必备工具了。</p>
<p>今天就主要来分析一下 LeakCanary 的实现原理。在开头就简单地讲讲它的实现思路：LeakCanary 将检测的对象(一般是 Activity 或 Fragment)放入弱引用中，并且弱引用关联到引用队列中，触发 GC 之后，查看引用队列中是否存在该弱引用,如果发现没有，那么有可能发生内存泄漏了,dump 出堆内存快照进行分析。分析出泄漏实例后再查找到它的引用链，最后发送通知给开发者。</p>
<h1 id="Prepare"><a href="#Prepare" class="headerlink" title="Prepare"></a>Prepare</h1><p>这里先简单讲解一下 WeakReference 的知识。</p>
<p>Q: 如何检测一个对象是否被回收？<br>A: 采用 WeakReference + ReferenceQueue 的方案检测</p>
<h2 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h2><p>Reference 把内存分为 4 种状态，Active 、 Pending 、 Enqueued 、 Inactive。</p>
<ul>
<li>Active ：一般说来 Reference 被创建出来分配的状态都是 Active</li>
<li>Pending ：马上要放入队列（ReferenceQueue）的状态，也就是马上要回收的对象</li>
<li>Enqueued ：Reference 对象已经进入队列，即 Reference 对象已经被回收</li>
<li>Inactive ：Reference 从队列中取出后的最终状态，无法变成其他的状态。</li>
</ul>
<h2 id="ReferenceQueue"><a href="#ReferenceQueue" class="headerlink" title="ReferenceQueue"></a>ReferenceQueue</h2><p>引用队列，在 Reference 被回收的时候，Reference 会被添加到 ReferenceQueue 中。<br>作用：用来检测 Reference 是否被回收。</p>
<h2 id="u4EE3_u7801_u89E3_u91CA"><a href="#u4EE3_u7801_u89E3_u91CA" class="headerlink" title="代码解释"></a>代码解释</h2><p>下面这段代码来自于 <a href="https://www.jianshu.com/p/9cc0db9f7c52" target="_blank" rel="external">「Leakcanary 源码分析」看这一篇就够了</a></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个引用队列  </span></span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();  </span><br><span class="line">	</span><br><span class="line"><span class="comment">// 创建弱引用，此时状态为Active，并且Reference.pending为空，</span></span><br><span class="line"><span class="comment">// 当前Reference.queue = 上面创建的queue，并且next=null  </span></span><br><span class="line"><span class="comment">// reference 创建并关联 queue</span></span><br><span class="line">WeakReference reference = <span class="keyword">new</span> WeakReference(<span class="keyword">new</span> Object(), queue);  </span><br><span class="line">	</span><br><span class="line"><span class="comment">// 当GC执行后，由于是弱引用，所以回收该object对象，并且置于pending上，此时reference的状态为PENDING  </span></span><br><span class="line">System.gc();  </span><br><span class="line">  </span><br><span class="line"><span class="comment">// ReferenceHandler从 pending 中取下该元素，并且将该元素放入到queue中，</span></span><br><span class="line"><span class="comment">//此时Reference状态为ENQUEUED，Reference.queue = Reference.ENQUEUED </span></span><br><span class="line">  </span><br><span class="line"><span class="comment">// 当从queue里面取出该元素，则变为INACTIVE，Reference.queue = Reference.NULL  </span></span><br><span class="line">Reference reference1 = queue.remove();</span><br></pre></td></tr></table></figure>
<p>在 Reference 类加载的时候，Java 虚拟机会会创建一个最大优先级的后台线程，这个线程的工作就是不断检测 pending 是否为 null，如果不为 null，那么就将它放到 ReferenceQueue。因为 pending 不为 null，就说明引用所指向的对象已经被 GC，变成了不也达。</p>
<h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><p>LeakCanary 初始化的代码就一句 <code>LeakCanary.install(application)</code> 。所以我们就从入口开始看吧。</p>
<h2 id="LeakCanary-install"><a href="#LeakCanary-install" class="headerlink" title="LeakCanary.install"></a>LeakCanary.install</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@NonNull</span> <span class="function">RefWatcher <span class="title">install</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> refWatcher(application).listenerServiceClass(DisplayLeakService.class)</span><br><span class="line">      .excludedRefs(AndroidExcludedRefs.createAppDefaults().build())</span><br><span class="line">      .buildAndInstall();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@NonNull</span> <span class="function">AndroidRefWatcherBuilder <span class="title">refWatcher</span><span class="params">(@NonNull Context context)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> AndroidRefWatcherBuilder(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 install 方法中，使用了构造者模式来创建 RefWatcher 。我们直接看 AndroidRefWatcherBuilder 的 buildAndInstall 模式。</p>
<h2 id="AndroidRefWatcherBuilder-buildAndInstall"><a href="#AndroidRefWatcherBuilder-buildAndInstall" class="headerlink" title="AndroidRefWatcherBuilder.buildAndInstall"></a>AndroidRefWatcherBuilder.buildAndInstall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="annotation">@NonNull</span> <span class="function">RefWatcher <span class="title">buildAndInstall</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (LeakCanaryInternals.installedRefWatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> UnsupportedOperationException(<span class="string">"buildAndInstall() should only be called once."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 创建出 RefWatcher</span></span><br><span class="line">  RefWatcher refWatcher = build();</span><br><span class="line">  <span class="keyword">if</span> (refWatcher != DISABLED) &#123;</span><br><span class="line">    <span class="keyword">if</span> (enableDisplayLeakActivity) &#123;</span><br><span class="line">      LeakCanaryInternals.setEnabledAsync(context, DisplayLeakActivity.class, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 侦测 Activity</span></span><br><span class="line">    <span class="keyword">if</span> (watchActivities) &#123;</span><br><span class="line">      ActivityRefWatcher.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 侦测 Fragment</span></span><br><span class="line">    <span class="keyword">if</span> (watchFragments) &#123;</span><br><span class="line">      FragmentRefWatcher.Helper.install(context, refWatcher);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  LeakCanaryInternals.installedRefWatcher = refWatcher;</span><br><span class="line">  <span class="keyword">return</span> refWatcher;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来看 <code>ActivityRefWatcher.install(context, refWatcher);</code> 在这里我们就只看 ActivityRefWatcher 了，因为 FragmentRefWatcher 的原理也是差不多。</p>
<h2 id="AndroidRefWatcher-install"><a href="#AndroidRefWatcher-install" class="headerlink" title="AndroidRefWatcher.install"></a>AndroidRefWatcher.install</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(@NonNull Context context, @NonNull RefWatcher refWatcher)</span> </span>&#123;</span><br><span class="line">  Application application = (Application) context.getApplicationContext();</span><br><span class="line">  ActivityRefWatcher activityRefWatcher = <span class="keyword">new</span> ActivityRefWatcher(application, refWatcher);</span><br><span class="line"></span><br><span class="line">  application.registerActivityLifecycleCallbacks(activityRefWatcher.lifecycleCallbacks);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Application.ActivityLifecycleCallbacks lifecycleCallbacks =</span><br><span class="line">    <span class="keyword">new</span> ActivityLifecycleCallbacksAdapter() &#123;</span><br><span class="line">      <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityDestroyed</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        refWatcher.watch(activity);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<p>在 AndroidRefWatcher 中，只是去注册了 ActivityLifecycleCallbacks 接口。在 onActivityDestroyed 方法中调用 refWatcher 去观察该 Activity 有没有内存泄漏。这样，就不需要开发者手动地去写代码监听每一个 Activity 了。</p>
<h2 id="RefWatcher-watch"><a href="#RefWatcher-watch" class="headerlink" title="RefWatcher.watch"></a>RefWatcher.watch</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference)</span> </span>&#123;</span><br><span class="line">  watch(watchedReference, <span class="string">""</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">watch</span><span class="params">(Object watchedReference, String referenceName)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span> == DISABLED) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  checkNotNull(watchedReference, <span class="string">"watchedReference"</span>);</span><br><span class="line">  checkNotNull(referenceName, <span class="string">"referenceName"</span>);</span><br><span class="line">  <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="comment">// 创建出唯一的 key ，用来标示该 WeakReference</span></span><br><span class="line">  String key = UUID.randomUUID().toString();</span><br><span class="line">  <span class="comment">// 把该 key 加入到 Set 集合中</span></span><br><span class="line">  retainedKeys.add(key);</span><br><span class="line">  <span class="comment">// 创建弱引用，把 activity 传入</span></span><br><span class="line">  <span class="keyword">final</span> KeyedWeakReference reference =</span><br><span class="line">      <span class="keyword">new</span> KeyedWeakReference(watchedReference, key, referenceName, queue);</span><br><span class="line">  <span class="comment">// 观察该 Activity 有没有被GC回收</span></span><br><span class="line">  ensureGoneAsync(watchStartNanoTime, reference);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureGoneAsync</span><span class="params">(<span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime, <span class="keyword">final</span> KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里会调用 IdleHandler 等待主线程空闲的时候再执行</span></span><br><span class="line">  watchExecutor.execute(<span class="keyword">new</span> Retryable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="keyword">public</span> Retryable.<span class="function">Result <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="comment">// 确认 Activity 有没有被回收</span></span><br><span class="line">      <span class="keyword">return</span> ensureGone(reference, watchStartNanoTime);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建出一个有唯一标示的 WeakReference ，然后调用 ensureGone 来看看 Activity 有没有被回收。</p>
<h2 id="RefWatcher-ensureGone"><a href="#RefWatcher-ensureGone" class="headerlink" title="RefWatcher.ensureGone"></a>RefWatcher.ensureGone</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"ReferenceEquality"</span>) <span class="comment">// Explicitly checking for named null.</span></span><br><span class="line">Retryable.<span class="function">Result <span class="title">ensureGone</span><span class="params">(<span class="keyword">final</span> KeyedWeakReference reference, <span class="keyword">final</span> <span class="keyword">long</span> watchStartNanoTime)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> gcStartNanoTime = System.nanoTime();</span><br><span class="line">  <span class="keyword">long</span> watchDurationMs = NANOSECONDS.toMillis(gcStartNanoTime - watchStartNanoTime);</span><br><span class="line">  <span class="comment">//把 referenceQueue 中已经入列的弱引用取出</span></span><br><span class="line">  <span class="comment">//然后从 set 集合中把对应的 retainedKeys 移除</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (debuggerControl.isDebuggerAttached()) &#123;</span><br><span class="line">    <span class="comment">// The debugger can create false leaks.</span></span><br><span class="line">    <span class="keyword">return</span> RETRY;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果 set 中没有对应的key ，那就说明没有内存泄漏</span></span><br><span class="line">  <span class="keyword">if</span> (gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">return</span> DONE;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 触发 GC </span></span><br><span class="line">  gcTrigger.runGc();</span><br><span class="line">  <span class="comment">// 再检查一遍</span></span><br><span class="line">  removeWeaklyReachableReferences();</span><br><span class="line">  <span class="comment">// 如果在 set 中还有这个key，说明内存泄漏了</span></span><br><span class="line">  <span class="keyword">if</span> (!gone(reference)) &#123;</span><br><span class="line">    <span class="keyword">long</span> startDumpHeap = System.nanoTime();</span><br><span class="line">    <span class="keyword">long</span> gcDurationMs = NANOSECONDS.toMillis(startDumpHeap - gcStartNanoTime);</span><br><span class="line">    <span class="comment">// 调用 Debug.dumpHprofData dump出内存快照</span></span><br><span class="line">    File heapDumpFile = heapDumper.dumpHeap();</span><br><span class="line">    <span class="keyword">if</span> (heapDumpFile == RETRY_LATER) &#123;</span><br><span class="line">      <span class="comment">// Could not dump the heap.</span></span><br><span class="line">      <span class="keyword">return</span> RETRY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">long</span> heapDumpDurationMs = NANOSECONDS.toMillis(System.nanoTime() - startDumpHeap);</span><br><span class="line"></span><br><span class="line">    HeapDump heapDump = heapDumpBuilder.heapDumpFile(heapDumpFile).referenceKey(reference.key)</span><br><span class="line">        .referenceName(reference.name)</span><br><span class="line">        .watchDurationMs(watchDurationMs)</span><br><span class="line">        .gcDurationMs(gcDurationMs)</span><br><span class="line">        .heapDumpDurationMs(heapDumpDurationMs)</span><br><span class="line">        .build();</span><br><span class="line">    <span class="comment">// 分析内存, 这里的 heapdumpListener 实现类是 ServiceHeapDumpListener</span></span><br><span class="line">    heapdumpListener.analyze(heapDump);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> DONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">gone</span><span class="params">(KeyedWeakReference reference)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> !retainedKeys.contains(reference.key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeWeaklyReachableReferences</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// WeakReferences are enqueued as soon as the object to which they point to becomes weakly</span></span><br><span class="line">  <span class="comment">// reachable. This is before finalization or garbage collection has actually happened.</span></span><br><span class="line">  KeyedWeakReference ref;</span><br><span class="line">  <span class="keyword">while</span> ((ref = (KeyedWeakReference) queue.poll()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">    retainedKeys.remove(ref.key);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ensureGone 中逻辑就是反复地确认 Set 集合中还有没有 key ，如果没有的话就代表没有内存泄漏；反之，就很有可能发生了内存泄漏。</p>
<h2 id="ServiceHeapDumpListener-analyze"><a href="#ServiceHeapDumpListener-analyze" class="headerlink" title="ServiceHeapDumpListener.analyze"></a>ServiceHeapDumpListener.analyze</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ServiceHeapDumpListener</span> <span class="keyword">implements</span> <span class="title">HeapDump</span>.<span class="title">Listener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Context context;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ServiceHeapDumpListener</span><span class="params">(@NonNull <span class="keyword">final</span> Context context,</span><br><span class="line">      @NonNull <span class="keyword">final</span> Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listenerServiceClass = checkNotNull(listenerServiceClass, <span class="string">"listenerServiceClass"</span>);</span><br><span class="line">    <span class="keyword">this</span>.context = checkNotNull(context, <span class="string">"context"</span>).getApplicationContext();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">analyze</span><span class="params">(@NonNull HeapDump heapDump)</span> </span>&#123;</span><br><span class="line">    checkNotNull(heapDump, <span class="string">"heapDump"</span>);</span><br><span class="line">    <span class="comment">// HeapAnalyzerService 将运行在另外一个独立的进程中</span></span><br><span class="line">    HeapAnalyzerService.runAnalysis(context, heapDump, listenerServiceClass);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ServiceHeapDumpListener 这里主要调用了 HeapAnalyzerService 来分析内存。注意，HeapAnalyzerService 是运行在另外一个进程中的，不是主进程。</p>
<h2 id="HeapAnalyzerService-runAnalysis"><a href="#HeapAnalyzerService-runAnalysis" class="headerlink" title="HeapAnalyzerService.runAnalysis"></a>HeapAnalyzerService.runAnalysis</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runAnalysis</span><span class="params">(Context context, HeapDump heapDump,</span><br><span class="line">    Class&lt;? extends AbstractAnalysisResultService&gt; listenerServiceClass)</span> </span>&#123;</span><br><span class="line">  setEnabledBlocking(context, HeapAnalyzerService.class, <span class="keyword">true</span>);</span><br><span class="line">  setEnabledBlocking(context, listenerServiceClass, <span class="keyword">true</span>);</span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(context, HeapAnalyzerService.class);</span><br><span class="line">  intent.putExtra(LISTENER_CLASS_EXTRA, listenerServiceClass.getName());</span><br><span class="line">  intent.putExtra(HEAPDUMP_EXTRA, heapDump);</span><br><span class="line">  ContextCompat.startForegroundService(context, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HeapAnalyzerService 其实是继承了 IntentService 的。所以只要看 onHandleIntent 中的内容就好了，对应着也就是 onHandleIntentInForeground 方法。</p>
<h2 id="HeapAnalyzerService-onHandleIntentInForeground"><a href="#HeapAnalyzerService-onHandleIntentInForeground" class="headerlink" title="HeapAnalyzerService.onHandleIntentInForeground"></a>HeapAnalyzerService.onHandleIntentInForeground</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleIntentInForeground</span><span class="params">(@Nullable Intent intent)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">    CanaryLog.d(<span class="string">"HeapAnalyzerService received a null intent, ignoring."</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String listenerClassName = intent.getStringExtra(LISTENER_CLASS_EXTRA);</span><br><span class="line">  HeapDump heapDump = (HeapDump) intent.getSerializableExtra(HEAPDUMP_EXTRA);</span><br><span class="line"></span><br><span class="line">  HeapAnalyzer heapAnalyzer =</span><br><span class="line">      <span class="keyword">new</span> HeapAnalyzer(heapDump.excludedRefs, <span class="keyword">this</span>, heapDump.reachabilityInspectorClasses);</span><br><span class="line">  <span class="comment">// 分析内存，查找内存泄漏点以及引用链</span></span><br><span class="line">  AnalysisResult result = heapAnalyzer.checkForLeak(heapDump.heapDumpFile, heapDump.referenceKey,</span><br><span class="line">      heapDump.computeRetainedHeapSize);</span><br><span class="line">  <span class="comment">// 找到后，发送通知给开发者    </span></span><br><span class="line">  AbstractAnalysisResultService.sendResultToListener(<span class="keyword">this</span>, listenerClassName, heapDump, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>分析内存的步骤主要在 HeapAnalyzer 中。</p>
<h2 id="HeapAnalyzer-checkForLeak"><a href="#HeapAnalyzer-checkForLeak" class="headerlink" title="HeapAnalyzer.checkForLeak"></a>HeapAnalyzer.checkForLeak</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="annotation">@NonNull</span> <span class="function">AnalysisResult <span class="title">checkForLeak</span><span class="params">(@NonNull File heapDumpFile,</span><br><span class="line">    @NonNull String referenceKey,</span><br><span class="line">    <span class="keyword">boolean</span> computeRetainedSize)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">long</span> analysisStartNanoTime = System.nanoTime();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!heapDumpFile.exists()) &#123;</span><br><span class="line">    Exception exception = <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File does not exist: "</span> + heapDumpFile);</span><br><span class="line">    <span class="keyword">return</span> failure(exception, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    listener.onProgressUpdate(READING_HEAP_DUMP_FILE);</span><br><span class="line">    HprofBuffer buffer = <span class="keyword">new</span> MemoryMappedFileBuffer(heapDumpFile);</span><br><span class="line">    HprofParser parser = <span class="keyword">new</span> HprofParser(buffer);</span><br><span class="line">    listener.onProgressUpdate(PARSING_HEAP_DUMP);</span><br><span class="line">    Snapshot snapshot = parser.parse();</span><br><span class="line">    listener.onProgressUpdate(DEDUPLICATING_GC_ROOTS);</span><br><span class="line">    deduplicateGcRoots(snapshot);</span><br><span class="line">    listener.onProgressUpdate(FINDING_LEAKING_REF);</span><br><span class="line">    <span class="comment">// 发现内存泄漏的实例</span></span><br><span class="line">    Instance leakingRef = findLeakingReference(referenceKey, snapshot);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// False alarm, weak reference was cleared in between key check and heap dump.</span></span><br><span class="line">    <span class="comment">// 如果实例不存在，那就说明没有内存泄漏</span></span><br><span class="line">    <span class="keyword">if</span> (leakingRef == <span class="keyword">null</span>) &#123;</span><br><span class="line">      String className = leakingRef.getClassObj().getClassName();</span><br><span class="line">      <span class="keyword">return</span> noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 分析出对应的引用链</span></span><br><span class="line">    <span class="keyword">return</span> findLeakTrace(analysisStartNanoTime, snapshot, leakingRef, computeRetainedSize);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    <span class="keyword">return</span> failure(e, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要有两个方法的看点：</p>
<ul>
<li>findLeakingReference</li>
<li>findLeakTrace</li>
</ul>
<p>我们先来看第一个 findLeakingReference 。</p>
<h2 id="HeapAnalyzer-findLeakingReference"><a href="#HeapAnalyzer-findLeakingReference" class="headerlink" title="HeapAnalyzer.findLeakingReference"></a>HeapAnalyzer.findLeakingReference</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Instance <span class="title">findLeakingReference</span><span class="params">(String key, Snapshot snapshot)</span> </span>&#123;</span><br><span class="line">  ClassObj refClass = snapshot.findClass(KeyedWeakReference.class.getName());</span><br><span class="line">  <span class="keyword">if</span> (refClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">        <span class="string">"Could not find the "</span> + KeyedWeakReference.class.getName() + <span class="string">" class in the heap dump."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  List&lt;String&gt; keysFound = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Instance instance : refClass.getInstancesList()) &#123;</span><br><span class="line">    List&lt;ClassInstance.FieldValue&gt; values = classInstanceValues(instance);</span><br><span class="line">    Object keyFieldValue = fieldValue(values, <span class="string">"key"</span>);</span><br><span class="line">    <span class="keyword">if</span> (keyFieldValue == <span class="keyword">null</span>) &#123;</span><br><span class="line">      keysFound.add(<span class="keyword">null</span>);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String keyCandidate = asString(keyFieldValue);</span><br><span class="line">    <span class="keyword">if</span> (keyCandidate.equals(key)) &#123;</span><br><span class="line">      <span class="keyword">return</span> fieldValue(values, <span class="string">"referent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    keysFound.add(keyCandidate);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">      <span class="string">"Could not find weak reference with key "</span> + key + <span class="string">" in "</span> + keysFound);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还记得之前 KeyedWeakReference 中的那个唯一标示 key 吗？对，这里找内存泄漏的实例也是靠它。</p>
<p>通过那个 key 可以找出 KeyedWeakReference 实例，然后 KeyedWeakReference 实例中 referent 全局变量就是我们要找的内存泄漏实例。也就是我们的 Activity/Fragment 对象。</p>
<p>这样，就完成了内存泄漏的实例查找。然后我们再来看第二个点 findLeakTrace 方法。</p>
<h2 id="HeapAnalyzer-findLeakTrace"><a href="#HeapAnalyzer-findLeakTrace" class="headerlink" title="HeapAnalyzer.findLeakTrace"></a>HeapAnalyzer.findLeakTrace</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AnalysisResult <span class="title">findLeakTrace</span><span class="params">(<span class="keyword">long</span> analysisStartNanoTime, Snapshot snapshot,</span><br><span class="line">    Instance leakingRef, <span class="keyword">boolean</span> computeRetainedSize)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  listener.onProgressUpdate(FINDING_SHORTEST_PATH);</span><br><span class="line">  ShortestPathFinder pathFinder = <span class="keyword">new</span> ShortestPathFinder(excludedRefs);</span><br><span class="line">  ShortestPathFinder.Result result = pathFinder.findPath(snapshot, leakingRef);</span><br><span class="line"></span><br><span class="line">  String className = leakingRef.getClassObj().getClassName();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// False alarm, no strong reference path to GC Roots.</span></span><br><span class="line">  <span class="keyword">if</span> (result.leakingNode == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> noLeak(className, since(analysisStartNanoTime));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  listener.onProgressUpdate(BUILDING_LEAK_TRACE);</span><br><span class="line">  LeakTrace leakTrace = buildLeakTrace(result.leakingNode);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">long</span> retainedSize;</span><br><span class="line">  <span class="keyword">if</span> (computeRetainedSize) &#123;</span><br><span class="line"></span><br><span class="line">    listener.onProgressUpdate(COMPUTING_DOMINATORS);</span><br><span class="line">    <span class="comment">// Side effect: computes retained size.</span></span><br><span class="line">    snapshot.computeDominators();</span><br><span class="line"></span><br><span class="line">    Instance leakingInstance = result.leakingNode.instance;</span><br><span class="line"></span><br><span class="line">    retainedSize = leakingInstance.getTotalRetainedSize();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> check O sources and see what happened to android.graphics.Bitmap.mBuffer</span></span><br><span class="line">    <span class="keyword">if</span> (SDK_INT &lt;= N_MR1) &#123;</span><br><span class="line">      listener.onProgressUpdate(COMPUTING_BITMAP_SIZE);</span><br><span class="line">      retainedSize += computeIgnoredBitmapRetainedSize(snapshot, leakingInstance);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    retainedSize = AnalysisResult.RETAINED_HEAP_SKIPPED;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> leakDetected(result.excludingKnownLeaks, className, leakTrace, retainedSize,</span><br><span class="line">      since(analysisStartNanoTime));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>findLeakTrace 方法总体的逻辑就是</p>
<ul>
<li>建立内存泄漏点到 GC Roots 的最短引用链</li>
<li>计算整个内存泄漏的大小 retained size</li>
</ul>
<p>这里的在内存快照中引用链建立等都是在 haha 库中完成的。haha 是 square 出品一款 Android Heap 分析库。</p>
<p>具体可以看这里 ：<a href="https://github.com/square/haha" target="_blank" rel="external">https://github.com/square/haha</a></p>
<p>到这里，LeakCanary 整体的逻辑分析就讲完了。下面再给出一张流程图。</p>
<h1 id="u6D41_u7A0B_u56FE"><a href="#u6D41_u7A0B_u56FE" class="headerlink" title="流程图"></a>流程图</h1><p><img src="/uploads/20190706/20190706173423.png" alt="LeakCanary流程图"></p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>其实 LeakCanary 整体的代码流程很清晰，阅读起来也比较易懂，也给我们好好地上了一课。</p>
<p>Read the fucking source code!</p>
<h1 id="Reference-1"><a href="#Reference-1" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://www.jianshu.com/p/9cc0db9f7c52" target="_blank" rel="external">「Leakcanary 源码分析」看这一篇就够了</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>LeakCanary : <a href="https://github.com/square/leakcanary" target="_blank" rel="external">https://github.com/square/leakcanary</a></p>
<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="内存泄漏" scheme="http://yuqirong.me/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[闲谈Android中的内存泄漏]]></title>
    <link href="http://yuqirong.me/2019/06/28/%E9%97%B2%E8%B0%88Android%E4%B8%AD%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    <id>http://yuqirong.me/2019/06/28/闲谈Android中的内存泄漏/</id>
    <published>2019-06-28T15:42:44.000Z</published>
    <updated>2019-06-29T06:05:09.225Z</updated>
    <content type="html"><![CDATA[<h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><p>在长久以来的 Android 开发过程中，内存泄漏一直是一个比较头疼的问题。内存泄漏会导致应用卡顿，用户体验不佳，甚至会造成应用崩溃的严重后果。所以如何科学地进行内存管理一直是大家探讨的话题，从一开始主动使用 MAT 分析 hprof 文件，到后来 LeakCanary “被动”的接收内存泄漏消息。应用中发现内存泄漏的手段越来越多了，操作也越来越便捷，但内存泄漏的问题还是不能轻易忽视的，提高应用的体验和质量也是迫在眉睫。</p>
<p>那今天，就从最基本的开始聊聊内存泄漏。</p>
<h1 id="Part_2"><a href="#Part_2" class="headerlink" title="Part 2"></a>Part 2</h1><p>内存泄漏简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。我们所说的内存泄露是针对于堆内存而言，堆内存中存放的就是引用指向的对象实体。</p>
<p>在这里先科普下内存分配的三种策略。（以下这段讲解来自于 <a href="https://segmentfault.com/a/1190000003984512" target="_blank" rel="external">《内存泄露从入门到精通三部曲之基础知识篇》</a>）</p>
<ul>
<li>静态的，使用的内存空间是静态存储区</li>
<li>栈式的，使用的内存空间是栈区</li>
<li>堆式的，使用的内存空间是堆区</li>
</ul>
<p>静态存储区（方法区）：内存在程序编译的时候就已经分配好，这块内存在程序整个运行期间都存在。它主要存放静态数据、全局static数据和常量。 </p>
<p>栈区：在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束时这些存储单元自动被释放。栈内存分配运算内置于处理器的指令集中，效率很高，但是分配的内存容量有限。 </p>
<p>堆区：亦称动态内存分配。程序在运行的时候用malloc或new申请任意大小的内存，程序员自己负责在适当的时候用free或delete释放内存（Java则依赖垃圾回收器）。动态内存的生存期可以由我们决定，如果我们不释放内存，程序将在最后才释放掉动态内存。 但是，良好的编程习惯是：如果某动态内存不再使用，需要将其释放掉。<br> 接下来我们集中说下堆和栈的区别：</p>
<p>在函数中（说明是局部变量）定义的一些基本类型的变量和对象的引用变量都是在函数的栈内存中分配。当在一段代码块中定义一个变量时，java就在栈中为这个变量分配内存空间，当超过变量的作用域后，java会自动释放掉为该变量分配的内存空间，该内存空间可以立刻被另作他用。<br> <br>堆内存用于存放所有由new创建的对象（内容包括该对象其中的所有成员变量）和数组。在堆中分配的内存，由java虚拟机自动垃圾回收器来管理。在堆中产生了一个数组或者对象后，还可以在栈中定义一个特殊的变量，这个变量的取值等于数组或者对象在堆内存中的首地址，在栈中的这个特殊的变量就变成了数组或者对象的引用变量，以后就可以在程序中使用栈内存中的引用变量来访问堆中的数组或者对象，引用变量相当于为数组或者对象起的一个别名，或者代号。<br> <br>堆是不连续的内存区域（因为系统是用链表来存储空闲内存地址，自然不是连续的），堆大小受限于计算机系统中有效的虚拟内存（32bit系统理论上是4G），所以堆的空间比较灵活，比较大。栈是一块连续的内存区域，大小是操作系统预定好的，windows下栈大小是2M（也有是1M，在编译时确定，VC中可设置）。<br> <br>对于堆，频繁的new/delete会造成大量内存碎片，使程序效率降低。对于栈，它是先进后出的队列，进出一一对应，不产生碎片，运行效率稳定高。</p>
<p>说了这么多了，我们来看一个例子吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">int</span> age = <span class="number">10</span>;</span><br><span class="line">	<span class="keyword">private</span> School school = <span class="keyword">new</span> School();</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doHomework</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		Book book = <span class="keyword">new</span> Book();</span><br><span class="line">		<span class="keyword">int</span> pageNo = <span class="number">15</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Student s = <span class="keyword">new</span> Student();</span><br></pre></td></tr></table></figure>
<p>s 自己存放在栈中，而 s 指向的对象实体存放在堆中；</p>
<p>其中 s 这个对象实体中的全局变量 age 和 school 都是存放在堆中（包括基本数据类型、引用和引用的对象实体）</p>
<p>doHomework 中的引用变量 book 和局部变量 pageNo 是存放在栈中的，而引用变量 book 指向的对象是存放在堆中的。</p>
<p><strong>结论</strong>：（以下结论来自于<a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=401527654&amp;idx=1&amp;sn=eb91bf358b28ede2b7a984c08e5cdab0#rd" target="_blank" rel="external">《Android 内存泄漏探讨》</a>）</p>
<p>局部变量的基本数据类型和引用存储于栈中，引用的对象实体存储于堆中。—— 因为它们属于方法中的变量，生命周期随方法而结束。<br>成员变量全部存储与堆中（包括基本数据类型，引用和引用的对象实体）—— 因为它们属于类，类对象终究是要被new出来使用的。</p>
<h1 id="Part_3"><a href="#Part_3" class="headerlink" title="Part 3"></a>Part 3</h1><p>那么有没有想过，内存为什么会泄露？</p>
<p>Java的内存垃圾回收机制是从程序的主要运行对象(如静态对象/寄存器/栈上指向的堆内存对象等)开始检查引用链，当遍历一遍后得到上述这些无法回收的对象和他们所引用的对象链，组成无法回收的对象集合，而其他孤立对象（集）就作为垃圾回收。GC为了能够正确释放对象，必须监控每一个对象的运行状态，包括对象的申请、引用、被引用、赋值等，GC都需要进行监控。监视对象状态是为了更加准确地、及时地释放对象，而释放对象的根本原则就是该对象不再被引用。</p>
<p>在Java中，这些无用的对象都由GC负责回收，因此程序员不需要考虑这部分的内存泄露。虽然，我们有几个函数可以访问GC，例如运行GC的函数System.gc()，但是根据Java语言规范定义，该函数不保证JVM的垃圾收集器一定会执行。因为不同的JVM实现者可能使用不同的算法管理GC。通常GC的线程的优先级别较低。JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。</p>
<p>GC过程与对象的引用类型是严重相关的，我们来看看Java对引用的分类Strong reference, SoftReference, WeakReference, PhatomReference<br> <img src="/uploads/20190629/20190629134830.png" alt="java引用"></p>
<p>在Android应用的开发中，为了防止内存溢出，在处理一些占用内存大而且声明周期较长的对象时候，可以尽量应用软引用和弱引用技术。</p>
<p>如果只是想避免OutOfMemory异常的发生，则可以使用软引用。如果对于应用的性能更在意，想尽快回收一些占用内存比较大的对象，则可以使用弱引用。</p>
<p>另外可以根据对象是否经常使用来判断选择软引用还是弱引用。如果该对象可能会经常使用的，就尽量用软引用。如果该对象不被使用的可能性更大些，就可以用弱引用。</p>
<p><strong>结论</strong>：<br> 堆内存中的长生命周期的对象持有短生命周期对象的强/软引用，尽管短生命周期对象已经不再需要，但是因为长生命周期对象持有它的引用而导致不能被回收，这就是Java中内存泄露的根本原因。</p>
<h1 id="Part_4"><a href="#Part_4" class="headerlink" title="Part 4"></a>Part 4</h1><p>Android中常见的内存泄漏问题：</p>
<ul>
<li>单例造成的内存泄露</li>
<li>InnerClass匿名内部类</li>
<li>Activity Context 的不正确使用</li>
<li>Handler引起的内存泄漏</li>
<li>注册监听器的泄漏</li>
<li>Cursor，Stream没有close，View没有recyle</li>
<li>集合中对象没清理造成的内存泄漏</li>
<li>WebView造成的泄露</li>
<li>构造Adapter时，没有使用缓存的ConvertView</li>
</ul>
<p>具体可以参考  <a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=1116PDhSmvxU6YwfbJuVCEJx#rd" target="_blank" rel="external">Android内存泄漏分析心得</a></p>
<h1 id="Part_5"><a href="#Part_5" class="headerlink" title="Part 5"></a>Part 5</h1><p>Android 中检测内存泄漏的工具</p>
<ul>
<li>MAT</li>
<li>Android Profiler</li>
<li>LeakCanary</li>
</ul>
<h1 id="Part_6"><a href="#Part_6" class="headerlink" title="Part 6"></a>Part 6</h1><p>参考资料</p>
<ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzA4MjA0MTc4NQ==&amp;mid=401527654&amp;idx=1&amp;sn=eb91bf358b28ede2b7a984c08e5cdab0#rd" target="_blank" rel="external">Android 内存泄漏探讨</a></li>
<li><a href="https://segmentfault.com/a/1190000003984512" target="_blank" rel="external">内存泄露从入门到精通三部曲之基础知识篇</a></li>
<li><a href="https://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=2649796884&amp;idx=1&amp;sn=92b4e344060362128e4a86d6132c3736&amp;chksm=f1fcc54cc68b4c5add08371265320163381ea81333daea5664b94e9a12246a34cfaa31e6f0b3&amp;mpshare=1&amp;scene=1&amp;srcid=1116PDhSmvxU6YwfbJuVCEJx#rd" target="_blank" rel="external">Android内存泄漏分析心得</a></li>
<li><a href="https://droidyue.com/blog/2016/11/23/memory-leaks-in-android/" target="_blank" rel="external">系统剖析Android中的内存泄漏</a>
 </li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><p>在长久以来的 Android 开发过程中，内存泄漏一直是一个比较头疼的问题。内存泄漏会导致应用卡顿，用户体验]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="内存泄漏" scheme="http://yuqirong.me/tags/%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入理解Binder]]></title>
    <link href="http://yuqirong.me/2019/05/21/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Binder/"/>
    <id>http://yuqirong.me/2019/05/21/深入理解Binder/</id>
    <published>2019-05-21T15:26:43.000Z</published>
    <updated>2019-06-04T14:42:41.681Z</updated>
    <content type="html"><![CDATA[<p>之前一直对 Binder 理解不够透彻，仅仅知道一些皮毛，所以最近抽空深入理解一下，并在这里做个小结。</p>
<h1 id="Binder_u662F_u4EC0_u4E48"><a href="#Binder_u662F_u4EC0_u4E48" class="headerlink" title="Binder是什么"></a>Binder是什么</h1><p>Binder 是 Android 系统中实现 IPC (进程间通信)的一种机制。Binder 原意是“胶水、粘合剂”，所以可以想象它的用途就是像胶水一样把两个进程紧紧“粘”在一起，从而可以方便地实现 IPC 。</p>
<h1 id="u8FDB_u7A0B_u901A_u4FE1"><a href="#u8FDB_u7A0B_u901A_u4FE1" class="headerlink" title="进程通信"></a>进程通信</h1><p>那么为什么会有进程通信呢？这是因为在 Linux 中进程之间是隔离的，也就是说 A 进程不知道有 B 进程的存在，相应的 B 进程也不知道 A 进程的存在。A 、B 两进程的内存是不共享的，所以 A 进程的数据想要传给 B 进程就需要用到 IPC 。</p>
<p>在这里再科普一下进程空间的知识点：进程空间可以分为用户空间和内核空间。简单的说，用户空间是用户程序运行的空间，而内核空间就是内核运行的空间了。因为像内核这么底层、至关重要的东西肯定是不会简单地让用户程序随便调用的，所以需要把内核保护起来，就创造了内核空间，让内核运行在内核空间中，这样就不会被用户空间随便干扰到了。两个进程之间的用户空间是不共享的，但是内核空间是共享的。</p>
<p>所以到这里，有些同学会有个大胆的想法，两个进程间的通信可以利用内核空间来实现啊，因为它们的内核空间是共享的，这样数据不就传过去了嘛。但是接着又来了一个问题：为了保证安全性，用户空间和内核空间也是隔离的。那么如何把数据从发送方的用户空间传到内核空间呢？</p>
<p>针对这个问题提供了<strong>系统调用</strong>来解决，可以让用户程序调用内核资源。系统调用是用户空间访问内核空间的唯一方式，保证了所有的资源访问都是在内核的控制下进行的，避免了用户程序对系统资源的越权访问，提升了系统安全性和稳定性(这段话来自<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)。我们平时的网络、I/O操作其实都是通过系统调用在内核空间中运行的（也就是<strong>内核态</strong>）。</p>
<p>至此，关于 IPC 我们有了一个大概的实现方案：A 进程的数据通过系统调用把数据传输到内核空间（即copy_from_user），内核空间再利用系统调用把数据传输到 B 进程（即 copy_to_user）。这也正是目前 Linux 中传统 IPC 通信的实现原理，可以看到这其中会有两次数据拷贝。</p>
<p><img src="/uploads/20190521/20190521235434.jpg" alt="IPC原理"></p>
<p>(图片来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<p>Linux 中的一些 IPC 方式：</p>
<ol>
<li>管道（Pipe）</li>
<li>信号（Signal）</li>
<li>报文（Message）队列（消息队列）</li>
<li>共享内存</li>
<li>信号量（semaphore）</li>
<li>套接字（Socket）</li>
</ol>
<h1 id="Binder_IPC__u539F_u7406"><a href="#Binder_IPC__u539F_u7406" class="headerlink" title="Binder IPC 原理"></a>Binder IPC 原理</h1><p>通过上面的讲解我们可以知道，IPC 是需要内核空间来支持的。Linux 中的管道、socket 等都是在内核中的。但是在 Linux 系统里面是没有 Binder 的。那么 Android 中是如何利用 Binder 来实现 IPC 的呢？</p>
<p>这就要讲到 Linux 中的<strong>动态内核可加载模块</strong>。动态内核可加载模块是具有独立功能的程序，它可以被单独编译，但是不能独立运行。它在运行时被链接到内核作为内核的一部分运行。这样，Android 系统就可以通过动态添加一个内核模块运行在内核空间，用户进程之间通过这个内核模块作为桥梁来实现通信。（这段话来自<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>）在 Android 中，这个内核模块也就是 Binder 驱动。</p>
<p>另外，Binder IPC 原理相比较上面传统的 Linux IPC 而言，只需要一次数据拷贝就可以完成了。那么究竟是怎么做到的呢？</p>
<p>其实 Binder 是借助于 mmap （内存映射）来实现的。mmap 用于文件或者其它对象映射进内存，通常是用在有物理介质的文件系统上的。mmap 简单的来说就是可以把用户空间的内存区域和内核空间的内存区域之间建立映射关系，这样就减少了数据拷贝的次数，任何一方的对内存区域的改动都将被反应给另一方。</p>
<p>所以，Binder 的做法就是建立一个虚拟设备（设备驱动是/dev/binder），然后在内核空间创建一块数据接收的缓存区，这个缓存区会和内存缓存区以及接收数据进程的用户空间建立映射，这样发送数据进程把数据发送到内存缓存区，该数据就会被间接映射到接收进程的用户空间中，减少了一次数据拷贝。具体可以看下图理解</p>
<p><img src="/uploads/20190521/20190522105623.jpg" alt="Binder IPC原理"></p>
<p>(图片来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<h1 id="u4E3A_u4EC0_u4E48_u9009_u62E9Binder"><a href="#u4E3A_u4EC0_u4E48_u9009_u62E9Binder" class="headerlink" title="为什么选择Binder"></a>为什么选择Binder</h1><p>Binder 的优点</p>
<ol>
<li><strong>效率高，性能好</strong>：传统的 Linux 下 IPC 通信都需要两次数据拷贝，即一次 copy_from_user 和一次 copy_to_user ，而 binder 只需要一次拷贝；</li>
<li><strong>安全性高</strong>：Binder 可以做安全校验，如果没有相应权限可以拒绝提供连接。在底层为每个 app 添加UID/PID，鉴别进程身份；</li>
<li><strong>稳定性高</strong>：Binder 是 C/S 架构，Client 端和 Server 端分工明确，互不干扰。并且 Client 端可以设置死亡通知，及时监听 Server 端的存活情况；</li>
<li><strong>使用简单，对开发者友好</strong>：Binder 封装了底层 IPC 通信，让开发者无需关心底层细节，也无需关心 Server 端的实现细节。只需要面向 binder 对象就可以完成 IPC 通信，简单无脑。</li>
</ol>
<h1 id="Binder_u901A_u4FE1_u8FC7_u7A0B"><a href="#Binder_u901A_u4FE1_u8FC7_u7A0B" class="headerlink" title="Binder通信过程"></a>Binder通信过程</h1><p>在整个 Binder 通信过程中，可以分为四个部分：</p>
<ul>
<li>Client : 即客户端进程；</li>
<li>Server : 即服务端进程；</li>
<li>Binder 驱动 : 驱动负责进程之间 Binder 通信的建立，Binder 在进程之间的传递，Binder 引用计数管理，数据包在进程之间的传递和交互等一系列底层支持；(来自<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Android Binder 设计与实现》</a>)</li>
<li>ServiceManager : 作用是将字符形式的 Binder 名字转化成 Client 中对该 Binder 的引用，使得 Client 能够通过 Binder 的名字获得对 Binder 实体的引用。(来自<a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">《Android Binder 设计与实现》</a>)</li>
</ul>
<p>其中 Client 和 Server 是应用层实现的，而 Binder 驱动和 ServiceManager 是 Android 系统底层实现的。</p>
<p>具体流程如下：</p>
<ol>
<li>首先由一个进程使用 BINDER_SET_CONTEXT_MGR 命令通过 Binder 驱动将自己注册为 ServiceManager 。</li>
<li>Server 进程向 Binder 驱动发起 Binder 注册的请求，驱动为这个 Binder 创建位于内核中的实体节点以及 ServiceManager 对实体的引用，将名字以及新建的引用打包传给 ServiceManager，ServiceManger 将其填入查找表。</li>
<li>Client 通过服务名称，在 Binder 驱动的帮助下从 ServiceManager 中获取到对 Binder 实体的引用，通过这个引用就能实现和 Server 进程的通信。</li>
<li>然后 Binder 驱动为跨进程通信做准备，Binder 驱动在内核中创建接收缓存区，并将接收缓存区与内核缓存区、接收进程的用户空间做内存映射。</li>
<li>Client 进程调用 copy_from_user 将数据发送到内核缓存区（Client 进程中当前的线程将被挂起），因为之前做了内存映射，所以这就相当于把数据间接发送到了 Server 端。然后 Binder 驱动通知 Server 解包；</li>
<li>收到 Binder 驱动的通知后，Server 进程从线程池中取出线程，进行数据解包并调用相关的目标方法，最后将方法执行的返回值写入到内存中；</li>
<li>又因为之前做了内存映射，所以方法的返回值就间接地发送到了内核缓存区中，最后 Binder 驱动通知 Client 进程获取方法的返回值（此时 Client 进程被唤醒），然后 Client 进程调用 copy_to_user 将返回值发送到自己的用户空间中。</li>
</ol>
<p><img src="/uploads/20190521/20190530122134.jpg" alt="Binder通信过程"></p>
<p>(Binder通信过程示意图来自于<a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">《写给 Android 应用工程师的 Binder 原理剖析》</a>)</p>
<h1 id="Binder_u539F_u7406_u8BE6_u89E3"><a href="#Binder_u539F_u7406_u8BE6_u89E3" class="headerlink" title="Binder原理详解"></a>Binder原理详解</h1><ul>
<li><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="external">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></li>
</ul>
<h1 id="u53C2_u8003"><a href="#u53C2_u8003" class="headerlink" title="参考"></a>参考</h1><ul>
<li><a href="https://juejin.im/post/5acccf845188255c3201100f" target="_blank" rel="external">写给 Android 应用工程师的 Binder 原理剖析</a></li>
<li><a href="https://www.jianshu.com/p/4ee3fd07da14" target="_blank" rel="external">图文详解 Android Binder跨进程通信的原理</a></li>
<li><a href="https://blog.csdn.net/universus/article/details/6211589" target="_blank" rel="external">Android Binder设计与实现 - 设计篇</a></li>
<li><a href="https://www.jianshu.com/p/af2993526daf" target="_blank" rel="external">Binder学习指南</a></li>
<li><a href="https://blog.csdn.net/freekiteyu/article/details/70082302" target="_blank" rel="external">一篇文章了解相见恨晚的 Android Binder 进程间通讯机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前一直对 Binder 理解不够透彻，仅仅知道一些皮毛，所以最近抽空深入理解一下，并在这里做个小结。</p>
<h1 id="Binder_u662F_u4EC0_u4E48"><a href="#Binder_u662F_u4EC0_u4E48" class="head]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Binder" scheme="http://yuqirong.me/tags/Binder/"/>
    
      <category term="IPC" scheme="http://yuqirong.me/tags/IPC/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Activity生命周期调用流程]]></title>
    <link href="http://yuqirong.me/2019/04/09/Activity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E8%B0%83%E7%94%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.me/2019/04/09/Activity生命周期调用流程/</id>
    <published>2019-04-09T14:26:55.000Z</published>
    <updated>2019-04-11T16:08:58.470Z</updated>
    <content type="html"><![CDATA[<p>注：源码分析基于 Android SDK API 28 </p>
<p>在前一篇中，我们分析了 startActivity 的整个流程，并且也讲到了何时调用了 onCreate() 。</p>
<p>那么就会有一个疑问，其他的生命周期方法是在哪里被调用的呢？今天就来揭开这个谜底。</p>
<p>我们知道，Activity A 启动 Activity B ，其生命周期方法调用如下：</p>
<ol>
<li>Activity A onPause()</li>
<li>Activity B onCreate()</li>
<li>Activity B onStart()</li>
<li>Activity B onResume()</li>
<li>Activity A onStop()</li>
</ol>
<p>那首先我们来看看 Activity A 的 onPause() 是什么地方调用的？</p>
<h1 id="onPause_28_29"><a href="#onPause_28_29" class="headerlink" title="onPause()"></a>onPause()</h1><p>在前一篇文章中讲到，startActivity 的流程中有一步是 resumeTopActivityInnerLocked 。</p>
<p>我们来看一下其中的源码片段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line"><span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">            <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">    pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 startPausingLocked 方法的名字上来看，这就是去调用 onPause 方法的入口。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">startPausingLocked</span><span class="params">(<span class="keyword">boolean</span> userLeaving, <span class="keyword">boolean</span> uiSleeping,</span><br><span class="line">        ActivityRecord resuming, <span class="keyword">boolean</span> pauseImmediately)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Going to pause when pause is already pending for "</span> + mPausingActivity</span><br><span class="line">                + <span class="string">" state="</span> + mPausingActivity.getState());</span><br><span class="line">        <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">            <span class="comment">// Avoid recursion among check for sleep and complete pause during sleeping.</span></span><br><span class="line">            <span class="comment">// Because activity will be paused immediately after resume, just let pause</span></span><br><span class="line">            <span class="comment">// be completed by the order of activity paused from clients.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityRecord prev = mResumedActivity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Slog.wtf(TAG, <span class="string">"Trying to pause when nothing is resumed"</span>);</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev == resuming) &#123;</span><br><span class="line">        Slog.wtf(TAG, <span class="string">"Trying to pause activity that is in process of being resumed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to PAUSING: "</span> + prev);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Start pausing: "</span> + prev);</span><br><span class="line">    mPausingActivity = prev;</span><br><span class="line">    mLastPausedActivity = prev;</span><br><span class="line">    mLastNoHistoryActivity = (prev.intent.getFlags() &amp; Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">            || (prev.info.flags &amp; ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span> ? prev : <span class="keyword">null</span>;</span><br><span class="line">    prev.setState(PAUSING, <span class="string">"startPausingLocked"</span>);</span><br><span class="line">    prev.getTask().touchActiveTime();</span><br><span class="line">    clearLaunchTime(prev);</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.getLaunchTimeTracker().stopFullyDrawnTraceIfNeeded(getWindowingMode());</span><br><span class="line"></span><br><span class="line">    mService.updateCpuStats();</span><br><span class="line">    <span class="comment">// 这里开始调用 onPause</span></span><br><span class="line">    <span class="keyword">if</span> (prev.app != <span class="keyword">null</span> &amp;&amp; prev.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Enqueueing pending pause: "</span> + prev);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            EventLogTags.writeAmPauseActivity(prev.userId, System.identityHashCode(prev),</span><br><span class="line">                    prev.shortComponentName, <span class="string">"userLeaving="</span> + userLeaving);</span><br><span class="line">            mService.updateUsageStats(prev, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(prev.app.thread, prev.appToken,</span><br><span class="line">                    PauseActivityItem.obtain(prev.finishing, userLeaving,</span><br><span class="line">                            prev.configChangeFlags, pauseImmediately));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Ignore exception, if process died other code will cleanup.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</span><br><span class="line">            mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">            mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mPausingActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are not going to sleep, we want to ensure the device is</span></span><br><span class="line">    <span class="comment">// awake until the next activity is started.</span></span><br><span class="line">    <span class="keyword">if</span> (!uiSleeping &amp;&amp; !mService.isSleepingOrShuttingDownLocked()) &#123;</span><br><span class="line">        mStackSupervisor.acquireLaunchWakelock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mPausingActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Have the window manager pause its key dispatching until the new</span></span><br><span class="line">        <span class="comment">// activity has started.  If we're pausing the activity just because</span></span><br><span class="line">        <span class="comment">// the screen is being turned off and the UI is sleeping, don't interrupt</span></span><br><span class="line">        <span class="comment">// key dispatch; the same activity will pick it up again on wakeup.</span></span><br><span class="line">        <span class="keyword">if</span> (!uiSleeping) &#123;</span><br><span class="line">            prev.pauseKeyDispatchingLocked();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (DEBUG_PAUSE) &#123;</span><br><span class="line">             Slog.v(TAG_PAUSE, <span class="string">"Key dispatch not paused for screen off"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pauseImmediately) &#123;</span><br><span class="line">            <span class="comment">// If the caller said they don't want to wait for the pause, then complete</span></span><br><span class="line">            <span class="comment">// the pause now.</span></span><br><span class="line">            completePauseLocked(<span class="keyword">false</span>, resuming);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            schedulePauseTimeout(prev);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity failed to schedule the</span></span><br><span class="line">        <span class="comment">// pause, so just treat it as being paused now.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_PAUSE) Slog.v(TAG_PAUSE, <span class="string">"Activity not running, resuming next."</span>);</span><br><span class="line">        <span class="keyword">if</span> (resuming == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mStackSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和调用 onCreate 一样，onPause 也是利用 Transaction 来完成的。不过这里的是 PauseActivityItem 。</p>
<p>追踪到 PauseActivityItem 的 execute 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityPause"</span>);</span><br><span class="line">    <span class="comment">// 调用 ActivityThread 的 handlePauseActivity 方法</span></span><br><span class="line">    client.handlePauseActivity(token, mFinished, mUserLeaving, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="string">"PAUSE_ACTIVITY_ITEM"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现还是一个套路，最终还是要去 ActivityThread 中找答案。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished, <span class="keyword">boolean</span> userLeaving,</span><br><span class="line">        <span class="keyword">int</span> configChanges, PendingTransactionActions pendingActions, String reason)</span> </span>&#123;</span><br><span class="line">    ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (userLeaving) &#123;</span><br><span class="line">            performUserLeavingActivity(r);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line">        performPauseActivity(r, finished, reason, pendingActions);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            QueuedWork.waitToFinish();</span><br><span class="line">        &#125;</span><br><span class="line">        mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点关注 performPauseActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Bundle <span class="title">performPauseActivity</span><span class="params">(ActivityClientRecord r, <span class="keyword">boolean</span> finished, String reason,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">            <span class="comment">// If we are finishing, we won't call onResume() in certain cases.</span></span><br><span class="line">            <span class="comment">// So here we likewise don't want to call onPause() if the activity</span></span><br><span class="line">            <span class="comment">// isn't resumed.</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Performing pause of activity that is not resumed: "</span></span><br><span class="line">                + r.intent.getComponent().toShortString());</span><br><span class="line">        Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finished) &#123;</span><br><span class="line">        r.activity.mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Pre-Honeycomb apps always save their state before pausing</span></span><br><span class="line">    <span class="comment">// 调用 Activity 的 OnSaveInstanceState 方法</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> shouldSaveState = !r.activity.mFinished &amp;&amp; r.isPreHoneycomb();</span><br><span class="line">    <span class="keyword">if</span> (shouldSaveState) &#123;</span><br><span class="line">        callActivityOnSaveInstanceState(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 onPause</span></span><br><span class="line">    performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Notify any outstanding on paused listeners</span></span><br><span class="line">    ArrayList&lt;OnActivityPausedListener&gt; listeners;</span><br><span class="line">    <span class="keyword">synchronized</span> (mOnPauseListeners) &#123;</span><br><span class="line">        listeners = mOnPauseListeners.remove(r.activity);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> size = (listeners != <span class="keyword">null</span> ? listeners.size() : <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">        listeners.get(i).onPaused(r.activity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Bundle oldState = pendingActions != <span class="keyword">null</span> ? pendingActions.getOldState() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (oldState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We need to keep around the original state, in case we need to be created again.</span></span><br><span class="line">        <span class="comment">// But we only do this for pre-Honeycomb apps, which always save their state when</span></span><br><span class="line">        <span class="comment">// pausing, so we can not have them save their state when restarting from a paused</span></span><br><span class="line">        <span class="comment">// state. For HC and later, we want to (and can) let the state be saved as the</span></span><br><span class="line">        <span class="comment">// normal part of stopping the activity.</span></span><br><span class="line">        <span class="keyword">if</span> (r.isPreHoneycomb()) &#123;</span><br><span class="line">            r.state = oldState;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> shouldSaveState ? r.state : <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// 调用 Activity.onPause</span></span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to pause activity "</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终由 mInstrumentation 内部调用 Activity.performPause 。而 performPause 方法内部又调用了 onPause 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity.performPause</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onPause();</span><br><span class="line">    writeEventLog(LOG_AM_ON_PAUSE_CALLED, <span class="string">"performPause"</span>);</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onCreate_28_29"><a href="#onCreate_28_29" class="headerlink" title="onCreate()"></a>onCreate()</h1><p>onCreate 的生命周期调用在前一篇中已经分析过了，所以在这里就不讲了。</p>
<p>如果有需要的话可以看前一篇博客。</p>
<h1 id="onResume_28_29"><a href="#onResume_28_29" class="headerlink" title="onResume()"></a>onResume()</h1><p>在前一篇中讲到，<code>resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)</code> 方法中有一段代码</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">transaction</span><span class="class">.setLifecycleStateRequest</span>(</span><br><span class="line">                        <span class="tag">ResumeActivityItem</span><span class="class">.obtain</span>(<span class="tag">next</span><span class="class">.app</span><span class="class">.repProcState</span>,</span><br><span class="line">                                <span class="tag">mService</span><span class="class">.isNextTransitionForward</span>()));</span><br><span class="line"><span class="tag">mService</span><span class="class">.getLifecycleManager</span>()<span class="class">.scheduleTransaction</span>(<span class="tag">transaction</span>);</span><br></pre></td></tr></table></figure>
<p>可以看到 transaction 将最后的生命周期状态设置为了 resume 。</p>
<p>根据前一篇博客的分析，代码最后会执行 ResumeActivityItem.execute</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityResume"</span>);</span><br><span class="line">    client.handleResumeActivity(token, <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, mIsForward,</span><br><span class="line">            <span class="string">"RESUME_ACTIVITY"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 execute 中调用了 ActivityThread 的 handleResumeActivity 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest, <span class="keyword">boolean</span> isForward,</span><br><span class="line">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO Push resumeArgs into the activity for consideration</span></span><br><span class="line">    <span class="comment">// 请关注这里</span></span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We didn't actually resume the activity, so skipping any follow-up actions.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = r.activity;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Resume "</span> + r + <span class="string">" started activity: "</span> + a.mStartedActivity</span><br><span class="line">                + <span class="string">", hideForNow: "</span> + r.hideForNow + <span class="string">", finished: "</span> + a.mFinished);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> forwardBit = isForward</span><br><span class="line">            ? WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the window hasn't yet been added to the window manager,</span></span><br><span class="line">    <span class="comment">// and this guy didn't finish itself or start another activity,</span></span><br><span class="line">    <span class="comment">// then go ahead and add the window.</span></span><br><span class="line">    <span class="keyword">boolean</span> willBeVisible = !a.mStartedActivity;</span><br><span class="line">    <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            willBeVisible = ActivityManager.getService().willActivityBeVisible(</span><br><span class="line">                    a.getActivityToken());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> e.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.window == <span class="keyword">null</span> &amp;&amp; !a.mFinished &amp;&amp; willBeVisible) &#123;</span><br><span class="line">        r.window = r.activity.getWindow();</span><br><span class="line">        View decor = r.window.getDecorView();</span><br><span class="line">        decor.setVisibility(View.INVISIBLE);</span><br><span class="line">        ViewManager wm = a.getWindowManager();</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        a.mDecor = decor;</span><br><span class="line">        l.type = WindowManager.LayoutParams.TYPE_BASE_APPLICATION;</span><br><span class="line">        l.softInputMode |= forwardBit;</span><br><span class="line">        <span class="keyword">if</span> (r.mPreserveWindow) &#123;</span><br><span class="line">            a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">            r.mPreserveWindow = <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">// Normally the ViewRoot sets up callbacks with the Activity</span></span><br><span class="line">            <span class="comment">// in addView-&gt;ViewRootImpl#setView. If we are instead reusing</span></span><br><span class="line">            <span class="comment">// the decor view we have to notify the view root that the</span></span><br><span class="line">            <span class="comment">// callbacks may have changed.</span></span><br><span class="line">            ViewRootImpl impl = decor.getViewRootImpl();</span><br><span class="line">            <span class="keyword">if</span> (impl != <span class="keyword">null</span>) &#123;</span><br><span class="line">                impl.notifyChildRebuilt();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a.mVisibleFromClient) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!a.mWindowAdded) &#123;</span><br><span class="line">                a.mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">                wm.addView(decor, l);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// The activity will get a callback for this &#123;@link LayoutParams&#125; change</span></span><br><span class="line">                <span class="comment">// earlier. However, at that time the decor will not be set (this is set</span></span><br><span class="line">                <span class="comment">// in this method), so no action will be taken. This call ensures the</span></span><br><span class="line">                <span class="comment">// callback occurs with the decor set.</span></span><br><span class="line">                a.onWindowAttributesChanged(l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the window has already been added, but during resume</span></span><br><span class="line">        <span class="comment">// we started another activity, then don't yet make the</span></span><br><span class="line">        <span class="comment">// window visible.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!willBeVisible) &#123;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Launch "</span> + r + <span class="string">" mStartedActivity set"</span>);</span><br><span class="line">        r.hideForNow = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Get rid of anything left hanging around.</span></span><br><span class="line">    cleanUpPendingRemoveWindows(r, <span class="keyword">false</span> <span class="comment">/* force */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The window is now visible if it has been added, we are not</span></span><br><span class="line">    <span class="comment">// simply finishing, and we are not starting another activity.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; willBeVisible &amp;&amp; r.activity.mDecor != <span class="keyword">null</span> &amp;&amp; !r.hideForNow) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.newConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">            performConfigurationChangedForActivity(r, r.newConfig);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) &#123;</span><br><span class="line">                Slog.v(TAG, <span class="string">"Resuming activity "</span> + r.activityInfo.name + <span class="string">" with newConfig "</span></span><br><span class="line">                        + r.activity.mCurrentConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            r.newConfig = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Resuming "</span> + r + <span class="string">" with isForward="</span> + isForward);</span><br><span class="line">        WindowManager.LayoutParams l = r.window.getAttributes();</span><br><span class="line">        <span class="keyword">if</span> ((l.softInputMode</span><br><span class="line">                &amp; WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION)</span><br><span class="line">                != forwardBit) &#123;</span><br><span class="line">            l.softInputMode = (l.softInputMode</span><br><span class="line">                    &amp; (~WindowManager.LayoutParams.SOFT_INPUT_IS_FORWARD_NAVIGATION))</span><br><span class="line">                    | forwardBit;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">                ViewManager wm = a.getWindowManager();</span><br><span class="line">                View decor = r.window.getDecorView();</span><br><span class="line">                wm.updateViewLayout(decor, l);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        r.activity.mVisibleFromServer = <span class="keyword">true</span>;</span><br><span class="line">        mNumVisibleActivities++;</span><br><span class="line">        <span class="keyword">if</span> (r.activity.mVisibleFromClient) &#123;</span><br><span class="line">            r.activity.makeVisible();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.nextIdle = mNewActivities;</span><br><span class="line">    mNewActivities = r;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Scheduling idle handler for "</span> + r);</span><br><span class="line">    Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 handleResumeActivity 中调用了 performResumeActivity 来完成 Activity 的 resume 操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityClientRecord <span class="title">performResumeActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finalStateRequest,</span><br><span class="line">        String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) &#123;</span><br><span class="line">        Slog.v(TAG, <span class="string">"Performing resume of "</span> + r + <span class="string">" finished="</span> + r.activity.mFinished);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || r.activity.mFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.getLifecycleState() == ON_RESUME) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!finalStateRequest) &#123;</span><br><span class="line">            <span class="keyword">final</span> RuntimeException e = <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Trying to resume activity which is already resumed"</span>);</span><br><span class="line">            Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">            Slog.e(TAG, r.getStateString());</span><br><span class="line">            <span class="comment">// TODO(lifecycler): A double resume request is possible when an activity</span></span><br><span class="line">            <span class="comment">// receives two consequent transactions with relaunch requests and "resumed"</span></span><br><span class="line">            <span class="comment">// final state requests and the second relaunch is omitted. We still try to</span></span><br><span class="line">            <span class="comment">// handle two resume requests for the final state. For cases other than this</span></span><br><span class="line">            <span class="comment">// one, we don't expect it to happen.</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finalStateRequest) &#123;</span><br><span class="line">        r.hideForNow = <span class="keyword">false</span>;</span><br><span class="line">        r.activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.onStateNotSaved();</span><br><span class="line">        r.activity.mFragments.noteStateNotSaved();</span><br><span class="line">        checkAndBlockForNetworkAccess();</span><br><span class="line">        <span class="keyword">if</span> (r.pendingIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverNewIntents(r, r.pendingIntents);</span><br><span class="line">            r.pendingIntents = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (r.pendingResults != <span class="keyword">null</span>) &#123;</span><br><span class="line">            deliverResults(r, r.pendingResults, reason);</span><br><span class="line">            r.pendingResults = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 Activity 的 performResume 方法</span></span><br><span class="line">        r.activity.performResume(r.startsNotResumed, reason);</span><br><span class="line"></span><br><span class="line">        r.state = <span class="keyword">null</span>;</span><br><span class="line">        r.persistentState = <span class="keyword">null</span>;</span><br><span class="line">        r.setState(ON_RESUME);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to resume activity "</span></span><br><span class="line">                    + r.intent.getComponent().toShortString() + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>activity.performResume 的内部将 onResume 回调的操作交给了 mInstrumentation 来处理。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performResume</span><span class="params">(<span class="keyword">boolean</span> followedByPause, String reason)</span> </span>&#123;</span><br><span class="line">    performRestart(<span class="keyword">true</span> <span class="comment">/* start */</span>, reason);</span><br><span class="line"></span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    mLastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mAutoFillResetNeeded) &#123;</span><br><span class="line">        <span class="comment">// When Activity is destroyed in paused state, and relaunch activity, there will be</span></span><br><span class="line">        <span class="comment">// extra onResume and onPause event,  ignore the first onResume and onPause.</span></span><br><span class="line">        <span class="comment">// see ActivityThread.handleRelaunchActivity()</span></span><br><span class="line">        mAutoFillIgnoreFirstResumePause = followedByPause;</span><br><span class="line">        <span class="keyword">if</span> (mAutoFillIgnoreFirstResumePause &amp;&amp; DEBUG_LIFECYCLE) &#123;</span><br><span class="line">            Slog.v(TAG, <span class="string">"autofill will ignore first pause when relaunching "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// mResumed is set by the instrumentation</span></span><br><span class="line">    mInstrumentation.callActivityOnResume(<span class="keyword">this</span>);</span><br><span class="line">    writeEventLog(LOG_AM_ON_RESUME_CALLED, reason);</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// invisible activities must be finished before onResume() completes</span></span><br><span class="line">    <span class="keyword">if</span> (!mVisibleFromClient &amp;&amp; !mFinished) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"An activity without a UI must call finish() before onResume() completes"</span>);</span><br><span class="line">        <span class="keyword">if</span> (getApplicationInfo().targetSdkVersion</span><br><span class="line">                &gt; android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                    <span class="string">" did not call finish() prior to onResume() completing"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Now really resume, and install the current status bar and menu.</span></span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mFragments.dispatchResume();</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line"></span><br><span class="line">    onPostResume();</span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onPostResume()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 mInstrumentation.callActivityOnResume 内部调用了 Activity 的 onResume 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnResume</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.mResumed = <span class="keyword">true</span>;</span><br><span class="line">    activity.onResume();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                am.match(activity, activity, activity.getIntent());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onStart_28_29"><a href="#onStart_28_29" class="headerlink" title="onStart()"></a>onStart()</h1><p>可能有些同学会觉得奇怪，怎么从 onCreate 直接跳到 onResume 了？不是应该还有一个 onStart 么？</p>
<p>那接下来，我们就来看看 onStart 是哪里被调用的。</p>
<p>话还要从 transaction 开始说起。</p>
<p>一开始 transaction 设置了 LaunchActivityItem ，然后又设置了生命周期状态 ResumeActivityItem 。</p>
<p>所以可以简单地看出，onCreate -&gt; onResume ，中间并没有加 onStart 。那么 onStart 是哪里在调用呢？</p>
<p>我们来看下 TransactionExecutor.execute 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(<span class="string">"Start resolving transaction for client: "</span> + mTransactionHandler + <span class="string">", token: "</span> + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(<span class="string">"End resolving transaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>经过上一篇中分析，我们知道执行 <code>executeCallbacks(transaction);</code> 之后，Activity 就完成了 onCreate 的调用，所以此时 Activity 的状态应该是 ON_CREATE 。</p>
<p>然后来看看 executeLifecycleState 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">executeLifecycleState</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleItem == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No lifecycle request, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"Resolving lifecycle state: "</span> + lifecycleItem);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Ignore requests for non-existent client records for now.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Cycle to the state right before the final requested state.</span></span><br><span class="line">    <span class="comment">// 这里的 lifecycleItem.getTargetState() 正是 ResumeActivityItem.ON_RESUME</span></span><br><span class="line">    cycleToPath(r, lifecycleItem.getTargetState(), <span class="keyword">true</span> <span class="comment">/* excludeLastState */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Execute the final transition with proper parameters.</span></span><br><span class="line">    lifecycleItem.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">    lifecycleItem.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>重点来关注下 cycleToPath 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cycleToPath</span><span class="params">(ActivityClientRecord r, <span class="keyword">int</span> finish,</span><br><span class="line">        <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> start = r.getLifecycleState();</span><br><span class="line">    log(<span class="string">"Cycle from: "</span> + start + <span class="string">" to: "</span> + finish + <span class="string">" excludeLastState:"</span> + excludeLastState);</span><br><span class="line">    <span class="comment">// 这里需要我们重点来关注</span></span><br><span class="line">    <span class="keyword">final</span> IntArray path = mHelper.getLifecyclePath(start, finish, excludeLastState);</span><br><span class="line">    <span class="comment">// 去执行 path 中的生命周期</span></span><br><span class="line">    performLifecycleSequence(r, path);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用 ActivityThread 中对应的生命周期方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLifecycleSequence</span><span class="params">(ActivityClientRecord r, IntArray path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = path.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, state; i &lt; size; i++) &#123;</span><br><span class="line">        state = path.get(i);</span><br><span class="line">        log(<span class="string">"Transitioning to state: "</span> + state);</span><br><span class="line">        <span class="keyword">switch</span> (state) &#123;</span><br><span class="line">            <span class="keyword">case</span> ON_CREATE:</span><br><span class="line">                mTransactionHandler.handleLaunchActivity(r, mPendingActions,</span><br><span class="line">                        <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_START:</span><br><span class="line">                mTransactionHandler.handleStartActivity(r, mPendingActions);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESUME:</span><br><span class="line">                mTransactionHandler.handleResumeActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        r.isForward, <span class="string">"LIFECYCLER_RESUME_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_PAUSE:</span><br><span class="line">                mTransactionHandler.handlePauseActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finished */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* userLeaving */</span>, <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions,</span><br><span class="line">                        <span class="string">"LIFECYCLER_PAUSE_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_STOP:</span><br><span class="line">                mTransactionHandler.handleStopActivity(r.token, <span class="keyword">false</span> <span class="comment">/* show */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, mPendingActions, <span class="keyword">false</span> <span class="comment">/* finalStateRequest */</span>,</span><br><span class="line">                        <span class="string">"LIFECYCLER_STOP_ACTIVITY"</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_DESTROY:</span><br><span class="line">                mTransactionHandler.handleDestroyActivity(r.token, <span class="keyword">false</span> <span class="comment">/* finishing */</span>,</span><br><span class="line">                        <span class="number">0</span> <span class="comment">/* configChanges */</span>, <span class="keyword">false</span> <span class="comment">/* getNonConfigInstance */</span>,</span><br><span class="line">                        <span class="string">"performLifecycleSequence. cycling to:"</span> + path.get(size - <span class="number">1</span>));</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> ON_RESTART:</span><br><span class="line">                mTransactionHandler.performRestartActivity(r.token, <span class="keyword">false</span> <span class="comment">/* start */</span>);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Unexpected lifecycle state: "</span> + state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 mHelper.getLifecyclePath 返回的 path 直接传入到 performLifecycleSequence 方法中。</p>
<p>而 performLifecycleSequence 方法里面一堆 switch case 正是去调用生命周期的，可以看到有 ON_START 的身影。我们的可以猜想到，在 mHelper.getLifecyclePath 方法中应该会返回 ON_START 。这样在 performLifecycleSequence 中就会去调用 <code>mTransactionHandler.handleStartActivity(r, mPendingActions)</code> 了。</p>
<p>那么我们来看看 mHelper.getLifecyclePath 中的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> IntArray <span class="title">getLifecyclePath</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> finish, <span class="keyword">boolean</span> excludeLastState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (start == UNDEFINED || finish == UNDEFINED) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can't resolve lifecycle path for undefined state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (start == ON_RESTART || finish == ON_RESTART) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                <span class="string">"Can't start or finish in intermittent RESTART state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (finish == PRE_ON_CREATE &amp;&amp; start != finish) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Can only start in pre-onCreate state"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mLifecycleSequence.clear();</span><br><span class="line">    <span class="keyword">if</span> (finish &gt;= start) &#123;</span><br><span class="line">        <span class="comment">// just go there</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= finish; i++) &#123;</span><br><span class="line">            mLifecycleSequence.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// finish &lt; start, can't just cycle down</span></span><br><span class="line">        <span class="keyword">if</span> (start == ON_PAUSE &amp;&amp; finish == ON_RESUME) &#123;</span><br><span class="line">            <span class="comment">// Special case when we can just directly go to resumed state.</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESUME);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (start &lt;= ON_STOP &amp;&amp; finish &gt;= ON_START) &#123;</span><br><span class="line">            <span class="comment">// Restart and go to required state.</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to stopped state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_STOP; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Restart</span></span><br><span class="line">            mLifecycleSequence.add(ON_RESTART);</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_START; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Relaunch and go to required state</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Go to destroyed state first.</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = start + <span class="number">1</span>; i &lt;= ON_DESTROY; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Go to required state</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = ON_CREATE; i &lt;= finish; i++) &#123;</span><br><span class="line">                mLifecycleSequence.add(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remove last transition in case we want to perform it with some specific params.</span></span><br><span class="line">    <span class="keyword">if</span> (excludeLastState &amp;&amp; mLifecycleSequence.size() != <span class="number">0</span>) &#123;</span><br><span class="line">        mLifecycleSequence.remove(mLifecycleSequence.size() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mLifecycleSequence;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完上面这一段代码，相信你已经大致的明白了吧。上面这段代码中主要做的就是把“中间路径”给计算出来。</p>
<p>比如起点是 ON_CREATE , 终点是 ON_RESUME 。所以“中间路径”就是 [ON_START, ON_RESUME] 。但是之前传入的 excludeLastState 参数是 true 。所以还要减掉最后一个终点，因为“中间路径”就是 [ON_START] 了。</p>
<p>这样一连贯起来，我们就明白了 onStart 是怎么调用了的吧！</p>
<p>那么接着看吧。有了 ON_START 后，会调用 ActivityThread.handleStartActivity</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStartActivity</span><span class="params">(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Activity activity = r.activity;</span><br><span class="line">    <span class="keyword">if</span> (r.activity == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): What do we do in this case?</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!r.stopped) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Can't start activity that is not stopped."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">        <span class="comment">// TODO(lifecycler): How can this happen?</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start</span></span><br><span class="line">    <span class="comment">// 调用 performStart</span></span><br><span class="line">    activity.performStart(<span class="string">"handleStartActivity"</span>);</span><br><span class="line">    r.setState(ON_START);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pendingActions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No more work to do.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Restore instance state</span></span><br><span class="line">    <span class="comment">// 调用 OnRestoreInstanceState</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldRestoreInstanceState()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.state != <span class="keyword">null</span> || r.persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state,</span><br><span class="line">                        r.persistentState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnRestoreInstanceState(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Call postOnCreate()</span></span><br><span class="line">    <span class="keyword">if</span> (pendingActions.shouldCallOnPostCreate()) &#123;</span><br><span class="line">        activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state,</span><br><span class="line">                    r.persistentState);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mInstrumentation.callActivityOnPostCreate(activity, r.state);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">" did not call through to super.onPostCreate()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 handleStartActivity 里面调用了 Activity.performStart</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performStart</span><span class="params">(String reason)</span> </span>&#123;</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">    mFragments.noteStateNotSaved();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.execPendingActions();</span><br><span class="line">    <span class="comment">// 调用 Instrumentation 的 callActivityOnStart</span></span><br><span class="line">    mInstrumentation.callActivityOnStart(<span class="keyword">this</span>);</span><br><span class="line">    writeEventLog(LOG_AM_ON_START_CALLED, reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mCalled) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">            <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">            <span class="string">" did not call through to super.onStart()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mFragments.dispatchStart();</span><br><span class="line">    mFragments.reportLoaderStart();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isAppDebuggable =</span><br><span class="line">            (mApplication.getApplicationInfo().flags &amp; ApplicationInfo.FLAG_DEBUGGABLE) != <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This property is set for all non-user builds except final release</span></span><br><span class="line">    <span class="keyword">boolean</span> isDlwarningEnabled = SystemProperties.getInt(<span class="string">"ro.bionic.ld.warning"</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isDlwarningEnabled) &#123;</span><br><span class="line">        String dlwarning = getDlWarning();</span><br><span class="line">        <span class="keyword">if</span> (dlwarning != <span class="keyword">null</span>) &#123;</span><br><span class="line">            String appName = getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            String warning = <span class="string">"Detected problems with app native libraries\n"</span> +</span><br><span class="line">                             <span class="string">"(please consult log for detail):\n"</span> + dlwarning;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                  <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>).</span><br><span class="line">                      setTitle(appName).</span><br><span class="line">                      setMessage(warning).</span><br><span class="line">                      setPositiveButton(android.R.string.ok, <span class="keyword">null</span>).</span><br><span class="line">                      setCancelable(<span class="keyword">false</span>).</span><br><span class="line">                      show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, appName + <span class="string">"\n"</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This property is set for all non-user builds except final release</span></span><br><span class="line">    <span class="keyword">boolean</span> isApiWarningEnabled = SystemProperties.getInt(<span class="string">"ro.art.hiddenapi.warning"</span>, <span class="number">0</span>) == <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (isAppDebuggable || isApiWarningEnabled) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mMainThread.mHiddenApiWarningShown &amp;&amp; VMRuntime.getRuntime().hasUsedHiddenApi()) &#123;</span><br><span class="line">            <span class="comment">// Only show the warning once per process.</span></span><br><span class="line">            mMainThread.mHiddenApiWarningShown = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            String appName = getApplicationInfo().loadLabel(getPackageManager())</span><br><span class="line">                    .toString();</span><br><span class="line">            String warning = <span class="string">"Detected problems with API compatibility\n"</span></span><br><span class="line">                             + <span class="string">"(visit g.co/dev/appcompat for more info)"</span>;</span><br><span class="line">            <span class="keyword">if</span> (isAppDebuggable) &#123;</span><br><span class="line">                <span class="keyword">new</span> AlertDialog.Builder(<span class="keyword">this</span>)</span><br><span class="line">                    .setTitle(appName)</span><br><span class="line">                    .setMessage(warning)</span><br><span class="line">                    .setPositiveButton(android.R.string.ok, <span class="keyword">null</span>)</span><br><span class="line">                    .setCancelable(<span class="keyword">false</span>)</span><br><span class="line">                    .show();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                Toast.makeText(<span class="keyword">this</span>, appName + <span class="string">"\n"</span> + warning, Toast.LENGTH_LONG).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mActivityTransitionState.enterReady(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不出所料，performStart 中又调用了 mInstrumentation.callActivityOnStart(this)</p>
<p>在 callActivityOnStart 中直接调用 activity.onStart</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnStart</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.onStart();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="onStop_28_29"><a href="#onStop_28_29" class="headerlink" title="onStop()"></a>onStop()</h1><p>最后，我们来看一下 onStop 。</p>
<p>在 ActivityThread 的 handleResumeActivity 方法中，末尾有一段代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">r.nextIdle = mNewActivities;</span><br><span class="line">mNewActivities = r;</span><br><span class="line"><span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Scheduling idle handler for "</span> + r);</span><br><span class="line">Looper.myQueue().addIdleHandler(<span class="keyword">new</span> Idler());</span><br></pre></td></tr></table></figure>
<p>重点来关注下 Idler 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">Idler</span> <span class="keyword">implements</span> <span class="title">MessageQueue</span>.<span class="title">IdleHandler</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">queueIdle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ActivityClientRecord a = mNewActivities;</span><br><span class="line">        <span class="keyword">boolean</span> stopProfiling = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (mBoundApplication != <span class="keyword">null</span> &amp;&amp; mProfiler.profileFd != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mProfiler.autoStopProfiler) &#123;</span><br><span class="line">            stopProfiling = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mNewActivities = <span class="keyword">null</span>;</span><br><span class="line">            IActivityManager am = ActivityManager.getService();</span><br><span class="line">            ActivityClientRecord prev;</span><br><span class="line">            do &#123;</span><br><span class="line">                <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                    TAG, <span class="string">"Reporting idle of "</span> + a +</span><br><span class="line">                    <span class="string">" finished="</span> +</span><br><span class="line">                    (a.activity != <span class="keyword">null</span> &amp;&amp; a.activity.mFinished));</span><br><span class="line">                <span class="keyword">if</span> (a.activity != <span class="keyword">null</span> &amp;&amp; !a.activity.mFinished) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                    	<span class="comment">// 调用 AMS 来处理 activity 的 onStop</span></span><br><span class="line">                        am.activityIdle(a.token, a.createdConfig, stopProfiling);</span><br><span class="line">                        a.createdConfig = <span class="keyword">null</span>;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                prev = a;</span><br><span class="line">                a = a.nextIdle;</span><br><span class="line">                prev.nextIdle = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (a != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">            mProfiler.stopProfiling();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureJitEnabled();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，其中有一句 <code>am.activityIdle(a.token, a.createdConfig, stopProfiling);</code> 。</p>
<p>而 am 就是 AMS 了，所以我们需要去 AMS 里面看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">activityIdle</span><span class="params">(IBinder token, Configuration config, <span class="keyword">boolean</span> stopProfiling)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        ActivityStack stack = ActivityRecord.getStackLocked(token);</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ActivityRecord r =</span><br><span class="line">                    mStackSupervisor.activityIdleInternalLocked(token, <span class="keyword">false</span> <span class="comment">/* fromTimeout */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* processPausingActivities */</span>, config);</span><br><span class="line">            <span class="keyword">if</span> (stopProfiling) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((mProfileProc == r.app) &amp;&amp; mProfilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    clearProfilerLocked();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Binder.restoreCallingIdentity(origId);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用 mStackSupervisor 来处理 Activity 任务栈的操作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">final</span> ActivityRecord <span class="title">activityIdleInternalLocked</span><span class="params">(<span class="keyword">final</span> IBinder token, <span class="keyword">boolean</span> fromTimeout,</span><br><span class="line">        <span class="keyword">boolean</span> processPausingActivities, Configuration config)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"Activity idle: "</span> + token);</span><br><span class="line"></span><br><span class="line">    ArrayList&lt;ActivityRecord&gt; finishes = <span class="keyword">null</span>;</span><br><span class="line">    ArrayList&lt;UserState&gt; startingUsers = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">int</span> NS = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> NF = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> booting = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> activityRemoved = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = ActivityRecord.forTokenLocked(token);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_IDLE) Slog.d(TAG_IDLE, <span class="string">"activityIdleInternalLocked: Callers="</span></span><br><span class="line">                + Debug.getCallers(<span class="number">4</span>));</span><br><span class="line">        mHandler.removeMessages(IDLE_TIMEOUT_MSG, r);</span><br><span class="line">        r.finishLaunchTickingLocked();</span><br><span class="line">        <span class="keyword">if</span> (fromTimeout) &#123;</span><br><span class="line">            reportActivityLaunchedLocked(fromTimeout, r, -<span class="number">1</span>, -<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This is a hack to semi-deal with a race condition</span></span><br><span class="line">        <span class="comment">// in the client where it can be constructed with a</span></span><br><span class="line">        <span class="comment">// newer configuration from when we asked it to launch.</span></span><br><span class="line">        <span class="comment">// We'll update with whatever configuration it now says</span></span><br><span class="line">        <span class="comment">// it used to launch.</span></span><br><span class="line">        <span class="keyword">if</span> (config != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.setLastReportedGlobalConfiguration(config);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// We are now idle.  If someone is waiting for a thumbnail from</span></span><br><span class="line">        <span class="comment">// us, we can now deliver.</span></span><br><span class="line">        r.idle = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Slog.i(TAG, "IDLE: mBooted=" + mBooted + ", fromTimeout=" + fromTimeout);</span></span><br><span class="line">        <span class="keyword">if</span> (isFocusedStack(r.getStack()) || fromTimeout) &#123;</span><br><span class="line">            booting = checkFinishBootingLocked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (allResumedActivitiesIdle()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.scheduleAppGcsLocked();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLaunchingActivity.isHeld()) &#123;</span><br><span class="line">            mHandler.removeMessages(LAUNCH_TIMEOUT_MSG);</span><br><span class="line">            <span class="keyword">if</span> (VALIDATE_WAKE_LOCK_CALLER &amp;&amp;</span><br><span class="line">                    Binder.getCallingUid() != Process.myUid()) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling must be system uid"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mLaunchingActivity.release();</span><br><span class="line">        &#125;</span><br><span class="line">        ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Atomically retrieve all of the other things to do.</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;ActivityRecord&gt; stops = processStoppingActivitiesLocked(r,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* remove */</span>, processPausingActivities);</span><br><span class="line">    NS = stops != <span class="keyword">null</span> ? stops.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((NF = mFinishingActivities.size()) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        finishes = <span class="keyword">new</span> ArrayList&lt;&gt;(mFinishingActivities);</span><br><span class="line">        mFinishingActivities.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartingUsers.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        startingUsers = <span class="keyword">new</span> ArrayList&lt;&gt;(mStartingUsers);</span><br><span class="line">        mStartingUsers.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Stop any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NS; i++) &#123;</span><br><span class="line">        r = stops.get(i);</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.finishing) &#123;</span><br><span class="line">                stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, <span class="keyword">false</span>,</span><br><span class="line">                        <span class="string">"activityIdleInternalLocked"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                stack.stopActivityLocked(r);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finish any activities that are scheduled to do so but have been</span></span><br><span class="line">    <span class="comment">// waiting for the next one to start.</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; NF; i++) &#123;</span><br><span class="line">        r = finishes.get(i);</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = r.getStack();</span><br><span class="line">        <span class="keyword">if</span> (stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            activityRemoved |= stack.destroyActivityLocked(r, <span class="keyword">true</span>, <span class="string">"finish-idle"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!booting) &#123;</span><br><span class="line">        <span class="comment">// Complete user switch</span></span><br><span class="line">        <span class="keyword">if</span> (startingUsers != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; startingUsers.size(); i++) &#123;</span><br><span class="line">                mService.mUserController.finishUserSwitch(startingUsers.get(i));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.trimApplications();</span><br><span class="line">    <span class="comment">//dump();</span></span><br><span class="line">    <span class="comment">//mWindowManager.dump();</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (activityRemoved) &#123;</span><br><span class="line">        resumeFocusedStackTopActivityLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码有点长，其实我们只要关注以下这段代码就好了</p>
<pre><code>// Stop any activities that are scheduled to do so but have been
// waiting for the next one to start.
for (int i = 0; i &lt; NS; i++) {
   r = stops.get(i);
   final ActivityStack stack = r.getStack();
   if (stack != null) {
       if (r.finishing) {
           stack.finishCurrentActivityLocked(r, ActivityStack.FINISH_IMMEDIATELY, false,
                   &quot;activityIdleInternalLocked&quot;);
       } else {
           stack.stopActivityLocked(r);
       }
   }
}
</code></pre><p>发现如果 ActivityRecord 没有 finish 的话，就会调用 <code>stack.stopActivityLocked(r);</code></p>
<p>那我们去 ActivityStack 中看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">stopActivityLocked</span><span class="params">(ActivityRecord r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SWITCH) Slog.d(TAG_SWITCH, <span class="string">"Stopping: "</span> + r);</span><br><span class="line">    <span class="keyword">if</span> ((r.intent.getFlags()&amp;Intent.FLAG_ACTIVITY_NO_HISTORY) != <span class="number">0</span></span><br><span class="line">            || (r.info.flags&amp;ActivityInfo.FLAG_NO_HISTORY) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!r.finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!shouldSleepActivities()) &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"no-history finish of "</span> + r);</span><br><span class="line">                <span class="keyword">if</span> (requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="string">"stop-no-history"</span>, <span class="keyword">false</span>)) &#123;</span><br><span class="line">                    <span class="comment">// If &#123;@link requestFinishActivityLocked&#125; returns &#123;@code true&#125;,</span></span><br><span class="line">                    <span class="comment">// &#123;@link adjustFocusedActivityStack&#125; would have been already called.</span></span><br><span class="line">                    r.resumeKeyDispatchingLocked();</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"Not finishing noHistory "</span> + r</span><br><span class="line">                        + <span class="string">" on stop because we're just sleeping"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span> &amp;&amp; r.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        adjustFocusedActivityStack(r, <span class="string">"stopActivity"</span>);</span><br><span class="line">        r.resumeKeyDispatchingLocked();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            r.stopped = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                    <span class="string">"Moving to STOPPING: "</span> + r + <span class="string">" (stop requested)"</span>);</span><br><span class="line">            r.setState(STOPPING, <span class="string">"stopActivityLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_VISIBILITY) Slog.v(TAG_VISIBILITY,</span><br><span class="line">                    <span class="string">"Stopping visible="</span> + r.visible + <span class="string">" for "</span> + r);</span><br><span class="line">            <span class="keyword">if</span> (!r.visible) &#123;</span><br><span class="line">                r.setVisible(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            EventLogTags.writeAmStopActivity(</span><br><span class="line">                    r.userId, System.identityHashCode(r), r.shortComponentName);</span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,</span><br><span class="line">                    StopActivityItem.obtain(r.visible, r.configChangeFlags));</span><br><span class="line">            <span class="keyword">if</span> (shouldSleepOrShutDownActivities()) &#123;</span><br><span class="line">                r.setSleeping(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            Message msg = mHandler.obtainMessage(STOP_TIMEOUT_MSG, r);</span><br><span class="line">            mHandler.sendMessageDelayed(msg, STOP_TIMEOUT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// Maybe just ignore exceptions here...  if the process</span></span><br><span class="line">            <span class="comment">// has crashed, our death notification will clean things</span></span><br><span class="line">            <span class="comment">// up.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during pause"</span>, e);</span><br><span class="line">            <span class="comment">// Just in case, assume it to be stopped.</span></span><br><span class="line">            r.stopped = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Stop failed; moving to STOPPED: "</span> + r);</span><br><span class="line">            r.setState(STOPPED, <span class="string">"stopActivityLocked"</span>);</span><br><span class="line">            <span class="keyword">if</span> (r.deferRelaunchUntilPaused) &#123;</span><br><span class="line">                destroyActivityLocked(r, <span class="keyword">true</span>, <span class="string">"stop-except"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一眼就看到了 onStop 调用的入口啦：</p>
<pre><code>mService.getLifecycleManager().scheduleTransaction(r.app.thread, r.appToken,
    StopActivityItem.obtain(r.visible, r.configChangeFlags));
</code></pre><p>经过上面这么多的分析，相信已经不用说这句代码意味着什么了吧！</p>
<p>我们直接看 StopActivityItem 的 execute 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStop"</span>);</span><br><span class="line">    client.handleStopActivity(token, mShowWindow, mConfigChanges, pendingActions,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* finalStateRequest */</span>, <span class="string">"STOP_ACTIVITY_ITEM"</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和其他的一样，也是调用了 ActivityThread 的 handleStopActivity 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleStopActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> show, <span class="keyword">int</span> configChanges,</span><br><span class="line">        PendingTransactionActions pendingActions, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ActivityClientRecord r = mActivities.get(token);</span><br><span class="line">    r.activity.mConfigChangeFlags |= configChanges;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> StopInfo stopInfo = <span class="keyword">new</span> StopInfo();</span><br><span class="line">    performStopActivityInner(r, stopInfo, show, <span class="keyword">true</span> <span class="comment">/* saveState */</span>, finalStateRequest,</span><br><span class="line">            reason);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Finishing stop of "</span> + r + <span class="string">": show="</span> + show</span><br><span class="line">        + <span class="string">" win="</span> + r.window);</span><br><span class="line"></span><br><span class="line">    updateVisibility(r, show);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure any pending writes are now committed.</span></span><br><span class="line">    <span class="keyword">if</span> (!r.isPreHoneycomb()) &#123;</span><br><span class="line">        QueuedWork.waitToFinish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    stopInfo.setActivity(r);</span><br><span class="line">    stopInfo.setState(r.state);</span><br><span class="line">    stopInfo.setPersistentState(r.persistentState);</span><br><span class="line">    pendingActions.setStopInfo(stopInfo);</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>关键代码 performStopActivityInner</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performStopActivityInner</span><span class="params">(ActivityClientRecord r, StopInfo info, <span class="keyword">boolean</span> keepShown,</span><br><span class="line">        <span class="keyword">boolean</span> saveState, <span class="keyword">boolean</span> finalStateRequest, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing stop of "</span> + r);</span><br><span class="line">    <span class="keyword">if</span> (r != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!keepShown &amp;&amp; r.stopped) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.activity.mFinished) &#123;</span><br><span class="line">                <span class="comment">// If we are finishing, we won't call onResume() in certain</span></span><br><span class="line">                <span class="comment">// cases.  So here we likewise don't want to call onStop()</span></span><br><span class="line">                <span class="comment">// if the activity isn't resumed.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!finalStateRequest) &#123;</span><br><span class="line">                <span class="keyword">final</span> RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                        <span class="string">"Performing stop of activity that is already stopped: "</span></span><br><span class="line">                                + r.intent.getComponent().toShortString());</span><br><span class="line">                Slog.e(TAG, e.getMessage(), e);</span><br><span class="line">                Slog.e(TAG, r.getStateString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// One must first be paused before stopped...</span></span><br><span class="line">        performPauseActivityIfNeeded(r, reason);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// First create a thumbnail for the activity...</span></span><br><span class="line">                <span class="comment">// For now, don't create the thumbnail here; we are</span></span><br><span class="line">                <span class="comment">// doing that by doing a screen snapshot.</span></span><br><span class="line">                info.setDescription(r.activity.onCreateDescription());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                            <span class="string">"Unable to save state of activity "</span></span><br><span class="line">                            + r.intent.getComponent().toShortString()</span><br><span class="line">                            + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!keepShown) &#123;</span><br><span class="line">            callActivityOnStop(r, saveState, reason);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部会调用 performPauseActivityIfNeeded</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performPauseActivityIfNeeded</span><span class="params">(ActivityClientRecord r, String reason)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (r.paused) &#123;</span><br><span class="line">        <span class="comment">// You are already paused silly...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">        mInstrumentation.callActivityOnPause(r.activity);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mCalled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(<span class="string">"Activity "</span> + safeToComponentShortString(r.intent)</span><br><span class="line">                    + <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(r.activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to pause activity "</span></span><br><span class="line">                    + safeToComponentShortString(r.intent) + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    r.setState(ON_PAUSE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们看到，还是利用 mInstrumentation 来调用 onStop</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnPause</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    activity.performPause();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Activity.performPause</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mDoReportFullyDrawn = <span class="keyword">false</span>;</span><br><span class="line">    mFragments.dispatchPause();</span><br><span class="line">    mCalled = <span class="keyword">false</span>;</span><br><span class="line">    onPause();</span><br><span class="line">    writeEventLog(LOG_AM_ON_PAUSE_CALLED, <span class="string">"performPause"</span>);</span><br><span class="line">    mResumed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (!mCalled &amp;&amp; getApplicationInfo().targetSdkVersion</span><br><span class="line">            &gt;= android.os.Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                <span class="string">"Activity "</span> + mComponent.toShortString() +</span><br><span class="line">                <span class="string">" did not call through to super.onPause()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，到这里就把整个 Activity 启动的生命周期回调流程都走了一遍，回去好好理解下吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：源码分析基于 Android SDK API 28 </p>
<p>在前一篇中，我们分析了 startActivity 的整个流程，并且也讲到了何时调用了 onCreate() 。</p>
<p>那么就会有一个疑问，其他的生命周期方法是在哪里被调用的呢？今天就来揭开这个]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.me/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[startActivity启动流程]]></title>
    <link href="http://yuqirong.me/2019/04/03/startActivity%E5%90%AF%E5%8A%A8%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.me/2019/04/03/startActivity启动流程/</id>
    <published>2019-04-03T13:56:50.000Z</published>
    <updated>2019-04-02T16:24:26.425Z</updated>
    <content type="html"><![CDATA[<p>注：源码分析基于 Android SDK API 28</p>
<p>对于 Activity 大家都已经很熟悉很亲切了吧，在这就不过多介绍了。</p>
<p>直接进入正题，走起！</p>
<p>一般我们启动 Activity 的入口都是 startActivity ，所以这也成为了我们分析整个流程的切入口。</p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="startActivity_28Intent_intent_29"><a href="#startActivity_28Intent_intent_29" class="headerlink" title="startActivity(Intent intent)"></a>startActivity(Intent intent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.startActivity(intent, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Intent intent, @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>, options);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Note we want to go through this call for compatibility with</span></span><br><span class="line">        <span class="comment">// applications that may have overridden the method.</span></span><br><span class="line">        startActivityForResult(intent, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    startActivityForResult(intent, requestCode, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实最后都是调用 startActivityForResult 这个方法。</p>
<h2 id="startActivityForResult_28@RequiresPermission_Intent_intent_2C_int_requestCode_2C_@Nullable_Bundle_options_29"><a href="#startActivityForResult_28@RequiresPermission_Intent_intent_2C_int_requestCode_2C_@Nullable_Bundle_options_29" class="headerlink" title="startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)"></a>startActivityForResult(@RequiresPermission Intent intent, int requestCode, @Nullable Bundle options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivityForResult</span><span class="params">(@RequiresPermission Intent intent, <span class="keyword">int</span> requestCode,</span><br><span class="line">        @Nullable Bundle options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        options = transferSpringboardActivityOptions(options);</span><br><span class="line">        Instrumentation.ActivityResult ar =</span><br><span class="line">            mInstrumentation.execStartActivity(</span><br><span class="line">                <span class="keyword">this</span>, mMainThread.getApplicationThread(), mToken, <span class="keyword">this</span>,</span><br><span class="line">                intent, requestCode, options);</span><br><span class="line">        <span class="keyword">if</span> (ar != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mMainThread.sendActivityResult(</span><br><span class="line">                mToken, mEmbeddedID, requestCode, ar.getResultCode(),</span><br><span class="line">                ar.getResultData());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// If this start is requesting a result, we can avoid making</span></span><br><span class="line">            <span class="comment">// the activity visible until the result is received.  Setting</span></span><br><span class="line">            <span class="comment">// this code during onCreate(Bundle savedInstanceState) or onResume() will keep the</span></span><br><span class="line">            <span class="comment">// activity hidden during this time, to avoid flickering.</span></span><br><span class="line">            <span class="comment">// This can only be done when a result is requested because</span></span><br><span class="line">            <span class="comment">// that guarantees we will get information back when the</span></span><br><span class="line">            <span class="comment">// activity is finished, no matter what happens to it.</span></span><br><span class="line">            mStartedActivity = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cancelInputsAndStartExitTransition(options);</span><br><span class="line">        <span class="comment">// TODO Consider clearing/flushing other event sources and events for child windows.</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (options != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode, options);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Note we want to go through this method for compatibility with</span></span><br><span class="line">            <span class="comment">// existing applications that may have overridden it.</span></span><br><span class="line">            mParent.startActivityFromChild(<span class="keyword">this</span>, intent, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 mParent 为空的情况下，直接调用 mInstrumentation.execStartActivity 来启动 Activity 。 </p>
<p>这里的 mParent 其实是指 ActivityGroup ，用来嵌套多个 Activity ，是早已废弃的 API 了。</p>
<p>所以一般情况下，mParent 都是为空的。那我们跟进到 Instrumentation 中的 execStartActivity 方法去看。</p>
<h1 id="Instrumentation"><a href="#Instrumentation" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><h2 id="execStartActivity"><a href="#execStartActivity" class="headerlink" title="execStartActivity"></a>execStartActivity</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(</span><br><span class="line">        Context who, IBinder contextThread, IBinder token, Activity target,</span><br><span class="line">        Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span> </span>&#123;</span><br><span class="line">    IApplicationThread whoThread = (IApplicationThread) contextThread;</span><br><span class="line">    Uri referrer = target != <span class="keyword">null</span> ? target.onProvideReferrer() : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (referrer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent.putExtra(Intent.EXTRA_REFERRER, referrer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mActivityMonitors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mSync) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> N = mActivityMonitors.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;N; i++) &#123;</span><br><span class="line">                <span class="keyword">final</span> ActivityMonitor am = mActivityMonitors.get(i);</span><br><span class="line">                ActivityResult result = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (am.ignoreMatchingSpecificIntents()) &#123;</span><br><span class="line">                    result = am.onStartActivity(intent);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (result != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (am.match(who, <span class="keyword">null</span>, intent)) &#123;</span><br><span class="line">                    am.mHits++;</span><br><span class="line">                    <span class="keyword">if</span> (am.isBlocking()) &#123;</span><br><span class="line">                        <span class="keyword">return</span> requestCode &gt;= <span class="number">0</span> ? am.getResult() : <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        intent.migrateExtraStreamToClipData();</span><br><span class="line">        intent.prepareToLeaveProcess(who);</span><br><span class="line">        <span class="comment">// 调用 ActivityManagerService 启动 Activity</span></span><br><span class="line">        <span class="keyword">int</span> result = ActivityManager.getService()</span><br><span class="line">            .startActivity(whoThread, who.getBasePackageName(), intent,</span><br><span class="line">                    intent.resolveTypeIfNeeded(who.getContentResolver()),</span><br><span class="line">                    token, target != <span class="keyword">null</span> ? target.mEmbeddedID : <span class="keyword">null</span>,</span><br><span class="line">                    requestCode, <span class="number">0</span>, <span class="keyword">null</span>, options); </span><br><span class="line">        <span class="comment">// 在 checkStartActivityResult 中会检查 Activity 启动的结果</span></span><br><span class="line">        <span class="comment">// 比如没有在 AndroidManifest.xml 中注册的异常就是在这里抛出来的</span></span><br><span class="line">        checkStartActivityResult(result, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Failure from system"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@hide</span> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">checkStartActivityResult</span><span class="params">(<span class="keyword">int</span> res, Object intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!ActivityManager.isStartResultFatalError(res)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_INTENT_NOT_RESOLVED:</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CLASS_NOT_FOUND:</span><br><span class="line">            <span class="keyword">if</span> (intent <span class="keyword">instanceof</span> Intent &amp;&amp; ((Intent)intent).getComponent() != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                        <span class="string">"Unable to find explicit activity class "</span></span><br><span class="line">                        + ((Intent)intent).getComponent().toShortString()</span><br><span class="line">                        + <span class="string">"; have you declared this activity in your AndroidManifest.xml?"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(</span><br><span class="line">                    <span class="string">"No Activity found to handle "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_PERMISSION_DENIED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Not allowed to start activity "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(</span><br><span class="line">                    <span class="string">"FORWARD_RESULT_FLAG used while also requesting a result"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_ACTIVITY:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(</span><br><span class="line">                    <span class="string">"PendingIntent is not an activity"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_NOT_VOICE_COMPATIBLE:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(</span><br><span class="line">                    <span class="string">"Starting under voice control not allowed for: "</span> + intent);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startVoiceActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_VOICE_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start voice activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_NOT_ACTIVE_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Session calling startAssistantActivity does not match active session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_ASSISTANT_HIDDEN_SESSION:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                    <span class="string">"Cannot start assistant activity on a hidden session"</span>);</span><br><span class="line">        <span class="keyword">case</span> ActivityManager.START_CANCELED:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Activity could not be started for "</span></span><br><span class="line">                    + intent);</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> AndroidRuntimeException(<span class="string">"Unknown error code "</span></span><br><span class="line">                    + res + <span class="string">" when starting "</span> + intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，调用了 ActivityManager.getService() 。其实实质上就是获取了 ActivityManagerService 。之后就会在 AMS 中去执行 Activity 的启动流程。</p>
<p>另外，返回的结果 result 会在 checkStartActivityResult 中去检查。比如 Activity 没有在 AndroidManifest.xml 中注册，就会抛出异常。</p>
<p>那我们来看看 AMS 中的实现。</p>
<h1 id="ActivityManager"><a href="#ActivityManager" class="headerlink" title="ActivityManager"></a>ActivityManager</h1><h2 id="getService_28_29"><a href="#getService_28_29" class="headerlink" title="getService()"></a>getService()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> IActivityManager <span class="title">getService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> IActivityManagerSingleton.get();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton&lt;IActivityManager&gt; IActivityManagerSingleton =</span><br><span class="line">        <span class="keyword">new</span> Singleton&lt;IActivityManager&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> IActivityManager <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> IBinder b = ServiceManager.getService(Context.ACTIVITY_SERVICE);</span><br><span class="line">                <span class="keyword">final</span> IActivityManager am = IActivityManager.Stub.asInterface(b);</span><br><span class="line">                <span class="keyword">return</span> am;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>
<p>可以看到 ActivityManager.getService() 获取的就是 AMS 对象。那么接着来看 AMS 的 startActivity 方法。</p>
<h1 id="ActivityManagerService"><a href="#ActivityManagerService" class="headerlink" title="ActivityManagerService"></a>ActivityManagerService</h1><h2 id="startActivity_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_29"><a href="#startActivity_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_29" class="headerlink" title="startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions)"></a>startActivity(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> startActivityAsUser(caller, callingPackage, intent, resolvedType, resultTo,</span><br><span class="line">            resultWho, requestCode, startFlags, profilerInfo, bOptions,</span><br><span class="line">            UserHandle.getCallingUserId());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用的是 startActivityAsUser 方法。</p>
<h2 id="startActivityAsUser_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_2C_int_userId_2C_boolean_validateIncomingUser_29"><a href="#startActivityAsUser_28IApplicationThread_caller_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_Bundle_bOptions_2C_int_userId_2C_boolean_validateIncomingUser_29" class="headerlink" title="startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser)"></a>startActivityAsUser(IApplicationThread caller, String callingPackage, Intent intent, String resolvedType, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, Bundle bOptions, int userId, boolean validateIncomingUser)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">startActivityAsUser</span><span class="params">(IApplicationThread caller, String callingPackage,</span><br><span class="line">        Intent intent, String resolvedType, IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode,</span><br><span class="line">        <span class="keyword">int</span> startFlags, ProfilerInfo profilerInfo, Bundle bOptions, <span class="keyword">int</span> userId,</span><br><span class="line">        <span class="keyword">boolean</span> validateIncomingUser)</span> </span>&#123;</span><br><span class="line">    enforceNotIsolatedCaller(<span class="string">"startActivity"</span>);</span><br><span class="line"></span><br><span class="line">    userId = mActivityStartController.checkTargetUser(userId, validateIncomingUser,</span><br><span class="line">            Binder.getCallingPid(), Binder.getCallingUid(), <span class="string">"startActivityAsUser"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Switch to user app stacks here.</span></span><br><span class="line">    <span class="keyword">return</span> mActivityStartController.obtainStarter(intent, <span class="string">"startActivityAsUser"</span>)</span><br><span class="line">            .setCaller(caller)</span><br><span class="line">            .setCallingPackage(callingPackage)</span><br><span class="line">            .setResolvedType(resolvedType)</span><br><span class="line">            .setResultTo(resultTo)</span><br><span class="line">            .setResultWho(resultWho)</span><br><span class="line">            .setRequestCode(requestCode)</span><br><span class="line">            .setStartFlags(startFlags)</span><br><span class="line">            .setProfilerInfo(profilerInfo)</span><br><span class="line">            .setActivityOptions(bOptions)</span><br><span class="line">            .setMayWait(userId)</span><br><span class="line">            .execute();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 mActivityStartController.obtainStarter 就是创建了一个 ActivityStarter 对象。</p>
<p>ActivityStarter 是什么东西呢？</p>
<pre><code>This class collects all the logic for determining how an intent and flags should be turned into an activity and associated task and stack.
</code></pre><p>官方的解释是把 activity 启动过程中处理 intent 和 flags 的逻辑以及任务栈等操作都被封装在 ActivityStarter 中了。</p>
<p>而 startActivityAsUser 干的事就是把参数传进去，用 builder 模式构造出一个 ActivityStarter 对象。然后调用他的 execute 方法去执行。</p>
<p>所以我们直接来看 execute 方法。</p>
<h1 id="ActivityStarter"><a href="#ActivityStarter" class="headerlink" title="ActivityStarter"></a>ActivityStarter</h1><h2 id="execute_28_29"><a href="#execute_28_29" class="headerlink" title="execute()"></a>execute()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// TODO(b/64750076): Look into passing request directly to these methods to allow</span></span><br><span class="line">        <span class="comment">// for transactional diffs and preprocessing.</span></span><br><span class="line">        <span class="keyword">if</span> (mRequest.mayWait) &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivityMayWait(mRequest.caller, mRequest.callingUid,</span><br><span class="line">                    mRequest.callingPackage, mRequest.intent, mRequest.resolvedType,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.startFlags,</span><br><span class="line">                    mRequest.profilerInfo, mRequest.waitResult, mRequest.globalConfig,</span><br><span class="line">                    mRequest.activityOptions, mRequest.ignoreTargetSecurity, mRequest.userId,</span><br><span class="line">                    mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> startActivity(mRequest.caller, mRequest.intent, mRequest.ephemeralIntent,</span><br><span class="line">                    mRequest.resolvedType, mRequest.activityInfo, mRequest.resolveInfo,</span><br><span class="line">                    mRequest.voiceSession, mRequest.voiceInteractor, mRequest.resultTo,</span><br><span class="line">                    mRequest.resultWho, mRequest.requestCode, mRequest.callingPid,</span><br><span class="line">                    mRequest.callingUid, mRequest.callingPackage, mRequest.realCallingPid,</span><br><span class="line">                    mRequest.realCallingUid, mRequest.startFlags, mRequest.activityOptions,</span><br><span class="line">                    mRequest.ignoreTargetSecurity, mRequest.componentSpecified,</span><br><span class="line">                    mRequest.outActivity, mRequest.inTask, mRequest.reason,</span><br><span class="line">                    mRequest.allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        onExecutionComplete();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上一步构造 ActivityStarter 的过程中，有一句 setMayWait(userId) 代码。这句代码内部会将 mayWait 设置为 true 。所以我们要深入到 startActivityMayWait 方法中去。</p>
<h2 id="startActivityMayWait_28IApplicationThread_caller_2C_int_callingUid_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_WaitResult_outResult_2C_Configuration_globalConfig_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_int_userId_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivityMayWait_28IApplicationThread_caller_2C_int_callingUid_2C_String_callingPackage_2C_Intent_intent_2C_String_resolvedType_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_startFlags_2C_ProfilerInfo_profilerInfo_2C_WaitResult_outResult_2C_Configuration_globalConfig_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_int_userId_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivityMayWait(IApplicationThread caller, int callingUid, String callingPackage, Intent intent, String resolvedType, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int startFlags, ProfilerInfo profilerInfo, WaitResult outResult, Configuration globalConfig, SafeActivityOptions options, boolean ignoreTargetSecurity, int userId, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityMayWait</span><span class="params">(IApplicationThread caller, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, Intent intent, String resolvedType,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> startFlags,</span><br><span class="line">        ProfilerInfo profilerInfo, WaitResult outResult,</span><br><span class="line">        Configuration globalConfig, SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity,</span><br><span class="line">        <span class="keyword">int</span> userId, TaskRecord inTask, String reason,</span><br><span class="line">        <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Refuse possible leaked file descriptors</span></span><br><span class="line">    <span class="keyword">if</span> (intent != <span class="keyword">null</span> &amp;&amp; intent.hasFileDescriptors()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"File descriptors passed in Intent"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.getActivityMetricsLogger().notifyActivityLaunching();</span><br><span class="line">    <span class="keyword">boolean</span> componentSpecified = intent.getComponent() != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingPid = Binder.getCallingPid();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> realCallingUid = Binder.getCallingUid();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> callingPid;</span><br><span class="line">    <span class="keyword">if</span> (callingUid &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        callingPid = -<span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (caller == <span class="keyword">null</span>) &#123;</span><br><span class="line">        callingPid = realCallingPid;</span><br><span class="line">        callingUid = realCallingUid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        callingPid = callingUid = -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Save a copy in case ephemeral needs it</span></span><br><span class="line">    <span class="keyword">final</span> Intent ephemeralIntent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="comment">// Don't modify the client's object!</span></span><br><span class="line">    intent = <span class="keyword">new</span> Intent(intent);</span><br><span class="line">    <span class="keyword">if</span> (componentSpecified</span><br><span class="line">            &amp;&amp; !(Intent.ACTION_VIEW.equals(intent.getAction()) &amp;&amp; intent.getData() == <span class="keyword">null</span>)</span><br><span class="line">            &amp;&amp; !Intent.ACTION_INSTALL_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">            &amp;&amp; !Intent.ACTION_RESOLVE_INSTANT_APP_PACKAGE.equals(intent.getAction())</span><br><span class="line">            &amp;&amp; mService.getPackageManagerInternalLocked()</span><br><span class="line">                    .isInstantAppInstallerComponent(intent.getComponent())) &#123;</span><br><span class="line">        <span class="comment">// intercept intents targeted directly to the ephemeral installer the</span></span><br><span class="line">        <span class="comment">// ephemeral installer should never be started with a raw Intent; instead</span></span><br><span class="line">        <span class="comment">// adjust the intent so it looks like a "normal" instant app launch</span></span><br><span class="line">        intent.setComponent(<span class="keyword">null</span> <span class="comment">/*component*/</span>);</span><br><span class="line">        componentSpecified = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ResolveInfo rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">            <span class="number">0</span> <span class="comment">/* matchFlags */</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">    <span class="keyword">if</span> (rInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        UserInfo userInfo = mSupervisor.getUserInfo(userId);</span><br><span class="line">        <span class="keyword">if</span> (userInfo != <span class="keyword">null</span> &amp;&amp; userInfo.isManagedProfile()) &#123;</span><br><span class="line">            <span class="comment">// Special case for managed profiles, if attempting to launch non-cryto aware</span></span><br><span class="line">            <span class="comment">// app in a locked managed profile from an unlocked parent allow it to resolve</span></span><br><span class="line">            <span class="comment">// as user will be sent via confirm credentials to unlock the profile.</span></span><br><span class="line">            UserManager userManager = UserManager.get(mService.mContext);</span><br><span class="line">            <span class="keyword">boolean</span> profileLockedAndParentUnlockingOrUnlocked = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">long</span> token = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UserInfo parent = userManager.getProfileParent(userId);</span><br><span class="line">                profileLockedAndParentUnlockingOrUnlocked = (parent != <span class="keyword">null</span>)</span><br><span class="line">                        &amp;&amp; userManager.isUserUnlockingOrUnlocked(parent.id)</span><br><span class="line">                        &amp;&amp; !userManager.isUserUnlockingOrUnlocked(userId);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                Binder.restoreCallingIdentity(token);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (profileLockedAndParentUnlockingOrUnlocked) &#123;</span><br><span class="line">                rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId,</span><br><span class="line">                        PackageManager.MATCH_DIRECT_BOOT_AWARE</span><br><span class="line">                                | PackageManager.MATCH_DIRECT_BOOT_UNAWARE,</span><br><span class="line">                        computeResolveFilterUid(</span><br><span class="line">                                callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Collect information about the target of the Intent.</span></span><br><span class="line">    ActivityInfo aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, profilerInfo);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mService) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line">        stack.mConfigWillChange = globalConfig != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mService.getGlobalConfiguration().diff(globalConfig) != <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                <span class="string">"Starting activity when config will change = "</span> + stack.mConfigWillChange);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aInfo != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                (aInfo.applicationInfo.privateFlags</span><br><span class="line">                        &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">            <span class="comment">// This may be a heavy-weight process!  Check to see if we already</span></span><br><span class="line">            <span class="comment">// have another, different heavy-weight process running.</span></span><br><span class="line">            <span class="keyword">if</span> (aInfo.processName.equals(aInfo.applicationInfo.packageName)) &#123;</span><br><span class="line">                <span class="keyword">final</span> ProcessRecord heavy = mService.mHeavyWeightProcess;</span><br><span class="line">                <span class="keyword">if</span> (heavy != <span class="keyword">null</span> &amp;&amp; (heavy.info.uid != aInfo.applicationInfo.uid</span><br><span class="line">                        || !heavy.processName.equals(aInfo.processName))) &#123;</span><br><span class="line">                    <span class="keyword">int</span> appCallingUid = callingUid;</span><br><span class="line">                    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        ProcessRecord callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">                        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            appCallingUid = callerApp.info.uid;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                                    + <span class="string">" (pid="</span> + callingPid + <span class="string">") when starting: "</span></span><br><span class="line">                                    + intent.toString());</span><br><span class="line">                            SafeActivityOptions.abort(options);</span><br><span class="line">                            <span class="keyword">return</span> ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                            ActivityManager.INTENT_SENDER_ACTIVITY, <span class="string">"android"</span>,</span><br><span class="line">                            appCallingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[] &#123; intent &#125;,</span><br><span class="line">                            <span class="keyword">new</span> String[] &#123; resolvedType &#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                                    | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">                    Intent newIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">                    <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// Caller is requesting a result.</span></span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_HAS_RESULT, <span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_INTENT,</span><br><span class="line">                            <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">                    <span class="keyword">if</span> (heavy.activities.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        ActivityRecord hist = heavy.activities.get(<span class="number">0</span>);</span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_APP,</span><br><span class="line">                                hist.packageName);</span><br><span class="line">                        newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_CUR_TASK,</span><br><span class="line">                                hist.getTask().taskId);</span><br><span class="line">                    &#125;</span><br><span class="line">                    newIntent.putExtra(HeavyWeightSwitcherActivity.KEY_NEW_APP,</span><br><span class="line">                            aInfo.packageName);</span><br><span class="line">                    newIntent.setFlags(intent.getFlags());</span><br><span class="line">                    newIntent.setClassName(<span class="string">"android"</span>,</span><br><span class="line">                            HeavyWeightSwitcherActivity.class.getName());</span><br><span class="line">                    intent = newIntent;</span><br><span class="line">                    resolvedType = <span class="keyword">null</span>;</span><br><span class="line">                    caller = <span class="keyword">null</span>;</span><br><span class="line">                    callingUid = Binder.getCallingUid();</span><br><span class="line">                    callingPid = Binder.getCallingPid();</span><br><span class="line">                    componentSpecified = <span class="keyword">true</span>;</span><br><span class="line">                    rInfo = mSupervisor.resolveIntent(intent, <span class="keyword">null</span> <span class="comment">/*resolvedType*/</span>, userId,</span><br><span class="line">                            <span class="number">0</span> <span class="comment">/* matchFlags */</span>, computeResolveFilterUid(</span><br><span class="line">                                    callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">                    aInfo = rInfo != <span class="keyword">null</span> ? rInfo.activityInfo : <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        aInfo = mService.getActivityInfoForUser(aInfo, userId);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord[] outRecord = <span class="keyword">new</span> ActivityRecord[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">int</span> res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,</span><br><span class="line">                voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,</span><br><span class="line">                callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,</span><br><span class="line">                ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,</span><br><span class="line">                allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">        Binder.restoreCallingIdentity(origId);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (stack.mConfigWillChange) &#123;</span><br><span class="line">            <span class="comment">// If the caller also wants to switch to a new configuration,</span></span><br><span class="line">            <span class="comment">// do so now.  This allows a clean switch, as we are waiting</span></span><br><span class="line">            <span class="comment">// for the current activity to pause (so we will not destroy</span></span><br><span class="line">            <span class="comment">// it), and have not yet started the next activity.</span></span><br><span class="line">            mService.enforceCallingPermission(android.Manifest.permission.CHANGE_CONFIGURATION,</span><br><span class="line">                    <span class="string">"updateConfiguration()"</span>);</span><br><span class="line">            stack.mConfigWillChange = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG_CONFIGURATION,</span><br><span class="line">                    <span class="string">"Updating to new configuration after starting activity."</span>);</span><br><span class="line">            mService.updateConfigurationLocked(globalConfig, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outResult != <span class="keyword">null</span>) &#123;</span><br><span class="line">            outResult.result = res;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord r = outRecord[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">switch</span>(res) &#123;</span><br><span class="line">                <span class="keyword">case</span> START_SUCCESS: &#123;</span><br><span class="line">                    mSupervisor.mWaitingActivityLaunched.add(outResult);</span><br><span class="line">                    do &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            mService.wait();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">while</span> (outResult.result != START_TASK_TO_FRONT</span><br><span class="line">                            &amp;&amp; !outResult.timeout &amp;&amp; outResult.who == <span class="keyword">null</span>);</span><br><span class="line">                    <span class="keyword">if</span> (outResult.result == START_TASK_TO_FRONT) &#123;</span><br><span class="line">                        res = START_TASK_TO_FRONT;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> START_DELIVERED_TO_TOP: &#123;</span><br><span class="line">                    outResult.timeout = <span class="keyword">false</span>;</span><br><span class="line">                    outResult.who = r.realActivity;</span><br><span class="line">                    outResult.totalTime = <span class="number">0</span>;</span><br><span class="line">                    outResult.thisTime = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> START_TASK_TO_FRONT: &#123;</span><br><span class="line">                    <span class="comment">// ActivityRecord may represent a different activity, but it should not be</span></span><br><span class="line">                    <span class="comment">// in the resumed state.</span></span><br><span class="line">                    <span class="keyword">if</span> (r.nowVisible &amp;&amp; r.isState(RESUMED)) &#123;</span><br><span class="line">                        outResult.timeout = <span class="keyword">false</span>;</span><br><span class="line">                        outResult.who = r.realActivity;</span><br><span class="line">                        outResult.totalTime = <span class="number">0</span>;</span><br><span class="line">                        outResult.thisTime = <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        outResult.thisTime = SystemClock.uptimeMillis();</span><br><span class="line">                        mSupervisor.waitActivityVisible(r.realActivity, outResult);</span><br><span class="line">                        <span class="comment">// Note: the timeout variable is not currently not ever set.</span></span><br><span class="line">                        do &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mService.wait();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> (!outResult.timeout &amp;&amp; outResult.who == <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSupervisor.getActivityMetricsLogger().notifyActivityLaunched(res, outRecord[<span class="number">0</span>]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，获取 Activity 的 intent 信息，解析得到 ResolveInfo 和 ActivityInfo ，另外获取 callingPid 和 callingUid 。</p>
<p>这个方法的代码很多，看得头疼。但是我们就关心其中的关键代码：</p>
<pre><code>final ActivityRecord[] outRecord = new ActivityRecord[1];
int res = startActivity(caller, intent, ephemeralIntent, resolvedType, aInfo, rInfo,
            voiceSession, voiceInteractor, resultTo, resultWho, requestCode, callingPid,
            callingUid, callingPackage, realCallingPid, realCallingUid, startFlags, options,
            ignoreTargetSecurity, componentSpecified, outRecord, inTask, reason,
            allowPendingRemoteAnimationRegistryLookup);
</code></pre><p>startActivityMayWait 内部调用 startActivity 来启动 Activity 。所以我们还是要追踪到 startActivity 方法中。</p>
<h2 id="startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_String_reason_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags,  SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags,  SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, String reason, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span><br><span class="line">        SafeActivityOptions options, <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified,</span><br><span class="line">        ActivityRecord[] outActivity, TaskRecord inTask, String reason,</span><br><span class="line">        <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(reason)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Need to specify a reason."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mLastStartReason = reason;</span><br><span class="line">    mLastStartActivityTimeMs = System.currentTimeMillis();</span><br><span class="line">    mLastStartActivityRecord[<span class="number">0</span>] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mLastStartActivityResult = startActivity(caller, intent, ephemeralIntent, resolvedType,</span><br><span class="line">            aInfo, rInfo, voiceSession, voiceInteractor, resultTo, resultWho, requestCode,</span><br><span class="line">            callingPid, callingUid, callingPackage, realCallingPid, realCallingUid, startFlags,</span><br><span class="line">            options, ignoreTargetSecurity, componentSpecified, mLastStartActivityRecord,</span><br><span class="line">            inTask, allowPendingRemoteAnimationRegistryLookup);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// mLastStartActivityRecord[0] is set in the call to startActivity above.</span></span><br><span class="line">        outActivity[<span class="number">0</span>] = mLastStartActivityRecord[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getExternalResult(mLastStartActivityResult);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部又调用了另一个 startActivity 的重载方法。</p>
<h2 id="startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29"><a href="#startActivity_28IApplicationThread_caller_2C_Intent_intent_2C_Intent_ephemeralIntent_2C_String_resolvedType_2C_ActivityInfo_aInfo_2C_ResolveInfo_rInfo_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_IBinder_resultTo_2C_String_resultWho_2C_int_requestCode_2C_int_callingPid_2C_int_callingUid_2C_String_callingPackage_2C_int_realCallingPid_2C_int_realCallingUid_2C_int_startFlags_2C_SafeActivityOptions_options_2C_boolean_ignoreTargetSecurity_2C_boolean_componentSpecified_2C_ActivityRecord_5B_5D_outActivity_2C_TaskRecord_inTask_2C_boolean_allowPendingRemoteAnimationRegistryLookup_29" class="headerlink" title="startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup)"></a>startActivity(IApplicationThread caller, Intent intent, Intent ephemeralIntent, String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, IBinder resultTo, String resultWho, int requestCode, int callingPid, int callingUid, String callingPackage, int realCallingPid, int realCallingUid, int startFlags, SafeActivityOptions options, boolean ignoreTargetSecurity, boolean componentSpecified, ActivityRecord[] outActivity, TaskRecord inTask, boolean allowPendingRemoteAnimationRegistryLookup)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(IApplicationThread caller, Intent intent, Intent ephemeralIntent,</span><br><span class="line">        String resolvedType, ActivityInfo aInfo, ResolveInfo rInfo,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        IBinder resultTo, String resultWho, <span class="keyword">int</span> requestCode, <span class="keyword">int</span> callingPid, <span class="keyword">int</span> callingUid,</span><br><span class="line">        String callingPackage, <span class="keyword">int</span> realCallingPid, <span class="keyword">int</span> realCallingUid, <span class="keyword">int</span> startFlags,</span><br><span class="line">        SafeActivityOptions options,</span><br><span class="line">        <span class="keyword">boolean</span> ignoreTargetSecurity, <span class="keyword">boolean</span> componentSpecified, ActivityRecord[] outActivity,</span><br><span class="line">        TaskRecord inTask, <span class="keyword">boolean</span> allowPendingRemoteAnimationRegistryLookup)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> err = ActivityManager.START_SUCCESS;</span><br><span class="line">    <span class="comment">// Pull the optional Ephemeral Installer-only bundle out of the options early.</span></span><br><span class="line">    <span class="keyword">final</span> Bundle verificationBundle</span><br><span class="line">            = options != <span class="keyword">null</span> ? options.popAppVerificationBundle() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    ProcessRecord callerApp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (caller != <span class="keyword">null</span>) &#123;</span><br><span class="line">        callerApp = mService.getRecordForAppLocked(caller);</span><br><span class="line">        <span class="keyword">if</span> (callerApp != <span class="keyword">null</span>) &#123;</span><br><span class="line">            callingPid = callerApp.pid;</span><br><span class="line">            callingUid = callerApp.info.uid;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Unable to find app for caller "</span> + caller</span><br><span class="line">                    + <span class="string">" (pid="</span> + callingPid + <span class="string">") when starting: "</span></span><br><span class="line">                    + intent.toString());</span><br><span class="line">            err = ActivityManager.START_PERMISSION_DENIED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> userId = aInfo != <span class="keyword">null</span> &amp;&amp; aInfo.applicationInfo != <span class="keyword">null</span></span><br><span class="line">            ? UserHandle.getUserId(aInfo.applicationInfo.uid) : <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS) &#123;</span><br><span class="line">        Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">true</span>, <span class="keyword">false</span>)</span><br><span class="line">                + <span class="string">"&#125; from uid "</span> + callingUid);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord sourceRecord = <span class="keyword">null</span>;</span><br><span class="line">    ActivityRecord resultRecord = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (resultTo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sourceRecord = mSupervisor.isInAnyStackLocked(resultTo);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                <span class="string">"Will send result to "</span> + resultTo + <span class="string">" "</span> + sourceRecord);</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span> &amp;&amp; !sourceRecord.finishing) &#123;</span><br><span class="line">                resultRecord = sourceRecord;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> launchFlags = intent.getFlags();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((launchFlags &amp; Intent.FLAG_ACTIVITY_FORWARD_RESULT) != <span class="number">0</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// Transfer the result target from the source activity to the new</span></span><br><span class="line">        <span class="comment">// one being started, including any failures.</span></span><br><span class="line">        <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            SafeActivityOptions.abort(options);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_FORWARD_AND_REQUEST_CONFLICT;</span><br><span class="line">        &#125;</span><br><span class="line">        resultRecord = sourceRecord.resultTo;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span> &amp;&amp; !resultRecord.isInStackLocked()) &#123;</span><br><span class="line">            resultRecord = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        resultWho = sourceRecord.resultWho;</span><br><span class="line">        requestCode = sourceRecord.requestCode;</span><br><span class="line">        sourceRecord.resultTo = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultRecord.removeResultsLocked(sourceRecord, resultWho, requestCode);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sourceRecord.launchedFromUid == callingUid) &#123;</span><br><span class="line">            <span class="comment">// The new activity is being launched from the same uid as the previous</span></span><br><span class="line">            <span class="comment">// activity in the flow, and asking to forward its result back to the</span></span><br><span class="line">            <span class="comment">// previous.  In this case the activity is serving as a trampoline between</span></span><br><span class="line">            <span class="comment">// the two, so we also want to update its launchedFromPackage to be the</span></span><br><span class="line">            <span class="comment">// same as the previous activity.  Note that this is safe, since we know</span></span><br><span class="line">            <span class="comment">// these two packages come from the same uid; the caller could just as</span></span><br><span class="line">            <span class="comment">// well have supplied that same package name itself.  This specifially</span></span><br><span class="line">            <span class="comment">// deals with the case of an intent picker/chooser being launched in the app</span></span><br><span class="line">            <span class="comment">// flow to redirect to an activity picked by the user, where we want the final</span></span><br><span class="line">            <span class="comment">// activity to consider it to have been launched by the previous app activity.</span></span><br><span class="line">            callingPackage = sourceRecord.launchedFromPackage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; intent.getComponent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find a class that can handle the given Intent.</span></span><br><span class="line">        <span class="comment">// That's the end of that!</span></span><br><span class="line">        err = ActivityManager.START_INTENT_NOT_RESOLVED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; aInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// We couldn't find the specific class specified in the Intent.</span></span><br><span class="line">        <span class="comment">// Also the end of the line.</span></span><br><span class="line">        err = ActivityManager.START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; sourceRecord != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; sourceRecord.getTask().voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If this activity is being launched as part of a voice session, we need</span></span><br><span class="line">        <span class="comment">// to ensure that it is safe to do so.  If the upcoming activity will also</span></span><br><span class="line">        <span class="comment">// be part of the voice session, we can only launch it if it has explicitly</span></span><br><span class="line">        <span class="comment">// said it supports the VOICE category, or it is a part of the calling app.</span></span><br><span class="line">        <span class="keyword">if</span> ((launchFlags &amp; FLAG_ACTIVITY_NEW_TASK) == <span class="number">0</span></span><br><span class="line">                &amp;&amp; sourceRecord.info.applicationInfo.uid != aInfo.applicationInfo.uid) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                intent.addCategory(Intent.CATEGORY_VOICE);</span><br><span class="line">                <span class="keyword">if</span> (!mService.getPackageManager().activitySupportsIntent(</span><br><span class="line">                        intent.getComponent(), intent, resolvedType)) &#123;</span><br><span class="line">                    Slog.w(TAG,</span><br><span class="line">                            <span class="string">"Activity being started in current voice task does not support voice: "</span></span><br><span class="line">                                    + intent);</span><br><span class="line">                    err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                Slog.w(TAG, <span class="string">"Failure checking voice capabilities"</span>, e);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err == ActivityManager.START_SUCCESS &amp;&amp; voiceSession != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller is starting a new voice session, just make sure the target</span></span><br><span class="line">        <span class="comment">// is actually allowing it to run this way.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!mService.getPackageManager().activitySupportsIntent(intent.getComponent(),</span><br><span class="line">                    intent, resolvedType)) &#123;</span><br><span class="line">                Slog.w(TAG,</span><br><span class="line">                        <span class="string">"Activity being started in new voice task does not support: "</span></span><br><span class="line">                                + intent);</span><br><span class="line">                err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Failure checking voice capabilities"</span>, e);</span><br><span class="line">            err = ActivityManager.START_NOT_VOICE_COMPATIBLE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack resultStack = resultRecord == <span class="keyword">null</span> ? <span class="keyword">null</span> : resultRecord.getStack();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultStack.sendActivityResultLocked(</span><br><span class="line">                    -<span class="number">1</span>, resultRecord, resultWho, requestCode, RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SafeActivityOptions.abort(options);</span><br><span class="line">        <span class="keyword">return</span> err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> abort = !mSupervisor.checkStartAnyActivityPermission(intent, aInfo, resultWho,</span><br><span class="line">            requestCode, callingPid, callingUid, callingPackage, ignoreTargetSecurity,</span><br><span class="line">            inTask != <span class="keyword">null</span>, callerApp, resultRecord, resultStack);</span><br><span class="line">    abort |= !mService.mIntentFirewall.checkStartActivity(intent, callingUid,</span><br><span class="line">            callingPid, resolvedType, aInfo.applicationInfo);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Merge the two options bundles, while realCallerOptions takes precedence.</span></span><br><span class="line">    ActivityOptions checkedOptions = options != <span class="keyword">null</span></span><br><span class="line">            ? options.getOptions(intent, aInfo, callerApp, mSupervisor)</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (allowPendingRemoteAnimationRegistryLookup) &#123;</span><br><span class="line">        checkedOptions = mService.getActivityStartController()</span><br><span class="line">                .getPendingRemoteAnimationRegistry()</span><br><span class="line">                .overrideOptionsIfNeeded(callingPackage, checkedOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mService.mController != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// The Intent we give to the watcher has the extra data</span></span><br><span class="line">            <span class="comment">// stripped off, since it can contain private information.</span></span><br><span class="line">            Intent watchIntent = intent.cloneFilter();</span><br><span class="line">            abort |= !mService.mController.activityStarting(watchIntent,</span><br><span class="line">                    aInfo.applicationInfo.packageName);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            mService.mController = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mInterceptor.setStates(userId, realCallingPid, realCallingUid, startFlags, callingPackage);</span><br><span class="line">    <span class="keyword">if</span> (mInterceptor.intercept(intent, rInfo, aInfo, resolvedType, inTask, callingPid,</span><br><span class="line">            callingUid, checkedOptions)) &#123;</span><br><span class="line">        <span class="comment">// activity start was intercepted, e.g. because the target user is currently in quiet</span></span><br><span class="line">        <span class="comment">// mode (turn off work) or the target application is suspended</span></span><br><span class="line">        intent = mInterceptor.mIntent;</span><br><span class="line">        rInfo = mInterceptor.mRInfo;</span><br><span class="line">        aInfo = mInterceptor.mAInfo;</span><br><span class="line">        resolvedType = mInterceptor.mResolvedType;</span><br><span class="line">        inTask = mInterceptor.mInTask;</span><br><span class="line">        callingPid = mInterceptor.mCallingPid;</span><br><span class="line">        callingUid = mInterceptor.mCallingUid;</span><br><span class="line">        checkedOptions = mInterceptor.mActivityOptions;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (abort) &#123;</span><br><span class="line">        <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">            resultStack.sendActivityResultLocked(-<span class="number">1</span>, resultRecord, resultWho, requestCode,</span><br><span class="line">                    RESULT_CANCELED, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// We pretend to the caller that it was really started, but</span></span><br><span class="line">        <span class="comment">// they will just get a cancel result.</span></span><br><span class="line">        ActivityOptions.abort(checkedOptions);</span><br><span class="line">        <span class="keyword">return</span> START_ABORTED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If permissions need a review before any of the app components can run, we</span></span><br><span class="line">    <span class="comment">// launch the review activity and pass a pending intent to start the activity</span></span><br><span class="line">    <span class="comment">// we are to launching now after the review is completed.</span></span><br><span class="line">    <span class="keyword">if</span> (mService.mPermissionReviewRequired &amp;&amp; aInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mService.getPackageManagerInternalLocked().isPermissionsReviewRequired(</span><br><span class="line">                aInfo.packageName, userId)) &#123;</span><br><span class="line">            IIntentSender target = mService.getIntentSenderLocked(</span><br><span class="line">                    ActivityManager.INTENT_SENDER_ACTIVITY, callingPackage,</span><br><span class="line">                    callingUid, userId, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>, <span class="keyword">new</span> Intent[]&#123;intent&#125;,</span><br><span class="line">                    <span class="keyword">new</span> String[]&#123;resolvedType&#125;, PendingIntent.FLAG_CANCEL_CURRENT</span><br><span class="line">                            | PendingIntent.FLAG_ONE_SHOT, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> flags = intent.getFlags();</span><br><span class="line">            Intent newIntent = <span class="keyword">new</span> Intent(Intent.ACTION_REVIEW_PERMISSIONS);</span><br><span class="line">            newIntent.setFlags(flags</span><br><span class="line">                    | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_PACKAGE_NAME, aInfo.packageName);</span><br><span class="line">            newIntent.putExtra(Intent.EXTRA_INTENT, <span class="keyword">new</span> IntentSender(target));</span><br><span class="line">            <span class="keyword">if</span> (resultRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newIntent.putExtra(Intent.EXTRA_RESULT_NEEDED, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            intent = newIntent;</span><br><span class="line"></span><br><span class="line">            resolvedType = <span class="keyword">null</span>;</span><br><span class="line">            callingUid = realCallingUid;</span><br><span class="line">            callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">            rInfo = mSupervisor.resolveIntent(intent, resolvedType, userId, <span class="number">0</span>,</span><br><span class="line">                    computeResolveFilterUid(</span><br><span class="line">                            callingUid, realCallingUid, mRequest.filterCallingUid));</span><br><span class="line">            aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_PERMISSIONS_REVIEW) &#123;</span><br><span class="line">                Slog.i(TAG, <span class="string">"START u"</span> + userId + <span class="string">" &#123;"</span> + intent.toShortString(<span class="keyword">true</span>, <span class="keyword">true</span>,</span><br><span class="line">                        <span class="keyword">true</span>, <span class="keyword">false</span>) + <span class="string">"&#125; from uid "</span> + callingUid + <span class="string">" on display "</span></span><br><span class="line">                        + (mSupervisor.mFocusedStack == <span class="keyword">null</span></span><br><span class="line">                        ? DEFAULT_DISPLAY : mSupervisor.mFocusedStack.mDisplayId));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we have an ephemeral app, abort the process of launching the resolved intent.</span></span><br><span class="line">    <span class="comment">// Instead, launch the ephemeral installer. Once the installer is finished, it</span></span><br><span class="line">    <span class="comment">// starts either the intent we resolved here [on install error] or the ephemeral</span></span><br><span class="line">    <span class="comment">// app [on install success].</span></span><br><span class="line">    <span class="keyword">if</span> (rInfo != <span class="keyword">null</span> &amp;&amp; rInfo.auxiliaryInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent = createLaunchIntent(rInfo.auxiliaryInfo, ephemeralIntent,</span><br><span class="line">                callingPackage, verificationBundle, resolvedType, userId);</span><br><span class="line">        resolvedType = <span class="keyword">null</span>;</span><br><span class="line">        callingUid = realCallingUid;</span><br><span class="line">        callingPid = realCallingPid;</span><br><span class="line"></span><br><span class="line">        aInfo = mSupervisor.resolveActivity(intent, rInfo, startFlags, <span class="keyword">null</span> <span class="comment">/*profilerInfo*/</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ActivityRecord r = <span class="keyword">new</span> ActivityRecord(mService, callerApp, callingPid, callingUid,</span><br><span class="line">            callingPackage, intent, resolvedType, aInfo, mService.getGlobalConfiguration(),</span><br><span class="line">            resultRecord, resultWho, requestCode, componentSpecified, voiceSession != <span class="keyword">null</span>,</span><br><span class="line">            mSupervisor, checkedOptions, sourceRecord);</span><br><span class="line">    <span class="keyword">if</span> (outActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        outActivity[<span class="number">0</span>] = r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.appTimeTracker == <span class="keyword">null</span> &amp;&amp; sourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the caller didn't specify an explicit time tracker, we want to continue</span></span><br><span class="line">        <span class="comment">// tracking under any it has.</span></span><br><span class="line">        r.appTimeTracker = sourceRecord.appTimeTracker;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = mSupervisor.mFocusedStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are starting an activity that is not from the same uid as the currently resumed</span></span><br><span class="line">    <span class="comment">// one, check whether app switches are allowed.</span></span><br><span class="line">    <span class="keyword">if</span> (voiceSession == <span class="keyword">null</span> &amp;&amp; (stack.getResumedActivity() == <span class="keyword">null</span></span><br><span class="line">            || stack.getResumedActivity().info.applicationInfo.uid != realCallingUid)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mService.checkAppSwitchAllowedLocked(callingPid, callingUid,</span><br><span class="line">                realCallingPid, realCallingUid, <span class="string">"Activity start"</span>)) &#123;</span><br><span class="line">            mController.addPendingActivityLaunch(<span class="keyword">new</span> PendingActivityLaunch(r,</span><br><span class="line">                    sourceRecord, startFlags, stack, callerApp));</span><br><span class="line">            ActivityOptions.abort(checkedOptions);</span><br><span class="line">            <span class="keyword">return</span> ActivityManager.START_SWITCHES_CANCELED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mService.mDidAppSwitch) &#123;</span><br><span class="line">        <span class="comment">// This is the second allowed switch since we stopped switches,</span></span><br><span class="line">        <span class="comment">// so now just generally allow switches.  Use case: user presses</span></span><br><span class="line">        <span class="comment">// home (switches disabled, switch to home, mDidAppSwitch now true);</span></span><br><span class="line">        <span class="comment">// user taps a home icon (coming from home so allowed, we hit here</span></span><br><span class="line">        <span class="comment">// and now allow anyone to switch again).</span></span><br><span class="line">        mService.mAppSwitchesAllowedTime = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mService.mDidAppSwitch = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mController.doPendingActivityLaunches(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags,</span><br><span class="line">            <span class="keyword">true</span> <span class="comment">/* doResume */</span>, checkedOptions, inTask, outActivity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个方法中，主要创建一个 ActivityRecord 。重点关注最后一句代码：</p>
<pre><code>return startActivity(r, sourceRecord, voiceSession, voiceInteractor, startFlags, true /* doResume */, checkedOptions, inTask, outActivity);
</code></pre><p>所以又又又跳转到另外一个 startActivity 的重载方法中了。。</p>
<h2 id="startActivity_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29"><a href="#startActivity_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29" class="headerlink" title="startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)"></a>startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivity</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">            IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">            <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">            ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = START_CANCELED;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mService.mWindowManager.deferSurfaceLayout();</span><br><span class="line">        <span class="comment">// 重点看这里</span></span><br><span class="line">        result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor,</span><br><span class="line">                startFlags, doResume, options, inTask, outActivity);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we are not able to proceed, disassociate the activity from the task. Leaving an</span></span><br><span class="line">        <span class="comment">// activity in an incomplete state can lead to issues, such as performing operations</span></span><br><span class="line">        <span class="comment">// without a window container.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityStack stack = mStartActivity.getStack();</span><br><span class="line">        <span class="keyword">if</span> (!ActivityManager.isStartResultSuccessful(result) &amp;&amp; stack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack.finishActivityLocked(mStartActivity, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* intentResultData */</span>, <span class="string">"startActivity"</span>, <span class="keyword">true</span> <span class="comment">/* oomAdj */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.mWindowManager.continueSurfaceLayout();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postStartActivityProcessing(r, result, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法内部，把操作交给了 startActivityUnchecked 方法。</p>
<h2 id="startActivityUnchecked_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29"><a href="#startActivityUnchecked_28final_ActivityRecord_r_2C_ActivityRecord_sourceRecord_2C_IVoiceInteractionSession_voiceSession_2C_IVoiceInteractor_voiceInteractor_2C_int_startFlags_2C_boolean_doResume_2C_ActivityOptions_options_2C_TaskRecord_inTask_2C_ActivityRecord_5B_5D_outActivity_29" class="headerlink" title="startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)"></a>startActivityUnchecked(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">startActivityUnchecked</span><span class="params">(<span class="keyword">final</span> ActivityRecord r, ActivityRecord sourceRecord,</span><br><span class="line">        IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor,</span><br><span class="line">        <span class="keyword">int</span> startFlags, <span class="keyword">boolean</span> doResume, ActivityOptions options, TaskRecord inTask,</span><br><span class="line">        ActivityRecord[] outActivity)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    setInitialState(r, options, inTask, doResume, startFlags, sourceRecord, voiceSession,</span><br><span class="line">            voiceInteractor);</span><br><span class="line"></span><br><span class="line">    computeLaunchingTaskFlags();</span><br><span class="line"></span><br><span class="line">    computeSourceStack();</span><br><span class="line"></span><br><span class="line">    mIntent.setFlags(mLaunchFlags);</span><br><span class="line"></span><br><span class="line">    ActivityRecord reusedActivity = getReusableIntentActivity();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> preferredWindowingMode = WINDOWING_MODE_UNDEFINED;</span><br><span class="line">    <span class="keyword">int</span> preferredLaunchDisplayId = DEFAULT_DISPLAY;</span><br><span class="line">    <span class="keyword">if</span> (mOptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        preferredWindowingMode = mOptions.getLaunchWindowingMode();</span><br><span class="line">        preferredLaunchDisplayId = mOptions.getLaunchDisplayId();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// windowing mode and preferred launch display values from &#123;@link LaunchParams&#125; take</span></span><br><span class="line">    <span class="comment">// priority over those specified in &#123;@link ActivityOptions&#125;.</span></span><br><span class="line">    <span class="keyword">if</span> (!mLaunchParams.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mLaunchParams.hasPreferredDisplay()) &#123;</span><br><span class="line">            preferredLaunchDisplayId = mLaunchParams.mPreferredDisplayId;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mLaunchParams.hasWindowingMode()) &#123;</span><br><span class="line">            preferredWindowingMode = mLaunchParams.mWindowingMode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// When the flags NEW_TASK and CLEAR_TASK are set, then the task gets reused but</span></span><br><span class="line">        <span class="comment">// still needs to be a lock task mode violation since the task gets cleared out and</span></span><br><span class="line">        <span class="comment">// the device would otherwise leave the locked task.</span></span><br><span class="line">        <span class="keyword">if</span> (mService.getLockTaskController().isLockTaskModeViolation(reusedActivity.getTask(),</span><br><span class="line">                (mLaunchFlags &amp; (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))</span><br><span class="line">                        == (FLAG_ACTIVITY_NEW_TASK | FLAG_ACTIVITY_CLEAR_TASK))) &#123;</span><br><span class="line">            Slog.e(TAG, <span class="string">"startActivityUnchecked: Attempt to violate Lock Task Mode"</span>);</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_LOCK_TASK_MODE_VIOLATION;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// True if we are clearing top and resetting of a standard (default) launch mode</span></span><br><span class="line">        <span class="comment">// (&#123;@code LAUNCH_MULTIPLE&#125;) activity. The existing activity will be finished.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> clearTopAndResetStandardLaunchMode =</span><br><span class="line">                (mLaunchFlags &amp; (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED))</span><br><span class="line">                        == (FLAG_ACTIVITY_CLEAR_TOP | FLAG_ACTIVITY_RESET_TASK_IF_NEEDED)</span><br><span class="line">                &amp;&amp; mLaunchMode == LAUNCH_MULTIPLE;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If mStartActivity does not have a task associated with it, associate it with the</span></span><br><span class="line">        <span class="comment">// reused activity's task. Do not do so if we're clearing top and resetting for a</span></span><br><span class="line">        <span class="comment">// standard launchMode activity.</span></span><br><span class="line">        <span class="keyword">if</span> (mStartActivity.getTask() == <span class="keyword">null</span> &amp;&amp; !clearTopAndResetStandardLaunchMode) &#123;</span><br><span class="line">            mStartActivity.setTask(reusedActivity.getTask());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reusedActivity.getTask().intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// This task was started because of movement of the activity based on affinity...</span></span><br><span class="line">            <span class="comment">// Now that we are actually launching it, we can assign the base intent.</span></span><br><span class="line">            reusedActivity.getTask().setIntent(mStartActivity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// This code path leads to delivering a new intent, we want to make sure we schedule it</span></span><br><span class="line">        <span class="comment">// as the first operation, in case the activity will be resumed as a result of later</span></span><br><span class="line">        <span class="comment">// operations.</span></span><br><span class="line">        <span class="keyword">if</span> ((mLaunchFlags &amp; FLAG_ACTIVITY_CLEAR_TOP) != <span class="number">0</span></span><br><span class="line">                || isDocumentLaunchesIntoExisting(mLaunchFlags)</span><br><span class="line">                || isLaunchModeOneOf(LAUNCH_SINGLE_INSTANCE, LAUNCH_SINGLE_TASK)) &#123;</span><br><span class="line">            <span class="keyword">final</span> TaskRecord task = reusedActivity.getTask();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// In this situation we want to remove all activities from the task up to the one</span></span><br><span class="line">            <span class="comment">// being started. In most cases this means we are resetting the task to its initial</span></span><br><span class="line">            <span class="comment">// state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityRecord top = task.performClearTaskForReuseLocked(mStartActivity,</span><br><span class="line">                    mLaunchFlags);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// The above code can remove &#123;@code reusedActivity&#125; from the task, leading to the</span></span><br><span class="line">            <span class="comment">// the &#123;@code ActivityRecord&#125; removing its reference to the &#123;@code TaskRecord&#125;. The</span></span><br><span class="line">            <span class="comment">// task reference is needed in the call below to</span></span><br><span class="line">            <span class="comment">// &#123;@link setTargetStackAndMoveToFrontIfNeeded&#125;.</span></span><br><span class="line">            <span class="keyword">if</span> (reusedActivity.getTask() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                reusedActivity.setTask(task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (top != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (top.frontOfTask) &#123;</span><br><span class="line">                    <span class="comment">// Activity aliases may mean we use different intents for the top activity,</span></span><br><span class="line">                    <span class="comment">// so make sure the task now has the identity of the new intent.</span></span><br><span class="line">                    top.getTask().setIntent(mStartActivity);</span><br><span class="line">                &#125;</span><br><span class="line">                deliverNewIntent(top);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mSupervisor.sendPowerHintForLaunchStartIfNeeded(<span class="keyword">false</span> <span class="comment">/* forceSend */</span>, reusedActivity);</span><br><span class="line"></span><br><span class="line">        reusedActivity = setTargetStackAndMoveToFrontIfNeeded(reusedActivity);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord outResult =</span><br><span class="line">                outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span> ? outActivity[<span class="number">0</span>] : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When there is a reused activity and the current result is a trampoline activity,</span></span><br><span class="line">        <span class="comment">// set the reused activity as the result.</span></span><br><span class="line">        <span class="keyword">if</span> (outResult != <span class="keyword">null</span> &amp;&amp; (outResult.finishing || outResult.noDisplay)) &#123;</span><br><span class="line">            outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do anything</span></span><br><span class="line">            <span class="comment">// if that is the case, so this is it!  And for paranoia, make sure we have</span></span><br><span class="line">            <span class="comment">// correctly resumed the top activity.</span></span><br><span class="line">            resumeTargetStackIfNeeded();</span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (reusedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setTaskFromIntentActivity(reusedActivity);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!mAddingToTask &amp;&amp; mReuseTask == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// We didn't do anything...  but it was needed (a.k.a., client don't use that</span></span><br><span class="line">                <span class="comment">// intent!)  And for paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line"></span><br><span class="line">                resumeTargetStackIfNeeded();</span><br><span class="line">                <span class="keyword">if</span> (outActivity != <span class="keyword">null</span> &amp;&amp; outActivity.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    outActivity[<span class="number">0</span>] = reusedActivity;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> mMovedToFront ? START_TASK_TO_FRONT : START_DELIVERED_TO_TOP;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.packageName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityStack sourceStack = mStartActivity.resultTo != <span class="keyword">null</span></span><br><span class="line">                ? mStartActivity.resultTo.getStack() : <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (sourceStack != <span class="keyword">null</span>) &#123;</span><br><span class="line">            sourceStack.sendActivityResultLocked(-<span class="number">1</span> <span class="comment">/* callingUid */</span>, mStartActivity.resultTo,</span><br><span class="line">                    mStartActivity.resultWho, mStartActivity.requestCode, RESULT_CANCELED,</span><br><span class="line">                    <span class="keyword">null</span> <span class="comment">/* data */</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">return</span> START_CLASS_NOT_FOUND;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the activity being launched is the same as the one currently at the top, then</span></span><br><span class="line">    <span class="comment">// we need to check if it should only be launched once.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityStack topStack = mSupervisor.mFocusedStack;</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord topFocused = topStack.getTopActivity();</span><br><span class="line">    <span class="keyword">final</span> ActivityRecord top = topStack.topRunningNonDelayedActivityLocked(mNotTop);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dontStart = top != <span class="keyword">null</span> &amp;&amp; mStartActivity.resultTo == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; top.realActivity.equals(mStartActivity.realActivity)</span><br><span class="line">            &amp;&amp; top.userId == mStartActivity.userId</span><br><span class="line">            &amp;&amp; top.app != <span class="keyword">null</span> &amp;&amp; top.app.thread != <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; ((mLaunchFlags &amp; FLAG_ACTIVITY_SINGLE_TOP) != <span class="number">0</span></span><br><span class="line">            || isLaunchModeOneOf(LAUNCH_SINGLE_TOP, LAUNCH_SINGLE_TASK));</span><br><span class="line">    <span class="keyword">if</span> (dontStart) &#123;</span><br><span class="line">        <span class="comment">// For paranoia, make sure we have correctly resumed the top activity.</span></span><br><span class="line">        topStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked();</span><br><span class="line">        &#125;</span><br><span class="line">        ActivityOptions.abort(mOptions);</span><br><span class="line">        <span class="keyword">if</span> ((mStartFlags &amp; START_FLAG_ONLY_IF_NEEDED) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// We don't need to start a new activity, and the client said not to do</span></span><br><span class="line">            <span class="comment">// anything if that is the case, so this is it!</span></span><br><span class="line">            <span class="keyword">return</span> START_RETURN_INTENT_TO_CALLER;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        deliverNewIntent(top);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't use mStartActivity.task to show the toast. We're not starting a new activity</span></span><br><span class="line">        <span class="comment">// but reusing 'top'. Fields in mStartActivity may not be fully initialized.</span></span><br><span class="line">        mSupervisor.handleNonResizableTaskIfNeeded(top.getTask(), preferredWindowingMode,</span><br><span class="line">                preferredLaunchDisplayId, topStack);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> START_DELIVERED_TO_TOP;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> newTask = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> TaskRecord taskToAffiliate = (mLaunchTaskBehind &amp;&amp; mSourceRecord != <span class="keyword">null</span>)</span><br><span class="line">            ? mSourceRecord.getTask() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Should this be considered a new task?</span></span><br><span class="line">    <span class="keyword">int</span> result = START_SUCCESS;</span><br><span class="line">    <span class="keyword">if</span> (mStartActivity.resultTo == <span class="keyword">null</span> &amp;&amp; mInTask == <span class="keyword">null</span> &amp;&amp; !mAddingToTask</span><br><span class="line">            &amp;&amp; (mLaunchFlags &amp; FLAG_ACTIVITY_NEW_TASK) != <span class="number">0</span>) &#123;</span><br><span class="line">        newTask = <span class="keyword">true</span>;</span><br><span class="line">        result = setTaskFromReuseOrCreateNewTask(taskToAffiliate, topStack);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mSourceRecord != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromSourceRecord();</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mInTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">        result = setTaskFromInTask();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This not being started from an existing activity, and not part of a new task...</span></span><br><span class="line">        <span class="comment">// just put it in the top task, though these days this case should never happen.</span></span><br><span class="line">        setTaskToCurrentTopOrCreateNewTask();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (result != START_SUCCESS) &#123;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.grantUriPermissionFromIntentLocked(mCallingUid, mStartActivity.packageName,</span><br><span class="line">            mIntent, mStartActivity.getUriPermissionsLocked(), mStartActivity.userId);</span><br><span class="line">    mService.grantEphemeralAccessLocked(mStartActivity.userId, mIntent,</span><br><span class="line">            mStartActivity.appInfo.uid, UserHandle.getAppId(mCallingUid));</span><br><span class="line">    <span class="keyword">if</span> (newTask) &#123;</span><br><span class="line">        EventLog.writeEvent(EventLogTags.AM_CREATE_TASK, mStartActivity.userId,</span><br><span class="line">                mStartActivity.getTask().taskId);</span><br><span class="line">    &#125;</span><br><span class="line">    ActivityStack.logStartActivity(</span><br><span class="line">            EventLogTags.AM_CREATE_ACTIVITY, mStartActivity, mStartActivity.getTask());</span><br><span class="line">    mTargetStack.mLastPausedActivity = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mSupervisor.sendPowerHintForLaunchStartIfNeeded(<span class="keyword">false</span> <span class="comment">/* forceSend */</span>, mStartActivity);</span><br><span class="line"></span><br><span class="line">    mTargetStack.startActivityLocked(mStartActivity, topFocused, newTask, mKeepCurTransition,</span><br><span class="line">            mOptions);</span><br><span class="line">    <span class="keyword">if</span> (mDoResume) &#123;</span><br><span class="line">        <span class="keyword">final</span> ActivityRecord topTaskActivity =</span><br><span class="line">                mStartActivity.getTask().topRunningActivityLocked();</span><br><span class="line">        <span class="keyword">if</span> (!mTargetStack.isFocusable()</span><br><span class="line">                || (topTaskActivity != <span class="keyword">null</span> &amp;&amp; topTaskActivity.mTaskOverlay</span><br><span class="line">                &amp;&amp; mStartActivity != topTaskActivity)) &#123;</span><br><span class="line">            <span class="comment">// If the activity is not focusable, we can't resume it, but still would like to</span></span><br><span class="line">            <span class="comment">// make sure it becomes visible as it starts (this will also trigger entry</span></span><br><span class="line">            <span class="comment">// animation). An example of this are PIP activities.</span></span><br><span class="line">            <span class="comment">// Also, we don't want to resume activities in a task that currently has an overlay</span></span><br><span class="line">            <span class="comment">// as the starting activity just needs to be in the visible paused state until the</span></span><br><span class="line">            <span class="comment">// over is removed.</span></span><br><span class="line">            mTargetStack.ensureActivitiesVisibleLocked(<span class="keyword">null</span>, <span class="number">0</span>, !PRESERVE_WINDOWS);</span><br><span class="line">            <span class="comment">// Go ahead and tell window manager to execute app transition for this activity</span></span><br><span class="line">            <span class="comment">// since the app transition will not be triggered through the resume channel.</span></span><br><span class="line">            mService.mWindowManager.executeAppTransition();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// If the target stack was not previously focusable (previous top running activity</span></span><br><span class="line">            <span class="comment">// on that stack was not visible) then any prior calls to move the stack to the</span></span><br><span class="line">            <span class="comment">// will not update the focused stack.  If starting the new activity now allows the</span></span><br><span class="line">            <span class="comment">// task stack to be focusable, then ensure that we now update the focused stack</span></span><br><span class="line">            <span class="comment">// accordingly.</span></span><br><span class="line">            <span class="keyword">if</span> (mTargetStack.isFocusable() &amp;&amp; !mSupervisor.isFocusedStack(mTargetStack)) &#123;</span><br><span class="line">                mTargetStack.moveToFront(<span class="string">"startActivityUnchecked"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mSupervisor.resumeFocusedStackTopActivityLocked(mTargetStack, mStartActivity,</span><br><span class="line">                    mOptions);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mStartActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mSupervisor.mRecentTasks.add(mStartActivity.getTask());</span><br><span class="line">    &#125;</span><br><span class="line">    mSupervisor.updateUserStackLocked(mStartActivity.userId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    mSupervisor.handleNonResizableTaskIfNeeded(mStartActivity.getTask(), preferredWindowingMode,</span><br><span class="line">            preferredLaunchDisplayId, mTargetStack);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> START_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 startActivityUnchecked 中，给 Activity 设置了 TaskRecord , 完成后执行ActivityStackSupervisor.resumeFocusedStackTopActivityLocked 方法。</p>
<h1 id="ActivityStackSupervisor"><a href="#ActivityStackSupervisor" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h1><h2 id="resumeFocusedStackTopActivityLocked_28ActivityStack_targetStack_2C_ActivityRecord_target_2C_ActivityOptions_targetOptions_29"><a href="#resumeFocusedStackTopActivityLocked_28ActivityStack_targetStack_2C_ActivityRecord_target_2C_ActivityOptions_targetOptions_29" class="headerlink" title="resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)"></a>resumeFocusedStackTopActivityLocked(ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeFocusedStackTopActivityLocked</span><span class="params">(</span><br><span class="line">        ActivityStack targetStack, ActivityRecord target, ActivityOptions targetOptions)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!readyToResume()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (targetStack != <span class="keyword">null</span> &amp;&amp; isFocusedStack(targetStack)) &#123;</span><br><span class="line">        <span class="keyword">return</span> targetStack.resumeTopActivityUncheckedLocked(target, targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord r = mFocusedStack.topRunningActivityLocked();</span><br><span class="line">    <span class="keyword">if</span> (r == <span class="keyword">null</span> || !r.isState(RESUMED)) &#123;</span><br><span class="line">        mFocusedStack.resumeTopActivityUncheckedLocked(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (r.isState(RESUMED)) &#123;</span><br><span class="line">        <span class="comment">// Kick off any lingering app transitions form the MoveTaskToFront operation.</span></span><br><span class="line">        mFocusedStack.executeAppTransition(targetOptions);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 resumeFocusedStackTopActivityLocked 中，跳转到 ActivityStack 的 resumeTopActivityUncheckedLocked 方法中去执行了。</p>
<h1 id="ActivityStack"><a href="#ActivityStack" class="headerlink" title="ActivityStack"></a>ActivityStack</h1><h2 id="resumeTopActivityUncheckedLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29"><a href="#resumeTopActivityUncheckedLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29" class="headerlink" title="resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options)"></a>resumeTopActivityUncheckedLocked(ActivityRecord prev, ActivityOptions options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">resumeTopActivityUncheckedLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mStackSupervisor.inResumeTopActivity) &#123;</span><br><span class="line">        <span class="comment">// Don't even start recursing.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Protect against recursion.</span></span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">true</span>;</span><br><span class="line">        result = resumeTopActivityInnerLocked(prev, options);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// When resuming the top activity, it may be necessary to pause the top activity (for</span></span><br><span class="line">        <span class="comment">// example, returning to the lock screen. We suppress the normal pause logic in</span></span><br><span class="line">        <span class="comment">// &#123;@link #resumeTopActivityUncheckedLocked&#125;, since the top activity is resumed at the</span></span><br><span class="line">        <span class="comment">// end. We call the &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; again here</span></span><br><span class="line">        <span class="comment">// to ensure any necessary pause logic occurs. In the case where the Activity will be</span></span><br><span class="line">        <span class="comment">// shown regardless of the lock screen, the call to</span></span><br><span class="line">        <span class="comment">// &#123;@link ActivityStackSupervisor#checkReadyForSleepLocked&#125; is skipped.</span></span><br><span class="line">        <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span> || !next.canTurnScreenOn()) &#123;</span><br><span class="line">            checkReadyForSleep();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mStackSupervisor.inResumeTopActivity = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到代码中的 result 是 resumeTopActivityInnerLocked 方法的返回值。所以还要跳到 resumeTopActivityInnerLocked 方法中去看。</p>
<h2 id="resumeTopActivityInnerLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29"><a href="#resumeTopActivityInnerLocked_28ActivityRecord_prev_2C_ActivityOptions_options_29" class="headerlink" title="resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)"></a>resumeTopActivityInnerLocked(ActivityRecord prev, ActivityOptions options)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@GuardedBy</span>(<span class="string">"mService"</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">resumeTopActivityInnerLocked</span><span class="params">(ActivityRecord prev, ActivityOptions options)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mService.mBooting &amp;&amp; !mService.mBooted) &#123;</span><br><span class="line">        <span class="comment">// Not ready yet!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Find the next top-most activity to resume in this stack that is not finishing and is</span></span><br><span class="line">    <span class="comment">// focusable. If it is not focusable, we will fall into the case below to resume the</span></span><br><span class="line">    <span class="comment">// top activity in the next focusable task.</span></span><br><span class="line">    <span class="keyword">final</span> ActivityRecord next = topRunningActivityLocked(<span class="keyword">true</span> <span class="comment">/* focusableOnly */</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> hasRunningActivity = next != <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Maybe this entire condition can get removed?</span></span><br><span class="line">    <span class="keyword">if</span> (hasRunningActivity &amp;&amp; !isAttached()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.cancelInitializingActivities();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remember how we'll process this pause/resume situation, and ensure</span></span><br><span class="line">    <span class="comment">// that the state is reset however we wind up proceeding.</span></span><br><span class="line">    <span class="keyword">boolean</span> userLeaving = mStackSupervisor.mUserLeaving;</span><br><span class="line">    mStackSupervisor.mUserLeaving = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!hasRunningActivity) &#123;</span><br><span class="line">        <span class="comment">// There are no activities left in the stack, let's look somewhere else.</span></span><br><span class="line">        <span class="keyword">return</span> resumeTopActivityInNextFocusableStack(prev, options, <span class="string">"noMoreActivities"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    next.delayedResume = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the top activity is the resumed one, nothing to do.</span></span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Top activity resumed "</span> + next);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are sleeping, and there is no resumed activity, and the top</span></span><br><span class="line">    <span class="comment">// activity is paused, well that is the state we want.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSleepOrShutDownActivities()</span><br><span class="line">            &amp;&amp; mLastPausedActivity == next</span><br><span class="line">            &amp;&amp; mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Going to sleep and all paused"</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure that the user who owns this activity is started.  If not,</span></span><br><span class="line">    <span class="comment">// we will just leave it as is because someone should be bringing</span></span><br><span class="line">    <span class="comment">// another user's activities to the top of the stack.</span></span><br><span class="line">    <span class="keyword">if</span> (!mService.mUserController.hasStartedUserState(next.userId)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Skipping resume of top activity "</span> + next</span><br><span class="line">                + <span class="string">": user "</span> + next.userId + <span class="string">" is stopped"</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// The activity may be waiting for stop, but that is no longer</span></span><br><span class="line">    <span class="comment">// appropriate for it.</span></span><br><span class="line">    mStackSupervisor.mStoppingActivities.remove(next);</span><br><span class="line">    mStackSupervisor.mGoingToSleepActivities.remove(next);</span><br><span class="line">    next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">    mStackSupervisor.mActivitiesWaitingForVisibleActivity.remove(next);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resuming "</span> + next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we are currently pausing an activity, then don't do anything until that is done.</span></span><br><span class="line">    <span class="keyword">if</span> (!mStackSupervisor.allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Skip resume: some activity pausing."</span>);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.setLaunchSource(next.info.applicationInfo.uid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> lastResumedCanPip = <span class="keyword">false</span>;</span><br><span class="line">    ActivityRecord lastResumed = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">final</span> ActivityStack lastFocusedStack = mStackSupervisor.getLastStack();</span><br><span class="line">    <span class="keyword">if</span> (lastFocusedStack != <span class="keyword">null</span> &amp;&amp; lastFocusedStack != <span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// So, why aren't we using prev here??? See the param comment on the method. prev doesn't</span></span><br><span class="line">        <span class="comment">// represent the last resumed activity. However, the last focus stack does if it isn't null.</span></span><br><span class="line">        lastResumed = lastFocusedStack.mResumedActivity;</span><br><span class="line">        <span class="keyword">if</span> (userLeaving &amp;&amp; inMultiWindowMode() &amp;&amp; lastFocusedStack.shouldBeVisible(next)) &#123;</span><br><span class="line">            <span class="comment">// The user isn't leaving if this stack is the multi-window mode and the last</span></span><br><span class="line">            <span class="comment">// focused stack should still be visible.</span></span><br><span class="line">            <span class="keyword">if</span>(DEBUG_USER_LEAVING) Slog.i(TAG_USER_LEAVING, <span class="string">"Overriding userLeaving to false"</span></span><br><span class="line">                    + <span class="string">" next="</span> + next + <span class="string">" lastResumed="</span> + lastResumed);</span><br><span class="line">            userLeaving = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        lastResumedCanPip = lastResumed != <span class="keyword">null</span> &amp;&amp; lastResumed.checkEnterPictureInPictureState(</span><br><span class="line">                <span class="string">"resumeTopActivity"</span>, userLeaving <span class="comment">/* beforeStopping */</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If the flag RESUME_WHILE_PAUSING is set, then continue to schedule the previous activity</span></span><br><span class="line">    <span class="comment">// to be paused, while at the same time resuming the new resume activity only if the</span></span><br><span class="line">    <span class="comment">// previous activity can't go into Pip since we want to give Pip activities a chance to</span></span><br><span class="line">    <span class="comment">// enter Pip before resuming the next activity.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> resumeWhilePausing = (next.info.flags &amp; FLAG_RESUME_WHILE_PAUSING) != <span class="number">0</span></span><br><span class="line">            &amp;&amp; !lastResumedCanPip;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> pausing = mStackSupervisor.pauseBackStacks(userLeaving, next, <span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (mResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Pausing "</span> + mResumedActivity);</span><br><span class="line">        pausing |= startPausingLocked(userLeaving, <span class="keyword">false</span>, next, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pausing &amp;&amp; !resumeWhilePausing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Skip resume: need to start pausing"</span>);</span><br><span class="line">        <span class="comment">// At this point we want to put the upcoming activity's process</span></span><br><span class="line">        <span class="comment">// at the top of the LRU list, since we know we will be needing it</span></span><br><span class="line">        <span class="comment">// very soon and it would be a waste to let it get killed if it</span></span><br><span class="line">        <span class="comment">// happens to be sitting towards the end.</span></span><br><span class="line">        <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">if</span> (lastResumed != <span class="keyword">null</span>) &#123;</span><br><span class="line">            lastResumed.setWillCloseOrEnterPip(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mResumedActivity == next &amp;&amp; next.isState(RESUMED)</span><br><span class="line">            &amp;&amp; mStackSupervisor.allResumedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// It is possible for the activity to be resumed when we paused back stacks above if the</span></span><br><span class="line">        <span class="comment">// next activity doesn't have to wait for pause to complete.</span></span><br><span class="line">        <span class="comment">// So, nothing else to-do except:</span></span><br><span class="line">        <span class="comment">// Make sure we have executed any pending transitions, since there</span></span><br><span class="line">        <span class="comment">// should be nothing left to do at this point.</span></span><br><span class="line">        executeAppTransition(options);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"resumeTopActivityLocked: Top activity resumed (dontWaitForPause) "</span> + next);</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the most recent activity was noHistory but was only stopped rather</span></span><br><span class="line">    <span class="comment">// than stopped+finished because the device went to sleep, we need to make</span></span><br><span class="line">    <span class="comment">// sure to finish it as we're making a new activity topmost.</span></span><br><span class="line">    <span class="keyword">if</span> (shouldSleepActivities() &amp;&amp; mLastNoHistoryActivity != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !mLastNoHistoryActivity.finishing) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES,</span><br><span class="line">                <span class="string">"no-history finish of "</span> + mLastNoHistoryActivity + <span class="string">" on new resume"</span>);</span><br><span class="line">        requestFinishActivityLocked(mLastNoHistoryActivity.appToken, Activity.RESULT_CANCELED,</span><br><span class="line">                <span class="keyword">null</span>, <span class="string">"resume-no-history"</span>, <span class="keyword">false</span>);</span><br><span class="line">        mLastNoHistoryActivity = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span> &amp;&amp; prev != next) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                &amp;&amp; next != <span class="keyword">null</span> &amp;&amp; !next.nowVisible) &#123;</span><br><span class="line">            mStackSupervisor.mActivitiesWaitingForVisibleActivity.add(prev);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                    <span class="string">"Resuming top, waiting visible to hide: "</span> + prev);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The next activity is already visible, so hide the previous</span></span><br><span class="line">            <span class="comment">// activity's windows right now so we can show the new one ASAP.</span></span><br><span class="line">            <span class="comment">// We only do this if the previous is finishing, which should mean</span></span><br><span class="line">            <span class="comment">// it is on top of the one being resumed so hiding it quickly</span></span><br><span class="line">            <span class="comment">// is good.  Otherwise, we want to do the normal route of allowing</span></span><br><span class="line">            <span class="comment">// the resumed activity to be shown so we can decide if the</span></span><br><span class="line">            <span class="comment">// previous should actually be hidden depending on whether the</span></span><br><span class="line">            <span class="comment">// new one is found to be full-screen or not.</span></span><br><span class="line">            <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">                prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                        <span class="string">"Not waiting for visible to hide: "</span> + prev + <span class="string">", waitingVisible="</span></span><br><span class="line">                        + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                        + <span class="string">", nowVisible="</span> + next.nowVisible);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                        <span class="string">"Previous already visible but still waiting to hide: "</span> + prev</span><br><span class="line">                        + <span class="string">", waitingVisible="</span></span><br><span class="line">                        + mStackSupervisor.mActivitiesWaitingForVisibleActivity.contains(prev)</span><br><span class="line">                        + <span class="string">", nowVisible="</span> + next.nowVisible);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launching this app's activity, make sure the app is no longer</span></span><br><span class="line">    <span class="comment">// considered stopped.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AppGlobals.getPackageManager().setPackageStoppedState(</span><br><span class="line">                next.packageName, <span class="keyword">false</span>, next.userId); <span class="comment">/* <span class="doctag">TODO:</span> Verify if correct userid */</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e1) &#123;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Failed trying to unstop package "</span></span><br><span class="line">                + next.packageName + <span class="string">": "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We are starting up the next activity, so tell the window manager</span></span><br><span class="line">    <span class="comment">// that the previous one will be hidden soon.  This way it can know</span></span><br><span class="line">    <span class="comment">// to ignore it when computing the desired screen orientation.</span></span><br><span class="line">    <span class="keyword">boolean</span> anim = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prev.finishing) &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                    <span class="string">"Prepare close transition: prev="</span> + prev);</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(prev)) &#123;</span><br><span class="line">                anim = <span class="keyword">false</span>;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                        ? TRANSIT_ACTIVITY_CLOSE</span><br><span class="line">                        : TRANSIT_TASK_CLOSE, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            prev.setVisibility(<span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION,</span><br><span class="line">                    <span class="string">"Prepare open transition: prev="</span> + prev);</span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">                anim = <span class="keyword">false</span>;</span><br><span class="line">                mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mWindowManager.prepareAppTransition(prev.getTask() == next.getTask()</span><br><span class="line">                        ? TRANSIT_ACTIVITY_OPEN</span><br><span class="line">                        : next.mLaunchTaskBehind</span><br><span class="line">                                ? TRANSIT_TASK_OPEN_BEHIND</span><br><span class="line">                                : TRANSIT_TASK_OPEN, <span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_TRANSITION) Slog.v(TAG_TRANSITION, <span class="string">"Prepare open transition: no previous"</span>);</span><br><span class="line">        <span class="keyword">if</span> (mStackSupervisor.mNoAnimActivities.contains(next)) &#123;</span><br><span class="line">            anim = <span class="keyword">false</span>;</span><br><span class="line">            mWindowManager.prepareAppTransition(TRANSIT_NONE, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mWindowManager.prepareAppTransition(TRANSIT_ACTIVITY_OPEN, <span class="keyword">false</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (anim) &#123;</span><br><span class="line">        next.applyOptionsLocked();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        next.clearOptionsLocked();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mStackSupervisor.mNoAnimActivities.clear();</span><br><span class="line"></span><br><span class="line">    ActivityStack lastStack = mStackSupervisor.getLastStack();</span><br><span class="line">    <span class="keyword">if</span> (next.app != <span class="keyword">null</span> &amp;&amp; next.app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Resume running: "</span> + next</span><br><span class="line">                + <span class="string">" stopped="</span> + next.stopped + <span class="string">" visible="</span> + next.visible);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If the previous activity is translucent, force a visibility update of</span></span><br><span class="line">        <span class="comment">// the next activity, so that it's added to WM's opening app list, and</span></span><br><span class="line">        <span class="comment">// transition animation can be set up properly.</span></span><br><span class="line">        <span class="comment">// For example, pressing Home button with a translucent activity in focus.</span></span><br><span class="line">        <span class="comment">// Launcher is already visible in this case. If we don't add it to opening</span></span><br><span class="line">        <span class="comment">// apps, maybeUpdateTransitToWallpaper() will fail to identify this as a</span></span><br><span class="line">        <span class="comment">// TRANSIT_WALLPAPER_OPEN animation, and run some funny animation.</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> lastActivityTranslucent = lastStack != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (lastStack.inMultiWindowMode()</span><br><span class="line">                || (lastStack.mLastPausedActivity != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; !lastStack.mLastPausedActivity.fullscreen));</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The contained logic must be synchronized, since we are both changing the visibility</span></span><br><span class="line">        <span class="comment">// and updating the &#123;@link Configuration&#125;. &#123;@link ActivityRecord#setVisibility&#125; will</span></span><br><span class="line">        <span class="comment">// ultimately cause the client code to schedule a layout. Since layouts retrieve the</span></span><br><span class="line">        <span class="comment">// current &#123;@link Configuration&#125;, we must ensure that the below code updates it before</span></span><br><span class="line">        <span class="comment">// the layout can occur.</span></span><br><span class="line">        <span class="keyword">synchronized</span>(mWindowManager.getWindowManagerLock()) &#123;</span><br><span class="line">            <span class="comment">// This activity is now becoming visible.</span></span><br><span class="line">            <span class="keyword">if</span> (!next.visible || next.stopped || lastActivityTranslucent) &#123;</span><br><span class="line">                next.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">            next.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">            ActivityRecord lastResumedActivity =</span><br><span class="line">                    lastStack == <span class="keyword">null</span> ? <span class="keyword">null</span> :lastStack.mResumedActivity;</span><br><span class="line">            <span class="keyword">final</span> ActivityState lastState = next.getState();</span><br><span class="line"></span><br><span class="line">            mService.updateCpuStats();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Moving to RESUMED: "</span> + next</span><br><span class="line">                    + <span class="string">" (in existing)"</span>);</span><br><span class="line"></span><br><span class="line">            next.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">            mService.updateLruProcessLocked(next.app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">            updateLRUListLocked(next);</span><br><span class="line">            mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Have the window manager re-evaluate the orientation of</span></span><br><span class="line">            <span class="comment">// the screen based on the new activity order.</span></span><br><span class="line">            <span class="keyword">boolean</span> notUpdated = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mStackSupervisor.isFocusedStack(<span class="keyword">this</span>)) &#123;</span><br><span class="line">                <span class="comment">// We have special rotation behavior when here is some active activity that</span></span><br><span class="line">                <span class="comment">// requests specific orientation or Keyguard is locked. Make sure all activity</span></span><br><span class="line">                <span class="comment">// visibilities are set correctly as well as the transition is updated if needed</span></span><br><span class="line">                <span class="comment">// to get the correct rotation behavior. Otherwise the following call to update</span></span><br><span class="line">                <span class="comment">// the orientation may cause incorrect configurations delivered to client as a</span></span><br><span class="line">                <span class="comment">// result of invisible window resize.</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Remove this once visibilities are set correctly immediately when</span></span><br><span class="line">                <span class="comment">// starting an activity.</span></span><br><span class="line">                notUpdated = !mStackSupervisor.ensureVisibilityAndConfig(next, mDisplayId,</span><br><span class="line">                        <span class="keyword">true</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">false</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (notUpdated) &#123;</span><br><span class="line">                <span class="comment">// The configuration update wasn't able to keep the existing</span></span><br><span class="line">                <span class="comment">// instance of the activity, and instead started a new one.</span></span><br><span class="line">                <span class="comment">// We should be all done, but let's just make sure our activity</span></span><br><span class="line">                <span class="comment">// is still at the top and schedule another run if something</span></span><br><span class="line">                <span class="comment">// weird happened.</span></span><br><span class="line">                ActivityRecord nextNext = topRunningActivityLocked();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_STATES) Slog.i(TAG_STATES,</span><br><span class="line">                        <span class="string">"Activity config changed during resume: "</span> + next</span><br><span class="line">                                + <span class="string">", new next: "</span> + nextNext);</span><br><span class="line">                <span class="keyword">if</span> (nextNext != next) &#123;</span><br><span class="line">                    <span class="comment">// Do over!</span></span><br><span class="line">                    mStackSupervisor.scheduleResumeTopActivities();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (!next.visible || next.stopped) &#123;</span><br><span class="line">                    next.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                next.completeResumeLocked();</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> ClientTransaction transaction = ClientTransaction.obtain(next.app.thread,</span><br><span class="line">                        next.appToken);</span><br><span class="line">                <span class="comment">// Deliver all pending results.</span></span><br><span class="line">                ArrayList&lt;ResultInfo&gt; a = next.results;</span><br><span class="line">                <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">int</span> N = a.size();</span><br><span class="line">                    <span class="keyword">if</span> (!next.finishing &amp;&amp; N &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (DEBUG_RESULTS) Slog.v(TAG_RESULTS,</span><br><span class="line">                                <span class="string">"Delivering results to "</span> + next + <span class="string">": "</span> + a);</span><br><span class="line">                        transaction.addCallback(ActivityResultItem.obtain(a));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (next.newIntents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    transaction.addCallback(NewIntentItem.obtain(next.newIntents,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* andPause */</span>));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Well the app will no longer be stopped.</span></span><br><span class="line">                <span class="comment">// Clear app token stopped state in window manager if needed.</span></span><br><span class="line">                next.notifyAppResumed(next.stopped);</span><br><span class="line"></span><br><span class="line">                EventLog.writeEvent(EventLogTags.AM_RESUME_ACTIVITY, next.userId,</span><br><span class="line">                        System.identityHashCode(next), next.getTask().taskId,</span><br><span class="line">                        next.shortComponentName);</span><br><span class="line"></span><br><span class="line">                next.sleeping = <span class="keyword">false</span>;</span><br><span class="line">                mService.getAppWarningsLocked().onResumeActivity(next);</span><br><span class="line">                mService.showAskCompatModeDialogLocked(next);</span><br><span class="line">                next.app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">                next.app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">                next.clearOptionsLocked();</span><br><span class="line">                transaction.setLifecycleStateRequest(</span><br><span class="line">                        ResumeActivityItem.obtain(next.app.repProcState,</span><br><span class="line">                                mService.isNextTransitionForward()));</span><br><span class="line">                mService.getLifecycleManager().scheduleTransaction(transaction);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Resumed "</span></span><br><span class="line">                        + next);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES, <span class="string">"Resume failed; resetting state to "</span></span><br><span class="line">                        + lastState + <span class="string">": "</span> + next);</span><br><span class="line">                next.setState(lastState, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// lastResumedActivity being non-null implies there is a lastStack present.</span></span><br><span class="line">                <span class="keyword">if</span> (lastResumedActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    lastResumedActivity.setState(RESUMED, <span class="string">"resumeTopActivityInnerLocked"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Slog.i(TAG, <span class="string">"Restarting because process died: "</span> + next);</span><br><span class="line">                <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">                    next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span>  <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW &amp;&amp; lastStack != <span class="keyword">null</span></span><br><span class="line">                        &amp;&amp; lastStack.isTopStackOnDisplay()) &#123;</span><br><span class="line">                    next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                            <span class="keyword">false</span> <span class="comment">/* taskSwitch */</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// From this point on, if something goes wrong there is no way</span></span><br><span class="line">        <span class="comment">// to recover the activity.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            next.completeResumeLocked();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="comment">// If any exception gets thrown, toss away this</span></span><br><span class="line">            <span class="comment">// activity and try the next one.</span></span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception thrown during resume of "</span> + next, e);</span><br><span class="line">            requestFinishActivityLocked(next.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                    <span class="string">"resume-exception"</span>, <span class="keyword">true</span>);</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Whoops, need to restart this activity!</span></span><br><span class="line">        <span class="keyword">if</span> (!next.hasBeenLaunched) &#123;</span><br><span class="line">            next.hasBeenLaunched = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (SHOW_APP_STARTING_PREVIEW) &#123;</span><br><span class="line">                next.showStartingWindow(<span class="keyword">null</span> <span class="comment">/* prev */</span>, <span class="keyword">false</span> <span class="comment">/* newTask */</span>,</span><br><span class="line">                        <span class="keyword">false</span> <span class="comment">/* taskSwich */</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH, <span class="string">"Restarting: "</span> + next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.d(TAG_STATES, <span class="string">"resumeTopActivityLocked: Restarting "</span> + next);</span><br><span class="line">        mStackSupervisor.startSpecificActivityLocked(next, <span class="keyword">true</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DEBUG_STACK) mStackSupervisor.validateTopActivitiesLocked();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法中的代码很长，可以看到最后都是调用了 mStackSupervisor.startSpecificActivityLocked</p>
<p>所以还是要到 ActivityStackSupervisor 的 startSpecificActivityLocked 方法中去看。</p>
<h1 id="ActivityStackSupervisor-1"><a href="#ActivityStackSupervisor-1" class="headerlink" title="ActivityStackSupervisor"></a>ActivityStackSupervisor</h1><h2 id="startSpecificActivityLocked_28ActivityRecord_r_2C_boolean_andResume_2C_boolean_checkConfig_29"><a href="#startSpecificActivityLocked_28ActivityRecord_r_2C_boolean_andResume_2C_boolean_checkConfig_29" class="headerlink" title="startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig)"></a>startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">startSpecificActivityLocked</span><span class="params">(ActivityRecord r,</span><br><span class="line">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Is this activity's application already running?</span></span><br><span class="line">    ProcessRecord app = mService.getProcessRecordLocked(r.processName,</span><br><span class="line">            r.info.applicationInfo.uid, <span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    getLaunchTimeTracker().setLaunchTime(r);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (app != <span class="keyword">null</span> &amp;&amp; app.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> ((r.info.flags&amp;ActivityInfo.FLAG_MULTIPROCESS) == <span class="number">0</span></span><br><span class="line">                    || !<span class="string">"android"</span>.equals(r.info.packageName)) &#123;</span><br><span class="line">                <span class="comment">// Don't add this if it is a platform component that is marked</span></span><br><span class="line">                <span class="comment">// to run in multiple processes, because this is actually</span></span><br><span class="line">                <span class="comment">// part of the framework so doesn't make sense to track as a</span></span><br><span class="line">                <span class="comment">// separate apk in the process.</span></span><br><span class="line">                app.addPackage(r.info.packageName, r.info.applicationInfo.longVersionCode,</span><br><span class="line">                        mService.mProcessStats);</span><br><span class="line">            &#125;</span><br><span class="line">            realStartActivityLocked(r, app, andResume, checkConfig);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            Slog.w(TAG, <span class="string">"Exception when starting activity "</span></span><br><span class="line">                    + r.intent.getComponent().flattenToShortString(), e);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a dead object exception was thrown -- fall through to</span></span><br><span class="line">        <span class="comment">// restart the application.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mService.startProcessLocked(r.processName, r.info.applicationInfo, <span class="keyword">true</span>, <span class="number">0</span>,</span><br><span class="line">            <span class="string">"activity"</span>, r.intent.getComponent(), <span class="keyword">false</span>, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 startSpecificActivityLocked 中会判断进程是否存在，因为我们分析的是 startActivity 的逻辑，所以肯定是已经存在了进程的，所以会调用 realStartActivityLocked()方法。</p>
<h2 id="realStartActivityLocked_28ActivityRecord_r_2C_ProcessRecord_app_2C_boolean_andResume_2C_boolean_checkConfig_29"><a href="#realStartActivityLocked_28ActivityRecord_r_2C_ProcessRecord_app_2C_boolean_andResume_2C_boolean_checkConfig_29" class="headerlink" title="realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig)"></a>realStartActivityLocked(ActivityRecord r, ProcessRecord app, boolean andResume, boolean checkConfig)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">realStartActivityLocked</span><span class="params">(ActivityRecord r, ProcessRecord app,</span><br><span class="line">        <span class="keyword">boolean</span> andResume, <span class="keyword">boolean</span> checkConfig)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!allPausedActivitiesComplete()) &#123;</span><br><span class="line">        <span class="comment">// While there are activities pausing we skipping starting any new activities until</span></span><br><span class="line">        <span class="comment">// pauses are complete. <span class="doctag">NOTE:</span> that we also do this for activities that are starting in</span></span><br><span class="line">        <span class="comment">// the paused state because they will first be resumed then paused on the client side.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_SWITCH || DEBUG_PAUSE || DEBUG_STATES) Slog.v(TAG_PAUSE,</span><br><span class="line">                <span class="string">"realStartActivityLocked: Skipping start of r="</span> + r</span><br><span class="line">                + <span class="string">" some activities pausing..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> TaskRecord task = r.getTask();</span><br><span class="line">    <span class="keyword">final</span> ActivityStack stack = task.getStack();</span><br><span class="line"></span><br><span class="line">    beginDeferResume();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        r.startFreezingScreenLocked(app, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// schedule launch ticks to collect information about slow apps.</span></span><br><span class="line">        r.startLaunchTickingLocked();</span><br><span class="line"></span><br><span class="line">        r.setProcess(app);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (getKeyguardController().isKeyguardLocked()) &#123;</span><br><span class="line">            r.notifyUnknownVisibilityLaunched();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Have the window manager re-evaluate the orientation of the screen based on the new</span></span><br><span class="line">        <span class="comment">// activity order.  Note that as a result of this, it can call back into the activity</span></span><br><span class="line">        <span class="comment">// manager with a new orientation.  We don't care about that, because the activity is</span></span><br><span class="line">        <span class="comment">// not currently running so we are just restarting it anyway.</span></span><br><span class="line">        <span class="keyword">if</span> (checkConfig) &#123;</span><br><span class="line">            <span class="comment">// Deferring resume here because we're going to launch new activity shortly.</span></span><br><span class="line">            <span class="comment">// We don't want to perform a redundant launch of the same record while ensuring</span></span><br><span class="line">            <span class="comment">// configurations and trying to resume top activity of focused stack.</span></span><br><span class="line">            ensureVisibilityAndConfig(r, r.getDisplayId(),</span><br><span class="line">                    <span class="keyword">false</span> <span class="comment">/* markFrozenIfConfigChanged */</span>, <span class="keyword">true</span> <span class="comment">/* deferResume */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (r.getStack().checkKeyguardVisibility(r, <span class="keyword">true</span> <span class="comment">/* shouldBeVisible */</span>,</span><br><span class="line">                <span class="keyword">true</span> <span class="comment">/* isTop */</span>)) &#123;</span><br><span class="line">            <span class="comment">// We only set the visibility to true if the activity is allowed to be visible</span></span><br><span class="line">            <span class="comment">// based on</span></span><br><span class="line">            <span class="comment">// keyguard state. This avoids setting this into motion in window manager that is</span></span><br><span class="line">            <span class="comment">// later cancelled due to later calls to ensure visible activities that set</span></span><br><span class="line">            <span class="comment">// visibility back to false.</span></span><br><span class="line">            r.setVisibility(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> applicationInfoUid =</span><br><span class="line">                (r.info.applicationInfo != <span class="keyword">null</span>) ? r.info.applicationInfo.uid : -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((r.userId != app.userId) || (r.appInfo.uid != applicationInfoUid)) &#123;</span><br><span class="line">            Slog.wtf(TAG,</span><br><span class="line">                    <span class="string">"User ID for activity changing for "</span> + r</span><br><span class="line">                            + <span class="string">" appInfo.uid="</span> + r.appInfo.uid</span><br><span class="line">                            + <span class="string">" info.ai.uid="</span> + applicationInfoUid</span><br><span class="line">                            + <span class="string">" old="</span> + r.app + <span class="string">" new="</span> + app);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        app.waitingToKill = <span class="keyword">null</span>;</span><br><span class="line">        r.launchCount++;</span><br><span class="line">        r.lastLaunchTime = SystemClock.uptimeMillis();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ALL) Slog.v(TAG, <span class="string">"Launching: "</span> + r);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> idx = app.activities.indexOf(r);</span><br><span class="line">        <span class="keyword">if</span> (idx &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            app.activities.add(r);</span><br><span class="line">        &#125;</span><br><span class="line">        mService.updateLruProcessLocked(app, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">        mService.updateOomAdjLocked();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LockTaskController lockTaskController = mService.getLockTaskController();</span><br><span class="line">        <span class="keyword">if</span> (task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE</span><br><span class="line">                || task.mLockTaskAuth == LOCK_TASK_AUTH_LAUNCHABLE_PRIV</span><br><span class="line">                || (task.mLockTaskAuth == LOCK_TASK_AUTH_WHITELISTED</span><br><span class="line">                        &amp;&amp; lockTaskController.getLockTaskModeState()</span><br><span class="line">                                == LOCK_TASK_MODE_LOCKED)) &#123;</span><br><span class="line">            lockTaskController.startLockTaskMode(task, <span class="keyword">false</span>, <span class="number">0</span> <span class="comment">/* blank UID */</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (app.thread == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RemoteException();</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ResultInfo&gt; results = <span class="keyword">null</span>;</span><br><span class="line">            List&lt;ReferrerIntent&gt; newIntents = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                <span class="comment">// We don't need to deliver new intents and/or set results if activity is going</span></span><br><span class="line">                <span class="comment">// to pause immediately after launch.</span></span><br><span class="line">                results = r.results;</span><br><span class="line">                newIntents = r.newIntents;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_SWITCH) Slog.v(TAG_SWITCH,</span><br><span class="line">                    <span class="string">"Launching: "</span> + r + <span class="string">" icicle="</span> + r.icicle + <span class="string">" with results="</span> + results</span><br><span class="line">                            + <span class="string">" newIntents="</span> + newIntents + <span class="string">" andResume="</span> + andResume);</span><br><span class="line">            EventLog.writeEvent(EventLogTags.AM_RESTART_ACTIVITY, r.userId,</span><br><span class="line">                    System.identityHashCode(r), task.taskId, r.shortComponentName);</span><br><span class="line">            <span class="keyword">if</span> (r.isActivityTypeHome()) &#123;</span><br><span class="line">                <span class="comment">// Home process is the root process of the task.</span></span><br><span class="line">                mService.mHomeProcess = task.mActivities.get(<span class="number">0</span>).app;</span><br><span class="line">            &#125;</span><br><span class="line">            mService.notifyPackageUse(r.intent.getComponent().getPackageName(),</span><br><span class="line">                    PackageManager.NOTIFY_PACKAGE_USE_ACTIVITY);</span><br><span class="line">            r.sleeping = <span class="keyword">false</span>;</span><br><span class="line">            r.forceNewConfig = <span class="keyword">false</span>;</span><br><span class="line">            mService.getAppWarningsLocked().onStartActivity(r);</span><br><span class="line">            mService.showAskCompatModeDialogLocked(r);</span><br><span class="line">            r.compat = mService.compatibilityInfoForPackageLocked(r.info.applicationInfo);</span><br><span class="line">            ProfilerInfo profilerInfo = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (mService.mProfileApp != <span class="keyword">null</span> &amp;&amp; mService.mProfileApp.equals(app.processName)) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mService.mProfileProc == <span class="keyword">null</span> || mService.mProfileProc == app) &#123;</span><br><span class="line">                    mService.mProfileProc = app;</span><br><span class="line">                    ProfilerInfo profilerInfoSvc = mService.mProfilerInfo;</span><br><span class="line">                    <span class="keyword">if</span> (profilerInfoSvc != <span class="keyword">null</span> &amp;&amp; profilerInfoSvc.profileFile != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (profilerInfoSvc.profileFd != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                profilerInfoSvc.profileFd = profilerInfoSvc.profileFd.dup();</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                profilerInfoSvc.closeFd();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        profilerInfo = <span class="keyword">new</span> ProfilerInfo(profilerInfoSvc);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            app.hasShownUi = <span class="keyword">true</span>;</span><br><span class="line">            app.pendingUiClean = <span class="keyword">true</span>;</span><br><span class="line">            app.forceProcessStateUpTo(mService.mTopProcessState);</span><br><span class="line">            <span class="comment">// Because we could be starting an Activity in the system process this may not go</span></span><br><span class="line">            <span class="comment">// across a Binder interface which would create a new Configuration. Consequently</span></span><br><span class="line">            <span class="comment">// we have to always create a new Configuration here.</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> MergedConfiguration mergedConfiguration = <span class="keyword">new</span> MergedConfiguration(</span><br><span class="line">                    mService.getGlobalConfiguration(), r.getMergedOverrideConfiguration());</span><br><span class="line">            r.setLastReportedConfiguration(mergedConfiguration);</span><br><span class="line"></span><br><span class="line">            logIfTransactionTooLarge(r.intent, r.icicle);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="comment">// Create activity launch transaction.</span></span><br><span class="line">            <span class="keyword">final</span> ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,</span><br><span class="line">                    r.appToken);</span><br><span class="line">            clientTransaction.addCallback(LaunchActivityItem.obtain(<span class="keyword">new</span> Intent(r.intent),</span><br><span class="line">                    System.identityHashCode(r), r.info,</span><br><span class="line">                    <span class="comment">// <span class="doctag">TODO:</span> Have this take the merged configuration instead of separate global</span></span><br><span class="line">                    <span class="comment">// and override configs.</span></span><br><span class="line">                    mergedConfiguration.getGlobalConfiguration(),</span><br><span class="line">                    mergedConfiguration.getOverrideConfiguration(), r.compat,</span><br><span class="line">                    r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,</span><br><span class="line">                    r.persistentState, results, newIntents, mService.isNextTransitionForward(),</span><br><span class="line">                    profilerInfo));</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set desired final state.</span></span><br><span class="line">            <span class="keyword">final</span> ActivityLifecycleItem lifecycleItem;</span><br><span class="line">            <span class="keyword">if</span> (andResume) &#123;</span><br><span class="line">                lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                lifecycleItem = PauseActivityItem.obtain();</span><br><span class="line">            &#125;</span><br><span class="line">            clientTransaction.setLifecycleStateRequest(lifecycleItem);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Schedule transaction.</span></span><br><span class="line">            mService.getLifecycleManager().scheduleTransaction(clientTransaction);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((app.info.privateFlags &amp; ApplicationInfo.PRIVATE_FLAG_CANT_SAVE_STATE) != <span class="number">0</span></span><br><span class="line">                    &amp;&amp; mService.mHasHeavyWeightFeature) &#123;</span><br><span class="line">                <span class="comment">// This may be a heavy-weight process!  Note that the package</span></span><br><span class="line">                <span class="comment">// manager will ensure that only activity can run in the main</span></span><br><span class="line">                <span class="comment">// process of the .apk, which is the only thing that will be</span></span><br><span class="line">                <span class="comment">// considered heavy-weight.</span></span><br><span class="line">                <span class="keyword">if</span> (app.processName.equals(app.info.packageName)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mService.mHeavyWeightProcess != <span class="keyword">null</span></span><br><span class="line">                            &amp;&amp; mService.mHeavyWeightProcess != app) &#123;</span><br><span class="line">                        Slog.w(TAG, <span class="string">"Starting new heavy weight process "</span> + app</span><br><span class="line">                                + <span class="string">" when already running "</span></span><br><span class="line">                                + mService.mHeavyWeightProcess);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mService.mHeavyWeightProcess = app;</span><br><span class="line">                    Message msg = mService.mHandler.obtainMessage(</span><br><span class="line">                            ActivityManagerService.POST_HEAVY_NOTIFICATION_MSG);</span><br><span class="line">                    msg.obj = r;</span><br><span class="line">                    mService.mHandler.sendMessage(msg);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (r.launchFailed) &#123;</span><br><span class="line">                <span class="comment">// This is the second time we failed -- finish activity</span></span><br><span class="line">                <span class="comment">// and give up.</span></span><br><span class="line">                Slog.e(TAG, <span class="string">"Second failure launching "</span></span><br><span class="line">                        + r.intent.getComponent().flattenToShortString()</span><br><span class="line">                        + <span class="string">", giving up"</span>, e);</span><br><span class="line">                mService.appDiedLocked(app);</span><br><span class="line">                stack.requestFinishActivityLocked(r.appToken, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                        <span class="string">"2nd-crash"</span>, <span class="keyword">false</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This is the first time we failed -- restart process and</span></span><br><span class="line">            <span class="comment">// retry.</span></span><br><span class="line">            r.launchFailed = <span class="keyword">true</span>;</span><br><span class="line">            app.activities.remove(r);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        endDeferResume();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    r.launchFailed = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (stack.updateLRUListLocked(r)) &#123;</span><br><span class="line">        Slog.w(TAG, <span class="string">"Activity "</span> + r + <span class="string">" being launched, but already in LRU list"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO(lifecycler): Resume or pause requests are done as part of launch transaction,</span></span><br><span class="line">    <span class="comment">// so updating the state should be done accordingly.</span></span><br><span class="line">    <span class="keyword">if</span> (andResume &amp;&amp; readyToResume()) &#123;</span><br><span class="line">        <span class="comment">// As part of the process of launching, ActivityThread also performs</span></span><br><span class="line">        <span class="comment">// a resume.</span></span><br><span class="line">        stack.minimalResumeActivityLocked(r);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// This activity is not starting in the resumed state... which should look like we asked</span></span><br><span class="line">        <span class="comment">// it to pause+stop (but remain visible), and it has done so and reported back the</span></span><br><span class="line">        <span class="comment">// current icicle and other state.</span></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_STATES) Slog.v(TAG_STATES,</span><br><span class="line">                <span class="string">"Moving to PAUSED: "</span> + r + <span class="string">" (starting in paused state)"</span>);</span><br><span class="line">        r.setState(PAUSED, <span class="string">"realStartActivityLocked"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Launch the new version setup screen if needed.  We do this -after-</span></span><br><span class="line">    <span class="comment">// launching the initial activity (that is, home), so that it can have</span></span><br><span class="line">    <span class="comment">// a chance to initialize itself while in the background, making the</span></span><br><span class="line">    <span class="comment">// switch back to it faster and look better.</span></span><br><span class="line">    <span class="keyword">if</span> (isFocusedStack(stack)) &#123;</span><br><span class="line">        mService.getActivityStartController().startSetupActivity();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update any services we are bound to that might care about whether</span></span><br><span class="line">    <span class="comment">// their client may have activities.</span></span><br><span class="line">    <span class="keyword">if</span> (r.app != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mService.mServices.updateServiceConnectionActivitiesLocked(r.app);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面又是一段贼长的代码，看的费劲。我们就直接来关注重点：</p>
<pre><code>// Create activity launch transaction.
final ClientTransaction clientTransaction = ClientTransaction.obtain(app.thread,
        r.appToken);
clientTransaction.addCallback(LaunchActivityItem.obtain(new Intent(r.intent),
        System.identityHashCode(r), r.info,
        // TODO: Have this take the merged configuration instead of separate global
        // and override configs.
        mergedConfiguration.getGlobalConfiguration(),
        mergedConfiguration.getOverrideConfiguration(), r.compat,
        r.launchedFromPackage, task.voiceInteractor, app.repProcState, r.icicle,
        r.persistentState, results, newIntents, mService.isNextTransitionForward(),
        profilerInfo));

// Set desired final state.
final ActivityLifecycleItem lifecycleItem;
if (andResume) {
    lifecycleItem = ResumeActivityItem.obtain(mService.isNextTransitionForward());
} else {
    lifecycleItem = PauseActivityItem.obtain();
}
clientTransaction.setLifecycleStateRequest(lifecycleItem);

// Schedule transaction.
mService.getLifecycleManager().scheduleTransaction(clientTransaction);
</code></pre><ol>
<li>首先创建了一个 ClientTransaction ，那什么是 ClientTransaction 呢？ClientTransaction 可以理解为内部包含了一系列的 Activity 生命周期状态的事务，这些事务会最终交给 ActiivtyThread 来处理，然后 ActiivtyThread 再回调相应的 Activity 生命周期。</li>
<li>ClientTransaction 添加了 LaunchActivityItem ，LaunchActivityItem 简单的说就是用来启动 Activity 的。</li>
<li>设置了最终的生命周期状态，这里是添加了 ResumeActivityItem 。即 Activity 最终生命周期的状态是 resumed 。</li>
<li>调用 LifecycleManager 来启动 clientTransaction 。mService.getLifecycleManager() 其实是一个 ClientLifecycleManager 对象。</li>
</ol>
<p>那么就来看看 ClientLifecycleManager.scheduleTransaction 方法</p>
<h1 id="ClientLifecycleManager"><a href="#ClientLifecycleManager" class="headerlink" title="ClientLifecycleManager"></a>ClientLifecycleManager</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29"><a href="#scheduleTransaction_28ClientTransaction_transaction_29" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IApplicationThread client = transaction.getClient();</span><br><span class="line">    transaction.schedule();</span><br><span class="line">    <span class="keyword">if</span> (!(client <span class="keyword">instanceof</span> Binder)) &#123;</span><br><span class="line">        <span class="comment">// If client is not an instance of Binder - it's a remote call and at this point it is</span></span><br><span class="line">        <span class="comment">// safe to recycle the object. All objects used for local calls will be recycled after</span></span><br><span class="line">        <span class="comment">// the transaction is executed on client in ActivityThread.</span></span><br><span class="line">        transaction.recycle();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>transaction.getClient() 方法主要获取了需要启动 Activity 进程的代理对象 IApplicationThread </p>
<p>然后内部直接调用了 ClientTransaction 的 schedule 方法。</p>
<h1 id="ClientTransaction"><a href="#ClientTransaction" class="headerlink" title="ClientTransaction"></a>ClientTransaction</h1><h2 id="schedule_28_29"><a href="#schedule_28_29" class="headerlink" title="schedule()"></a>schedule()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    mClient.scheduleTransaction(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>schedule 又调用了 mClient.scheduleTransaction 。mClient 就是与 ActivityThread 通讯的代理对象 IApplicationThread ，所以这里其实是调用 ActivityThread 类中 ApplicationThread 内部类    </p>
<h1 id="ApplicationThread"><a href="#ApplicationThread" class="headerlink" title="ApplicationThread"></a>ApplicationThread</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29-1"><a href="#scheduleTransaction_28ClientTransaction_transaction_29-1" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">    ActivityThread.<span class="keyword">this</span>.scheduleTransaction(transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用的是 ActivityThread 的 scheduleTransaction 方法。</p>
<p>有些同学可能会纳闷，ActivityThread 里面没有找到 scheduleTransaction 这个方法啊？别着急，我们来看 ActivityThread 是继承 ClientTransactionHandler 的。所以 scheduleTransaction 这个方法在 ClientTransactionHandler 里面。</p>
<h1 id="ClientTransactionHandler"><a href="#ClientTransactionHandler" class="headerlink" title="ClientTransactionHandler"></a>ClientTransactionHandler</h1><h2 id="scheduleTransaction_28ClientTransaction_transaction_29-2"><a href="#scheduleTransaction_28ClientTransaction_transaction_29-2" class="headerlink" title="scheduleTransaction(ClientTransaction transaction)"></a>scheduleTransaction(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">scheduleTransaction</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    transaction.preExecute(<span class="keyword">this</span>);</span><br><span class="line">    sendMessage(ActivityThread.H.EXECUTE_TRANSACTION, transaction);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用了 ActivityThread 的 sendMessage() 方法。</p>
<h1 id="ActivityThread"><a href="#ActivityThread" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><h2 id="handleMessage_28Message_msg_29"><a href="#handleMessage_28Message_msg_29" class="headerlink" title="handleMessage(Message msg)"></a>handleMessage(Message msg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, <span class="number">0</span>, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, arg1, <span class="number">0</span>, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2)</span> </span>&#123;</span><br><span class="line">    sendMessage(what, obj, arg1, arg2, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sendMessage</span><span class="params">(<span class="keyword">int</span> what, Object obj, <span class="keyword">int</span> arg1, <span class="keyword">int</span> arg2, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(</span><br><span class="line">        TAG, <span class="string">"SCHEDULE "</span> + what + <span class="string">" "</span> + mH.codeToString(what)</span><br><span class="line">        + <span class="string">": "</span> + arg1 + <span class="string">" / "</span> + obj);</span><br><span class="line">    Message msg = Message.obtain();</span><br><span class="line">    msg.what = what;</span><br><span class="line">    msg.obj = obj;</span><br><span class="line">    msg.arg1 = arg1;</span><br><span class="line">    msg.arg2 = arg2;</span><br><span class="line">    <span class="keyword">if</span> (async) &#123;</span><br><span class="line">        msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    mH.sendMessage(msg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>sendMessage 方法其实就是将 ClientTransaction 参数通过 Handler 机制切换至主线程进行处理。这里的 Handler 就是 H 。相应的，sendMessage 之后，我们就要追踪到 H 的 handleMessage 方法中看了。</p>
<h1 id="H"><a href="#H" class="headerlink" title="H"></a>H</h1><h2 id="handleMessage_28Message_msg_29-1"><a href="#handleMessage_28Message_msg_29-1" class="headerlink" title="handleMessage(Message msg)"></a>handleMessage(Message msg)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));</span><br><span class="line">    <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">    	...</span><br><span class="line">		<span class="keyword">case</span> EXECUTE_TRANSACTION:</span><br><span class="line">		    <span class="keyword">final</span> ClientTransaction transaction = (ClientTransaction) msg.obj;</span><br><span class="line">		    mTransactionExecutor.execute(transaction);</span><br><span class="line">		    <span class="keyword">if</span> (isSystem()) &#123;</span><br><span class="line">		        <span class="comment">// Client transactions inside system process are recycled on the client side</span></span><br><span class="line">		        <span class="comment">// instead of ClientLifecycleManager to avoid being cleared before this</span></span><br><span class="line">		        <span class="comment">// message is handled.</span></span><br><span class="line">		        transaction.recycle();</span><br><span class="line">		    &#125;</span><br><span class="line">		    <span class="comment">// TODO(lifecycler): Recycle locally scheduled transactions.</span></span><br><span class="line">		    <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>handleMessage 的代码有点长，我们只关注 EXECUTE_TRANSACTION 部分。</p>
<p>发现利用了 mTransactionExecutor 来处理 transaction 。mTransactionExecutor 其实是 TransactionExecutor 的一个对象，所以要到 TransactionExecutor 中去追踪。</p>
<h1 id="TransactionExecutor"><a href="#TransactionExecutor" class="headerlink" title="TransactionExecutor"></a>TransactionExecutor</h1><h2 id="execute_28ClientTransaction_transaction_29"><a href="#execute_28ClientTransaction_transaction_29" class="headerlink" title="execute(ClientTransaction transaction)"></a>execute(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    log(<span class="string">"Start resolving transaction for client: "</span> + mTransactionHandler + <span class="string">", token: "</span> + token);</span><br><span class="line"></span><br><span class="line">    executeCallbacks(transaction);</span><br><span class="line"></span><br><span class="line">    executeLifecycleState(transaction);</span><br><span class="line">    mPendingActions.clear();</span><br><span class="line">    log(<span class="string">"End resolving transaction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里主要看这两行代码：</p>
<ol>
<li>executeCallbacks(transaction) 在这里面会去执行 LaunchActivityItem 。也就是会去创建 Activity 并回调 onCreate 生命周期方法；</li>
<li>executeLifecycleState(transaction) 在这里会执行 ResumeActivityItem 。之前创建出来的 Activity 的也会回调 onStart 、onResume 生命周期方法。</li>
</ol>
<p>那我们慢慢看吧，先来看 executeCallbacks(transaction)</p>
<h2 id="executeCallbacks_28ClientTransaction_transaction_29"><a href="#executeCallbacks_28ClientTransaction_transaction_29" class="headerlink" title="executeCallbacks(ClientTransaction transaction)"></a>executeCallbacks(ClientTransaction transaction)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeCallbacks</span><span class="params">(ClientTransaction transaction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> List&lt;ClientTransactionItem&gt; callbacks = transaction.getCallbacks();</span><br><span class="line">    <span class="keyword">if</span> (callbacks == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// No callbacks to execute, return early.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    log(<span class="string">"Resolving callbacks"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> IBinder token = transaction.getActivityToken();</span><br><span class="line">    ActivityClientRecord r = mTransactionHandler.getActivityClient(token);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In case when post-execution state of the last callback matches the final state requested</span></span><br><span class="line">    <span class="comment">// for the activity in this transaction, we won't do the last transition here and do it when</span></span><br><span class="line">    <span class="comment">// moving to final state instead (because it may contain additional parameters from server).</span></span><br><span class="line">    <span class="keyword">final</span> ActivityLifecycleItem finalStateRequest = transaction.getLifecycleStateRequest();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> finalState = finalStateRequest != <span class="keyword">null</span> ? finalStateRequest.getTargetState()</span><br><span class="line">            : UNDEFINED;</span><br><span class="line">    <span class="comment">// Index of the last callback that requests some post-execution state.</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> lastCallbackRequestingState = lastCallbackRequestingState(transaction);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> size = callbacks.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; ++i) &#123;</span><br><span class="line">        <span class="keyword">final</span> ClientTransactionItem item = callbacks.get(i);</span><br><span class="line">        log(<span class="string">"Resolving callback: "</span> + item);</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> postExecutionState = item.getPostExecutionState();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> closestPreExecutionState = mHelper.getClosestPreExecutionState(r,</span><br><span class="line">                item.getPostExecutionState());</span><br><span class="line">        <span class="keyword">if</span> (closestPreExecutionState != UNDEFINED) &#123;</span><br><span class="line">            cycleToPath(r, closestPreExecutionState);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        item.execute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        item.postExecute(mTransactionHandler, token, mPendingActions);</span><br><span class="line">        <span class="keyword">if</span> (r == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Launch activity request will create an activity record.</span></span><br><span class="line">            r = mTransactionHandler.getActivityClient(token);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (postExecutionState != UNDEFINED &amp;&amp; r != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Skip the very last transition and perform it by explicit state request instead.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> shouldExcludeLastTransition =</span><br><span class="line">                    i == lastCallbackRequestingState &amp;&amp; finalState == postExecutionState;</span><br><span class="line">            cycleToPath(r, postExecutionState, shouldExcludeLastTransition);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码主要干的事情就是先获取 ClientTransaction 中的 ClientTransactionItem 对象。然后调用 ClientTransactionItem.execute 。</p>
<p>别看上面代码一大串的，其实最重要的就是 <code>item.execute(mTransactionHandler, token, mPendingActions);</code> 这句代码了。</p>
<p>说明了 TransactionExecutor 内部是交给每个 item 来处理对应的操作的。而上面分析可以知道，这个 item 就是 LaunchActivityItem 。</p>
<h1 id="LaunchActivityItem"><a href="#LaunchActivityItem" class="headerlink" title="LaunchActivityItem"></a>LaunchActivityItem</h1><h2 id="execute_28ClientTransactionHandler_client_2C_IBinder_token_2C_PendingTransactionActions_pendingActions_29"><a href="#execute_28ClientTransactionHandler_client_2C_IBinder_token_2C_PendingTransactionActions_pendingActions_29" class="headerlink" title="execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)"></a>execute(ClientTransactionHandler client, IBinder token, PendingTransactionActions pendingActions)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(ClientTransactionHandler client, IBinder token,</span><br><span class="line">        PendingTransactionActions pendingActions)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);</span><br><span class="line">    ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord(token, mIntent, mIdent, mInfo,</span><br><span class="line">            mOverrideConfig, mCompatInfo, mReferrer, mVoiceInteractor, mState, mPersistentState,</span><br><span class="line">            mPendingResults, mPendingNewIntents, mIsForward,</span><br><span class="line">            mProfilerInfo, client);</span><br><span class="line">    client.handleLaunchActivity(r, pendingActions, <span class="keyword">null</span> <span class="comment">/* customIntent */</span>);</span><br><span class="line">    Trace.traceEnd(TRACE_TAG_ACTIVITY_MANAGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 LaunchActivityItem 的 execute 内部，调用了 client.handleLaunchActivity 来执行。而 client 就是 ActivityThread 。所以我们要继续追踪到 ActivityThread.handleLaunchActivity 。</p>
<h1 id="ActivityThread-1"><a href="#ActivityThread-1" class="headerlink" title="ActivityThread"></a>ActivityThread</h1><h2 id="handleLaunchActivity_28ActivityClientRecord_r_2C_PendingTransactionActions_pendingActions_2C_Intent_customIntent_29"><a href="#handleLaunchActivity_28ActivityClientRecord_r_2C_PendingTransactionActions_pendingActions_2C_Intent_customIntent_29" class="headerlink" title="handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)"></a>handleLaunchActivity(ActivityClientRecord r, PendingTransactionActions pendingActions, Intent customIntent)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">handleLaunchActivity</span><span class="params">(ActivityClientRecord r,</span><br><span class="line">        PendingTransactionActions pendingActions, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// If we are getting ready to gc after going to the background, well</span></span><br><span class="line">    <span class="comment">// we are back active so skip it.</span></span><br><span class="line">    unscheduleGcIdler();</span><br><span class="line">    mSomeActivitiesChanged = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.profilerInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mProfiler.setProfiler(r.profilerInfo);</span><br><span class="line">        mProfiler.startProfiling();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Make sure we are running with the most recent config.</span></span><br><span class="line">    handleConfigurationChanged(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">        TAG, <span class="string">"Handling launch of "</span> + r);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Initialize before creating the activity</span></span><br><span class="line">    <span class="keyword">if</span> (!ThreadedRenderer.sRendererDisabled) &#123;</span><br><span class="line">        GraphicsEnvironment.earlyInitEGL();</span><br><span class="line">    &#125;</span><br><span class="line">    WindowManagerGlobal.initialize();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Activity a = performLaunchActivity(r, customIntent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.createdConfig = <span class="keyword">new</span> Configuration(mConfiguration);</span><br><span class="line">        reportSizeConfigurations(r);</span><br><span class="line">        <span class="keyword">if</span> (!r.activity.mFinished &amp;&amp; pendingActions != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingActions.setOldState(r.state);</span><br><span class="line">            pendingActions.setRestoreInstanceState(<span class="keyword">true</span>);</span><br><span class="line">            pendingActions.setCallOnPostCreate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there was an error, for any reason, tell the activity manager to stop us.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ActivityManager.getService()</span><br><span class="line">                    .finishActivity(r.token, Activity.RESULT_CANCELED, <span class="keyword">null</span>,</span><br><span class="line">                            Activity.DONT_FINISH_TASK_WITH_ACTIVITY);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> ex.rethrowFromSystemServer();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看来一句关键的代码</p>
<pre><code>final Activity a = performLaunchActivity(r, customIntent);
</code></pre><p>最终可以看到，Activity 就是 performLaunchActivity 方法创建出来的。</p>
<h2 id="performLaunchActivity_28ActivityClientRecord_r_2C_Intent_customIntent_29"><a href="#performLaunchActivity_28ActivityClientRecord_r_2C_Intent_customIntent_29" class="headerlink" title="performLaunchActivity(ActivityClientRecord r, Intent customIntent)"></a>performLaunchActivity(ActivityClientRecord r, Intent customIntent) </h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**  Core implementation of activity launch. */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Activity <span class="title">performLaunchActivity</span><span class="params">(ActivityClientRecord r, Intent customIntent)</span> </span>&#123;</span><br><span class="line">    ActivityInfo aInfo = r.activityInfo;</span><br><span class="line">    <span class="keyword">if</span> (r.packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        r.packageInfo = getPackageInfo(aInfo.applicationInfo, r.compatInfo,</span><br><span class="line">                Context.CONTEXT_INCLUDE_CODE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ComponentName component = r.intent.getComponent();</span><br><span class="line">    <span class="keyword">if</span> (component == <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = r.intent.resolveActivity(</span><br><span class="line">            mInitialApplication.getPackageManager());</span><br><span class="line">        r.intent.setComponent(component);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (r.activityInfo.targetActivity != <span class="keyword">null</span>) &#123;</span><br><span class="line">        component = <span class="keyword">new</span> ComponentName(r.activityInfo.packageName,</span><br><span class="line">                r.activityInfo.targetActivity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ContextImpl appContext = createBaseContextForActivity(r);</span><br><span class="line">    Activity activity = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        java.lang.ClassLoader cl = appContext.getClassLoader();</span><br><span class="line">        activity = mInstrumentation.newActivity(</span><br><span class="line">                cl, component.getClassName(), r.intent);</span><br><span class="line">        StrictMode.incrementExpectedActivityCount(activity.getClass());</span><br><span class="line">        r.intent.setExtrasClassLoader(cl);</span><br><span class="line">        r.intent.prepareToEnterProcess();</span><br><span class="line">        <span class="keyword">if</span> (r.state != <span class="keyword">null</span>) &#123;</span><br><span class="line">            r.state.setClassLoader(cl);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to instantiate activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Application app = r.packageInfo.makeApplication(<span class="keyword">false</span>, mInstrumentation);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(TAG, <span class="string">"Performing launch of "</span> + r);</span><br><span class="line">        <span class="keyword">if</span> (localLOGV) Slog.v(</span><br><span class="line">                TAG, r + <span class="string">": app="</span> + app</span><br><span class="line">                + <span class="string">", appName="</span> + app.getPackageName()</span><br><span class="line">                + <span class="string">", pkg="</span> + r.packageInfo.getPackageName()</span><br><span class="line">                + <span class="string">", comp="</span> + r.intent.getComponent().toShortString()</span><br><span class="line">                + <span class="string">", dir="</span> + r.packageInfo.getAppDir());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity != <span class="keyword">null</span>) &#123;</span><br><span class="line">            CharSequence title = r.activityInfo.loadLabel(appContext.getPackageManager());</span><br><span class="line">            Configuration config = <span class="keyword">new</span> Configuration(mCompatConfiguration);</span><br><span class="line">            <span class="keyword">if</span> (r.overrideConfig != <span class="keyword">null</span>) &#123;</span><br><span class="line">                config.updateFrom(r.overrideConfig);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (DEBUG_CONFIGURATION) Slog.v(TAG, <span class="string">"Launching activity "</span></span><br><span class="line">                    + r.activityInfo.name + <span class="string">" with config "</span> + config);</span><br><span class="line">            Window window = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.mPendingRemoveWindow != <span class="keyword">null</span> &amp;&amp; r.mPreserveWindow) &#123;</span><br><span class="line">                window = r.mPendingRemoveWindow;</span><br><span class="line">                r.mPendingRemoveWindow = <span class="keyword">null</span>;</span><br><span class="line">                r.mPendingRemoveWindowManager = <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            appContext.setOuterContext(activity);</span><br><span class="line">            activity.attach(appContext, <span class="keyword">this</span>, getInstrumentation(), r.token,</span><br><span class="line">                    r.ident, app, r.intent, r.activityInfo, title, r.parent,</span><br><span class="line">                    r.embeddedID, r.lastNonConfigurationInstances, config,</span><br><span class="line">                    r.referrer, r.voiceInteractor, window, r.configCallback);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (customIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                activity.mIntent = customIntent;</span><br><span class="line">            &#125;</span><br><span class="line">            r.lastNonConfigurationInstances = <span class="keyword">null</span>;</span><br><span class="line">            checkAndBlockForNetworkAccess();</span><br><span class="line">            activity.mStartedActivity = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">int</span> theme = r.activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (theme != <span class="number">0</span>) &#123;</span><br><span class="line">                activity.setTheme(theme);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            activity.mCalled = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">if</span> (r.isPersistable()) &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mInstrumentation.callActivityOnCreate(activity, r.state);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!activity.mCalled) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> SuperNotCalledException(</span><br><span class="line">                    <span class="string">"Activity "</span> + r.intent.getComponent().toShortString() +</span><br><span class="line">                    <span class="string">" did not call through to super.onCreate()"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            r.activity = activity;</span><br><span class="line">        &#125;</span><br><span class="line">        r.setState(ON_CREATE);</span><br><span class="line"></span><br><span class="line">        mActivities.put(r.token, r);</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (SuperNotCalledException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line"></span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mInstrumentation.onException(activity, e)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Unable to start activity "</span> + component</span><br><span class="line">                + <span class="string">": "</span> + e.toString(), e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> activity;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把上面这段代码整理一下（以下总结来自《Android开发艺术探索》）：</p>
<ol>
<li>从 ActivityClientRecord 中获取待启动的 Activity 的组件信息；</li>
<li>通过 Instrumentation 的 newActivity 方法使用类加载器创建 Activity 对象；</li>
<li>通过 LoadedApk 的 makeApplication 方法来尝试创建 Application 对象；</li>
<li>创建 ContextImpl 对象并通过 Activity 的 attach 方法来完成一些重要数据的初始化；</li>
<li>调用 Activity 的 onCreate 方法</li>
</ol>
<p>在这里，1-4点详细的分析就不展开了，我们重点来看一下第5小点。</p>
<p>即</p>
<pre><code>if (r.isPersistable()) {
     mInstrumentation.callActivityOnCreate(activity, r.state, r.persistentState);
} else {
     mInstrumentation.callActivityOnCreate(activity, r.state);
}
</code></pre><h1 id="Instrumentation-1"><a href="#Instrumentation-1" class="headerlink" title="Instrumentation"></a>Instrumentation</h1><h2 id="callActivityOnCreate"><a href="#callActivityOnCreate" class="headerlink" title="callActivityOnCreate"></a>callActivityOnCreate</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    prePerformCreate(activity);</span><br><span class="line">    activity.performCreate(icicle);</span><br><span class="line">    postPerformCreate(activity);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这，有一种豁然开朗的感觉。原来 Activity 的生命周期调用都是通过 Instrumentation 调用来完成的。</p>
<h1 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h1><h2 id="performCreate_28Bundle_icicle_29"><a href="#performCreate_28Bundle_icicle_29" class="headerlink" title="performCreate(Bundle icicle)"></a>performCreate(Bundle icicle)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle)</span> </span>&#123;</span><br><span class="line">    performCreate(icicle, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">performCreate</span><span class="params">(Bundle icicle, PersistableBundle persistentState)</span> </span>&#123;</span><br><span class="line">    mCanEnterPictureInPicture = <span class="keyword">true</span>;</span><br><span class="line">    restoreHasCurrentPermissionRequest(icicle);</span><br><span class="line">    <span class="comment">// 回调 activity 的 onCreate 生命周期</span></span><br><span class="line">    <span class="keyword">if</span> (persistentState != <span class="keyword">null</span>) &#123;</span><br><span class="line">        onCreate(icicle, persistentState);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        onCreate(icicle);</span><br><span class="line">    &#125;</span><br><span class="line">    writeEventLog(LOG_AM_ON_CREATE_CALLED, <span class="string">"performCreate"</span>);</span><br><span class="line">    mActivityTransitionState.readState(icicle);</span><br><span class="line"></span><br><span class="line">    mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(</span><br><span class="line">            com.android.internal.R.styleable.Window_windowNoDisplay, <span class="keyword">false</span>);</span><br><span class="line">    mFragments.dispatchActivityCreated();</span><br><span class="line">    mActivityTransitionState.setEnterActivityOptions(<span class="keyword">this</span>, getActivityOptions());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码分析到这里，基本上把 Activity 创建和回调 onCreate 生命周期讲完了。</p>
<p>前面还留了一个坑，就是 Activity 是怎么回调 onStart 和 onResume 的呢？我们只能到下一篇再讲了。</p>
<p>bye bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：源码分析基于 Android SDK API 28</p>
<p>对于 Activity 大家都已经很熟悉很亲切了吧，在这就不过多介绍了。</p>
<p>直接进入正题，走起！</p>
<p>一般我们启动 Activity 的入口都是 startActivity ，所以这]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.me/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(七):dex合成流程]]></title>
    <link href="http://yuqirong.me/2019/03/20/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%83)/"/>
    <id>http://yuqirong.me/2019/03/20/Tinker源码分析(七)/</id>
    <published>2019-03-20T15:36:31.000Z</published>
    <updated>2019-03-23T13:04:01.781Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前面讲到了 Tinker 安装补丁的流程，现在就详细地来看下 dex 合成的代码。代码入口就在 DexDiffPatchInternal.tryRecoverDexFiles 中。</p>
<h1 id="UpgradePatch"><a href="#UpgradePatch" class="headerlink" title="UpgradePatch"></a>UpgradePatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch dex failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>直接调用了 DexDiffPatchInternal.tryRecoverDexFiles 方法。</p>
<h1 id="tryRecoverDexFiles"><a href="#tryRecoverDexFiles" class="headerlink" title="tryRecoverDexFiles"></a>tryRecoverDexFiles</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">tryRecoverDexFiles</span><span class="params">(Tinker manager, ShareSecurityCheck checker, Context context,</span><br><span class="line">                                            String patchVersionDirectory, File patchFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否开启支持dex补丁开关                                        </span></span><br><span class="line">    <span class="keyword">if</span> (!manager.isEnabledForDex()) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, dex is not enabled"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查补丁包中的 dex_meta.txt 是否存在</span></span><br><span class="line">    String dexMeta = checker.getMetaContentMap().get(DEX_META_FILE);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dexMeta == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, dex is not contained"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="comment">// 到这个方法中执行具体的操作</span></span><br><span class="line">    <span class="keyword">boolean</span> result = patchDexExtractViaDexDiff(context, patchVersionDirectory, dexMeta, patchFile);</span><br><span class="line">    <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"recover dex result:%b, cost:%d"</span>, result, cost);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryRecoverDexFiles 方法开头做了些校验，最后又到 patchDexExtractViaDexDiff 中。</p>
<h1 id="patchDexExtractViaDexDiff"><a href="#patchDexExtractViaDexDiff" class="headerlink" title="patchDexExtractViaDexDiff"></a>patchDexExtractViaDexDiff</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">patchDexExtractViaDexDiff</span><span class="params">(Context context, String patchVersionDirectory, String meta, <span class="keyword">final</span> File patchFile)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// dex补丁合成的路径</span></span><br><span class="line">    String dir = patchVersionDirectory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</span><br><span class="line">    <span class="comment">// extractDexDiffInternals 这个方法是重点！！！</span></span><br><span class="line">    <span class="keyword">if</span> (!extractDexDiffInternals(context, dir, meta, patchFile, TYPE_DEX)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch recover, extractDiffInternals fail"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把 tinker/patch-xxxxx/dex/ 下面的文件校验下，看看是否是合法的dex文件</span></span><br><span class="line">    File dexFiles = <span class="keyword">new</span> File(dir);</span><br><span class="line">    File[] files = dexFiles.listFiles();</span><br><span class="line">    List&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// may have directory in android o</span></span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            <span class="keyword">final</span> String fileName = file.getName();</span><br><span class="line">            <span class="keyword">if</span> (file.isFile()</span><br><span class="line">                &amp;&amp;  (fileName.endsWith(ShareConstants.DEX_SUFFIX)</span><br><span class="line">                  || fileName.endsWith(ShareConstants.JAR_SUFFIX)</span><br><span class="line">                  || fileName.endsWith(ShareConstants.PATCH_SUFFIX))</span><br><span class="line">            ) &#123;</span><br><span class="line">                legalFiles.add(file);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"legal files to do dexopt: "</span> + legalFiles);</span><br><span class="line">    <span class="comment">// 对 dex 做 opt 优化</span></span><br><span class="line">    <span class="keyword">final</span> String optimizeDexDirectory = patchVersionDirectory + <span class="string">"/"</span> + DEX_OPTIMIZE_PATH + <span class="string">"/"</span>;</span><br><span class="line">    <span class="keyword">return</span> dexOptimizeDexFiles(context, legalFiles, optimizeDexDirectory, patchFile);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 patchDexExtractViaDexDiff 中可以看到， dex 文件合成之后，会对其做 opt 优化。而合成的代码就在 extractDexDiffInternals 里面。</p>
<p>extractDexDiffInternals 方法有点长。按照老规矩，我们分段来看。</p>
<h1 id="extractDexDiffInternals"><a href="#extractDexDiffInternals" class="headerlink" title="extractDexDiffInternals"></a>extractDexDiffInternals</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">extractDexDiffInternals</span><span class="params">(Context context, String dir, String meta, File patchFile, <span class="keyword">int</span> type)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 读取 dex_meta.txt 中的信息</span></span><br><span class="line">    patchList.clear();</span><br><span class="line">    ShareDexDiffPatchInfo.parseDexDiffPatchInfo(meta, patchList);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (patchList.isEmpty()) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"extract patch list is empty! type:%s:"</span>, ShareTinkerInternals.getTypeString(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先读取 dex_meta.txt 中的信息，用“,”分割，保存到 patchList 中。</p>
<p>下面贴出一份 dex_meta.txt 的示例：</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classes.dex,,<span class="number">1</span>a6e6d6a40eff95aa33ab06e07acd413,<span class="number">1</span>a6e6d6a40eff95aa33ab06e07acd413,d865f383455abd6e3f70096109543644,<span class="number">2999635299</span>,<span class="number">712828526</span>,jar</span><br><span class="line">test.dex,,<span class="number">56900442</span>eb5b7e1de45449d0685e6e00,<span class="number">56900442</span>eb5b7e1de45449d0685e6e00,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,jar</span><br></pre></td></tr></table></figure>
<p>dex_meta.txt 记录着</p>
<ul>
<li>name ：补丁 dex 名字</li>
<li>path ：补丁 dex 路径</li>
<li>destMd5InDvm ：合成新 dex 在 dvm 中的 md5 值</li>
<li>destMd5InArt ：合成新 dex 在 art 中的 md5 值</li>
<li>dexDiffMd5 ：补丁包 dex 文件的 md5 值</li>
<li>oldDexCrc ：基准包中对应 dex 的 crc 值</li>
<li>newDexCrc ：合成新 dex 的 crc 值</li>
<li>dexMode ：dex 类型，为 jar 类型</li>
</ul>
<p>接着往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">File directory = <span class="keyword">new</span> File(dir);</span><br><span class="line"><span class="keyword">if</span> (!directory.exists()) &#123;</span><br><span class="line">   directory.mkdirs();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//I think it is better to extract the raw files from apk</span></span><br><span class="line">Tinker manager = Tinker.with(context);</span><br><span class="line">ZipFile apk = <span class="keyword">null</span>;</span><br><span class="line">ZipFile patch = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   ApplicationInfo applicationInfo = context.getApplicationInfo();</span><br><span class="line">   <span class="keyword">if</span> (applicationInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="comment">// Looks like running on a test Context, so just return without patching.</span></span><br><span class="line">       TinkerLog.w(TAG, <span class="string">"applicationInfo == null!!!!"</span>);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 获取到基准包apk的路径</span></span><br><span class="line">   String apkPath = applicationInfo.sourceDir;</span><br><span class="line">   <span class="comment">// 基准包文件</span></span><br><span class="line">   apk = <span class="keyword">new</span> ZipFile(apkPath);</span><br><span class="line">   <span class="comment">// 补丁包文件</span></span><br><span class="line">   patch = <span class="keyword">new</span> ZipFile(patchFile);</span><br><span class="line">   <span class="keyword">if</span> (checkClassNDexFiles(dir)) &#123;</span><br><span class="line">       TinkerLog.w(TAG, <span class="string">"class n dex file %s is already exist, and md5 match, just continue"</span>, ShareConstants.CLASS_N_APK_NAME);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>然后获取基本包和补丁包的路径，为下面合成做准备。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 遍历 ShareDexDiffPatchInfo</span></span><br><span class="line"><span class="keyword">for</span> (ShareDexDiffPatchInfo info : patchList) &#123;</span><br><span class="line">  <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 补丁dex文件路径</span></span><br><span class="line">  <span class="keyword">final</span> String infoPath = info.path;</span><br><span class="line">  String patchRealPath;</span><br><span class="line">  <span class="keyword">if</span> (infoPath.equals(<span class="string">""</span>)) &#123;</span><br><span class="line">      patchRealPath = info.rawName;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      patchRealPath = info.path + <span class="string">"/"</span> + info.rawName;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  String dexDiffMd5 = info.dexDiffMd5;</span><br><span class="line">  String oldDexCrc = info.oldDexCrC;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果是 dvm 虚拟机环境，但是补丁dex是art环境的，就跳过</span></span><br><span class="line">  <span class="keyword">if</span> (!isVmArt &amp;&amp; info.destMd5InDvm.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"patch dex %s is only for art, just continue"</span>, patchRealPath);</span><br><span class="line">      <span class="keyword">continue</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  String extractedFileMd5 = isVmArt ? info.destMd5InArt : info.destMd5InDvm;</span><br><span class="line">  <span class="comment">// 检查 md5 值</span></span><br><span class="line">  <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(extractedFileMd5)) &#123;</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"meta file md5 invalid, type:%s, name: %s, md5: %s"</span>, ShareTinkerInternals.getTypeString(type), info.rawName, extractedFileMd5);</span><br><span class="line">      manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  File extractedFile = <span class="keyword">new</span> File(dir + info.realName);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果合成的dex文件已经存在了</span></span><br><span class="line">  <span class="keyword">if</span> (extractedFile.exists()) &#123;</span><br><span class="line">      <span class="comment">// 就校验合成的 dex 文件md5值，如果通过就跳过</span></span><br><span class="line">      <span class="keyword">if</span> (SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">          <span class="comment">//it is ok, just continue</span></span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"dex file %s is already exist, and md5 match, just continue"</span>, extractedFile.getPath());</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"have a mismatch corrupted dex "</span> + extractedFile.getPath());</span><br><span class="line">          <span class="comment">// 否则删除文件</span></span><br><span class="line">          extractedFile.delete();</span><br><span class="line">      &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      extractedFile.getParentFile().mkdirs();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从这里开始，就是遍历 patchList 中的记录，进行一个个 dex 文件合成了。一开头会去校验合成的文件是否存在，存在的话就跳过，进行下一个。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">ZipEntry patchFileEntry = patch.getEntry(patchRealPath);</span><br><span class="line">ZipEntry rawApkFileEntry = apk.getEntry(patchRealPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldDexCrc.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">    <span class="keyword">if</span> (patchFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"patch entry is null. path:"</span> + patchRealPath);</span><br><span class="line">        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//it is a new file, but maybe we need to repack the dex file</span></span><br><span class="line">    <span class="keyword">if</span> (!extractDexFile(patch, patchFileEntry, extractedFile, info)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"Failed to extract raw patch file "</span> + extractedFile.getPath());</span><br><span class="line">        manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 oldDexCrc 为0，就说明基准包中对应的 oldDex 文件不存在，直接按照 patch 信息重新打包 dex 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 dexDiffMd5 为 0， 就说明补丁包中没有这个dex，但是基准包中存在</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (dexDiffMd5.equals(<span class="string">"0"</span>)) &#123;</span><br><span class="line">      <span class="comment">// skip process old dex for real dalvik vm</span></span><br><span class="line">      <span class="comment">// 如果是 dvm 环境的无须做处理</span></span><br><span class="line">      <span class="keyword">if</span> (!isVmArt) &#123;</span><br><span class="line">          <span class="keyword">continue</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 检查基准包中的 dex 是否为空</span></span><br><span class="line">      <span class="keyword">if</span> (rawApkFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"apk entry is null. path:"</span> + patchRealPath);</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//check source crc instead of md5 for faster</span></span><br><span class="line">      <span class="comment">// 检查基准包中的 dex 的 crc 值和 dex_meta.txt 中是否一致</span></span><br><span class="line">      String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">      <span class="keyword">if</span> (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">          TinkerLog.e(TAG, <span class="string">"apk entry %s crc is not equal, expect crc: %s, got crc: %s"</span>, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Small patched dex generating strategy was disabled, we copy full original dex directly now.</span></span><br><span class="line">      <span class="comment">//patchDexFile(apk, patch, rawApkFileEntry, null, info, smallPatchInfoFile, extractedFile);</span></span><br><span class="line">      <span class="comment">// 直接复制 ：copy full original dex directly now.</span></span><br><span class="line">      extractDexFile(apk, rawApkFileEntry, extractedFile, info);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 复制完后校验一下md5值是否一致</span></span><br><span class="line">      <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">          TinkerLog.w(TAG, <span class="string">"Failed to recover dex file when verify patched dex: "</span> + extractedFile.getPath());</span><br><span class="line">          manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">          SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">          <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码用来处理基准包中有 oldDex ，但是补丁包中没有 dex 的情况。</p>
<p>如果是 dvm 环境就跳过不处理即可，如果是 art 环境就把 oldDex 复制过去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 检查补丁包中 dex 是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (patchFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"patch entry is null. path:"</span> + patchRealPath);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查补丁包中的 dex md5值是否合法</span></span><br><span class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(dexDiffMd5)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"meta file md5 invalid, type:%s, name: %s, md5: %s"</span>, ShareTinkerInternals.getTypeString(type), info.rawName, dexDiffMd5);</span><br><span class="line">                    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, BasePatchInternal.getMetaCorruptedCode(type));</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查基准包中的 dex 是否存在</span></span><br><span class="line">                <span class="keyword">if</span> (rawApkFileEntry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"apk entry is null. path:"</span> + patchRealPath);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 检查基准包中的 dex 的 crc 值是否一致</span></span><br><span class="line">                String rawEntryCrc = String.valueOf(rawApkFileEntry.getCrc());</span><br><span class="line">                <span class="keyword">if</span> (!rawEntryCrc.equals(oldDexCrc)) &#123;</span><br><span class="line">                    TinkerLog.e(TAG, <span class="string">"apk entry %s crc is not equal, expect crc: %s, got crc: %s"</span>, patchRealPath, oldDexCrc, rawEntryCrc);</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 执行合成操作</span></span><br><span class="line">                patchDexFile(apk, patch, rawApkFileEntry, patchFileEntry, info, extractedFile);</span><br><span class="line">                <span class="comment">// 检查合成出来的dex的 md5 值是否一致</span></span><br><span class="line">                <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(extractedFile, extractedFileMd5)) &#123;</span><br><span class="line">                    TinkerLog.w(TAG, <span class="string">"Failed to recover dex file when verify patched dex: "</span> + extractedFile.getPath());</span><br><span class="line">                    manager.getPatchReporter().onPatchTypeExtractFail(patchFile, extractedFile, info.rawName, type);</span><br><span class="line">                    SharePatchFileUtil.safeDeleteFile(extractedFile);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                TinkerLog.w(TAG, <span class="string">"success recover dex file: %s, size: %d, use time: %d"</span>,</span><br><span class="line">                    extractedFile.getPath(), extractedFile.length(), (System.currentTimeMillis() - start));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!mergeClassNDexFiles(context, patchFile, dir)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"patch "</span> + ShareTinkerInternals.getTypeString(type) + <span class="string">" extract failed ("</span> + e.getMessage() + <span class="string">")."</span>, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        SharePatchFileUtil.closeZip(apk);</span><br><span class="line">        SharePatchFileUtil.closeZip(patch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是基准包和补丁包中都存在对应 dex 的情况了。</p>
<p>代码一开始就是一堆的各种校验，都通过后，调用 patchDexFile 执行合成操作。合成完后再对合成的 dex 进行md5校验。</p>
<h1 id="patchDexFile"><a href="#patchDexFile" class="headerlink" title="patchDexFile"></a>patchDexFile</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patchDexFile</span><span class="params">(</span><br><span class="line">    ZipFile baseApk, ZipFile patchPkg, ZipEntry oldDexEntry, ZipEntry patchFileEntry,</span><br><span class="line">    ShareDexDiffPatchInfo patchInfo, File patchedDexFile)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream oldDexStream = <span class="keyword">null</span>;</span><br><span class="line">    InputStream patchFileStream = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 基准包 dex 文件输入流</span></span><br><span class="line">        oldDexStream = <span class="keyword">new</span> BufferedInputStream(baseApk.getInputStream(oldDexEntry));</span><br><span class="line">        <span class="comment">// 补丁包 dex 文件输入流</span></span><br><span class="line">        patchFileStream = (patchFileEntry != <span class="keyword">null</span> ? <span class="keyword">new</span> BufferedInputStream(patchPkg.getInputStream(patchFileEntry)) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> isRawDexFile = SharePatchFileUtil.isRawDexFile(patchInfo.rawName);</span><br><span class="line">        <span class="keyword">if</span> (!isRawDexFile || patchInfo.isJarMode) &#123;</span><br><span class="line">            ZipOutputStream zos = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 合成 dex 文件的输出流</span></span><br><span class="line">                zos = <span class="keyword">new</span> ZipOutputStream(<span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(patchedDexFile)));</span><br><span class="line">                zos.putNextEntry(<span class="keyword">new</span> ZipEntry(ShareConstants.DEX_IN_JAR));</span><br><span class="line">                <span class="comment">// Old dex is not a raw dex file.</span></span><br><span class="line">                <span class="keyword">if</span> (!isRawDexFile) &#123;</span><br><span class="line">                    ZipInputStream zis = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        zis = <span class="keyword">new</span> ZipInputStream(oldDexStream);</span><br><span class="line">                        ZipEntry entry;</span><br><span class="line">                        <span class="keyword">while</span> ((entry = zis.getNextEntry()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (ShareConstants.DEX_IN_JAR.equals(entry.getName())) <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"can't recognize zip dex format file:"</span> + patchedDexFile.getAbsolutePath());</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">new</span> DexPatchApplier(zis, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        StreamUtil.closeQuietly(zis);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">new</span> DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(zos);</span><br><span class="line">                &#125;</span><br><span class="line">                zos.closeEntry();</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                StreamUtil.closeQuietly(zos);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">new</span> DexPatchApplier(oldDexStream, patchFileStream).executeAndSaveTo(patchedDexFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        StreamUtil.closeQuietly(oldDexStream);</span><br><span class="line">        StreamUtil.closeQuietly(patchFileStream);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 patchDexFile 中，拿到基准包 dex 文件的 InputStream 和补丁包 dex 文件的 InputStream ，然后利用 DexPatchApplier 把这两个流合成一个 dex 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAndSaveTo</span><span class="params">(OutputStream out)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Before executing, we should check if this patch can be applied to</span></span><br><span class="line">    <span class="comment">// old dex we passed in.</span></span><br><span class="line">    <span class="keyword">byte</span>[] oldDexSign = <span class="keyword">this</span>.oldDex.computeSignature(<span class="keyword">false</span>);</span><br><span class="line">    <span class="keyword">if</span> (oldDexSign == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"failed to compute old dex's signature."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.patchFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"patch file is null."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">byte</span>[] oldDexSignInPatchFile = <span class="keyword">this</span>.patchFile.getOldDexSignature();</span><br><span class="line">    <span class="keyword">if</span> (CompareUtils.uArrCompare(oldDexSign, oldDexSignInPatchFile) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(</span><br><span class="line">                String.format(</span><br><span class="line">                        <span class="string">"old dex signature mismatch! expected: %s, actual: %s"</span>,</span><br><span class="line">                        Arrays.toString(oldDexSign),</span><br><span class="line">                        Arrays.toString(oldDexSignInPatchFile)</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Firstly, set sections' offset after patched, sort according to their offset so that</span></span><br><span class="line">    <span class="comment">// the dex lib of aosp can calculate section size.</span></span><br><span class="line">    TableOfContents patchedToc = <span class="keyword">this</span>.patchedDex.getTableOfContents();</span><br><span class="line"></span><br><span class="line">    patchedToc.header.off = <span class="number">0</span>;</span><br><span class="line">    patchedToc.header.size = <span class="number">1</span>;</span><br><span class="line">    patchedToc.mapList.size = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    patchedToc.stringIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedStringIdSectionOffset();</span><br><span class="line">    patchedToc.typeIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedTypeIdSectionOffset();</span><br><span class="line">    patchedToc.typeLists.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedTypeListSectionOffset();</span><br><span class="line">    patchedToc.protoIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedProtoIdSectionOffset();</span><br><span class="line">    patchedToc.fieldIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedFieldIdSectionOffset();</span><br><span class="line">    patchedToc.methodIds.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedMethodIdSectionOffset();</span><br><span class="line">    patchedToc.classDefs.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedClassDefSectionOffset();</span><br><span class="line">    patchedToc.mapList.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedMapListSectionOffset();</span><br><span class="line">    patchedToc.stringDatas.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedStringDataSectionOffset();</span><br><span class="line">    patchedToc.annotations.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSectionOffset();</span><br><span class="line">    patchedToc.annotationSets.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSetSectionOffset();</span><br><span class="line">    patchedToc.annotationSetRefLists.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationSetRefListSectionOffset();</span><br><span class="line">    patchedToc.annotationsDirectories.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedAnnotationsDirectorySectionOffset();</span><br><span class="line">    patchedToc.encodedArrays.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedEncodedArraySectionOffset();</span><br><span class="line">    patchedToc.debugInfos.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedDebugInfoSectionOffset();</span><br><span class="line">    patchedToc.codes.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedCodeSectionOffset();</span><br><span class="line">    patchedToc.classDatas.off</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedClassDataSectionOffset();</span><br><span class="line">    patchedToc.fileSize</span><br><span class="line">            = <span class="keyword">this</span>.patchFile.getPatchedDexSize();</span><br><span class="line"></span><br><span class="line">    Arrays.sort(patchedToc.sections);</span><br><span class="line"></span><br><span class="line">    patchedToc.computeSizesFromOffsets();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Secondly, run patch algorithms according to sections' dependencies.</span></span><br><span class="line">    <span class="keyword">this</span>.stringDataSectionPatchAlg = <span class="keyword">new</span> StringDataSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.typeIdSectionPatchAlg = <span class="keyword">new</span> TypeIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.protoIdSectionPatchAlg = <span class="keyword">new</span> ProtoIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.fieldIdSectionPatchAlg = <span class="keyword">new</span> FieldIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.methodIdSectionPatchAlg = <span class="keyword">new</span> MethodIdSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.classDefSectionPatchAlg = <span class="keyword">new</span> ClassDefSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.typeListSectionPatchAlg = <span class="keyword">new</span> TypeListSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSetRefListSectionPatchAlg = <span class="keyword">new</span> AnnotationSetRefListSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSetSectionPatchAlg = <span class="keyword">new</span> AnnotationSetSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.classDataSectionPatchAlg = <span class="keyword">new</span> ClassDataSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.codeSectionPatchAlg = <span class="keyword">new</span> CodeSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.debugInfoSectionPatchAlg = <span class="keyword">new</span> DebugInfoItemSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationSectionPatchAlg = <span class="keyword">new</span> AnnotationSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.encodedArraySectionPatchAlg = <span class="keyword">new</span> StaticValueSectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line">    <span class="keyword">this</span>.annotationsDirectorySectionPatchAlg = <span class="keyword">new</span> AnnotationsDirectorySectionPatchAlgorithm(</span><br><span class="line">            patchFile, oldDex, patchedDex, oldToPatchedIndexMap</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.stringDataSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.typeIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.typeListSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.protoIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.fieldIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.methodIdSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSetSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationSetRefListSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.annotationsDirectorySectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.debugInfoSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.codeSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.classDataSectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.encodedArraySectionPatchAlg.execute();</span><br><span class="line">    <span class="keyword">this</span>.classDefSectionPatchAlg.execute();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Thirdly, write header, mapList. Calculate and write patched dex's sign and checksum.</span></span><br><span class="line">    Dex.Section headerOut = <span class="keyword">this</span>.patchedDex.openSection(patchedToc.header.off);</span><br><span class="line">    patchedToc.writeHeader(headerOut);</span><br><span class="line"></span><br><span class="line">    Dex.Section mapListOut = <span class="keyword">this</span>.patchedDex.openSection(patchedToc.mapList.off);</span><br><span class="line">    patchedToc.writeMap(mapListOut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.patchedDex.writeHashes();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Finally, write patched dex to file.</span></span><br><span class="line">    <span class="keyword">this</span>.patchedDex.writeTo(out);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 DexPatchApplier 里面合流操作的代码是需要根据 Tinker 的 DexDiff 算法来的。大致就是把两个 Dex 文件的每个分区做 merge 操作。</p>
<p>这里先留一个坑。等以后把 DexDiff 算法看明白了再补上。</p>
<p>另外，dodola 写了一篇 <a href="https://www.zybuluo.com/dodola/note/554061" target="_blank" rel="external">Tinker Dexdiff算法解析</a>，有需要的同学可以看下。</p>
<p>那么 dex 合成的流程就到这吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前面讲到了 Tinker 安装补丁的流程，现在就详细地来看下 dex 合成的代码。代码入口就在 DexDiffPatchInternal.tryRecoverDexFiles 中。</p>
<h]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Apk安全之校验签名]]></title>
    <link href="http://yuqirong.me/2019/03/18/Apk%E5%AE%89%E5%85%A8%E4%B9%8B%E6%A0%A1%E9%AA%8C%E7%AD%BE%E5%90%8D/"/>
    <id>http://yuqirong.me/2019/03/18/Apk安全之校验签名/</id>
    <published>2019-03-18T15:17:31.000Z</published>
    <updated>2019-03-18T15:51:43.149Z</updated>
    <content type="html"><![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防护，比如代码混淆、加固等。</p>
<p>今天就来讲讲其中的一项：校验签名。</p>
<p>校验签名可以有效的防止二次打包，避免你的 app 被植入广告甚至破解等。而今天就从两个角度来讲签名的具体校验：</p>
<ul>
<li>Java 层</li>
<li>C/C++ 层</li>
</ul>
<p>那么就先开始讲 java 层好了。</p>
<h1 id="Java__u5C42"><a href="#Java__u5C42" class="headerlink" title="Java 层"></a>Java 层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateAppSignature</span><span class="params">(Context context, String apkSignature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">        PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">        <span class="keyword">for</span> (Signature signature : packageInfo.signatures) &#123;</span><br><span class="line">            String lowerCaseSignature = signature.toCharsString().toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (lowerCaseSignature.equals(apkSignature)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 层的签名校验核心代码就这些，传入的两个参数 ：</p>
<ul>
<li>Context context : 一般都是 Application</li>
<li>String apkSignature : 你的 apk 的正式签名</li>
</ul>
<p>Java 层的签名校验比较容易被攻破，因为别人可以反编译一下，然后在 smali 中把 validateAppSignature 方法的返回值改成 true 就大功告成了。</p>
<p>也正因为如此，所以需要在 C/C++ 层中也加入签名校验。</p>
<h1 id="C/C++__u5C42"><a href="#C/C++__u5C42" class="headerlink" title="C/C++ 层"></a>C/C++ 层</h1><p>在 so 文件加载的时候，会去调用 JNI_OnLoad 函数，所以我们可以在这里做签名校验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        LOGE(<span class="string">"no jni version 1.6"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkAppSignature(env) != JNI_TRUE) &#123;</span><br><span class="line">        LOGE(<span class="string">"the signature of apk is invalid"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>签名校验的代码主要在 checkAppSignature 函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">checkAppSignature</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass classNativeContext = (*env)-&gt;FindClass(env, <span class="string">"me/yuqirong/security/Security"</span>);</span><br><span class="line">    jmethodID midGetAppContext = (*env)-&gt;GetStaticMethodID(env, classNativeContext,</span><br><span class="line">                                                        <span class="string">"getContext"</span>,</span><br><span class="line">                                                        <span class="string">"()Landroid/content/Context;"</span>);</span><br><span class="line">    jobject appContext = (*env)-&gt;CallStaticObjectMethod(env, classNativeContext, midGetAppContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appContext != NULL) &#123;</span><br><span class="line">        jboolean signatureValid = Android_checkSignature(env, NULL, appContext);</span><br><span class="line">        <span class="keyword">return</span> signatureValid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"app context is null, please check the context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，checkAppSignature 主要是通过 C 的代码反射来获取 Context 。</p>
<p>对应的 Java 层代码如下，一般来说， <code>Security.setContext(application)</code> 会在 Application.onCreate 方法中调用 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Application application;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> application;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Application context)</span> </span>&#123;</span><br><span class="line">	    application = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到 Context 之后，就可以来比较签名了 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* APP_SIGNATURE = <span class="string">"input your signature of apk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">Android_checkSignature</span><span class="params">(</span><br><span class="line">        JNIEnv *env, jclass clazz, jobject context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jstring appSignature = loadSignature(env, context);</span><br><span class="line">    jstring releaseSignature = (*env)-&gt;NewStringUTF(env, APP_SIGNATURE);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charAppSignature = (*env)-&gt;GetStringUTFChars(env, appSignature, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charReleaseSignature = (*env)-&gt;GetStringUTFChars(env, releaseSignature, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jboolean result = JNI_FALSE;</span><br><span class="line">    <span class="keyword">if</span> (charAppSignature != <span class="literal">NULL</span> &amp;&amp; charReleaseSignature != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(charAppSignature, charReleaseSignature) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGI(<span class="string">"the signature of apk is valid, so pass it"</span>);</span><br><span class="line">            result = JNI_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, appSignature, charAppSignature);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, releaseSignature, charReleaseSignature);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 APP_SIGNATURE 就是正式版的签名字符串，而 loadSignature 函数需要反射安卓系统的 API 才能获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">loadSignature</span><span class="params">(JNIEnv *env, jobject context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得Context类</span></span><br><span class="line">    jclass cls = (*env)-&gt;GetObjectClass(env, context);</span><br><span class="line">    <span class="comment">// 得到getPackageManager方法的ID</span></span><br><span class="line">    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageManager"</span>, <span class="string">"()Landroid/content/pm/PackageManager;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得应用包的管理器</span></span><br><span class="line">    jobject pm = (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到getPackageName方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 获得当前应用包名</span></span><br><span class="line">    jstring packageName = (jstring) (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得PackageManager类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, pm);</span><br><span class="line">    <span class="comment">// 得到getPackageInfo方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageInfo"</span>, <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);</span><br><span class="line">    <span class="comment">// 获得应用包的信息</span></span><br><span class="line">    jobject packageInfo = (*env)-&gt;CallObjectMethod(env, pm, mid, packageName, <span class="number">0x40</span>); <span class="comment">//GET_SIGNATURES = 64;</span></span><br><span class="line">    <span class="comment">// 获得PackageInfo 类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, packageInfo);</span><br><span class="line">    <span class="comment">// 获得签名数组属性的ID</span></span><br><span class="line">    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</span><br><span class="line">    <span class="comment">// 得到签名数组</span></span><br><span class="line">    jobjectArray signatures = (jobjectArray) (*env)-&gt;GetObjectField(env, packageInfo, fid);</span><br><span class="line">    <span class="comment">// 得到签名</span></span><br><span class="line">    jobject signature = (*env)-&gt;GetObjectArrayElement(env, signatures, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Signature类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signature);</span><br><span class="line">    <span class="comment">// 得到toCharsString方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toCharsString"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 返回当前应用签名信息</span></span><br><span class="line">    jstring signatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signature, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toLowerCase</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signatureString);</span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toLowerCase"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring lowerCaseSignatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signatureString, mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowerCaseSignatureString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadSignature 函数可以说就是用 C 语言把上面 Java 的那段代码实现了一遍，并没有什么差别。</p>
<p>至此，有了 Java 和 C/C++ 的双重保护，app 的安全性又提升了一级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(六):补丁合成流程]]></title>
    <link href="http://yuqirong.me/2019/03/14/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)/"/>
    <id>http://yuqirong.me/2019/03/14/Tinker源码分析(六)/</id>
    <published>2019-03-14T15:05:56.000Z</published>
    <updated>2019-03-14T15:41:53.172Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="headerlink" title="补丁合成流程"></a>补丁合成流程</h1><p>下发的补丁包其实并不能直接加载，因为补丁包只是差异包，需要和本地的 dex 、资源等进行合成后，得到全量的 dex 才能被完整地使用。这样也就避免了热修复中 dex 的 pre-verify 问题，也减少了补丁包的体积，方便用户下载。</p>
<p>补丁合成的入口在 TinkerInstaller.onReceiveUpgradePatch 方法</p>
<h1 id="TinkerInstaller-onReceiveUpgradePatch"><a href="#TinkerInstaller-onReceiveUpgradePatch" class="headerlink" title="TinkerInstaller.onReceiveUpgradePatch"></a>TinkerInstaller.onReceiveUpgradePatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onReceiveUpgradePatch</span><span class="params">(Context context, String patchLocation)</span> </span>&#123;</span><br><span class="line">    Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 PatchListener 有默认实现类，即 DefaultPatchListener 。</p>
<h1 id="DefaultPatchListener-onPatchReceived"><a href="#DefaultPatchListener-onPatchReceived" class="headerlink" title="DefaultPatchListener.onPatchReceived"></a>DefaultPatchListener.onPatchReceived</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onPatchReceived</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="comment">// 对补丁进行校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PATCH_OK) &#123;</span><br><span class="line">        <span class="comment">// 通过的话就启动 :process 进程进行补丁合成    </span></span><br><span class="line">        TinkerPatchService.runPatchService(context, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 校验失败就回调 onLoadPatchListenerReceiveFail</span></span><br><span class="line">        Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(<span class="keyword">new</span> File(path), returnCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看 TinkerPatchService.runPatchService 方法</p>
<h1 id="TinkerPatchService-runPatchService"><a href="#TinkerPatchService-runPatchService" class="headerlink" title="TinkerPatchService.runPatchService"></a>TinkerPatchService.runPatchService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runPatchService</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"run patch service..."</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, TinkerPatchService.class);</span><br><span class="line">    <span class="comment">// path 就是补丁的路径</span></span><br><span class="line">    intent.putExtra(PATCH_PATH_EXTRA, path);</span><br><span class="line">    <span class="comment">// RESULT_CLASS_EXTRA 一般默认就是 DefaultTinkerResultService</span></span><br><span class="line">    intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        enqueueWork(context, TinkerPatchService.class, JOB_ID, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"run patch service fail, exception:"</span> + thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 runPatchService 中去启动了 TinkerPatchService 。TinkerPatchService 是跑在 :patch<br> 进程中的。</p>
<p>TinkerPatchService 主要做的事情都在 onHandleWork 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleWork</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提高优先级</span></span><br><span class="line">    increasingPriority();</span><br><span class="line">    <span class="comment">// 合成补丁</span></span><br><span class="line">    doApplyPatch(<span class="keyword">this</span>, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 increasingPriority 方法，目的就是提高 service 的优先级，具体的方案就是设置为前台服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increasingPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for system version &gt;= Android O, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash or toasts."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"ZUK"</span>.equals(Build.MANUFACTURER)) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for ZUK device, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"try to increase patch process priority"</span>);</span><br><span class="line">    <span class="comment">// 设置为前台服务，提高优先级</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">            <span class="comment">// start InnerService</span></span><br><span class="line">            startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"try to increase patch process priority error:"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是 doApplyPatch 方法，在这里做补丁合成的事</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doApplyPatch</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since we may retry with IntentService, we should prevent</span></span><br><span class="line">    <span class="comment">// racing here again.</span></span><br><span class="line">    <span class="keyword">if</span> (!sIsPatchApplying.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"TinkerPatchService doApplyPatch is running by another runner."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    tinker.getPatchReporter().onPatchServiceStart(intent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService received a null intent, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取补丁文件的路径</span></span><br><span class="line">    String path = getPatchPathExtra(intent);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService can't get the path extra, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">long</span> cost;</span><br><span class="line">    Throwable e = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PatchResult patchResult = <span class="keyword">new</span> PatchResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (upgradePatchProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"upgradePatchProcessor is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理补丁合成</span></span><br><span class="line">        result = upgradePatchProcessor.tryPatch(context, path, patchResult);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        e = throwable;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">        tinker.getPatchReporter().onPatchException(patchFile, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    tinker.getPatchReporter().</span><br><span class="line">        onPatchResult(patchFile, result, cost);</span><br><span class="line"></span><br><span class="line">    patchResult.isSuccess = result;</span><br><span class="line">    patchResult.rawPatchFilePath = path;</span><br><span class="line">    patchResult.costTime = cost;</span><br><span class="line">    patchResult.e = e;</span><br><span class="line">    <span class="comment">// 补丁合成的结果回调给 DefaultResultService</span></span><br><span class="line">    AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));</span><br><span class="line"></span><br><span class="line">    sIsPatchApplying.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upgradePatchProcessor 是一个接口，具体的实现类是 UpgradePatch 。</p>
<h1 id="UpgradePatch-tryPatch"><a href="#UpgradePatch-tryPatch" class="headerlink" title="UpgradePatch.tryPatch"></a>UpgradePatch.tryPatch</h1><p>那么来看看 UpgradePatch.tryPatch ，方法比较长，分段来看吧。</p>
<p>首先是对 Tinker 自身开关的校验，然后对补丁文件的合法性进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryPatch</span><span class="params">(Context context, String tempPatchPath, PatchResult patchResult)</span> </span>&#123;</span><br><span class="line">    Tinker manager = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File patchFile = <span class="keyword">new</span> File(tempPatchPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch is disabled, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchFile)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch file is not found, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后检查补丁包的签名以及 tinkerId , 这里的操作和加载补丁是一样的。</p>
<p>然后就是获取补丁文件的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check the signature, we should create a new checker</span></span><br><span class="line">ShareSecurityCheck signatureCheck = <span class="keyword">new</span> ShareSecurityCheck(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchPackageCheckFail"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取补丁文件的 md5</span></span><br><span class="line">String patchMd5 = SharePatchFileUtil.getMD5(patchFile);</span><br><span class="line"><span class="keyword">if</span> (patchMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch md5 is null, just return"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use md5 as version</span></span><br><span class="line"><span class="comment">// 用 md5 做版本号</span></span><br><span class="line">patchResult.patchVersion = patchMd5;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchMd5:%s"</span>, patchMd5);</span><br></pre></td></tr></table></figure>
<p>接着，校验完成后，我们就来构造一个新的 patch.info 文件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check ok, we can real recover a new patch</span></span><br><span class="line"><span class="keyword">final</span> String patchDirectory = manager.getPatchDirectory().getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// info.lock 文件</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);</span><br><span class="line"><span class="comment">// patch.info 文件</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取出老的 patch.info 文件，可能存在 可能不存在</span></span><br><span class="line">SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//it is a new patch, so we should not find a exist</span></span><br><span class="line">SharePatchInfo newInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有老的 patch.info 文件</span></span><br><span class="line"><span class="keyword">if</span> (oldInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldInfo.oldVersion == <span class="keyword">null</span> || oldInfo.newVersion == <span class="keyword">null</span> || oldInfo.oatDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchInfoCorrupted"</span>);</span><br><span class="line">        manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid"</span>, patchMd5);</span><br><span class="line">        manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if it is interpret now, use changing flag to wait main process</span></span><br><span class="line">    <span class="keyword">final</span> String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)</span><br><span class="line">        ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(oldInfo.oldVersion, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, finalOatDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(<span class="string">""</span>, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来，就是把补丁包复制到私有目录中</p>
<p>具体的路径也就是之前在加载补丁中遇到的 /data/data/应用包名/tinker/patch-xxxxxx/patch-xxxxxx.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//it is a new patch, we first delete if there is any files</span></span><br><span class="line"><span class="comment">//don't delete dir for faster retry</span></span><br><span class="line"><span class="comment">//        SharePatchFileUtil.deleteDir(patchVersionDirectory);</span></span><br><span class="line"><span class="keyword">final</span> String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String patchVersionDirectory = patchDirectory + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchVersionDirectory:%s"</span>, patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy file</span></span><br><span class="line">File destPatchFile = <span class="keyword">new</span> File(patchVersionDirectory + <span class="string">"/"</span> + SharePatchFileUtil.getPatchVersionFile(patchMd5));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// check md5 first</span></span><br><span class="line">  <span class="keyword">if</span> (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) &#123;</span><br><span class="line">      <span class="comment">// 复制补丁包到 /data/data/ 中</span></span><br><span class="line">      SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d"</span>, patchFile.getAbsolutePath(), patchFile.length(),</span><br><span class="line">          destPatchFile.getAbsolutePath(), destPatchFile.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">  TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:copy patch file fail from %s to %s"</span>, patchFile.getPath(), destPatchFile.getPath());</span><br><span class="line">  manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制好之后，就是把补丁包和基准包进行整合了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</span></span><br><span class="line"><span class="comment">// 合成 dex</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch dex failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成 so 文件</span></span><br><span class="line"><span class="keyword">if</span> (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch library failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成资源文件</span></span><br><span class="line"><span class="keyword">if</span> (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch resource failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的三个合成代码我们到后面的章节再分析，这里先跳过了。</p>
<p>合成完后，还要对 dex 进行opt优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, check dex opt file failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是把结果重新写入到 patch.info ，这样在加载补丁的流程中就能加载新补丁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, rewrite patch info failed"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TinkerLog.w(TAG, <span class="string">"UpgradePatch tryPatch: done, it is ok"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>over ，整个合成补丁的流程讲完了，这里还留了三个坑：</p>
<ul>
<li>dex 文件的合成</li>
<li>so 文件的合成</li>
<li>资源文件的合成</li>
</ul>
<p>到后面再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="h]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(五):加载so补丁流程]]></title>
    <link href="http://yuqirong.me/2019/03/10/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)/"/>
    <id>http://yuqirong.me/2019/03/10/Tinker源码分析(五)/</id>
    <published>2019-03-10T14:50:22.000Z</published>
    <updated>2019-03-10T16:33:02.144Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="校验so补丁流程"></a>校验so补丁流程</h1><p>与加载资源补丁类似，加载so补丁也要先从校验开始看起。</p>
<p>其实总体来说，Tinker 中加载 so 补丁文件的关键代码就一句：</p>
<p>System.load(String filePath)</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>从 assets/so_meta.txt 中读取 so 补丁信息，每一条 so 补丁信息都会被封装成一个 ShareBsDiffPatchInfo 对象，然后放入 libraryList 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String meta = securityCheck.getMetaContentMap().get(SO_MEAT_FILE);</span><br><span class="line"><span class="comment">//not found lib</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;ShareBsDiffPatchInfo&gt; libraryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ShareBsDiffPatchInfo.parseDiffPatchInfo(meta, libraryList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (libraryList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后遍历 libraryList ，去校验里面的 ShareBsDiffPatchInfo 对象中 md5 和 name 值是否合法。合法的 ShareBsDiffPatchInfo 对象再放入 libs 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker//patch-641e634c/lib</span></span><br><span class="line">String libraryPath = directory + <span class="string">"/"</span> + SO_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; libs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareBsDiffPatchInfo info : libraryList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ShareBsDiffPatchInfo.checkDiffPatchInfo(info)) &#123;</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String middle = info.path + <span class="string">"/"</span> + info.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlike dex, keep the original structure</span></span><br><span class="line">    libs.put(middle, info.md5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着会校验 so 补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File libraryDir = <span class="keyword">new</span> File(libraryPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!libraryDir.exists() || !libraryDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再校验上面的从 so_meta.txt 中获取到的 so 补丁文件路径是否真的存在并且 so 文件是可读的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fast check whether there is any dex files missing</span></span><br><span class="line"><span class="keyword">for</span> (String relative : libs.keySet()) &#123;</span><br><span class="line">    File libFile = <span class="keyword">new</span> File(libraryPath + relative);</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(libFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH, libFile.getAbsolutePath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都没问题的话，就通过校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if is ok, add to result intent</span></span><br><span class="line">intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_LIBS_PATH, libs);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载so补丁流程"></a>加载so补丁流程</h1><p>加载so补丁的入口：TinkerLoadLibrary.loadArmLibrary / TinkerLoadLibrary.loadArmV7Library ，区别就是前者用来加载 armeabi 平台的，后者是用来加载 armeabi-v7a 平台的。我们就来看 loadArmLibrary 方法吧。</p>
<h2 id="loadArmLibrary"><a href="#loadArmLibrary" class="headerlink" title="loadArmLibrary"></a>loadArmLibrary</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadArmLibrary</span><span class="params">(Context context, String libName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 libName 和 context 参数</span></span><br><span class="line">    <span class="keyword">if</span> (libName == <span class="keyword">null</span> || libName.isEmpty() || context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"libName or context is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要保证已经调用了 Tinker.install 方法 不然 Tinker 没安装的话会抛出异常</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tinker 支持 so 补丁，就加载外部的 so 文件</span></span><br><span class="line">    <span class="keyword">if</span> (tinker.isEnabledForNativeLib()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TinkerLoadLibrary.loadLibraryFromTinker(context, <span class="string">"lib/armeabi"</span>, libName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 tinker 不支持 so 补丁，就调用系统的加载方法</span></span><br><span class="line">    System.loadLibrary(libName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadLibraryFromTinker"><a href="#loadLibraryFromTinker" class="headerlink" title="loadLibraryFromTinker"></a>loadLibraryFromTinker</h2><p>loadLibraryFromTinker 一开始校验了 libName 的名字是否是 lib 开头、 .so 结尾的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    libName = libName.startsWith(<span class="string">"lib"</span>) ? libName : <span class="string">"lib"</span> + libName;</span><br><span class="line">    libName = libName.endsWith(<span class="string">".so"</span>) ? libName : libName + <span class="string">".so"</span>;</span><br><span class="line">    String relativeLibPath = relativePath + <span class="string">"/"</span> + libName;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后就是用 relativeLibPath 去和之前 so 校验得到的 libs 去一一匹配。</span><br><span class="line"></span><br><span class="line">如果匹配上了，就说明要加载的就是这个 so 文件，调用 System.load ，传入文件路径即可。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="comment">//TODO we should add cpu abi, and the real path later</span></span><br><span class="line"><span class="comment">// tinker 支持 so 补丁并且 tinker 完成加载补丁</span></span><br><span class="line"><span class="keyword">if</span> (tinker.isEnabledForNativeLib() &amp;&amp; tinker.isTinkerLoaded()) &#123;</span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="comment">// 获取上面校验得到的 libs</span></span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : loadResult.libs.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 如果名字对上了，就说明要加载的就是这个外部的so补丁</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(relativeLibPath)) &#123;</span><br><span class="line">                String patchLibraryPath = loadResult.libraryDirectory + <span class="string">"/"</span> + name;</span><br><span class="line">                File library = <span class="keyword">new</span> File(patchLibraryPath);</span><br><span class="line">                <span class="comment">// 确认 so 补丁文件存在</span></span><br><span class="line">                <span class="keyword">if</span> (library.exists()) &#123;</span><br><span class="line">                    <span class="comment">//whether we check md5 when load</span></span><br><span class="line">                    <span class="keyword">boolean</span> verifyMd5 = tinker.isTinkerLoadVerify();</span><br><span class="line">                    <span class="comment">// 如果需要校验md5值但是校验失败了，就回调 onLoadFileMd5Mismatch 方法</span></span><br><span class="line">                    <span class="keyword">if</span> (verifyMd5 &amp;&amp; !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) &#123;</span><br><span class="line">                        tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则就调用 System.load 方法，传入 so 补丁文件的路径即可</span></span><br><span class="line">                        System.load(patchLibraryPath);</span><br><span class="line">                        TinkerLog.i(TAG, <span class="string">"loadLibraryFromTinker success:"</span> + patchLibraryPath);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，Tinker 中关于 so 补丁加载的流程就讲完了。</p>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>大家有没有发现，一个个单独去调用 TinkerLoadLibrary.loadArmLibrary 会很麻烦，因为如果我的 so 补丁文件有很多个，就需要调用很多次。所以从 Tinker v1.7.7 之后，提供了一键反射的方案来加载 so 补丁文件。</p>
<p>具体方法 TinkerLoadLibrary.installNavitveLibraryABI</p>
<h2 id="installNavitveLibraryABI"><a href="#installNavitveLibraryABI" class="headerlink" title="installNavitveLibraryABI"></a>installNavitveLibraryABI</h2><p>来看一下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">installNavitveLibraryABI</span><span class="params">(Context context, String currentABI)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 tinker 有没有安装</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    <span class="keyword">if</span> (!tinker.isTinkerLoaded()) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker is not loaded, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 tinker 加载的结果</span></span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker libs is null, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查当前 ABI 的 so 文件夹是否存在</span></span><br><span class="line">    File soDir = <span class="keyword">new</span> File(loadResult.libraryDirectory, <span class="string">"lib/"</span> + currentABI);</span><br><span class="line">    <span class="keyword">if</span> (!soDir.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"current libraryABI folder is not exist, path: %s"</span>, soDir.getPath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 classloader</span></span><br><span class="line">    ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"before hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    <span class="comment">// 加载当前 ABI 的所有 so 补丁文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        installNativeLibraryPath(classLoader, soDir);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath fail:"</span> + throwable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"after hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在做了一堆的检查之后，具体 so 文件加载是在 installNativeLibraryPath 方法中。</p>
<h2 id="installNativeLibraryPath"><a href="#installNativeLibraryPath" class="headerlink" title="installNativeLibraryPath"></a>installNativeLibraryPath</h2><p>installNativeLibraryPath 中做的事情主要有两点：</p>
<ul>
<li>如果 classloader 中没有注入 so 补丁文件夹的路径的话，就执行注入；</li>
<li>如果 classloader 中已经有 so 补丁文件夹的路径了，就先删除，再进行注入；</li>
</ul>
<p>具体 hook 的代码根据 SDK 版本而定，这里就不展开讲了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installNativeLibraryPath</span><span class="params">(ClassLoader classLoader, File folder)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folder == <span class="keyword">null</span> || !folder.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, folder %s is illegal"</span>, folder);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// android o sdk_int 26</span></span><br><span class="line">    <span class="comment">// for android o preview sdk_int 25</span></span><br><span class="line">    <span class="keyword">if</span> ((Build.VERSION.SDK_INT == <span class="number">25</span> &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != <span class="number">0</span>)</span><br><span class="line">        || Build.VERSION.SDK_INT &gt; <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V25.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v23</span></span><br><span class="line">            <span class="comment">// some preview N version may go here</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23"</span>,</span><br><span class="line">                    Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v14</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14"</span>,</span><br><span class="line">                Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line"></span><br><span class="line">            V14.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        V14.install(classLoader, folder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V4.install(classLoader, folder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，有了 TinkerLoadLibrary.installNavitveLibraryABI 之后，你就只需要传入当前手机系统的 ABI ，就无需再对 so 的加载做任何的介入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" clas]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(四):加载资源补丁流程]]></title>
    <link href="http://yuqirong.me/2019/03/05/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)/"/>
    <id>http://yuqirong.me/2019/03/05/Tinker源码分析(四)/</id>
    <published>2019-03-05T15:54:26.000Z</published>
    <updated>2019-03-09T17:25:07.915Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载资源补丁流程"></a>加载资源补丁流程</h1><p>将到资源补丁的加载，首先还要回过头来先看资源补丁的校验和检查。</p>
<p>我们回到 TinkerLoader.tryLoadPatchFilesInternal 方法中来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的校验是在 TinkerResourceLoader.checkComplete 中完成的。这里为了校验的速度，所以只会校验资源补丁存不存在。</p>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>checkComplete 方法我们分段来看吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 assets/res_meta.txt </span></span><br><span class="line">String meta = securityCheck.getMetaContentMap().get(RESOURCE_META_FILE);</span><br><span class="line"><span class="comment">//not found resource</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//only parse first line for faster</span></span><br><span class="line">ShareResPatchInfo.parseResPatchInfoFirstLine(meta, resPatchInfo);</span><br></pre></td></tr></table></figure>
<p>为了校验的速度，只读取了 assets/res_meta.txt 的第一行，并存入到 resPatchInfo 中</p>
<p>res_meta.txt 的第一行主要是资源的 crc 值和 md5 值 ，在后面会做校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ShareResPatchInfo.checkResPatchInfo(resPatchInfo)) &#123;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验上面读取到的 md5 值是否为空以及 md5 值长度是否是 32 位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String resourcePath = directory + <span class="string">"/"</span> + RESOURCE_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">File resourceDir = <span class="keyword">new</span> File(resourcePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!resourceDir.exists() || !resourceDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件夹是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File resourceFile = <span class="keyword">new</span> File(resourcePath + RESOURCE_FILE);</span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(resourceFile)) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件是否存在及合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TinkerResourcePatcher.isResourceCanPatch(context);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"resource hook check failed."</span>, e);</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>通过 context 来检查当前环境是否支持加载资源补丁。方法里面做的事就是通过反射来获取各种系统的属性和方法。简单地举例以下几种：</p>
<ul>
<li>ActivityThread : 当前的 ActivityThread 实例，app主线程的入口。利用 ActivityThread 可以获取到 LoadedApk 对象；</li>
<li>LoadedApk : 通过 LoadedApk 可以获取 mResDir 属性；</li>
<li>mResDir : 这个值很关键，就是资源文件的路径。在后面会被 hook 成资源补丁的路径；</li>
<li>addAssetPath : 通过 addAssetPath 方法将资源补丁文件加载进新的 AssetManager 中；</li>
<li>mActiveResources : ResourcesManager 的 Resources 容器。里面会存储着每个 apk 对应的 Resources 对象。mActiveResources 是 ArrayMap 类型的，不同的 apk 都有一个不同的 key 来获取对应的 apk 的 Resource 对象；</li>
<li>mAssets : 即 Resources 类中的 mAssets 属性，其实就是一个 AssetManager 对象。在资源打补丁的时候，Resources 中原来的 mAssets 对象会被替换成新的 AssetManager 对象。</li>
</ul>
<p>这里就不详细讲了，总结起来就一句话：获取 Android 系统中与资源有关的一些属性和方法，为接下来的加载资源补丁做准备。如果在 isResourceCanPatch 方法中报出异常了，就认为当前环境不能加载资源补丁了。</p>
<h2 id="tryLoadPatchFilesInternal-1"><a href="#tryLoadPatchFilesInternal-1" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>然后我们再在 tryLoadPatchFilesInternal 中往下看。会看到资源补丁加载代码的入口，即 TinkerResourceLoader.loadTinkerResources 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadTinkerResources"><a href="#loadTinkerResources" class="headerlink" title="loadTinkerResources"></a>loadTinkerResources</h2><p>loadTinkerResources 方法我们分段来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  检查 res_meta.txt 中读取出来的 md5 值，如果 resPatchInfo 或者 md5 是空的，就说明补丁包中没有资源补丁，不需要加载</span></span><br><span class="line"><span class="keyword">if</span> (resPatchInfo == <span class="keyword">null</span> || resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">String resourceString = directory + <span class="string">"/"</span> + RESOURCE_PATH +  <span class="string">"/"</span> + RESOURCE_FILE;</span><br><span class="line">File resourceFile = <span class="keyword">new</span> File(resourceString);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 如果校验设置为 true ，就去校验资源补丁包 resources.apk 的 md5 值</span></span><br><span class="line"><span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Failed to load resource file, path: "</span> + resourceFile.getPath() + <span class="string">", expect md5: "</span> + resPatchInfo.resArscMd5);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify resource file:"</span> + resourceFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是加载资源补丁了，如果加载失败了，会把 dex 补丁卸载了。防止 dex 补丁代码中会引用到资源补丁中的资源文件，导致程序崩溃或报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载资源</span></span><br><span class="line">    TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);</span><br><span class="line">    Log.i(TAG, <span class="string">"monkeyPatchExistingResources resource file:"</span> + resourceString + <span class="string">", use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"install resources failed"</span>);</span><br><span class="line">    <span class="comment">//remove patch dex if resource is installed failed</span></span><br><span class="line">    <span class="comment">// 如果资源补丁加载失败的话，会移除 dex 补丁</span></span><br><span class="line">    <span class="comment">// 因为如果dex补丁代码中有引用到资源的话，会报错</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"uninstallPatchDex failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="monkeyPatchExistingResources"><a href="#monkeyPatchExistingResources" class="headerlink" title="monkeyPatchExistingResources"></a>monkeyPatchExistingResources</h2><p>monkeyPatchExistingResources 方法也一段一段来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查资源补丁apk是否为空</span></span><br><span class="line"><span class="keyword">if</span> (externalResourceFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ApplicationInfo appInfo = context.getApplicationInfo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Field[] packagesFields;</span><br><span class="line"><span class="comment">// 准备之前反射好的 packagesFiled 和 resourcePackagesFiled 字段</span></span><br><span class="line"><span class="comment">// 利用 packagesFiled 和 resourcePackagesFiled 可以获取 LoadedApk 对象</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">27</span>) &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled, resourcePackagesFiled&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 packagesFields ，获取对应的值</span></span><br><span class="line"><span class="keyword">for</span> (Field field : packagesFields) &#123;</span><br><span class="line">    <span class="comment">// 获取 ActivityThread 中 packagesFiled 或 resourcePackagesFiled</span></span><br><span class="line">    <span class="comment">// value 其实为 Map&lt;String, WeakReference&lt;LoadedApk&gt;&gt; 类型</span></span><br><span class="line">    <span class="keyword">final</span> Object value = field.get(currentActivityThread);</span><br><span class="line">    <span class="comment">// 再对 value 进行遍历，获取 LoadedApk 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry</span><br><span class="line">            : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object loadedApk = entry.getValue().get();</span><br><span class="line">        <span class="keyword">if</span> (loadedApk == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 LoadedApk 对象中获取 mResDir 属性，这个属性的意义在上面已经讲过了</span></span><br><span class="line">        <span class="keyword">final</span> String resDirPath = (String) resDir.get(loadedApk);</span><br><span class="line">        <span class="comment">// 将 mResDir 的值 hook 成资源补丁 apk 的路径</span></span><br><span class="line">        <span class="keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;</span><br><span class="line">            resDir.set(loadedApk, externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码基本上都有注释了，接着往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new AssetManager instance and point it to the resources installed under</span></span><br><span class="line"><span class="comment">// 创建一个新的 AssetManager 实例，并把资源补丁apk加载进 AssetManager 中</span></span><br><span class="line"><span class="keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm</span></span><br><span class="line"><span class="comment">// in L, so we do it unconditionally.</span></span><br><span class="line"><span class="comment">// 创建出 AssetManager 后，调用 ensureStringBlocks 来确保资源的字符串索引创建出来</span></span><br><span class="line"><span class="keyword">if</span> (stringBlocksField != <span class="keyword">null</span> &amp;&amp; ensureStringBlocksMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stringBlocksField.set(newAssetManager, <span class="keyword">null</span>);</span><br><span class="line">    ensureStringBlocksMethod.invoke(newAssetManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建出新的 AssetManager 之后，最后要做的事就是用新的 AssetManager 来替换旧的。下面代码中的 references 就是上面提到的 mActiveResources 的 value 集合。也就是每个 apk 的 Resources 资源集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources resources = wr.get();</span><br><span class="line">    <span class="keyword">if</span> (resources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the AssetManager of the Resources instance to our brand new one</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//pre-N</span></span><br><span class="line">        <span class="comment">// Android N 之前的方案</span></span><br><span class="line">        <span class="comment">// 把原来 resources 的 mAssets 属性替换成新的 AssetManager 对象</span></span><br><span class="line">        assetsFiled.set(resources, newAssetManager);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        <span class="comment">// N</span></span><br><span class="line">        <span class="comment">// Android N 之后， mAssets 属性被放在了 ResourcesImpl 中</span></span><br><span class="line">        <span class="comment">// 所以需要先获取 ResourcesImpl 对象再进行替换</span></span><br><span class="line">        <span class="keyword">final</span> Object resourceImpl = resourcesImplFiled.get(resources);</span><br><span class="line">        <span class="comment">// for Huawei HwResourcesImpl</span></span><br><span class="line">        <span class="keyword">final</span> Field implAssets = findField(resourceImpl, <span class="string">"mAssets"</span>);</span><br><span class="line">        implAssets.set(resourceImpl, newAssetManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 Resource 中会维护一个 mTypedArrayPool 资源池</span></span><br><span class="line">    <span class="comment">// 来减少频繁访问 AssetManager ，所以需要去释放这个资源池，否则取到的都是缓存</span></span><br><span class="line">    clearPreloadTypedArrayIssue(resources);</span><br><span class="line">    <span class="comment">// 最后调用 updateConfiguration 方法来确保资源更新了</span></span><br><span class="line">    resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle issues caused by WebView on Android N.</span></span><br><span class="line"><span class="comment">// Issue: On Android N, if an activity contains a webview, when screen rotates</span></span><br><span class="line"><span class="comment">// our resource patch may lost effects.</span></span><br><span class="line"><span class="comment">// for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicSourceDirField != <span class="keyword">null</span>) &#123;</span><br><span class="line">            publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是来确认一下资源补丁是否已经加载成功了。具体的方法就是在资源补丁Apk的 assets 中有一个 Tinker 的测试资源，名字叫 only_use_to_test_tinker_resource.txt ，如果可以正确读取到并且没报错的话，就证明资源补丁加载成功了。否则就抛出异常，会执行 dex 补丁卸载的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkResUpdate(context)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，资源补丁的加载流程就讲完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(三):加载dex补丁流程]]></title>
    <link href="http://yuqirong.me/2019/02/28/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)/"/>
    <id>http://yuqirong.me/2019/02/28/Tinker源码分析(三)/</id>
    <published>2019-02-28T11:23:19.000Z</published>
    <updated>2019-03-09T17:25:13.488Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载dex补丁流程"></a>加载dex补丁流程</h1><h2 id="TinkerDexLoader-loadTinkerJars"><a href="#TinkerDexLoader-loadTinkerJars" class="headerlink" title="TinkerDexLoader.loadTinkerJars"></a>TinkerDexLoader.loadTinkerJars</h2><p>判断一下 dexList 和 classLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadDexList.isEmpty() &amp;&amp; classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"there is no dex to load"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"classloader: "</span> + classLoader.toString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 TinkerLoadVerifyFlag 为 true 的话，会对每个 dex 进行 md5 校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String dexPath = directory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareDexDiffPatchInfo info : loadDexList) &#123;</span><br><span class="line">    <span class="comment">//for dalvik, ignore art support dex</span></span><br><span class="line">    <span class="comment">// 对于 dalvik 虚拟机，忽略 art support dex</span></span><br><span class="line">    <span class="keyword">if</span> (isJustArtSupportDex(info)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String path = dexPath + info.realName;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String checkMd5 = getInfoMd5(info);</span><br><span class="line">        <span class="comment">// 校验dex文件的 md5 值</span></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) &#123;</span><br><span class="line">            <span class="comment">//it is good to delete the mismatch file</span></span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"verify dex file:"</span> + file.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dex文件都通过的话，加入到 legalFiles 集合中 </span></span><br><span class="line">    legalFiles.add(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 art 虚拟机并且是 Android N 及以上的环境，会另外加上 tinker_classN.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// verify merge classN.apk</span></span><br><span class="line"><span class="keyword">if</span> (isVmArt &amp;&amp; !classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    File classNFile = <span class="keyword">new</span> File(dexPath + ShareConstants.CLASS_N_APK_NAME);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ShareDexDiffPatchInfo info : classNDexInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) &#123;</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                    classNFile.getAbsolutePath());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify dex file:"</span> + classNFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">    legalFiles.add(classNFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户是ART虚拟机并且做了OTA升级，那么在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍.这么做的原因是有些场景做了OTA后,oat的规则可能发生变化,在这种情况下去加载上个系统版本oat过的dex就会出现问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">File optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + oatDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span>[] parallelOTAResult = &#123;<span class="keyword">true</span>&#125;;</span><br><span class="line">            <span class="keyword">final</span> Throwable[] parallelOTAThrowable = <span class="keyword">new</span> Throwable[<span class="number">1</span>];</span><br><span class="line">            String targetISA;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetISA = ShareTinkerInternals.getCurrentInstructionSet();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"getCurrentInstructionSet fail:"</span> + throwable);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);</span></span><br><span class="line"><span class="comment">//                &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line">                <span class="comment">// don't ota on the front</span></span><br><span class="line">                deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">            Log.w(TAG, <span class="string">"systemOTA, try parallel oat dexes, targetISA:"</span> + targetISA);</span><br><span class="line">            <span class="comment">// change dir</span></span><br><span class="line">            optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 dex 文件作 odex 处理</span></span><br><span class="line">            TinkerDexOptimizer.optimizeAll(</span><br><span class="line">                legalFiles, optimizeDir, <span class="keyword">true</span>, targetISA,</span><br><span class="line">                <span class="keyword">new</span> TinkerDexOptimizer.ResultCallback() &#123;</span><br><span class="line">                    <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(File dexFile, File optimizedDir)</span> </span>&#123;</span><br><span class="line">                        start = System.currentTimeMillis();</span><br><span class="line">                        Log.i(TAG, <span class="string">"start to optimize dex:"</span> + dexFile.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File dexFile, File optimizedDir, File optimizedFile)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// Do nothing.</span></span><br><span class="line">                        Log.i(TAG, <span class="string">"success to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(File dexFile, File optimizedDir, Throwable thr)</span> </span>&#123;</span><br><span class="line">                        parallelOTAResult[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">                        parallelOTAThrowable[<span class="number">0</span>] = thr;</span><br><span class="line">                        Log.i(TAG, <span class="string">"fail to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!parallelOTAResult[<span class="number">0</span>]) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"parallel oat dexes failed"</span>);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable[<span class="number">0</span>]);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u52A0_u8F7Ddex"><a href="#u52A0_u8F7Ddex" class="headerlink" title="加载dex"></a>加载dex</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"install dexes failed"</span>);</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">       intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">       ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SystemClassLoaderAdder-installDexes"><a href="#SystemClassLoaderAdder-installDexes" class="headerlink" title="SystemClassLoaderAdder.installDexes"></a>SystemClassLoaderAdder.installDexes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"installDexes dexOptDir: "</span> + dexOptDir.getAbsolutePath() + <span class="string">", dex size:"</span> + files.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        files = createSortedAdditionalPathEntries(files);</span><br><span class="line">        ClassLoader classLoader = loader;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">            classLoader = AndroidNClassLoader.inject(loader, application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//because in dalvik, if inner class is not the same classloader with it wrapper class.</span></span><br><span class="line">        <span class="comment">//it won't fail at dex2opt</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            V23.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//install done</span></span><br><span class="line">        sPatchDexCount = files.size();</span><br><span class="line">        Log.i(TAG, <span class="string">"after loaded classloader: "</span> + classLoader + <span class="string">", dex size:"</span> + sPatchDexCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">            <span class="comment">//reset patch dex</span></span><br><span class="line">            SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在加载 dex 的时候，分别分成了四个版本：</p>
<ul>
<li>v4</li>
<li>v14</li>
<li>v19</li>
<li>v23</li>
</ul>
<p>其中如果是 SDK 24 及以上，需要改造一下 classloder</p>
<p>针对每个版本不同的源码，进行 dex 插入</p>
<p>我们就来看其中一个版本 v19</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                File optimizedDirectory)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">            suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A wrapper around</span><br><span class="line">     * &#123;<span class="doctag">@code</span> private static final dalvik.system.DexPathList#makeDexElements&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Method makeDexElements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class,</span><br><span class="line">                ArrayList.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure"</span>);</span><br><span class="line">            <span class="comment">// 对不同的 rom 做兼容，有的 rom 的 makeDexElements 方法参数类型是 List</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, List.class, File.class, List.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(List,File,List) failure"</span>);</span><br><span class="line">                <span class="keyword">throw</span> e1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先反射拿到反射得到 PathClassLoader 中的 pathList 对象,再将补丁文件通过反射调用makeDexElements 得到补丁文件的 Element[] ,再将补丁包的 Element[] 数组插入到 dexElements 中</p>
<p>另外，需要对 Android 7.0 及以上单独处理一下，具体看 <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a></p>
<p>加载补丁操作做好之后，最后还要检查一下，如果没加载成功就会执行卸载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">    <span class="comment">//reset patch dex</span></span><br><span class="line">    SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体验证补丁是否加载成功的方法就是判断 TinkerTestDexLoad.isPatch 的值。</p>
<p>在没有补丁加载的情况下都是返回 false 的, 在补丁中修改 isPatch 属性为 true 。所以只要反射拿到isPatch 的属性为 true 就说明补丁已经成功加载进来了。否则就调用 SystemClassLoaderAdder.uninstallPatchDex 执行卸载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninstallPatchDex</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPatchDexCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(classLoader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(classLoader);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(dexPathList, <span class="string">"dexElements"</span>, sPatchDexCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mPaths"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mFiles"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mZips"</span>, sPatchDexCount);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mDexs"</span>, sPatchDexCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卸载补丁可以说是加载补丁的逆向操作，具体操作可以分成 v4 和 v14 两个版本</p>
<p>具体的内容就是把 dexElements 中的头部 element 去除了。</p>
<p>到这，dex 补丁加载的流程结束了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" cl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(二):加载补丁流程]]></title>
    <link href="http://yuqirong.me/2019/02/27/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2019/02/27/Tinker源码分析(二)/</id>
    <published>2019-02-27T13:43:16.000Z</published>
    <updated>2019-03-14T15:54:09.840Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink" title="tryLoad"></a>tryLoad</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app)</span> </span>&#123;</span><br><span class="line">    Intent resultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">    <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</span><br><span class="line">    <span class="keyword">return</span> resultIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载的流程主要在 tryLoadPatchFilesInternal 里面。tryLoadPatchFilesInternal 方法很长，我们需要分段来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>一开始是各种校验</p>
<p>检查 tinker 是否开启</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tinkerFlag = app.getTinkerFlags();</span><br><span class="line"><span class="comment">// 检查 tinker 是否开启</span></span><br><span class="line"><span class="keyword">if</span> (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: tinker is disable, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前的进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前的进程，确保不是 :patch 进程</span></span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isInPatchProcess(app)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: we don't load patch with :patch process itself, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 tinker 目录，检查目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tinker 获取 tinker 目录，/data/data/tinker.sample.android/tinker</span></span><br><span class="line">File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</span><br><span class="line"><span class="keyword">if</span> (patchDirectoryFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:getPatchDirectory == null"</span>);</span><br><span class="line">    <span class="comment">//treat as not exist</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();</span><br><span class="line"><span class="comment">// 检查 tinker 目录是否存在</span></span><br><span class="line"><span class="comment">//check patch directory whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch dir not exist:"</span> + patchDirectoryPath);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 patch.info 文件是否存在, patch.info 是补丁信息文件，里面记录着新旧两个补丁版本的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件目录 /data/data/tinker.sample.android/tinker/patch.info</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch.info 补丁信息文件是否存在</span></span><br><span class="line"><span class="comment">//check patch info file whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchInfoFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch info not exist:"</span> + patchInfoFile.getAbsolutePath());</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取 patch.info 文件，并包装成一个 SharePatchInfo ，并检查 patchInfo 是否为空 (先加锁 file lock 再解锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//old = 641e634c5b8f1649c75caf73794acbdf</span></span><br><span class="line"><span class="comment">//new = 2c150d8560334966952678930ba67fa8</span></span><br><span class="line"><span class="comment">// tinker/info.lock</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch info 文件中的补丁版本信息</span></span><br><span class="line">patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"><span class="keyword">if</span> (patchInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查读取出来的 patchInfo 补丁版本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String oldVersion = patchInfo.oldVersion;</span><br><span class="line">String newVersion = patchInfo.newVersion;</span><br><span class="line">String oatDex = patchInfo.oatDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldVersion == <span class="keyword">null</span> || newVersion == <span class="keyword">null</span> || oatDex == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//it is nice to clean patch</span></span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchInfoCorrupted"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发现 patchInfo 中的 isRemoveNewVersion 为 true 并且在主进程中运行的话，就代表需要清除补丁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> mainProcess = ShareTinkerInternals.isInMainProcess(app);</span><br><span class="line"><span class="keyword">boolean</span> isRemoveNewVersion = patchInfo.isRemoveNewVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// So far new version is not loaded in main process and other processes.</span></span><br><span class="line"><span class="comment">// We can remove new version directory safely.</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; isRemoveNewVersion) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"found clean patch mark and we are in main process, delete patch file now."</span>);</span><br><span class="line">    <span class="comment">// 获取新的补丁文件夹，例如 patch-2c150d85</span></span><br><span class="line">    String patchName = SharePatchFileUtil.getPatchVersionDirectory(newVersion);</span><br><span class="line">    <span class="keyword">if</span> (patchName != <span class="keyword">null</span>) &#123;</span><br><span class="line">	     <span class="comment">// 删除新的补丁文件夹   </span></span><br><span class="line">        String patchVersionDirFullPath = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);</span><br><span class="line">        <span class="comment">// 如果旧版本和新版本一致，就把 oldVersion 和 newVersion 设置为空来清除补丁</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion.equals(newVersion)) &#123;</span><br><span class="line">            <span class="comment">// !oldVersion.equals(newVersion) means new patch is applied, just fall back to old one in that case.</span></span><br><span class="line">            <span class="comment">// Or we will set oldVersion and newVersion to empty string to clean patch.</span></span><br><span class="line">            oldVersion = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 !oldVersion.equals(newVersion) 意味着新补丁已经应用了，需要回退到原来的旧版本</span></span><br><span class="line">        newVersion = oldVersion;</span><br><span class="line">        patchInfo.oldVersion = oldVersion;</span><br><span class="line">        patchInfo.newVersion = newVersion;</span><br><span class="line">        <span class="comment">// 把数据重新写入 patchInfo 文件中</span></span><br><span class="line">        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);</span><br><span class="line">        <span class="comment">// 杀掉主进程以外的所有进程</span></span><br><span class="line">        ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</span><br></pre></td></tr></table></figure>
<p>根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> versionChanged = !(oldVersion.equals(newVersion));</span><br><span class="line"><span class="keyword">boolean</span> oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);</span><br><span class="line">oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);</span><br><span class="line"></span><br><span class="line">String version = oldVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</span></span><br><span class="line"><span class="keyword">if</span> (versionChanged &amp;&amp; mainProcess) &#123;</span><br><span class="line">    version = newVersion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isNullOrNil(version)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:version is blank, wait main process to restart"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前新版本补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//patch-641e634c</span></span><br><span class="line">String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</span><br><span class="line"><span class="keyword">if</span> (patchName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patchName is null"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c</span></span><br><span class="line">String patchVersionDirectory = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">File patchVersionDirectoryFile = <span class="keyword">new</span> File(patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!patchVersionDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionDirectoryNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件是否存在并且可读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</span></span><br><span class="line"><span class="keyword">final</span> String patchVersionFileRelPath = SharePatchFileUtil.getPatchVersionFile(version);</span><br><span class="line">File patchVersionFile = (patchVersionFileRelPath != <span class="keyword">null</span> ? <span class="keyword">new</span> File(patchVersionDirectoryFile.getAbsolutePath(), patchVersionFileRelPath) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionFileNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件签名以及补丁文件中的 tinker id 和基准包的 tinker id 是否一致。</p>
<p>注意，这里补丁文件的 tinker id 是当前补丁基准包的 tinker id ，也就是有 bug 的基准包 tinker id 。另外一个 new tinker id 是补丁加载完成后的 tinker id ，就是 bug 修复后的 tinker id 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ShareSecurityCheck securityCheck = <span class="keyword">new</span> ShareSecurityCheck(app);</span><br><span class="line"><span class="comment">// 1. 检查补丁包 apk 的签名</span></span><br><span class="line"><span class="comment">// 2. 检查基准包的 tinker id 与补丁包中是否一致</span></span><br><span class="line"><span class="comment">// 3. 检查 tinker 设置与补丁包中的类型是否符合</span></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkTinkerPackage"</span>);</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</span><br></pre></td></tr></table></figure>
<p>下面是 checkTinkerPackage 方法的具体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkTinkerPackage</span><span class="params">(Context context, <span class="keyword">int</span> tinkerFlag, File patchFile, ShareSecurityCheck securityCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查补丁文件签名和 tinker id 是否一致</span></span><br><span class="line">    <span class="comment">// 这里为了快速校验,就只检验补丁包内部以meta.txt结尾的文件的签名，而其他的文件的合法性则通过meta.txt文件内部记录的补丁文件Md5值来校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);</span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">        <span class="comment">// 检查配置的 tinker flag 和 meta.txt 是否匹配</span></span><br><span class="line">        <span class="comment">// 如果不匹配的话，中断接下来的流程</span></span><br><span class="line">        returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的情况,最多有四个文件是以meta.txt结尾的:</p>
<ul>
<li>package_meta.txt 补丁包的基本信息</li>
<li>dex_meta.txt dex补丁的信息</li>
<li>so_meta.txt so补丁的信息</li>
<li>res_meta.txt 资源补丁的信息</li>
</ul>
<p>如果开启了支持 dex 热修复，检查 dex_meta.txt 文件中记录的dex文件信息对应的dex文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/dex</span></span><br><span class="line">    <span class="comment">// 检查下发的meta文件中记录的dex信息中对应的dex文件是否存在</span></span><br><span class="line">    <span class="keyword">boolean</span> dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!dexCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:dex check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 so 热修复，检查 so_meta.txt 文件中记录的so文件信息对应的so文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 res 热修复，检查 res_meta.txt 文件中记录的res文件信息对应的res文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合条件的话就更新版本信息,并将最新的patch info更新入文件.在v1.7.5的版本开始有了isSystemOTA判断,</p>
<p>只要用户是ART环境并且做了OTA升级，则在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍重新生成odex，再加载dex补丁。否则会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//only work for art platform oat，because of interpret, refuse 4.4 art oat</span></span><br><span class="line"><span class="comment">//android o use quicken default, we don't need to use interpret mode</span></span><br><span class="line"><span class="keyword">boolean</span> isSystemOTA = ShareTinkerInternals.isVmArt()</span><br><span class="line">    &amp;&amp; ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)</span><br><span class="line">    &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">21</span> &amp;&amp; !ShareTinkerInternals.isAfterAndroidO();</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//we should first try rewrite patch info file, if there is a error, we can't load jar</span></span><br><span class="line"><span class="comment">// 把patch.info的旧版本的值更新为新版本的值，写入 patch.info 中</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; (versionChanged || oatModeChanged)) &#123;</span><br><span class="line">    patchInfo.oldVersion = version;</span><br><span class="line">    patchInfo.oatDir = oatDex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update old version to new</span></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"tryLoadPatchFiles:success to rewrite patch info, kill other process."</span>);</span><br><span class="line">    ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oatModeChanged) &#123;</span><br><span class="line">        <span class="comment">// delete interpret odex</span></span><br><span class="line">        <span class="comment">// for android o, directory change. Fortunately, we don't need to support android o interpret mode any more</span></span><br><span class="line">        Log.i(TAG, <span class="string">"tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files"</span>);</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirectory + <span class="string">"/"</span> + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁的安全次数最多三次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkSafeModeCount(app)) &#123;</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"checkSafeModeCount fail"</span>));</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkSafeModeCount fail"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁 jar ，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch jar</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</span><br><span class="line">    <span class="comment">// 如果是 ota 的话，更新 oat 的文件夹路径</span></span><br><span class="line">    <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">        <span class="comment">// update fingerprint after load success</span></span><br><span class="line">        patchInfo.fingerPrint = Build.FINGERPRINT;</span><br><span class="line">        patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;</span><br><span class="line">        <span class="comment">// reset to false</span></span><br><span class="line">        oatModeChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">            Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update oat dir</span></span><br><span class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerJars) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadDexesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁资源，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补丁加载流程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init component hotplug support.</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex &amp;&amp; isEnabledForResource) &#123;</span><br><span class="line">    ComponentHotplug.install(app, securityCheck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//all is ok!</span></span><br><span class="line">ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</span><br><span class="line">Log.i(TAG, <span class="string">"tryLoadPatchFiles: load end, ok!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink"]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(一):TinkerApplication]]></title>
    <link href="http://yuqirong.me/2019/02/24/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yuqirong.me/2019/02/24/Tinker源码分析(一)/</id>
    <published>2019-02-24T14:52:16.000Z</published>
    <updated>2019-03-09T17:25:02.046Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication" class="headerlink" title="自动生成TinkerApplication"></a>自动生成TinkerApplication</h1><p>接入 Tinker 第一步就是改造 Application 。官方推荐是利用 @DefaultLifeCycle 动态生成 Application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@DefaultLifeCycle</span>(application = <span class="string">"tinker.sample.android.app.SampleApplication"</span>,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们来解析一下 Tinker 是如何生成 Application 以及在 Application 中做了什么事？</p>
<p>看到 @DefaultLifeCycle 注解，我们可想而知应该是经过 processor 处理后动态生成了 Application 。</p>
<p>查看 Tinker 工程可以发现在 tinker-android-anno 下面有一个 AnnotationProcessor </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; supportedAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    supportedAnnotationTypes.add(DefaultLifeCycle.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> supportedAnnotationTypes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    processDefaultLifeCycle(roundEnv.getElementsAnnotatedWith(DefaultLifeCycle.class));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它正是处理 @DefaultLifeCycle 的。</p>
<p>下面重要看 processDefaultLifeCycle 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDefaultLifeCycle</span><span class="params">(Set&lt;? extends Element&gt; elements)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DefaultLifeCycle</span></span><br><span class="line">    <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">        DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);</span><br><span class="line"></span><br><span class="line">        String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();</span><br><span class="line">        String lifeCyclePackageName = lifeCycleClassName.substring(<span class="number">0</span>, lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String applicationClassName = ca.application();</span><br><span class="line">        <span class="keyword">if</span> (applicationClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            applicationClassName = lifeCyclePackageName + applicationClassName;</span><br><span class="line">        &#125;</span><br><span class="line">        String applicationPackageName = applicationClassName.substring(<span class="number">0</span>, applicationClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String loaderClassName = ca.loaderClass();</span><br><span class="line">        <span class="keyword">if</span> (loaderClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            loaderClassName = lifeCyclePackageName + loaderClassName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(is);</span><br><span class="line">        <span class="keyword">final</span> String template = scanner.useDelimiter(<span class="string">"\\A"</span>).next();</span><br><span class="line">        <span class="keyword">final</span> String fileContent = template</span><br><span class="line">            .replaceAll(<span class="string">"%PACKAGE%"</span>, applicationPackageName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION%"</span>, applicationClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION_LIFE_CYCLE%"</span>, lifeCyclePackageName + <span class="string">"."</span> + lifeCycleClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_FLAGS%"</span>, <span class="string">""</span> + ca.flags())</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOADER_CLASS%"</span>, <span class="string">""</span> + loaderClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOAD_VERIFY_FLAG%"</span>, <span class="string">""</span> + ca.loadVerifyFlag());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + <span class="string">"."</span> + applicationClassName);</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">"Creating "</span> + fileObject.toUri());</span><br><span class="line">            Writer writer = fileObject.openWriter();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(writer);</span><br><span class="line">                pw.print(fileContent);</span><br><span class="line">                pw.flush();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 processDefaultLifeCycle 方法看下来，其实主要在做的就是去读取一份模版，然后用注解中设置的值替换里面的一些占位符。这个模版就是 resouces/TinkerAnnoApplication.tmpl </p>
<pre><code>package %PACKAGE%;

import com.tencent.tinker.loader.app.TinkerApplication;

/**
 *
 * Generated application for tinker life cycle
 *
 */
public class %APPLICATION% extends TinkerApplication {

    public %APPLICATION%() {
        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%);
    }

}
</code></pre><p>最终生成的 SampleApplication 效果：</p>
<pre><code>/**
 *
 * Generated application for tinker life cycle
 *
 */
public class SampleApplication extends TinkerApplication {

    public SampleApplication() {
        super(7, &quot;tinker.sample.android.app.SampleApplicationLike&quot;, &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);
    }

}
</code></pre><h1 id="u89E3_u6790_TinkerApplication"><a href="#u89E3_u6790_TinkerApplication" class="headerlink" title="解析 TinkerApplication"></a>解析 TinkerApplication</h1><p>想要知道 TinkerApplication 里面干了什么？</p>
<p>一起看看 TinkerApplication.onCreate </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComponentHotplug.ensureComponentHotplugInstalled(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEnvironmentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"failed to make sure that ComponentHotplug logic is fine."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        invokeAppLikeOnCreate(applicationLike);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步，调用 ensureDelegate 创建 application 代理，即 applicationLike</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationLike == <span class="keyword">null</span>) &#123;</span><br><span class="line">        applicationLike = createDelegate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Use reflection to create the delegate so it doesn't need to go into the primary dex.</span></span><br><span class="line">        <span class="comment">// And we can also patch it</span></span><br><span class="line">        Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class,</span><br><span class="line">            <span class="keyword">long</span>.class, <span class="keyword">long</span>.class, Intent.class);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(<span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag,</span><br><span class="line">            applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"createDelegate failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用 invokeAppLikeOnCreate(applicationLike) 去回调 applicationLike 的 onCreate 方法。这样，applicationLike 和 application 的生命周期方法就做到同步了。另外，其余的生命周期方法也是如此来实现同步的，这里就不详细讲解了。</p>
<p>那么 Tinker 是什么时候加载的呢？</p>
<p>答案就在 attachBaseContext 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> TinkerUncaughtHandler(<span class="keyword">this</span>));</span><br><span class="line">    onBaseContextAttached(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class="line">        applicationStartMillisTime = System.currentTimeMillis();</span><br><span class="line">        loadTinker();</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        invokeAppLikeOnBaseContextAttached(applicationLike, base);</span><br><span class="line">        <span class="comment">//reset save mode</span></span><br><span class="line">        <span class="keyword">if</span> (useSafeMode) &#123;</span><br><span class="line">            ShareTinkerInternals.setSafeModeCount(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了 loadTinker 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></span><br><span class="line">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</span><br><span class="line">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">//has exception, put exception error code</span></span><br><span class="line">        tinkerResultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</span><br><span class="line">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 loaderClassName 就是上面 @DefaultLifeCycle 中定义的 loaderClass 。默认的是 com.tencent.tinker.loader.TinkerLoader ，也支持用户自定义 TinkerLoader 。</p>
<p>所以 loadTinker 中干的事就是利用反射执行了 TinkerLoader.tryLoad 方法。</p>
<p>至于在 tryLoad 方法中到底做了什么事，我们等到下一篇再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用AOP对点击事件作防抖处理]]></title>
    <link href="http://yuqirong.me/2019/02/23/%E5%88%A9%E7%94%A8AOP%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%BD%9C%E9%98%B2%E6%8A%96%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2019/02/23/利用AOP对点击事件作防抖处理/</id>
    <published>2019-02-23T14:11:21.000Z</published>
    <updated>2019-02-23T15:21:40.273Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>最近项目中有一个需求，需要对重复的点击事件作过滤处理。</p>
<p>可能第一个想到的方法是在 OnClickListener.onClick 中根据时间间隔来判断，这也是比较传统的方案。但是缺点同样也很明显，就是对现有代码的侵入性太强了。因为点击事件回调的代码我们早已写好了，现在再去改动会很痛苦，并且改动的范围也很广。</p>
<p>那么有没有一种方法是不需要改动源代码，就可以实现对点击事件去重的呢？当然有，我们可以利用 AOP 来实现一套方案。接下来就来讲讲这套方案就具体实现。</p>
<h1 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h1><p>在写代码之前，需要先设置 AOP 的配置，AOP 一般采用的是 AspectJ 。而在 Android 中一般直接使用 <a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">hugo</a> 或者 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="external">gradle_plugin_android_aspectjx</a> 插件，这样就省去了配置 AspectJ 的麻烦。在这里我使用的就是 gradle_plugin_android_aspectjx 插件，gradle_plugin_android_aspectjx 具体的配置就不详细展开了，可以自行去了解。</p>
<p>配置好之后，我们设计一下具体的方案，如果有不需要点击过滤的，我们就配置一个 @Except 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Except &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们就来写一下 AOP 处理的代码。首先我们来创建一个 SingleClickAspect 类，在这里面写 AOP 的代码（添加 @Aspect 注解来表明这是一个切面，需要 AspectJ 处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleClickAspect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来定义一下 AOP 的连接点（Join Point）。因为我们是打算在 onClick 中处理事件去重的，所以连接点显而易见是 method execution 。</p>
<p>接着是切点（Pointcuts）。最基本的切点就是 View.OnClickListener.onClick 方法了。所以可以得出第一个切点表达式：</p>
<pre><code>execution(* android.view.View.OnClickListener.onClick(..))
</code></pre><p>另外，如果是在布局 xml 中直接使用 android:onclick=”xxx” 指定点击事件的话，我们也需要进行防重处理。如果有看过这一块源码的同学可能会知道，其实 android:onclick=”xxx” 最后调用的是 DeclaredOnClickListener 这个类来完成点击方法包装的。</p>
<p>所以我们的切点就是 DeclaredOnClickListener.onClick 方法了。可以得出第二个切点表达式：</p>
<pre><code>execution(* android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener.onClick(..))
</code></pre><p>最后，还有不少同学会使用 ButterKnife 来完成 view 的初始化操作，所以对 ButterKnife 也要囊括进来。（其实 ButterKnife 内部已经对点击事件进行去重了，具体可以看下 DebouncingOnClickListener，但是我们这里还是写一下吧）</p>
<pre><code>execution(@butterknife.OnClick * *(..))
</code></pre><p>没错，ButterKnife 的切点表达式很简单，就是对 @OnClick 注解的地方处理一下即可。</p>
<p>定义完切点表达式后，我们就要来写点击事件去重的代码了。这里根据需求我们可以得出通知（Advice<br>）使用 @Around 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal onClick</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_POINTCUTS = <span class="string">"execution(* android.view.View.OnClickListener.onClick(..))"</span>;</span><br><span class="line"><span class="comment">// 如果 onClick 是写在 xml 里面的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_IN_XML_POINTCUTS = <span class="string">"execution(* android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener.onClick(..))"</span>;</span><br><span class="line"><span class="comment">// butterknife on click</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_IN_BUTTER_KNIFE_POINTCUTS = <span class="string">"execution(@butterknife.OnClick * *(..))"</span>;</span><br><span class="line"><span class="comment">// view tag unique key, must be one of resource id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SINGLE_CLICK_KEY = R.string.me_yuqirong_singleclick_tag_key;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickPointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_IN_XML_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickInXmlPointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_IN_BUTTER_KNIFE_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickInButterKnifePointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Around</span>(<span class="string">"onClickPointcuts() || onClickInXmlPointcuts() || onClickInButterKnifePointcuts()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throttleClick</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check for Except annotation</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="keyword">if</span> (signature <span class="keyword">instanceof</span> MethodSignature) &#123;</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">            Method method = methodSignature.getMethod();</span><br><span class="line">            <span class="comment">// 如果有 Except 注解，就不需要做点击防抖处理</span></span><br><span class="line">            <span class="keyword">boolean</span> isExcept = method != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(Except.class);</span><br><span class="line">            <span class="keyword">if</span> (isExcept) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"the click method is except, so proceed it"</span>);</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        View view = getViewFromArgs(args);</span><br><span class="line">        <span class="comment">// unknown click type, so skip it</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"unknown type method, so proceed it"</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long lastClickTime = (Long) view.getTag(SINGLE_CLICK_KEY);</span><br><span class="line">        <span class="comment">// if lastClickTime is null, means click first time</span></span><br><span class="line">        <span class="keyword">if</span> (lastClickTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"the click event is first time, so proceed it"</span>);</span><br><span class="line">            view.setTag(SINGLE_CLICK_KEY, SystemClock.elapsedRealtime());</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canClick(lastClickTime)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"the click event time interval is legal, so proceed it"</span>);</span><br><span class="line">            view.setTag(SINGLE_CLICK_KEY, SystemClock.elapsedRealtime());</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"throttle the click event, view id = "</span> + view.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取 view 参数</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getViewFromArgs</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Object arg = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">            <span class="keyword">return</span> (View) arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断是否达到可以点击的时间间隔，这里间隔就设置为500L</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> lastClickTime</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canClick</span><span class="params">(<span class="keyword">long</span> lastClickTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemClock.elapsedRealtime() - lastClickTime</span><br><span class="line">            &gt;= <span class="number">500L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑很简单，先判断一下是否有 @Except 注解，如果有的话就直接通过了。</p>
<p>然后得到 onClick 方法的参数 view 。判断 view.getTag 有没有值。如果没有值，就说明是第一次点击，那么放行通过。否则就判断是否两次点击时间间隔有没有大于规定的时间间隔，从而实现点击事件的去重。</p>
<p>到这里，基本就完事了，整下来代码其实也就没多少量。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>以后在做其他需求的时候，也可以思考一下是否使用 AOP 可以达成目标，可能代码量会更少，侵入性也会更低。</p>
<p>另外 AOP 的使用范围还是比较广泛的，比如打印日志、埋点统计等。如果看完这篇博客有想法的同学，可以自己去试试！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>最近项目中有一个需求，需要对重复的点击事件作过滤处理。</p>
<p>可能第一个想到的方法是在 OnClic]]>
    </summary>
    
      <category term="AOP" scheme="http://yuqirong.me/tags/AOP/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用OpenCV对图片进行二值化和去燥处理]]></title>
    <link href="http://yuqirong.me/2019/01/13/%E4%BD%BF%E7%94%A8OpenCV%E5%AF%B9%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%80%BC%E5%8C%96%E5%92%8C%E5%8E%BB%E7%87%A5%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2019/01/13/使用OpenCV对图片进行二值化和去燥处理/</id>
    <published>2019-01-13T08:33:00.000Z</published>
    <updated>2019-01-18T14:10:55.063Z</updated>
    <content type="html"><![CDATA[<p>最近做的项目中有使用到 OpenCV ，并且利用了 OpenCV 对图片做一些简单的处理。所以今天打算记录一下一些常用的 OpenCV 操作。</p>
<p>以下的 OpenCV 代码都是基于 OpenCV v3.3.0 aar 版本</p>
<h1 id="u4E8C_u503C_u5316"><a href="#u4E8C_u503C_u5316" class="headerlink" title="二值化"></a>二值化</h1><p>所谓的二值化，就是将图片上的像素点的灰度值设置为0或255，也就是将整个图片呈现出明显的只有黑和白的视觉效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">binarization</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建一张新的bitmap</span></span><br><span class="line">   Bitmap result = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">   Mat origin = <span class="keyword">new</span> Mat();</span><br><span class="line">   Mat gray = <span class="keyword">new</span> Mat();</span><br><span class="line">   Mat out = <span class="keyword">new</span> Mat();</span><br><span class="line">   Utils.bitmapToMat(bitmap, origin);</span><br><span class="line">   Imgproc.cvtColor(origin, gray, Imgproc.COLOR_RGB2GRAY);</span><br><span class="line">   <span class="comment">// 二值化处理</span></span><br><span class="line">   Imgproc.adaptiveThreshold(gray, out, <span class="number">255.0</span>D, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, <span class="number">25</span>, <span class="number">10.0</span>D);</span><br><span class="line">   Utils.matToBitmap(out, result);</span><br><span class="line">   origin.release();</span><br><span class="line">   gray.release();</span><br><span class="line">   out.release();</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u53BB_u71E5"><a href="#u53BB_u71E5" class="headerlink" title="去燥"></a>去燥</h1><p>如果发现二值化后燥点比较多，这时候就需要使用去燥处理了。其中参数 d 为去燥的强度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">denoising</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    Bitmap result = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.RGB_565);</span><br><span class="line">    Mat origin = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat gray = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat bf = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat out = <span class="keyword">new</span> Mat();</span><br><span class="line">    Utils.bitmapToMat(bitmap, origin);</span><br><span class="line">    Imgproc.cvtColor(origin, gray, Imgproc.COLOR_RGB2GRAY);</span><br><span class="line">    <span class="comment">// 去燥</span></span><br><span class="line">    Imgproc.bilateralFilter(gray, bf, d, (<span class="keyword">double</span>) (d * <span class="number">2</span>), (<span class="keyword">double</span>) (d / <span class="number">2</span>));</span><br><span class="line">    Imgproc.adaptiveThreshold(bf, out, <span class="number">255.0</span>D, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, <span class="number">25</span>, <span class="number">10.0</span>D);</span><br><span class="line">    Utils.matToBitmap(out, result);</span><br><span class="line">    origin.release();</span><br><span class="line">    gray.release();</span><br><span class="line">    bf.release();</span><br><span class="line">    out.release();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看一下最终的效果吧</p>
<p>原图：</p>
<p><img src="/uploads/20190113/20190118220513.png" alt="source"></p>
<p>二值化：</p>
<p><img src="/uploads/20190113/20190118220610.png" alt="binarization"></p>
<p>去燥：</p>
<p><img src="/uploads/20190113/20190118220630.png" alt="denoising"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近做的项目中有使用到 OpenCV ，并且利用了 OpenCV 对图片做一些简单的处理。所以今天打算记录一下一些常用的 OpenCV 操作。</p>
<p>以下的 OpenCV 代码都是基于 OpenCV v3.3.0 aar 版本</p>
<h1 id="u4E8C_u]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="OpenCV" scheme="http://yuqirong.me/tags/OpenCV/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（五）]]></title>
    <link href="http://yuqirong.me/2019/01/10/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/10/ARouter源码解析（五）/</id>
    <published>2019-01-10T13:42:23.000Z</published>
    <updated>2019-03-04T16:28:45.240Z</updated>
    <content type="html"><![CDATA[<p>arouter-gradle-plugin version : 1.0.2</p>
<p>AutoRegister : <a href="https://github.com/luckybilly/AutoRegister" target="_blank" rel="external">https://github.com/luckybilly/AutoRegister</a></p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在本系列的第一篇中讲过，ARouter 可以通过扫描 dex 文件中 class 的全类名，来加载 compiler 生成的路由类。但这种方式影响性能，并且效率也不高。所以在 ARouter v1.3.0 之后的版本中，加入了自动注册的方式进行路由表的加载，自动注册可以缩短初始化时间，解决应用加固导致无法直接访问 dex 文件从而初始化失败的问题。</p>
<p>那么自动注册到底是什么东东，为什么有这么强大的能力呢？</p>
<p>那么接下来，我们就来分析分析。</p>
<p>预先需要了解的知识点：</p>
<ul>
<li>自定义 gradle plugin</li>
<li>gradle transform api</li>
<li>使用 asm 实现字节码插桩</li>
</ul>
<h1 id="arouter-register"><a href="#arouter-register" class="headerlink" title="arouter-register"></a>arouter-register</h1><p>arouter-register 的入口就在 PluginLaunch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginLaunch</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class="line">        <span class="comment">//only application module needs this plugin to generate register code</span></span><br><span class="line">        <span class="keyword">if</span> (isApp) &#123;</span><br><span class="line">            Logger.make(project)</span><br><span class="line"></span><br><span class="line">            Logger.i(<span class="string">'Project enable arouter-register plugin'</span>)</span><br><span class="line"></span><br><span class="line">            def android = project.extensions.getByType(AppExtension)</span><br><span class="line">            def transformImpl = <span class="keyword">new</span> RegisterTransform(project)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//init arouter-auto-register settings</span></span><br><span class="line">            ArrayList&lt;ScanSetting&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>)</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IRouteRoot'</span>))</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IInterceptorGroup'</span>))</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IProviderGroup'</span>))</span><br><span class="line">            RegisterTransform.registerList = list</span><br><span class="line">            <span class="comment">//register this plugin</span></span><br><span class="line">            android.registerTransform(transformImpl)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知：</p>
<ul>
<li>只在 application module （一般都是 app module）生成自动注册的代码；</li>
<li>初始化了自动注册的设置，这样自动注册就知道需要注册 IRouteRoot IInterceptorGroup IProviderGroup 这三者；</li>
<li>注册 RegisterTransform ，字节码插桩将在 RegisterTransform 中完成；</li>
</ul>
<p>可以看出，重点就在 RegisterTransform 里面。那我们重点就关注下 RegisterTransform 的代码，这里就贴出 transform 方法的源码了。（关于 Transform 的 InputTypes 和 Scopes 知识点在这就不讲了，如有需要了解的同学可以看 <a href="https://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs</span><br><span class="line">	               , Collection&lt;TransformInput&gt; referencedInputs</span><br><span class="line">	               , TransformOutputProvider outputProvider</span><br><span class="line">	               , <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">'Start scan register info in jar file.'</span>)</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis()</span><br><span class="line">	    <span class="keyword">boolean</span> leftSlash = File.separator == <span class="string">'/'</span></span><br><span class="line">	</span><br><span class="line">	    inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">	</span><br><span class="line">	        <span class="comment">// 扫描所有的 jar 文件</span></span><br><span class="line">	        input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">	            String destName = jarInput.name</span><br><span class="line">	            <span class="comment">// rename jar files</span></span><br><span class="line">	            def hexName = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class="line">	            <span class="keyword">if</span> (destName.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">	                destName = destName.substring(<span class="number">0</span>, destName.length() - <span class="number">4</span>)</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="comment">// 输入的 jar 文件</span></span><br><span class="line">	            File src = jarInput.file</span><br><span class="line">	            <span class="comment">// 输出的 jar 文件</span></span><br><span class="line">	            File dest = outputProvider.getContentLocation(destName + <span class="string">"_"</span> + hexName, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">// 扫描 jar 文件，查找实现 IRouteRoot IInterceptorGroup IProviderGroup 接口的类，并且找到 LogisticsCenter 在哪个 jar 文件中</span></span><br><span class="line">	            <span class="comment">// 不扫描 com.android.support 开头的 jar</span></span><br><span class="line">	            <span class="keyword">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class="line">	                <span class="comment">// ScanUtil.scanJar 的代码就不详细展开了，感兴趣的同学可以自己去看下</span></span><br><span class="line">	                ScanUtil.scanJar(src, dest)</span><br><span class="line">	            &#125;</span><br><span class="line">	            FileUtils.copyFile(src, dest)</span><br><span class="line">	</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// 扫描所有的 class 文件，查找实现 IRouteRoot IInterceptorGroup IProviderGroup 接口的类</span></span><br><span class="line">	        <span class="comment">// 和扫描 jar 做差不多类似的工作。不同的点就是不用再去找 LogisticsCenter 类</span></span><br><span class="line">	        input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">	            File dest = outputProvider.getContentLocation(directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br><span class="line">	            String root = directoryInput.file.<span class="function">absolutePath</span><br><span class="line">	            <span class="title">if</span> <span class="params">(!root.endsWith(File.separator)</span>)</span><br><span class="line">	                root +</span>= File.separator</span><br><span class="line">	            directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class="line">	                def path = file.absolutePath.replace(root, <span class="string">''</span>)</span><br><span class="line">	                <span class="keyword">if</span> (!leftSlash) &#123;</span><br><span class="line">	                    path = path.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"/"</span>)</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="comment">// 只处理 com/alibaba/android/arouter/routes/ 开头的 class</span></span><br><span class="line">	                <span class="keyword">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class="line">	                    ScanUtil.scanClass(file)</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">// copy to dest</span></span><br><span class="line">	            FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">'Scan finish, current cost time '</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>)</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 这里开始字节码插桩操作</span></span><br><span class="line">	    <span class="keyword">if</span> (fileContainsInitClass) &#123;</span><br><span class="line">	        <span class="comment">// 遍历之前找的 IRouteRoot IInterceptorGroup IProviderGroup</span></span><br><span class="line">	        registerList.each &#123; ext -&gt;</span><br><span class="line">	            Logger.i(<span class="string">'Insert register code to file '</span> + fileContainsInitClass.absolutePath)</span><br><span class="line">	</span><br><span class="line">	            <span class="keyword">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class="line">	                Logger.e(<span class="string">"No class implements found for interface:"</span> + ext.interfaceName)</span><br><span class="line">	            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	                ext.classList.each &#123;</span><br><span class="line">	                    Logger.i(it)</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="comment">// 对 LogisticsCenter.class 做字节码插桩</span></span><br><span class="line">	                RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">"Generate code finish, current cost time: "</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑很清晰，按照之前设置好的 IRouteRoot IInterceptorGroup IProviderGroup 这三个接口，然后扫描整个项目的代码，分别找到这三者各自的实现类，然后加入到集合中。最后在 LogisticsCenter 中实现字节码插桩。</p>
<p>我们来详细看下 RegisterCodeGenerator.insertInitCodeTo(ext) 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInitCodeTo</span><span class="params">(ScanSetting registerSetting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registerSetting != <span class="keyword">null</span> &amp;&amp; !registerSetting.classList.isEmpty()) &#123;</span><br><span class="line">        RegisterCodeGenerator processor = <span class="keyword">new</span> RegisterCodeGenerator(registerSetting)</span><br><span class="line">        <span class="comment">// RegisterTransform.fileContainsInitClass 就是包含了 LogisticsCenter.class 的那个 jar 文件</span></span><br><span class="line">        File file = RegisterTransform.<span class="function">fileContainsInitClass</span><br><span class="line">        <span class="title">if</span> <span class="params">(file.getName()</span>.<span class="title">endsWith</span><span class="params">(<span class="string">'.jar'</span>)</span>)</span><br><span class="line">        		 <span class="comment">// 开始处理</span></span><br><span class="line">            processor.<span class="title">insertInitCodeIntoJarFile</span><span class="params">(file)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>插入的操作在 insertInitCodeIntoJarFile 中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">insertInitCodeIntoJarFile</span><span class="params">(File jarFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jarFile) &#123;</span><br><span class="line">        def optJar = <span class="keyword">new</span> File(jarFile.getParent(), jarFile.name + <span class="string">".opt"</span>)</span><br><span class="line">        <span class="keyword">if</span> (optJar.exists())</span><br><span class="line">            optJar.delete()</span><br><span class="line">        def file = <span class="keyword">new</span> JarFile(jarFile)</span><br><span class="line">        Enumeration enumeration = file.entries()</span><br><span class="line">        JarOutputStream jarOutputStream = <span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(optJar))</span><br><span class="line">        <span class="comment">// 遍历 jar 文件中的 class</span></span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            JarEntry jarEntry = (JarEntry) enumeration.nextElement()</span><br><span class="line">            String entryName = jarEntry.getName()</span><br><span class="line">            ZipEntry zipEntry = <span class="keyword">new</span> ZipEntry(entryName)</span><br><span class="line">            InputStream inputStream = file.getInputStream(jarEntry)</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            <span class="comment">// 如果是 LogisticsCenter.class 的话</span></span><br><span class="line">            <span class="keyword">if</span> (ScanSetting.GENERATE_TO_CLASS_FILE_NAME == entryName) &#123;</span><br><span class="line"></span><br><span class="line">                Logger.i(<span class="string">'Insert init code to class &gt;&gt; '</span> + entryName)</span><br><span class="line">                <span class="comment">// 插桩操作</span></span><br><span class="line">                def bytes = referHackWhenInit(inputStream)</span><br><span class="line">                jarOutputStream.write(bytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jarOutputStream.write(IOUtils.toByteArray(inputStream))</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close()</span><br><span class="line">            jarOutputStream.closeEntry()</span><br><span class="line">        &#125;</span><br><span class="line">        jarOutputStream.close()</span><br><span class="line">        file.close()</span><br><span class="line">        <span class="comment">// 把字节码插桩的 jar 替换掉原来旧的 jar 文件</span></span><br><span class="line">        <span class="keyword">if</span> (jarFile.exists()) &#123;</span><br><span class="line">            jarFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line">        optJar.renameTo(jarFile)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jarFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码插桩的代码还在 referHackWhenInit 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//refer hack class when object init</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] referHackWhenInit(InputStream inputStream) &#123;</span><br><span class="line">    ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream)</span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, <span class="number">0</span>)</span><br><span class="line">    ClassVisitor cv = <span class="keyword">new</span> MyClassVisitor(Opcodes.ASM5, cw)</span><br><span class="line">    cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyClassVisitor(<span class="keyword">int</span> api, ClassVisitor cv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(api, cv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span><br><span class="line">               String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function">MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span><br><span class="line">                              String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions)</span><br><span class="line">        <span class="comment">// 对 loadRouterMap 这个方法进行代码插入</span></span><br><span class="line">        <span class="keyword">if</span> (name == ScanSetting.GENERATE_TO_METHOD_NAME) &#123;</span><br><span class="line">            mv = <span class="keyword">new</span> RouteMethodVisitor(Opcodes.ASM5, mv)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RouteMethodVisitor(<span class="keyword">int</span> api, MethodVisitor mv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入的代码在 return 之前</span></span><br><span class="line">        <span class="keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)) &#123;</span><br><span class="line">            extension.classList.each &#123; name -&gt;</span><br><span class="line">                name = name.replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>)</span><br><span class="line">                mv.visitLdcInsn(name)<span class="comment">//这里的name就是之前扫描出来的 IRouteRoot IInterceptorGroup IProviderGroup 实现类名</span></span><br><span class="line">                <span class="comment">// 生成 LogisticsCenter.register(name) 代码</span></span><br><span class="line">                mv.visitMethodInsn(Opcodes.INVOKESTATIC</span><br><span class="line">                        , ScanSetting.GENERATE_TO_CLASS_NAME</span><br><span class="line">                        , ScanSetting.REGISTER_METHOD_NAME</span><br><span class="line">                        , <span class="string">"(Ljava/lang/String;)V"</span></span><br><span class="line">                        , <span class="keyword">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">int</span> maxStack, <span class="keyword">int</span> maxLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitMaxs(maxStack + <span class="number">4</span>, maxLocals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，生成的代码会像下面所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadRouterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerByPlugin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class="line">    <span class="comment">// looks like below:</span></span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$app"</span>);</span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app"</span>);</span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Group$$arouter"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么顺便来跟踪一下 register 方法的代码，看看里面是如何完成路由表注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IRouteRoot) &#123;</span><br><span class="line">                registerRouteRoot((IRouteRoot) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IProviderGroup) &#123;</span><br><span class="line">                registerProvider((IProviderGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IInterceptorGroup) &#123;</span><br><span class="line">                registerInterceptor((IInterceptorGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"register failed, class name: "</span> + className</span><br><span class="line">                        + <span class="string">" should implements one of IRouteRoot/IProviderGroup/IInterceptorGroup."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(TAG,<span class="string">"register class error:"</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IRouteRoot 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerRouteRoot</span><span class="params">(IRouteRoot routeRoot)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (routeRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        routeRoot.loadInto(Warehouse.groupsIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IInterceptorGroup 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerInterceptor</span><span class="params">(IInterceptorGroup interceptorGroup)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (interceptorGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptorGroup.loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IProviderGroup 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(IProviderGroup providerGroup)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (providerGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        providerGroup.loadInto(Warehouse.providersIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记通过gradle plugin完成自动注册</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRegisteredByPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!registerByPlugin) &#123;</span><br><span class="line">        registerByPlugin = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样相比之下，自动注册的方式确实比扫描 dex 文件更高效，扫描 dex 文件是在 app 运行时操作的，这样会影响 app 的性能，对用户造成不好的体验。而自动注册是在 build 的时候完成字节码插桩的，对运行时不产生影响。</p>
<p>学了今天这招，以后 compiler 生成的代码需要注册的步骤都可以通过自动注册来完成了，赞一个👍</p>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>之前看到自动注册这么神奇，所以想看下插入字节码之后 LogisticsCenter 代码的效果，所以反编译了一下 ARouter demo apk，可以看到 LogisticsCenter.smali 的 loadRouterMap 方法：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> private</span><span class="keyword"> static</span><span class="function"> loadRouterMap(</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 64</span><br><span class="line">   <span class="instruction"> const/4 </span><span class="variable">v0</span>, 0x0</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sput-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span>-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 69</span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>确实符合我们的预期啊，真好！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://juejin.im/post/5a2b95b96fb9a045284669a9" target="_blank" rel="external">AutoRegister:一种更高效的组件自动注册方案(android组件化开发)</a></li>
<li><a href="https://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a></li>
<li><a href="http://quinnchen.me/2018/09/13/2018-09-13-asm-transform/" target="_blank" rel="external">一起玩转Android项目中的字节码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-gradle-plugin version : 1.0.2</p>
<p>AutoRegister : <a href="https://github.com/luckybilly/AutoRegister" target="_blank" rel="ext]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yuqirong.me/tags/Gradle/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（四）]]></title>
    <link href="http://yuqirong.me/2019/01/05/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/05/ARouter源码解析（四）/</id>
    <published>2019-01-05T14:35:21.000Z</published>
    <updated>2019-03-04T16:26:35.735Z</updated>
    <content type="html"><![CDATA[<p>arouter-compiler version : 1.2.2</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 arouter-api 做了整个流程的分析，今天来看看 arouter-compiler 。</p>
<p>arouter-compiler 主要是利用 apt 在编译期自动生成代码的。之前我们看到的 <code>ARouter$$Root$$app</code> 、 <code>ARouter$$Group$$test</code> 和 <code>Test1Activity$$ARouter$$Autowired</code> 等都是 arouter-compiler 生成的。</p>
<p>那接下来就分析分析 arouter-compiler 是怎么生成这些源码的。</p>
<h1 id="arouter-compiler"><a href="#arouter-compiler" class="headerlink" title="arouter-compiler"></a>arouter-compiler</h1><p>arouter-compiler 中 processor 有三种：</p>
<ul>
<li>AutowiredProcessor : 用来生成像 <code>Test1Activity$$ARouter$$Autowired</code> 这种类型；</li>
<li>InterceptorProcessor : 用来生成像 <code>ARouter$$Interceptors$$app</code> 这种类型；</li>
<li>RouteProcessor : 用来生成像 <code>ARouter$$Root$$app</code> ，<code>ARouter$$Providers$$app</code> 和 <code>ARouter$$Group$$test</code> 这种类型；</li>
</ul>
<h2 id="RouteProcessor"><a href="#RouteProcessor" class="headerlink" title="RouteProcessor"></a>RouteProcessor</h2><p>在这里我们就只分析 RouteProcessor 了。</p>
<p>RouteProcessor 相比其他两个 Processor 来说，代码更长，逻辑更加复杂。并且 RouteProcessor 主要处理的是路由映射这一块。其他两个 RouteProcessor 也是大同小异，有兴趣的同学可以自行阅读源码。</p>
<p>先来看看 RouteProcessor 的定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="variable">@SupportedOptions</span>(&#123;KEY_MODULE_NAME, KEY_GENERATE_DOC_NAME&#125;)</span><br><span class="line"><span class="variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br><span class="line"><span class="variable">@SupportedAnnotationTypes</span>(&#123;ANNOTATION_TYPE_ROUTE, ANNOTATION_TYPE_AUTOWIRED&#125;)</span><br><span class="line">public class RouteProcessor extends AbstractProcessor &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RouteProcessor 类上面的注解很多，我们一个一个来看：</p>
<ul>
<li>@AutoService 会自动在 META-INF 文件夹下生成 Processor 配置信息文件，避免手动配置的麻烦;</li>
<li>@SupportedOptions 指定 Processor 支持的选项参数名称，KEY_MODULE_NAME 就是 AROUTER_MODULE_NAME ，KEY_GENERATE_DOC_NAME 就是 AROUTER_GENERATE_DOC；没错，这两个就是我们一开始在 build.gradle 中配置的。</li>
<li>@SupportedSourceVersion 指定 Processor 支持的 JDK 的版本；</li>
<li>@SupportedAnnotationTypes 指定 Processor 处理的注解；</li>
</ul>
<p>接着，趁热打铁。来瞧瞧 RouteProcessor 的 init 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line"></span><br><span class="line">    mFiler = processingEnv.getFiler();                  <span class="comment">// Generate class.</span></span><br><span class="line">    types = processingEnv.getTypeUtils();            <span class="comment">// Get type utils.</span></span><br><span class="line">    elements = processingEnv.getElementUtils();      <span class="comment">// Get class meta.</span></span><br><span class="line"></span><br><span class="line">    typeUtils = <span class="keyword">new</span> TypeUtils(types, elements);</span><br><span class="line">    logger = <span class="keyword">new</span> Logger(processingEnv.getMessager());   <span class="comment">// Package the log utils.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to get user configuration [moduleName]</span></span><br><span class="line">    Map&lt;String, String&gt; options = processingEnv.getOptions();</span><br><span class="line">    <span class="keyword">if</span> (MapUtils.isNotEmpty(options)) &#123;</span><br><span class="line">        moduleName = options.get(KEY_MODULE_NAME);</span><br><span class="line">        generateDoc = VALUE_ENABLE.equals(options.get(KEY_GENERATE_DOC_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(moduleName)) &#123;</span><br><span class="line">        moduleName = moduleName.replaceAll(<span class="string">"[^0-9a-zA-Z_]+"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"The user has configuration the module name, it was ["</span> + moduleName + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(NO_MODULE_NAME_TIPS);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ARouter::Compiler &gt;&gt;&gt; No module name, for more information, look at gradle log."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要生成路由 doc</span></span><br><span class="line">    <span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            docWriter = mFiler.createResource(</span><br><span class="line">                    StandardLocation.SOURCE_OUTPUT,</span><br><span class="line">                    PACKAGE_OF_GENERATE_DOCS,</span><br><span class="line">                    <span class="string">"arouter-map-of-"</span> + moduleName + <span class="string">".json"</span></span><br><span class="line">            ).openWriter();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Create doc writer failed, because "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iProvider = elements.getTypeElement(Consts.IPROVIDER).asType();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"&gt;&gt;&gt; RouteProcessor init. &lt;&lt;&lt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 init 方法中，主要获取了 KEY_MODULE_NAME 和 KEY_GENERATE_DOC_NAME 这两个编译选项参数。然后判断一下是否需要生成路由文档。</p>
<p>在 init 方法中获取参数后，接着就是 process 方法。</p>
<p>process 方法就好像是 main 方法一样，在这里面都是 processer 处理注解自动生成代码的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(annotations)) &#123;</span><br><span class="line">        <span class="comment">// 获取 @Route 注解的集合</span></span><br><span class="line">        Set&lt;? extends Element&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"&gt;&gt;&gt; Found routes, start... &lt;&lt;&lt;"</span>);</span><br><span class="line">            <span class="keyword">this</span>.parseRoutes(routeElements);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 process 中调用了 parseRoutes ，parseRoutes 方法实在是太长了，在这里我们进行分段讲解吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRoutes</span><span class="params">(Set&lt;? extends Element&gt; routeElements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(routeElements)) &#123;</span><br><span class="line">        <span class="comment">// prepare the type an so on.</span></span><br><span class="line">	</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found routes, size is "</span> + routeElements.size() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">	</span><br><span class="line">        rootMap.clear();</span><br><span class="line">        <span class="comment">// Activity 类型</span></span><br><span class="line">        TypeMirror type_Activity = elements.getTypeElement(ACTIVITY).asType();</span><br><span class="line">        <span class="comment">// Service 类型</span></span><br><span class="line">        TypeMirror type_Service = elements.getTypeElement(SERVICE).asType();</span><br><span class="line">        <span class="comment">// Fragment 类型</span></span><br><span class="line">        TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();</span><br><span class="line">        <span class="comment">// v4 Fragment 类型</span></span><br><span class="line">        TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// IRouteGroup 类型</span></span><br><span class="line">        TypeElement type_IRouteGroup = elements.getTypeElement(IROUTE_GROUP);</span><br><span class="line">        <span class="comment">// IProviderGroup 类型</span></span><br><span class="line">        TypeElement type_IProviderGroup = elements.getTypeElement(IPROVIDER_GROUP);</span><br><span class="line">        <span class="comment">// 获取 RouteMeta 和 RouteType 的类名</span></span><br><span class="line">        ClassName routeMetaCn = ClassName.get(RouteMeta.class);</span><br><span class="line">        ClassName routeTypeCn = ClassName.get(RouteType.class);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">           构造 ARouter$$Root$$xxx 的 loadInto 方法入参类型</span><br><span class="line">           Build input type, format as :</span><br><span class="line">	</span><br><span class="line">           Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span><br><span class="line">         */</span></span><br><span class="line">        ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ParameterizedTypeName.get(</span><br><span class="line">                        ClassName.get(Class.class),</span><br><span class="line">                        WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造 ARouter$$Group$$xxx 的 loadInto 方法入参类型</span><br><span class="line">          Map&lt;String, RouteMeta&gt;</span><br><span class="line">         */</span></span><br><span class="line">        ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ClassName.get(RouteMeta.class)</span><br><span class="line">        );</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造方法入参参数名称</span><br><span class="line">          Build input param name.</span><br><span class="line">         */</span></span><br><span class="line">        ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">"routes"</span>).build();</span><br><span class="line">        ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"atlas"</span>).build();</span><br><span class="line">        ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"providers"</span>).build();  <span class="comment">// Ps. its param type same as groupParamSpec!</span></span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造 ARouter$$Root$$xxx 的 loadInto 方法</span><br><span class="line">          Build method : 'loadInto'</span><br><span class="line">         */</span></span><br><span class="line">        MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addParameter(rootParamSpec);</span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parseRoutes 方法一开始，做足了准备。下面就到了放大招的时候了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Follow a sequence, find out metas of group first, generate java file, then statistics them as root.</span></span><br><span class="line"><span class="keyword">for</span> (Element element : routeElements) &#123;</span><br><span class="line">    TypeMirror tm = element.asType();</span><br><span class="line">    Route route = element.getAnnotation(Route.class);</span><br><span class="line">    RouteMeta routeMeta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 element 修饰的类是 Activity 类型的</span></span><br><span class="line">    <span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;                 <span class="comment">// Activity</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found activity route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Activity 中 @Autowired 注解的属性，IProvider 类型的除外</span></span><br><span class="line">        Map&lt;String, Integer&gt; paramsType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Autowired&gt; injectConfig = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Element field : element.getEnclosedElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getKind().isField() &amp;&amp; field.getAnnotation(Autowired.class) != <span class="keyword">null</span> &amp;&amp; !types.isSubtype(field.asType(), iProvider)) &#123;</span><br><span class="line">                <span class="comment">// It must be field, then it has annotation, but it not be provider.</span></span><br><span class="line">                Autowired paramConfig = field.getAnnotation(Autowired.class);</span><br><span class="line">                String injectName = StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name();</span><br><span class="line">                paramsType.put(injectName, typeUtils.typeExchange(field));</span><br><span class="line">                injectConfig.put(injectName, paramConfig);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造 activity 类型的路由数据</span></span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.ACTIVITY, paramsType);</span><br><span class="line">        routeMeta.setInjectConfig(injectConfig);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found provider route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.PROVIDER, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, type_Service)) &#123;           <span class="comment">// Service 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found service route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.parse(SERVICE), <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) &#123; <span class="comment">// fragment 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found fragment route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.parse(FRAGMENT), <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ARouter::Compiler &gt;&gt;&gt; Found unsupported class type, type = ["</span> + types.toString() + <span class="string">"]."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将生成好的 routeMeta 按组存放进入 groupMap 中</span></span><br><span class="line">    categories(routeMeta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码主要将每个 routeElement 进行了分类，将 @Route 修饰的类信息封装进 RouteMeta 中。再把 RouteMeta 按照组名分好组存进 groupMap 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造 ARouter$$Providers$$xxx 的 loadInto 方法</span></span><br><span class="line">MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(PUBLIC)</span><br><span class="line">        .addParameter(providerParamSpec);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;RouteDoc&gt;&gt; docSource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start generate java source, structure is divided into upper and lower levels, used for demand initialization.</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;RouteMeta&gt;&gt; entry : groupMap.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 每组的组名</span></span><br><span class="line">    String groupName = entry.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 ARouter$$Group$$xxx 的 loadInto 方法</span></span><br><span class="line">    MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(PUBLIC)</span><br><span class="line">            .addParameter(groupParamSpec);</span><br><span class="line"></span><br><span class="line">    List&lt;RouteDoc&gt; routeDocList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build group method body</span></span><br><span class="line">    Set&lt;RouteMeta&gt; groupData = entry.getValue();</span><br><span class="line">    <span class="keyword">for</span> (RouteMeta routeMeta : groupData) &#123;</span><br><span class="line">        RouteDoc routeDoc = extractDocInfo(routeMeta);</span><br><span class="line">        <span class="comment">// 类名。比如 com.alibaba.android.arouter.demo.testservice.HelloService</span></span><br><span class="line">        ClassName className = ClassName.get((TypeElement) routeMeta.getRawType());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// Need cache provider's super class</span></span><br><span class="line">                <span class="comment">// 获取该节点下的接口</span></span><br><span class="line">                List&lt;? extends TypeMirror&gt; interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();</span><br><span class="line">                <span class="comment">// 遍历接口</span></span><br><span class="line">                <span class="keyword">for</span> (TypeMirror tm : interfaces) &#123;</span><br><span class="line">                    routeDoc.addPrototype(tm.toString());</span><br><span class="line">                    <span class="comment">// 如果接口是 iProvider 类型</span></span><br><span class="line">                    <span class="keyword">if</span> (types.isSameType(tm, iProvider)) &#123;   <span class="comment">// Its implements iProvider interface himself.</span></span><br><span class="line">                        <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                        loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                <span class="string">"providers.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, null, "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">                                (routeMeta.getRawType()).toString(),</span><br><span class="line">                                routeMetaCn,</span><br><span class="line">                                routeTypeCn,</span><br><span class="line">                                className,</span><br><span class="line">                                routeMeta.getPath(),</span><br><span class="line">                                routeMeta.getGroup());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123; <span class="comment">// 如果是 iProvider 的子接口</span></span><br><span class="line">                        <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                        loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                <span class="string">"providers.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, null, "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">                                tm.toString(),    <span class="comment">// So stupid, will duplicate only save class name.</span></span><br><span class="line">                                routeMetaCn,</span><br><span class="line">                                routeTypeCn,</span><br><span class="line">                                className,</span><br><span class="line">                                routeMeta.getPath(),</span><br><span class="line">                                routeMeta.getGroup());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码最终会生成 ARouter$$Providers$$xxx 的 loadInto 方法，比如像这样：</p>
<pre><code>providers.put(&quot;com.alibaba.android.arouter.demo.testservice.HelloService&quot;, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, &quot;/yourservicegroupname/hello&quot;, &quot;yourservicegroupname&quot;, null, -1, -2147483648));
</code></pre><p>那我们接着看。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    // 构造 RouteMeta 的 paramType 参数</span><br><span class="line">    StringBuilder mapBodyBuilder = new StringBuilder();</span><br><span class="line">    Map<span class="variable">&lt;String, Integer&gt;</span> paramsType = routeMeta.getParamsType();</span><br><span class="line">    Map<span class="variable">&lt;String, Autowired&gt;</span> injectConfigs = routeMeta.getInjectConfig();</span><br><span class="line">    if (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">        List<span class="variable">&lt;RouteDoc.Param&gt;</span> paramList = new ArrayList<span class="variable">&lt;&gt;</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry<span class="variable">&lt;String, Integer&gt;</span> types : paramsType.entrySet()) &#123;</span><br><span class="line">            mapBodyBuilder.append(<span class="string">"put(\""</span>).append(types.getKey()).append(<span class="string">"\", "</span>).append(types.getValue()).append(<span class="string">"); "</span>);</span><br><span class="line"></span><br><span class="line">            RouteDoc.Param param = new RouteDoc.Param();</span><br><span class="line">            Autowired injectConfig = injectConfigs.get(types.getKey());</span><br><span class="line">            param.<span class="built_in">set</span>Key(types.getKey());</span><br><span class="line">            param.<span class="built_in">set</span>Type(TypeKind.values()[types.getValue()].name().<span class="keyword">to</span>LowerCase());</span><br><span class="line">            param.<span class="built_in">set</span>Description(injectConfig.desc());</span><br><span class="line">            param.<span class="built_in">set</span>Required(injectConfig.required());</span><br><span class="line"></span><br><span class="line">            paramList.add(param);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        routeDoc.<span class="built_in">set</span>Params(paramList);</span><br><span class="line">    &#125;</span><br><span class="line">    String mapBody = mapBodyBuilder.<span class="keyword">to</span>String();</span><br><span class="line"></span><br><span class="line">    // 以下代码生成这种模版 atlas.put(<span class="string">"/test/activity1"</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">"/test/activity1"</span>, <span class="string">"test"</span>, new java.util.HashMap<span class="variable">&lt;String, Integer&gt;</span>()&#123;&#123;put(<span class="string">"ser"</span>, <span class="number">9</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">load</span>IntoMethodOfGroupBuilder.addStatement(</span><br><span class="line">            <span class="string">"atlas.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, "</span> + (StringUtils.isEmpty(mapBody) ? null : (<span class="string">"new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;"</span> + mapBodyBuilder.<span class="keyword">to</span>String() + <span class="string">"&#125;&#125;"</span>)) + <span class="string">", "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">            routeMeta.getPath(),</span><br><span class="line">            routeMetaCn,</span><br><span class="line">            routeTypeCn,</span><br><span class="line">            className,</span><br><span class="line">            routeMeta.getPath().<span class="keyword">to</span>LowerCase(),</span><br><span class="line">            routeMeta.getGroup().<span class="keyword">to</span>LowerCase());</span><br><span class="line"></span><br><span class="line">    routeDoc.<span class="built_in">set</span>ClassName(className.<span class="keyword">to</span>String());</span><br><span class="line">    routeDocList.add(routeDoc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成 ARouter$<span class="variable">$Group</span>$<span class="variable">$xxx</span> 类</span><br><span class="line">String <span class="keyword">group</span>FileName = NAME_OF_GROUP + <span class="keyword">group</span>Name;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(<span class="keyword">group</span>FileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(type_IRouteGroup))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(<span class="built_in">load</span>IntoMethodOfGroupBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated group: "</span> + <span class="keyword">group</span>Name + <span class="string">"&lt;&lt;&lt;"</span>);</span><br><span class="line">rootMap.put(<span class="keyword">group</span>Name, <span class="keyword">group</span>FileName);</span><br><span class="line">docSource.put(<span class="keyword">group</span>Name, routeDocList);</span><br></pre></td></tr></table></figure>
<p>上面代码主要做的事情就是遍历 groupmap 集合给 ARouter$$Group$$xxx 类中的 loadInto 添加方法体，并生成 java 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MapUtils.isNotEmpty(rootMap)) &#123;</span><br><span class="line">    <span class="comment">// Generate root meta by group name, it must be generated before root, then I can find out the class of group.</span></span><br><span class="line">    <span class="comment">// 生成 ARouter$$Root$$app 的 loadInto 方法体</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : rootMap.entrySet()) &#123;</span><br><span class="line">        loadIntoMethodOfRootBuilder.addStatement(<span class="string">"routes.put($S, $T.class)"</span>, entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output route doc</span></span><br><span class="line"><span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">    docWriter.append(JSON.toJSONString(docSource, SerializerFeature.PrettyFormat));</span><br><span class="line">    docWriter.flush();</span><br><span class="line">    docWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 ARouter$$Providers$$app 类</span></span><br><span class="line">String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(providerMapFileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(type_IProviderGroup))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(loadIntoMethodOfProviderBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated provider map, name is "</span> + providerMapFileName + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 ARouter$$Root$$app 类 </span></span><br><span class="line">String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(rootFileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(elements.getTypeElement(ITROUTE_ROOT)))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(loadIntoMethodOfRootBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated root, name is "</span> + rootFileName + <span class="string">" &lt;&lt;&lt;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上，就是整个 RouteProcessor 的流程。看完 RouteProcessor 之后，相信你对 ARouter 的的了解也更加深入了。</p>
<p>之后，也会对 ARouter 的 arouter-register 模块做一个深入解析，敬请期待吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-compiler version : 1.2.2</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 arouter-]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（三）]]></title>
    <link href="http://yuqirong.me/2019/01/03/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/03/ARouter源码解析（三）/</id>
    <published>2019-01-03T13:46:43.000Z</published>
    <updated>2019-03-04T16:26:40.192Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>到现在为止，ARouter 还有最后的依赖注入还没有解析过，那么今天就来深入探究一下其实现原理。</p>
<p>PS : 因为依赖注入的原理还比较简单，所以本篇篇幅会较短。</p>
<h1 id="@Autowired_u89E3_u6790"><a href="#@Autowired_u89E3_u6790" class="headerlink" title="@Autowired解析"></a>@Autowired解析</h1><p>想要用 ARouter 实现依赖注入，需要在 Activity/Fragment 中加上</p>
<pre><code>ARouter.getInstance().inject(this);
</code></pre><p>那么我们这个代码就成为了我们分析的入口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object thiz)</span> </span>&#123;</span><br><span class="line">    _ARouter.inject(thiz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARouter 内部还是调用了 _ARouter 的 inject 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object thiz)</span> </span>&#123;</span><br><span class="line">    AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build(<span class="string">"/arouter/service/autowired"</span>).navigation());</span><br><span class="line">    <span class="comment">// 如果 autowiredService 不为空，完成依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != autowiredService) &#123;</span><br><span class="line">        autowiredService.autowire(thiz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现依赖注入和拦截器很相似，都是利用服务组件来完成的。依赖注入的服务组件叫 AutowiredService ，跟踪可以发现，它的实现类是 AutowiredServiceImpl 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Route</span>(path = <span class="string">"/arouter/service/autowired"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredServiceImpl</span> <span class="keyword">implements</span> <span class="title">AutowiredService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, ISyringe&gt; classCache;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        classCache = <span class="keyword">new</span> LruCache&lt;&gt;(<span class="number">66</span>);</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autowire</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        String className = instance.getClass().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 instance 这个类进入黑名单了，就不会完成依赖注入</span></span><br><span class="line">            <span class="keyword">if</span> (!blackList.contains(className)) &#123;</span><br><span class="line">                <span class="comment">// 先从缓存中取</span></span><br><span class="line">                ISyringe autowiredHelper = classCache.get(className);</span><br><span class="line">                <span class="comment">// 没有缓存就创建对象</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == autowiredHelper) &#123;  <span class="comment">// No cache.</span></span><br><span class="line">                    autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 完成依赖注入</span></span><br><span class="line">                autowiredHelper.inject(instance);</span><br><span class="line">                <span class="comment">// 放入缓存中</span></span><br><span class="line">                classCache.put(className, autowiredHelper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 出错就加入黑名单中</span></span><br><span class="line">            blackList.add(className);    <span class="comment">// This instance need not autowired.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 ISyringe 就是依赖注入抽取出来的接口，</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISyringe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object <span class="keyword">target</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 ISyringe 的实现类又是谁呢？答案就是在编译期自动生成的类 <code>XXXX$$ARouter$$Autowired</code> ，我们找 demo 中生成的 <code>Test1Activity$$ARouter$$Autowired</code> 来看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Activity</span>$$<span class="title">ARouter</span>$$<span class="title">Autowired</span> <span class="keyword">implements</span> <span class="title">ISyringe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SerializationService serializationService;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br><span class="line">    Test1Activity substitute = (Test1Activity)target;</span><br><span class="line">    substitute.name = substitute.getIntent().getStringExtra(<span class="string">"name"</span>);</span><br><span class="line">    substitute.age = substitute.getIntent().getIntExtra(<span class="string">"age"</span>, substitute.age);</span><br><span class="line">    substitute.height = substitute.getIntent().getIntExtra(<span class="string">"height"</span>, substitute.height);</span><br><span class="line">    substitute.girl = substitute.getIntent().getBooleanExtra(<span class="string">"boy"</span>, substitute.girl);</span><br><span class="line">    substitute.ch = substitute.getIntent().getCharExtra(<span class="string">"ch"</span>, substitute.ch);</span><br><span class="line">    substitute.fl = substitute.getIntent().getFloatExtra(<span class="string">"fl"</span>, substitute.fl);</span><br><span class="line">    substitute.dou = substitute.getIntent().getDoubleExtra(<span class="string">"dou"</span>, substitute.dou);</span><br><span class="line">    substitute.ser = (com.alibaba.android.arouter.demo.testinject.TestSerializable) substitute.getIntent().getSerializableExtra(<span class="string">"ser"</span>);</span><br><span class="line">    substitute.pac = substitute.getIntent().getParcelableExtra(<span class="string">"pac"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"obj"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;TestObj&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'obj' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.objList = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"objList"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;List&lt;TestObj&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'objList' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.map = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"map"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;Map&lt;String, List&lt;TestObj&gt;&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'map' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    substitute.url = substitute.getIntent().getStringExtra(<span class="string">"url"</span>);</span><br><span class="line">    substitute.helloService = ARouter.getInstance().navigation(HelloService.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面自动生成的代码中看出来，依赖注入实际上内部还是使用 <code>getIntent.getXxxExtra</code> 的形式来赋值的（同理，Fragment 用的是<code>getArguments().getXxx()</code> ）。需要注意的是，@Autowired 修饰的字段不能是 private 的，不然在自动生成代码的时候会报错。</p>
<p>另外，上面的代码中有一个 SerializationService 是用来干什么的？其实 SerializationService 是 json 序列化用的。在 demo 中官方给出了一个实现类 JsonServiceImpl ，内部用的是阿里的 fastjson 。如果有需要自定义的童鞋，可以参照着 JsonServiceImpl 自己去实现。</p>
<h1 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h1><p>看到这，基本上 ARouter 依赖注入的东西就讲完了。</p>
<p>这一系列下来，ARouter 代码层面的流程都讲的差不多。剩下就是 gradle-plugin 和 compiler 这两个部分还没解析过，等时间了再给大家讲。</p>
<p>bye bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>到现在为止，ARouter 还有最]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（二）]]></title>
    <link href="http://yuqirong.me/2019/01/02/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/02/ARouter源码解析（二）/</id>
    <published>2019-01-02T12:16:40.000Z</published>
    <updated>2019-03-04T16:26:49.903Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>前几天对 ARouter 的页面跳转源码进行了分析，趁着今天有空，就讲讲 ARouter 里面的拦截器吧。</p>
<p>ARouter 拦截器的使用方法在这就不多说了，不了解的同学可以去 GitHub 上看看。那就直接进入正题了。</p>
<h1 id="u62E6_u622A_u5668_u89E3_u6790"><a href="#u62E6_u622A_u5668_u89E3_u6790" class="headerlink" title="拦截器解析"></a>拦截器解析</h1><p>把视线转移回 ARouter 的 init 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = _ARouter.logger;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</span><br><span class="line">        hasInit = _ARouter.init(application);</span><br><span class="line">        <span class="comment">// 如果初始化完成了</span></span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            _ARouter.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 init 中，判断了初始化完成后，调用了 <code>_ARouter.afterInit()</code> 来初始化拦截器，跟进代码去看看。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">afterInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Trigger interceptor init, use byName.</span></span><br><span class="line">    interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">"/arouter/service/interceptor"</span>).navigation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现有个 InterceptorService ，InterceptorService 就是用来控制拦截的服务组件，来看看它的接口是怎么定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterceptorService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Do interceptions</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们分析过，IProvider 也是可以用 <code>ARouter.getInstance().build(&quot;xxx&quot;).navigation()</code> 的形式获取的。关键的代码在 LogisticsCenter 的 completion 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Completion the postcard by route metas</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> postcard Incomplete postcard, should complete by this method.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;</span><br><span class="line">        <span class="comment">// 省略一大串代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略一大串代码</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果是 PROVIDER 类型的，就会反射出一个单例对象，并且设置为绿色通道（即不受拦截器的影响）。更详细的代码就不过多介绍了，不理解的同学可以结合着上一篇博客私下回去再看。</p>
<p>所以其实在 afterInit 方法中，只是获取到了 InterceptorService 的实例对象，我们根据上面的 “/arouter/service/interceptor” 可以很轻松的查到，InterceptorService 接口的实现类就是 InterceptorServiceImpl </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Route</span>(path = <span class="string">"/arouter/service/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorServiceImpl</span> <span class="keyword">implements</span> <span class="title">InterceptorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> interceptorHasInit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object interceptorInitLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                        Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class="line">                            iInterceptor.init(context);</span><br><span class="line">                            Warehouse.interceptors.add(iInterceptor);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init interceptor error! name = ["</span> + interceptorClass.getName() + <span class="string">"], reason = ["</span> + ex.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    interceptorHasInit = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    logger.info(TAG, <span class="string">"ARouter interceptors init over."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (interceptorInitLock) &#123;</span><br><span class="line">                        interceptorInitLock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看 InterceptorServiceImpl 的 init 方法。</p>
<p>在 init 方法中，做的主要事情就是遍历所有 IInterceptor class 并创建出对象，调用其 init 方法，完成初始化操作。</p>
<p>初始化完成之后，InterceptorService又是在哪里被使用的呢？</p>
<p>我们在 _ARouter 的 navigation 方法里可以看到它的踪迹：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Continue process</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> postcard route meta</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Interrupt process, pipeline will be destory when this method called.</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> exception Reson of interrupt.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是绿色通道的话，就会启动拦截器去进行拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">       checkInterceptorsInitStatus();</span><br><span class="line">       <span class="comment">// 如果拦截器还没有初始化好</span></span><br><span class="line">       <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">           callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"Interceptors initialization takes too much time."</span>));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               CancelableCountDownLatch interceptorCounter = <span class="keyword">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   _excute(<span class="number">0</span>, interceptorCounter, postcard);</span><br><span class="line">                   <span class="comment">// 阻塞线程直到计数归0或者超时；超时时间 默认300s</span></span><br><span class="line">                   interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                   <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123;    <span class="comment">// 如果 count 大于 0 说明是拦截器超时</span></span><br><span class="line">                       callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"The interceptor processing timed out."</span>));</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != postcard.getTag()) &#123;    <span class="comment">// 说明是某个拦截器中断了，导致整个流程中断</span></span><br><span class="line">                       callback.onInterrupt(<span class="keyword">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就通过</span></span><br><span class="line">                       callback.onContinue(postcard);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   callback.onInterrupt(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有拦截器 就通过</span></span><br><span class="line">       callback.onContinue(postcard);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Excute interceptor</span><br><span class="line">*</span><br><span class="line">* <span class="doctag">@param</span> index    current interceptor index</span><br><span class="line">* <span class="doctag">@param</span> counter  interceptor counter</span><br><span class="line">* <span class="doctag">@param</span> postcard routeMeta</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_excute</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index, <span class="keyword">final</span> CancelableCountDownLatch counter, <span class="keyword">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">       IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class="line">       iInterceptor.process(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// Last interceptor excute over with no exception.</span></span><br><span class="line">               counter.countDown();</span><br><span class="line">               <span class="comment">// 一个拦截器执行好后，执行下一个</span></span><br><span class="line">               _excute(index + <span class="number">1</span>, counter, postcard);  <span class="comment">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// Last interceptor excute over with fatal exception.</span></span><br><span class="line"></span><br><span class="line">               postcard.setTag(<span class="keyword">null</span> == exception ? <span class="keyword">new</span> HandlerException(<span class="string">"No message."</span>) : exception.getMessage());    <span class="comment">// save the exception message for backup.</span></span><br><span class="line">               <span class="comment">// 如果其中一个拦截器中断的话，就中断整个流程</span></span><br><span class="line">               counter.cancel();</span><br><span class="line">               <span class="comment">// Be attention, maybe the thread in callback has been changed,</span></span><br><span class="line">               <span class="comment">// then the catch block(L207) will be invalid.</span></span><br><span class="line">               <span class="comment">// The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!</span></span><br><span class="line"><span class="comment">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // You shouldn't throw the exception if the thread is main thread.</span></span><br><span class="line"><span class="comment">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上都加了注释了，这里就不再多讲了。</p>
<p>到这里整个 ARouter 拦截器的流程就差不多讲完了，如果还有哪里不懂的地方可以在评论区留言。</p>
<p>再见👋</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>前几天对 ARouter 的页面跳]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（一）]]></title>
    <link href="http://yuqirong.me/2018/12/24/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yuqirong.me/2018/12/24/ARouter源码解析（一）/</id>
    <published>2018-12-24T13:13:20.000Z</published>
    <updated>2019-03-04T16:26:45.373Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 ActivityRouter 的源码做了一次分析，相信大家对路由框架已经有一个大概的理解了。</p>
<p>而今天给大家分析一下 ARouter 。大家在项目组件化的过程中，可能绝大多数的开发者都会使用 ARouter 来作为项目的路由框架。毕竟 ARouter 是阿里出品，优点自然不必多说了。</p>
<p>所以在平常使用的过程中，不仅仅要做到会用，还要深入了解一下 ARouter 的内部原理。</p>
<p>本次 ARouter 的解析分为三部分：</p>
<ol>
<li>对 IRouteRoot 页面跳转进行源码解析；</li>
<li>对 IInterceptorGroup 拦截器进行源码解析；</li>
<li>对 @Autowired 自动注入进行源码解析；</li>
<li>对 ARouter 的 arouter-compiler 进行源码分析；</li>
<li>对 ARouter 的 arouter-register 进行源码分析；</li>
</ol>
<p>本篇是 ARouter 系列的第一篇，下面就对 IRouteRoot 页面跳转进行详细解析。</p>
<h1 id="ARouter__u6E90_u7801"><a href="#ARouter__u6E90_u7801" class="headerlink" title="ARouter 源码"></a>ARouter 源码</h1><p>使用 ARouter 的时候，都需要初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDebug()) &#123;          </span><br><span class="line">    ARouter.openLog();</span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure>
<p>源码分析的入口，就在 ARouter.init 里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = _ARouter.logger;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</span><br><span class="line">        hasInit = _ARouter.init(application);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            _ARouter.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码上可以看到，ARouter 的内部其实是 _ARouter 在起作用，ARouter 只是把 _ARouter 再做了一层包装。那么我们就跟进 _ARouter 的 init 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    mContext = application;</span><br><span class="line">    LogisticsCenter.init(mContext, executor);</span><br><span class="line">    logger.info(Consts.TAG, <span class="string">"ARouter init success!"</span>);</span><br><span class="line">    hasInit = <span class="keyword">true</span>;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的一句代码还是 <code>LogisticsCenter.init(mContext, executor)</code> ，其中 executor 是线程池。</p>
<p>那么问题来了， LogisticsCenter 是干什么的呢？</p>
<pre><code>* LogisticsCenter contains all of the map.
* 
* 1. Creates instance when it is first used.
* 2. Handler Multi-Module relationship map(*)
* 3. Complex logic to solve duplicate group definition
</code></pre><p>根据官方的注释，LogisticsCenter 是包含了所有的映射，处理跨模块的映射关系以及匹配路由等。</p>
<p>所以根据之前 ActivityRouter 的经验猜测得到，LogisticsCenter 的 init 方法里面，肯定会去加载路由，并建立关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    executor = tpe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startInit = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//billy.qi modified at 2017-12-06</span></span><br><span class="line">        <span class="comment">//load by plugin first</span></span><br><span class="line">        loadRouterMap();</span><br><span class="line">        <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">            logger.info(TAG, <span class="string">"Load router map by arouter-auto-register plugin."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是debug或者新版本的话，会去重新加载路由映射</span></span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"Run with debug mode or new install, rebuild router map."</span>);</span><br><span class="line">                <span class="comment">// 加载路由映射</span></span><br><span class="line">                routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                <span class="comment">// 保存所有的路由映射到 SharedPreferences</span></span><br><span class="line">                <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                    context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存新版本号到 sharedpreference</span></span><br><span class="line">                PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就从 SharedPreferences 中读取之前保存的所有路由映射</span></span><br><span class="line">                logger.info(TAG, <span class="string">"Load router map from cache."</span>);</span><br><span class="line">                routerMap = <span class="keyword">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.info(TAG, <span class="string">"Find router map finished, map size = "</span> + routerMap.size() + <span class="string">", cost "</span> + (System.currentTimeMillis() - startInit) + <span class="string">" ms."</span>);</span><br><span class="line">            startInit = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把上面加载得到的路由映射根据ClassName分为三种，分别进行注册</span></span><br><span class="line">            <span class="comment">// IRouteRoot 页面跳转</span></span><br><span class="line">            <span class="comment">// IInterceptorGroup 拦截器</span></span><br><span class="line">            <span class="comment">// IProviderGroup 服务组件</span></span><br><span class="line">            <span class="keyword">for</span> (String className : routerMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                    <span class="comment">// This one of root elements, load root.</span></span><br><span class="line">                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                    <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                    <span class="comment">// Load providerIndex</span></span><br><span class="line">                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init logistics center exception! ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogisticsCenter 的 init 方法的代码基本上都可以看得懂，其中 <code>ClassUtils.getFileNameByPackageName</code> 是我们值得探究的地方。这句代码主要做的事情就是从 dex 中遍历 class 找到 arouter-compiler 生成的类集合。具体的分析我们到最后面再讲，这里先埋个伏笔。</p>
<p>接着往下看，我们知道，routerMap 中的 className 都是 arouter-compiler 在编译期生成的，那我们先来看看生成的类长什么样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Root</span>$$<span class="title">app</span> <span class="keyword">implements</span> <span class="title">IRouteRoot</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class="line">    routes.put(<span class="string">"test"</span>, ARouter$$Group$$test.class);</span><br><span class="line">    routes.put(<span class="string">"yourservicegroupname"</span>, ARouter$$Group$$yourservicegroupname.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARouter 的路由会分组加载，比如当前有 /test/abc 和 /test/def 两个路由，那他们同属于 /test 这个组。所以在 Warehouse.groupsIndex 中存放的 key 是路由组名，value 是对应组路由类。查找路由的时候也是根据组名 key ，再找到组路由类 value 中查找匹配的路由。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">test</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/test/activity1"</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">"/test/activity1"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"ser"</span>, <span class="number">9</span>); put(<span class="string">"ch"</span>, <span class="number">5</span>); put(<span class="string">"fl"</span>, <span class="number">6</span>); put(<span class="string">"dou"</span>, <span class="number">7</span>); put(<span class="string">"boy"</span>, <span class="number">0</span>); put(<span class="string">"url"</span>, <span class="number">8</span>); put(<span class="string">"pac"</span>, <span class="number">10</span>); put(<span class="string">"obj"</span>, <span class="number">11</span>); put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"objList"</span>, <span class="number">11</span>); put(<span class="string">"map"</span>, <span class="number">11</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); put(<span class="string">"height"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity2"</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class="string">"/test/activity2"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"key1"</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity3"</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class="string">"/test/activity3"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"boy"</span>, <span class="number">0</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity4"</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class="string">"/test/activity4"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/fragment"</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class="string">"/test/fragment"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/webview"</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class="string">"/test/webview"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到路由相关的参数配置被构造成了一个 RouteMeta 对象。RouteMeta 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteMeta</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RouteType type;         <span class="comment">// Type of route</span></span><br><span class="line">    <span class="keyword">private</span> Element rawType;        <span class="comment">// Raw type of route</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; destination;   <span class="comment">// Destination</span></span><br><span class="line">    <span class="keyword">private</span> String path;            <span class="comment">// Path of route</span></span><br><span class="line">    <span class="keyword">private</span> String group;           <span class="comment">// Group of route</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority = -<span class="number">1</span>;      <span class="comment">// The smaller the number, the higher the priority</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> extra;              <span class="comment">// Extra data</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; paramsType;  <span class="comment">// Param type</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Autowired&gt; injectConfig;  <span class="comment">// Cache inject config.</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，加载路由的部分就完成了，剩下的就是跳转路由了。</p>
<p>跳转路由的通常操作：</p>
<pre><code>ARouter.getInstance().build(&quot;/test/abc&quot;).navigation();
</code></pre><p>那先看一下 ARouter 的 build 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().build(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面调用的是 _ARouter 的 build 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 PathReplaceService 实例，如果不为空，就处理 path</span></span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 截取跳转路径中的第一段作为分组名</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">extractGroup</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || !path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String defaultGroup = path.substring(<span class="number">1</span>, path.indexOf(<span class="string">"/"</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(defaultGroup)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Extract the default group failed! There's nothing between 2 '/'!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultGroup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, <span class="string">"Failed to extract default group! "</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PathReplaceService 是官方给我们预留的口子，用来对 path 做预处理。如果你有需求来对 path 做统一的预处理，那么直接实现 PathReplaceService 即可。</p>
<p>我们接着跟进，看下 <code>_ARouter.build(String path, String group)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 <code>build(String path, String group)</code> 中直接创建了一个 Postcard 对象并返回。Postcard 类是继承了 RouteMeta ，额外添加了一些其他的信息。</p>
<p>有了 Postcard 之后，直接调用 navigation 进行跳转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context context, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ARouter.getInstance().navigation(context, <span class="keyword">this</span>, -<span class="number">1</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">navigation</span><span class="params">(Activity mContext, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    ARouter.getInstance().navigation(mContext, <span class="keyword">this</span>, requestCode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postcard 的所有 navigation 方法最后都会调用 ARouter 的 navigation 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还是调用了 _ARouter.navigation </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 postcard 与路由表中进行匹配，并且填充 postcard 的数据</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">        <span class="comment">// 如果 debug ，就显示匹配错误</span></span><br><span class="line">        <span class="keyword">if</span> (debuggable()) &#123;</span><br><span class="line">            <span class="comment">// Show friendly tips for user.</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(mContext, <span class="string">"There's no route matched!\n"</span> +</span><br><span class="line">                            <span class="string">" Path = ["</span> + postcard.getPath() + <span class="string">"]\n"</span> +</span><br><span class="line">                            <span class="string">" Group = ["</span> + postcard.getGroup() + <span class="string">"]"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调路由匹配失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            <span class="comment">// 如果没有回调，就调用全局降级的策略</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调路由匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是绿色通道，就调用拦截器，拦截器这部分后面单独出来讲，这里就不讲了</span></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Continue process</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> postcard route meta</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Interrupt process, pipeline will be destory when this method called.</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> exception Reson of interrupt.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则调用 _navigation 进行跳转</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTIVITY: <span class="comment">// 如果是 activity 的，执行跳转</span></span><br><span class="line">            <span class="comment">// Build intent</span></span><br><span class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">            intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set flags.</span></span><br><span class="line">            <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                intent.setFlags(flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set Actions</span></span><br><span class="line">            String action = postcard.getAction();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                intent.setAction(action);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Navigation in main looper.</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROVIDER: <span class="comment">// 如果是服务组件，那么直接返回该组件</span></span><br><span class="line">            <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">        <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">        <span class="keyword">case</span> FRAGMENT: <span class="comment">// 如果是 fragment 的话，返回该 fragment 的实例</span></span><br><span class="line">            Class fragmentMeta = postcard.getDestination();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                    ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> METHOD:</span><br><span class="line">        <span class="keyword">case</span> SERVICE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上都写了注释，大家应该都能看懂。</p>
<p>我们重点来关注下 <code>LogisticsCenter.completion(postcard);</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先根据 path 去获取 RouteMeta</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// 如果 routeMeta 为空，可能是不存在或者是未加载</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// 加载分组下的路由映射</span></span><br><span class="line">        <span class="comment">// 如果不存在，就报错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] starts loading, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 实现按需加载</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                <span class="comment">// 移除 groupsIndex , 否则会造成死循环</span></span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] has already been loaded, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新加载一遍</span></span><br><span class="line">            completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到对应的 routeMeta， 填充 postcard 数据</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType());</span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="comment">// 如果 rawUri 不为空，则是 uri 跳转。就解析 rawUri 中的参数，放入 bundle 中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是 PROVIDER 和 FRAGMENT 类型的，开启绿色通道</span></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个路由跳转的流程就讲完了，大致的流程可以分为</p>
<ol>
<li>加载路由映射</li>
<li>根据 path 构造出 Postcard 对象</li>
<li>区分 Postcard 的 type 来实现跳转</li>
</ol>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>前面说过，ARouter 会在 dex 中寻找 arouter-compiler 生成的类。那我们最后来看看是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getFileNameByPackageName</span><span class="params">(Context context, <span class="keyword">final</span> String packageName)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; classNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取 dex 文件存放的路径</span></span><br><span class="line">    List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch parserCtl = <span class="keyword">new</span> CountDownLatch(paths.size());</span><br><span class="line">    <span class="comment">// 遍历所有 dex 文件的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String path : paths) &#123;</span><br><span class="line">        DefaultPoolExecutor.getInstance().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DexFile dexfile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据路径加载 dex 文件</span></span><br><span class="line">                    <span class="keyword">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class="line">                        <span class="comment">//NOT use new DexFile(path), because it will throw "permission error in /data/dalvik-cache"</span></span><br><span class="line">                        dexfile = DexFile.loadDex(path, path + <span class="string">".tmp"</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dexfile = <span class="keyword">new</span> DexFile(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 遍历 dexfile 的中所有 className 如果是 arouter 报名开头的，就加入到 classNames 中</span></span><br><span class="line">                    Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class="line">                    <span class="keyword">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class="line">                        String className = dexEntries.nextElement();</span><br><span class="line">                        <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">                            classNames.add(className);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                    Log.e(<span class="string">"ARouter"</span>, <span class="string">"Scan map file in dex files made error."</span>, ignore);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != dexfile) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            dexfile.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    parserCtl.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parserCtl.await();</span><br><span class="line"></span><br><span class="line">    Log.d(Consts.TAG, <span class="string">"Filter "</span> + classNames.size() + <span class="string">" classes by packageName &lt;"</span> + packageName + <span class="string">"&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span> classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看下 getSourcePaths 方法，看看它是怎么找 dex 文件路径的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getSourcePaths</span><span class="params">(Context context)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException </span>&#123;</span><br><span class="line">        ApplicationInfo applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sourcePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourcePaths.add(applicationInfo.sourceDir); <span class="comment">//add the default apk path</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//the prefix of extracted file, ie: test.classes</span></span><br><span class="line">        String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        如果VM已经支持了MultiDex，就不要去Secondary Folder加载 Classesx.zip了，那里已经么有了</span></span><br><span class="line"><span class="comment">//        通过是否存在sp中的multidex.version是不准确的，因为从低版本升级上来的用户，是包含这个sp配置的</span></span><br><span class="line">        <span class="keyword">if</span> (!isVMMultidexCapable()) &#123;</span><br><span class="line">            <span class="comment">//the total dex numbers</span></span><br><span class="line">            <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, <span class="number">1</span>);</span><br><span class="line">            File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">                <span class="comment">//for each dex file, ie: test.classes2.zip, test.classes3.zip...</span></span><br><span class="line">                String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">                File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">                <span class="keyword">if</span> (extractedFile.isFile()) &#123;</span><br><span class="line">                    sourcePaths.add(extractedFile.getAbsolutePath());</span><br><span class="line">                    <span class="comment">//we ignore the verify zip part</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> + extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是debug的，那么额外去加载下 instant run 中的dex文件路径</span></span><br><span class="line">        <span class="keyword">if</span> (ARouter.debuggable()) &#123; <span class="comment">// Search instant run support only debuggable</span></span><br><span class="line">            sourcePaths.addAll(tryLoadInstantRunDexFile(applicationInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sourcePaths;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更多的细节有兴趣的同学可以自己回去看，这里因为篇幅的原因就不过多讲这些了。</p>
<p>那么今天就到这里结束了，关于 ARouter 系列的更多源码解析，可以看接下来的两篇博客。</p>
<p>bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 ActivityRoute]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
