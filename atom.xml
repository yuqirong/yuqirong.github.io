<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2017-01-07T15:06:22.272Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[EventBus源码解析]]></title>
    <link href="http://yuqirong.me/2016/12/20/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/20/EventBus源码解析/</id>
    <published>2016-12-20T15:46:27.000Z</published>
    <updated>2017-01-07T15:06:22.272Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码。那就正好今天来说说 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的那些事儿。</p>
<p>EventBus 是什么呢（相信地球人都知道→_→）？</p>
<p>EventBus is a publish/subscribe event bus optimized for Android.</p>
<p>这是官方给的介绍，简洁、明了、霸气。翻译过来就是：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一种为 Android 而优化设计的发布/订阅事件总线。这官方的套词可能有些人看了还是不懂。。。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20161226232951.jpg" alt="???"></p>
<p>简单地举了栗子，<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 就好像一辆公交车（快上车，老司机要飙车 乀(ˉεˉ乀) ）。相对应的，发布事件就可以类比为乘客，订阅事件就好似接站服务的人。乘客想要到达指定目的地就必须上车乘坐该公交车，公交车会做统一配置管理每位乘客（发布事件流程）。达到目的地后，打开下车门，把乘客交任给接站服务的人做相应的处理（订阅事件流程）。不知道这个栗子你们懂不懂，反正我是懂了(￣ε ￣)。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170107005159.jpg" alt="快上车"></p>
<p>所以总的来说，对于一个事件，你只要关心发送和接收就行了，而其中的收集、分发等都交给 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 来处理，你不需要做任何事。不得不说这太方便了，能让代码更见简洁，大大降低了模块之间的耦合性。</p>
<h1 id="0002B__u4F7F_u7528_u65B9_u6CD5"><a href="#0002B__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0002B 使用方法"></a>0002B 使用方法</h1><p>现在，来看一下 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的使用方法，直接复制粘贴 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 中的例子：</p>
<ol>
<li><p>第一步，定义一个事件类 <code>MessageEvent</code> :</p>
<pre><code>public static class MessageEvent { 
    /* Additional fields if needed */ 
}
</code></pre></li>
<li><p>定义一个订阅方法，可以使用 <code>@Subscribe</code> 注解来指定订阅方法所在的线程：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    /* Do something */
};
</code></pre><p> 注册和反注册你的订阅方法。比如在 Android 中，Activity 和 Fragment 通常在如下的生命周期中进行注册和反注册：</p>
<pre><code>@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}
</code></pre></li>
</ol>
<p>3.发送事件：</p>
<pre><code>EventBus.getDefault().post(new MessageEvent());
</code></pre><p>可以看出 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 使用起来很简单，就这么几行代码解决了许多我们备受困扰的问题。那么接下来我们就深入 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码内部，一探究竟。</p>
<h1 id="0003B_EventBus"><a href="#0003B_EventBus" class="headerlink" title="0003B EventBus"></a>0003B EventBus</h1><p>在 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 上对于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 整体有一张示意图，很明确地画出了整个框架的设计原理：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170102003651.png" alt="EventBus示意图"></p>
<p>那么依据这张图，我们先从 “Publisher” 开始讲起吧。PS : 本文分析的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 源码版本为 3.0.0 。</p>
<h2 id="EventBus-getDefault_28_29"><a href="#EventBus-getDefault_28_29" class="headerlink" title="EventBus.getDefault()"></a>EventBus.getDefault()</h2><p>来看一下 <code>EventBus.getDefault()</code> 的源码（文件路径：org/greenrobot/eventbus/EventBus.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span><br><span class="line"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    <span class="comment">// key 为事件的类型，value 为所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// key 为某个订阅者，value 为该订阅者所有的事件类型</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 粘性事件的集合，key 为事件的类型，value 为该事件的对象</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 主线程事件发送者</span></span><br><span class="line">    mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 子线程事件发送者</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 异步线程事件发送者</span></span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 索引类的数量</span></span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 订阅方法查找者</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    <span class="comment">// 是否打印订阅者异常的日志，默认为 true</span></span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    <span class="comment">// 是否打印没有订阅者的异常日志，默认为 true</span></span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    <span class="comment">// 是否允许发送 SubscriberExceptionEvent ，默认为 true</span></span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    <span class="comment">// 是否允许发送 sendNoSubscriberEvent ，默认为 true</span></span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    <span class="comment">// 是否允许抛出订阅者的异常，默认是 false</span></span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    <span class="comment">// 是否支持事件继承，默认是 true</span></span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中可以看出，平时的我们经常调用的 <code>EventBus.getDefault()</code> 代码，其实是获取了 <code>Event</code> 类的单例。若该单例未实例化，那么会根据 <code>DEFAULT_BUILDER</code> 采用构造者模式去实例化该单例。在 <code>EventBus</code> 构造器中初始化了一堆的成员变量，这些都会在下面中使用到。</p>
<h2 id="register_28Object_subscriber_29"><a href="#register_28Object_subscriber_29" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h2><p>事件订阅者必须调用 <code>register(Object subscriber)</code> 方法来进行注册，一起来看看在 <code>register(Object subscriber)</code> 中到底做了一些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅者的类 class</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 找到该 class 下所有的订阅方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;		</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>register(Object subscriber)</code> 中，利用 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法找到订阅者 class 下所有的订阅方法，然后用 <code>for</code> 循环建立订阅关系。其中 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法我们暂时先不看了，跳过。在这里只要知道作用是找到该订阅者所有的订阅方法就好了。具体 <code>SubscriberMethodFinder</code> 的代码会在后面的章节中详细分析。</p>
<p>而 <code>SubscriberMethod</code> 其实就是订阅方法的包装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅的方法</span></span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="comment">// 订阅所在的线程</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">    <span class="comment">// 订阅事件的类型</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">    <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="comment">// 订阅是否是粘性的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">    <span class="comment">// 特定字符串，用来比较两个 SubscriberMethod 是否为同一个</span></span><br><span class="line">    String methodString;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是轮到了 <code>subscribe(subscriber, subscriberMethod)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅方法的事件类型</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// 根据订阅方法的事件类型得到所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 subscriptions 已经包含了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据该 subscriberMethod 优先级插入到 subscriptions 中</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入 subscribedEvents 中，key：订阅者  value：该订阅者的所有订阅事件的类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">    <span class="comment">// 如果订阅的方法支持 sticky</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">// 如果支持事件继承</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="comment">// 遍历 stickyEvents</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="comment">// 判断 eventType 类型是否是 candidateEventType 的父类</span></span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="comment">// 得到对应 eventType 的子类事件，类型为 candidateEventType</span></span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到之前 sticky 的事件，然后发送给 newSubscription</span></span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>subscribe(subscriber, subscriberMethod)</code> 方法主要就做了三件事：</p>
<ol>
<li>得到 <code>subscriptions</code> ，然后根据优先级把 <code>subscriberMethod</code> 插入到 <code>subscriptions</code> 中；</li>
<li>将 <code>eventType</code> 放入到 <code>subscribedEvents</code> 中；</li>
<li>如果订阅方法支持 <code>sticky</code> ，那么发送相关的粘性事件。</li>
</ol>
<p>粘性事件发送调用了 <code>checkPostStickyEventToSubscription(newSubscription, stickyEvent);</code> 。从方法的命名上来看，知道应该是事件发送到订阅者相关的代码。那么继续跟进代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程模式执行对应</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING: <span class="comment">// 和发送事件处于同一个线程</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN: <span class="comment">// 主线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND: <span class="comment">// 子线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC: <span class="comment">// 和发送事件处于不同的线程</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行订阅方法</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent)</code> 方法的内部调用了 <code>postToSubscription(Subscription subscription, Object event, boolean isMainThread)</code> 。主要的操作都在 <code>postToSubscription</code> 中。根据 <code>threadMode</code> 共分为四种：</p>
<ol>
<li>同一个线程：表示订阅方法所处的线程和发布事件的线程是同一个线程；</li>
<li>主线程：如果发布事件的线程是主线程，那么直接执行订阅方法；否则利用 Handler 回调主线程来执行；</li>
<li>子线程：如果发布事件的线程是主线程，那么调用线程池中的子线程来执行订阅方法；否则直接执行；</li>
<li>异步线程：无论发布事件执行在主线程还是子线程，都利用一个异步线程来执行订阅方法。</li>
</ol>
<p>这四种线程模式其实最后都会调用 <code>invokeSubscriber(Subscription subscription, Object event)</code> 方法通过反射来执行。至此，关于粘性事件的发送就告一段落了。</p>
<p>另外，在这里因篇幅原因就不对 <code>mainThreadPoster</code> 和 <code>backgroundPoster</code> 等细说了，可以自行回去看相关源码，比较简单。</p>
<h2 id="unregister_28Object_subscriber_29"><a href="#unregister_28Object_subscriber_29" class="headerlink" title="unregister(Object subscriber)"></a>unregister(Object subscriber)</h2><p>看完 <code>register(Object subscriber)</code> ，接下来顺便看看 <code>unregister(Object subscriber)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 subscriber 来找到 subscribedTypes</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">// 解除每个订阅的事件类型</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 typesBySubscriber 中移除</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞟了一眼 <code>unregister(Object subscriber)</code> 方法，我们基本上就已经知道其中做了什么。在之前 <code>register(Object subscriber)</code> 中 <code>subscriptionsByEventType</code> 和 <code>typesBySubscriber</code> 会对 <code>subscriber</code> 间接进行绑定。而在 <code>unregister(Object subscriber)</code> 会对其解绑，这样就防止了造成内存泄露的危险。</p>
<h2 id="post_28Object_event_29"><a href="#post_28Object_event_29" class="headerlink" title="post(Object event)"></a>post(Object event)</h2><p>最后，我们来分析下发送事件 <code>post(Object event)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前线程的 postingState</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">// 加入到队列中</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    <span class="comment">// 如果没有持续在发送事件，那么开始发送事件并一直保持发送ing</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 发送单个事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>post(Object event)</code> 中，首先根据 <code>currentPostingThreadState</code> 获取当前线程状态 <code>postingState</code> 。<code>currentPostingThreadState</code> 其实就是一个 <code>ThreadLocal</code> 类的对象，不同的线程根据自己独有的索引值可以得到相应属于自己的 <code>postingState</code> 数据。</p>
<p>然后把事件 <code>event</code> 加入到 <code>eventQueue</code> 队列中排队。只要 <code>eventQueue</code> 不为空，就不间断地发送事件。而发送单个事件的代码在 <code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中，我们跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    <span class="comment">// 得到事件的类型</span></span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="comment">// 是否找到订阅者</span></span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果支持事件继承</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 查找 eventClass 的所有父类和接口</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">// 依次向订阅方法类型为 eventClass 的父类或接口的发送事件</span></span><br><span class="line">            <span class="comment">// 只要其中有一个 postSingleEventForEventType 返回 true ，那么 subscriptionFound 就为 true</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送事件</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            <span class="comment">// 发送 NoSubscriberEvent 事件，可以自定义接收</span></span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中的代码逻辑还是比较清晰的，会根据 <code>eventInheritance</code> 分成两种：</p>
<ol>
<li>支持事件继承：得到 <code>eventClass</code> 的所有父类和接口，然后循环依次发送事件；</li>
<li>不支持事件继承：直接发送事件。</li>
</ol>
<p>另外，若找不到订阅者，在默认配置下还会发送 <code>NoSubscriberEvent</code> 事件。需要开发者自定义订阅方法接收这个事件。</p>
<p>关于发送的具体操作还是要到 <code>postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 得到订阅者</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 依次遍历订阅者</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送事件</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                <span class="comment">// 是否被取消了</span></span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果被取消，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看上面的代码，我们应该能发现一个重要的线索—— <code>postToSubscription</code> 。没错，就是上面讲解发送粘性事件中的 <code>postToSubscription</code> 方法。神奇地绕了一圈又绕回来了。</p>
<p>而 <code>postSingleEventForEventType</code> 方法做的事情只不过是遍历了订阅者，然后一个个依次调用 <code>postToSubscription</code> 方法，之后就是进入 <code>switch</code> 四种线程模式（<code>POSTING</code> 、<code>MAIN</code> 、<code>BACKGROUND</code> 和 <code>ASYNC</code>）并执行订阅者的订阅方法的逻辑了。这里就不重复讲了，具体可以查看上面发送粘性事件中的分析。</p>
<p>至此，整个 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 发布/订阅的原理就讲完了。<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一款典型的运行观察者模式的开源框架，设计巧妙，代码也通俗易懂，值得我们学习。</p>
<p>别以为到这里就本文结束了，可不要忘了，在前面我们还留下一个坑没填—— <code>SubscriberMethodFinder</code> 。想不想知道 <code>SubscriberMethodFinder</code> 到底是如何工作的呢？那还等什么，我们赶快进入下一章节。</p>
<h1 id="0004B_SubscriberMethodFinder"><a href="#0004B_SubscriberMethodFinder" class="headerlink" title="0004B SubscriberMethodFinder"></a>0004B SubscriberMethodFinder</h1><p><code>SubscriberMethodFinder</code> 的作用说白了其实就是寻找订阅者的订阅方法。正如在上面的代码中提到的那样， <code>findSubscriberMethods</code> 方法可以返回指定订阅者中的所有订阅方法。</p>
<h2 id="findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findSubscriberMethods(Class&lt;?&gt; subscriberClass)"></a>findSubscriberMethods(Class&lt;?&gt; subscriberClass)</h2><p>我们看下内部的源码（文件路径：org/greenrobot/eventbus/SubscriberMethodFinder.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果忽略索引，就根据反射来获取</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则使用索引</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放入缓存中</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有两种途径获取：<code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 和 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 。另外，还有缓存可以提高索引效率。</p>
<h2 id="findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingReflection(Class&lt;?&gt; subscriberClass)"></a>findUsingReflection(Class&lt;?&gt; subscriberClass)</h2><p>那么我们先来看看 <code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    <span class="comment">// 做初始化操作</span></span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射查找订阅方法</span></span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        <span class="comment">// 查找 clazz 的父类</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 findState 中的 subscriberMethods</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现一个新的类 <code>FindState</code> ，而 <code>FindState</code> 的作用可以对订阅方法做一些校验，以及查找到的所有订阅方法也是封装在 <code>FindState.subscriberMethods</code> 中的。另外，在 <code>SubscriberMethodFinder</code> 类内部还维持着一个 <code>FIND_STATE_POOL</code> ，可以循环利用，节省内存。</p>
<p>接着往下看，就发现了一个关键的方法： <code>findUsingReflectionInSingleClass(FindState findState)</code> 。根据这方法名可以知道反射获取订阅方法的操作就在这儿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 方法的修饰符只能为 public 并且不能是 static 和 abstract</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 订阅方法的参数只能有一个</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 @Subscribe 注解，如果注解不为空那就认为是订阅方法</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 将该 method 做校验</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 解析 @Subscribe 注解中的 threadMode</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">// 加入到 findState.subscriberMethods 中</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个个循环订阅者中的方法，筛选得到其中的订阅方法后，保存在 <code>findState.subscriberMethods</code> 中。最后在 <code>getMethodsAndRelease(FindState findState)</code> 方法中把 <code>findState.subscriberMethods</code> 返回。（这里就不对 <code>getMethodsAndRelease(FindState findState)</code> 做解析了，可以下去自己看代码，比较简单 *^ο^* ）</p>
<h2 id="findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingInfo(Class&lt;?&gt; subscriberClass)"></a>findUsingInfo(Class&lt;?&gt; subscriberClass)</h2><p>最后，剩下另外一种获取订阅方法的途径还没讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接获取 subscriberInfo 中的 SubscriberMethods</span></span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 subscriberInfo 没有，就通过反射的方式</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 SubscriberInfoIndex 来获取 SubscriberInfo</span></span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 中是通过 <code>SubscriberInfo</code> 类来获取订阅方法的；如果没有 <code>SubscriberInfo</code> ，就直接通过反射的形式来获取。那么 <code>SubscriberInfo</code> 又是如何得到的呢？还要继续跟踪到 <code>getSubscriberInfo(FindState findState)</code> 方法中。然后又有一个新的类蹦出来—— <code>SubscriberInfoIndex</code> 。那么 <code>SubscriberInfoIndex</code> 又是什么东东啊（文件路径：org/greenrobot/eventbus/meta/SubscriberInfoIndex.java）？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="function">SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进去后发现 <code>SubscriberInfoIndex</code> 只是一个接口而已，是不是感到莫名其妙。What the hell is it!</p>
<p>我们把这个疑问先放在心里，到 <code>EventBusPerformance</code> 这个 module 中，进入 build/generated/source/apt/debug/org/greenrobot/eventbusperf 目录下，发现有一个类叫 <code>MyEventBusIndex</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.SubscribeClassEventBusDefault.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEvent"</span>, TestEvent.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusBackground.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventBackgroundThread"</span>, TestEvent.class, ThreadMode.BACKGROUND),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusMain.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>MyEventBusIndex</code> 其实是 <code>SubscriberInfoIndex</code> 的实现类，并且是 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 自动生成的（根据注释可知这点）。而 <code>getSubscriberInfo(Class&lt;?&gt; subscriberClass)</code> 方法已经实现了，内部维持着一个 <code>SUBSCRIBER_INDEX</code> 的 <code>HashMap</code> ，用来保存订阅类的相关信息 <code>info</code> 。然后在需要的时候可以通过 <code>info</code> 快速返回 <code>SubscriberMethod</code> 。这样就达到了不用反射获取订阅方法的目的，提高了执行效率。</p>
<p>到了这里我们明白了上面关于 <code>SubscriberInfoIndex</code> 的疑问，但是又有一个新的疑问产生了：<code>MyEventBusIndex</code> 到底是如何生成的？想要解开这个疑问，我们就要去 <code>EventBusAnnotationProcessor</code> 类中寻找答案了。</p>
<h1 id="0005B_EventBusAnnotationProcessor"><a href="#0005B_EventBusAnnotationProcessor" class="headerlink" title="0005B EventBusAnnotationProcessor"></a>0005B EventBusAnnotationProcessor</h1><p>一看到 <code>EventBusAnnotationProcessor</code> ，菊花一紧，料想肯定逃不了注解。我们可以猜出个大概： <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 在编译时通过 <code>EventBusAnnotationProcessor</code> 寻找到所有标有 <code>@Subscribe</code> 注解的订阅方法，然后依据这些订阅方法自动生成像 <code>MyEventBusIndex</code> 一样的索引类代码，以此提高索引效率。</p>
<p>总体来说，这种注解的思路和 <a href="https://github.com/square/dagger" target="_blank" rel="external">Dagger</a> 、<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 等框架类似。想要了更多，可以阅读我的上一篇博客<a href="/2016/12/18/ButterKnife源码解析/">《ButterKnife源码分析》</a>。</p>
<p>在这里由于篇幅的原因只能简单粗略地解析 <code>EventBusAnnotationProcessor</code> 的源码了，还请多多谅解。</p>
<h2 id="process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)"></a>process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)</h2><p>我们简单地来分析一下 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Messager messager = processingEnv.getMessager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 省略一堆代码</span></span><br><span class="line">        <span class="comment">// 根据 @Subscribe 的注解得到所有订阅方法</span></span><br><span class="line">        collectSubscribers(annotations, env, messager);</span><br><span class="line">        <span class="comment">// 校验这些订阅方法，过滤掉不符合的</span></span><br><span class="line">        checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 生成索引类，比如 MyEventBusIndex</span></span><br><span class="line">            createInfoIndexFile(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">"No @Subscribe annotations found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writerRoundDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// IntelliJ does not handle exceptions nicely, so log and print a message</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Unexpected error in EventBusAnnotationProcessor: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> 方法中重要的代码就这么几行，其他不重要的代码都省略了。那现在我们顺着一个一个方法来看。</p>
<h2 id="collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29"><a href="#collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29" class="headerlink" title="collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)"></a>collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)</h2><p>我们先从 <code>collectSubscribers(annotations, env, messager);</code> 开始入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectSubscribers</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 根据注解去获得 elements</span></span><br><span class="line">        Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> ExecutableElement) &#123;</span><br><span class="line">                ExecutableElement method = (ExecutableElement) element;</span><br><span class="line">                <span class="keyword">if</span> (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    TypeElement classElement = (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    <span class="comment">// 添加该订阅方法</span></span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"@Subscribe is only valid for methods"</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHasNoErrors</span><span class="params">(ExecutableElement element, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法不能是 static 的</span></span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must not be static"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法要是 public 的</span></span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must be public"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数只能有一个</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must have exactly 1 parameter"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码做的事情就是根据注解获取了对应的方法，然后初步筛选了一些方法，放入 <code>methodsByClass</code> 中。</p>
<h2 id="checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29"><a href="#checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29" class="headerlink" title="checkForSubscribersToSkip(Messager messager, String myPackage)"></a>checkForSubscribersToSkip(Messager messager, String myPackage)</h2><p>得到这些初选的订阅方法后，就要进入 <code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 环节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForSubscribersToSkip</span><span class="params">(Messager messager, String myPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        TypeElement subscriberClass = skipCandidate;</span><br><span class="line">        <span class="keyword">while</span> (subscriberClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该订阅类是 public 的，可以通过</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是 private 或者 protected 的，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是默认修饰符，但是订阅类的包和索引类的包不是同一个包，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    <span class="keyword">if</span> (subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because class is not public"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because "</span> + skipCandidate +</span><br><span class="line">                                <span class="string">" has a non-public super class"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 校验订阅方法是否合格</span></span><br><span class="line">                <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">                    String skipReason = <span class="keyword">null</span>;</span><br><span class="line">                    VariableElement param = method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">                    TypeMirror typeMirror = getParamTypeMirror(param, messager);</span><br><span class="line">                    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">                            !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                        skipReason = <span class="string">"event type cannot be processed"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = <span class="string">"event type is not public"</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                            String msg = <span class="string">"Falling back to reflection because "</span> + skipReason;</span><br><span class="line">                            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += <span class="string">" (found in super class for "</span> + skipCandidate + <span class="string">")"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找父类</span></span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一句话来概括，<code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 做的事情就是如果这些订阅类中牵扯到不可见状态，那么就会被加入到 <code>classesToSkip</code> 中，导致后面生成索引类中跳过这些订阅类。</p>
<h2 id="createInfoIndexFile_28String_index_29"><a href="#createInfoIndexFile_28String_index_29" class="headerlink" title="createInfoIndexFile(String index)"></a>createInfoIndexFile(String index)</h2><p>经过筛选后，<code>EventBusAnnotationProcessor</code> 最终要生成一个索引类，具体的代码就在 <code>createInfoIndexFile(String index)</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInfoIndexFile</span><span class="params">(String index)</span> </span>&#123;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index);</span><br><span class="line">        <span class="keyword">int</span> period = index.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        String myPackage = period &gt; <span class="number">0</span> ? index.substring(<span class="number">0</span>, period) : <span class="keyword">null</span>;</span><br><span class="line">        String clazz = index.substring(period + <span class="number">1</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(sourceFile.openWriter());</span><br><span class="line">        <span class="comment">// 下面都是自动生成的代码</span></span><br><span class="line">        <span class="keyword">if</span> (myPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            writer.write(<span class="string">"package "</span> + myPackage + <span class="string">";\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.ThreadMode;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.HashMap;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.Map;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"/** This class is generated by EventBus, do not edit. */\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"public class "</span> + clazz + <span class="string">" implements SubscriberInfoIndex &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    static &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n"</span>);</span><br><span class="line">        writeIndexLines(writer, myPackage);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static void putIndex(SubscriberInfo info) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    @Override\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        if (info != null) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return info;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125; else &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return null;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"&#125;\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not write source for "</span> + index, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">//Silent</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeIndexLines</span><span class="params">(BufferedWriter writer, String myPackage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 如果是被包含在 classesToSkip 中的，就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (classesToSkip.contains(subscriberTypeElement)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成对应的 index</span></span><br><span class="line">        String subscriberClass = getClassString(subscriberTypeElement, myPackage);</span><br><span class="line">        <span class="keyword">if</span> (isVisible(myPackage, subscriberTypeElement)) &#123;</span><br><span class="line">            writeLine(writer, <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"putIndex(new SimpleSubscriberInfo("</span> + subscriberClass + <span class="string">".class,"</span>,</span><br><span class="line">                    <span class="string">"true,"</span>, <span class="string">"new SubscriberMethodInfo[] &#123;"</span>);</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement);</span><br><span class="line">            writeCreateSubscriberMethods(writer, methods, <span class="string">"new SubscriberMethodInfo"</span>, myPackage);</span><br><span class="line">            writer.write(<span class="string">"        &#125;));\n\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(<span class="string">"        // Subscriber not visible to index: "</span> + subscriberClass + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这几行代码应该很眼熟吧，<code>MyEventBusIndex</code> 就是从这个模子里“刻”出来的，都是写死的代码。不同的是在 <code>writeIndexLines(BufferedWriter writer, String myPackage)</code> 中会把之前包含在 <code>classesToSkip</code> 里的跳过，其他的都自动生成 index 。最后就能得到一个像 <code>MyEventBusIndex</code> 一样的索引类了。</p>
<p>另外补充一句，如果你想使用像 <code>MyEventBusIndex</code> 一样的索引类，需要在初始化 <code>EventBus</code> 时通过 <code>EventBus.builder().addIndex(new MyEventBusIndex()).build();</code> 形式来将索引类配置进去。</p>
<p>话已至此，整个 <code>EventBusAnnotationProcessor</code> 我们大致地分析了一遍。利用编译时注解的特性来生成索引类是一种很好的解决途径，避免了程序在运行时利用反射去获取订阅方法，提高了运行效率的同时又提高了逼格。</p>
<h1 id="0006B__u603B_u7ED3"><a href="#0006B__u603B_u7ED3" class="headerlink" title="0006B 总结"></a>0006B 总结</h1><p>从头到尾分析下来，发现 EventBus 真的是一款不错的开源框架，完美诠释了观察者模式。从之前的 2.0 版本到现在的 3.0 版本，加入了注解的同时也减少了反射，提高了性能，为此增添了不少的色彩。</p>
<p>与 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 相似的还有 <a href="https://github.com/square/otto" target="_blank" rel="external">Otto</a> 框架，当然现在业内也有不少使用 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 来实现具备发布/订阅功能的 “RxBus” 。对此我的看法是，如果是小型项目，可以使用 RxBus 来代替 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> ，但是一旦项目成熟起来，涉及到模块之前通信和解耦，那么还是使用更加专业的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 吧。毕竟若是新手想上手 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 还是需要一段时间的。</p>
<p>今天就到这了，对 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 有问题的同学可以留言，bye bye ！</p>
<h1 id="0007B_References"><a href="#0007B_References" class="headerlink" title="0007B References"></a>0007B References</h1><ul>
<li><a href="http://www.jianshu.com/p/f057c460c77e" target="_blank" rel="external">EventBus 3.0 源码分析</a></li>
<li><a href="https://segmentfault.com/a/1190000005089229?utm_source=tuicool&amp;utm_medium=referral#articleHeader11" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ButterKnife源码分析]]></title>
    <link href="http://yuqirong.me/2016/12/18/ButterKnife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/18/ButterKnife源码解析/</id>
    <published>2016-12-18T15:19:02.000Z</published>
    <updated>2016-12-18T16:58:46.683Z</updated>
    <content type="html"><![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而程序员一般都是懒惰了（懒惰促使人进步 ^ο^ ），所以就出现了很多可以减少重复工作的框架或者工具。比如今天要分析的主角—— <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> ，如果你做 Android 开发却没有听说过 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 那就 Out 啦。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 使用依赖注入的方式来减少程序员去编写一堆 <code>findViewById</code> 的代码，使用起来很方便。那么接下来就一步步地带你深入理解 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 框架。PS：最近写的博客篇幅都有点长，请耐心阅读！Logo 图镇楼！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161208143552.png" alt="butterknife_logo"></p>
<h1 id="0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0x02 ButterKnife 的使用方法"></a>0x02 ButterKnife 的使用方法</h1><p>我们先讲下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法：</p>
<ol>
<li><p>在 <code>app/build.gradle</code> 中添加依赖：</p>
<pre><code>dependencies {
  compile &apos;com.jakewharton:butterknife:8.4.0&apos;
  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;
}
</code></pre></li>
<li><p>在 <code>Activity</code> 中添加注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.user)</span><br><span class="line">  EditText username;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.pass)</span><br><span class="line">  EditText password;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@OnClick</span>(R.id.submit)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO onClick View...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// TODO Use fields...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用方法非常简单，不得不赞叹 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 实在是太方便了。彻底跟 <code>findViewById</code> say goodbye 啦。但是我们也认识到，如果一个框架使用起来越简单，那么这个框架内部做的事情就越多。所以在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 内部一定做了很多事情。</p>
<p>今天我们主要分析下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的三个部分：Annotation 、ButterKnifeProcessor 和 ButterKnife 。这三个部分就把整个 View 依赖注入的原理串联起来了。</p>
<p>准备好了吗？下面我们就一探究竟。（PS：本文分析的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 源码为 8.4.0 版本）</p>
<h1 id="0x03_Annotation"><a href="#0x03_Annotation" class="headerlink" title="0x03 Annotation"></a>0x03 Annotation</h1><p>我们先来看一下其中的注解部分。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的注解都在 butterknife-annotations 模块下：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161210153211.png" alt="butterknife注解"></p>
<p>发现我们平时常用的 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 都在里面。我们就挑 <code>@BindView</code> (路径：butterknife-annotations/butterknife/BindView.java) 来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(CLASS)</span><br><span class="line"><span class="annotation">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="annotation">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解都是用 <code>@interface</code> 来表示。在 BindView 注解的上面还有 <code>@Retention</code> 和 <code>@Target</code> 。</p>
<ul>
<li><code>@Retention</code> ：表示注解的保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS ；</li>
<li><code>@Target</code> ：表示可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有。</li>
</ul>
<p>所以我们可知，<code>@BindView</code> 是用来修饰 field 的，并且保留至编译时刻。内部有一个默认属性 <code>value</code> ，用来表示 View 的 id ，即平时程序中的 <code>R.id.xxx</code> 。</p>
<h1 id="0x04_ButterKnifeProcessor"><a href="#0x04_ButterKnifeProcessor" class="headerlink" title="0x04 ButterKnifeProcessor"></a>0x04 ButterKnifeProcessor</h1><p>如果只有 <code>@BindView</code> 是不行的，我们还需要去解析注解。如何去解析编译时的注解呢？我们可以创建一个继承自 <code>AbstractProcessor</code> 的注解处理器，然后实现相关方法。在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 中 <code>ButterKnifeProcessor</code> (路径：butterknife-compiler/butterknife/compiler/ButterKnifeProcessor.java) 就是用来解析这些注解的注解处理器。</p>
<h2 id="init_28ProcessingEnvironment_env_29"><a href="#init_28ProcessingEnvironment_env_29" class="headerlink" title="init(ProcessingEnvironment env)"></a>init(ProcessingEnvironment env)</h2><p>我们先来看看 <code>ButterKnifeProcessor</code> 中的 <code>init(ProcessingEnvironment env)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.init(env);</span><br><span class="line">	</span><br><span class="line">	String sdk = env.getOptions().get(OPTION_SDK_INT);</span><br><span class="line">	<span class="keyword">if</span> (sdk != <span class="keyword">null</span>) &#123;</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="keyword">this</span>.sdk = Integer.parseInt(sdk);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">	    env.getMessager()</span><br><span class="line">	        .printMessage(Kind.WARNING, <span class="string">"Unable to parse supplied minSdk option '"</span></span><br><span class="line">	            + sdk</span><br><span class="line">	            + <span class="string">"'. Falling back to API 1 support."</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到一些有用的工具类</span></span><br><span class="line">	elementUtils = env.getElementUtils();</span><br><span class="line">	typeUtils = env.getTypeUtils();</span><br><span class="line">	filer = env.getFiler();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	  trees = Trees.instance(processingEnv);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalArgumentException ignored) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>init</code> 中主要根据 <code>env</code> 得到一些工具类。其中的 <code>filter</code> 主要是用来生成 Java 代码，而 <code>elementUtils</code> 和 <code>typeUtils</code> 会在下面源码中用到。</p>
<h2 id="getSupportedAnnotationTypes_28_29"><a href="#getSupportedAnnotationTypes_28_29" class="headerlink" title="getSupportedAnnotationTypes()"></a>getSupportedAnnotationTypes()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(<span class="comment">//</span></span><br><span class="line">	OnCheckedChanged.class, <span class="comment">//</span></span><br><span class="line">	OnClick.class, <span class="comment">//</span></span><br><span class="line">	OnEditorAction.class, <span class="comment">//</span></span><br><span class="line">	OnFocusChange.class, <span class="comment">//</span></span><br><span class="line">	OnItemClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemSelected.class, <span class="comment">//</span></span><br><span class="line">	OnLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnPageChange.class, <span class="comment">//</span></span><br><span class="line">	OnTextChanged.class, <span class="comment">//</span></span><br><span class="line">	OnTouch.class <span class="comment">//</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回注解处理器支持处理的注解</span></span><br><span class="line">	Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">	  types.add(annotation.getCanonicalName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有的注解</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123;</span><br><span class="line">	Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	annotations.add(BindArray.class);</span><br><span class="line">	annotations.add(BindBitmap.class);</span><br><span class="line">	annotations.add(BindBool.class);</span><br><span class="line">	annotations.add(BindColor.class);</span><br><span class="line">	annotations.add(BindDimen.class);</span><br><span class="line">	annotations.add(BindDrawable.class);</span><br><span class="line">	annotations.add(BindFloat.class);</span><br><span class="line">	annotations.add(BindInt.class);</span><br><span class="line">	annotations.add(BindString.class);</span><br><span class="line">	annotations.add(BindView.class);</span><br><span class="line">	annotations.add(BindViews.class);</span><br><span class="line">	annotations.addAll(LISTENERS);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> annotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSupportedAnnotationTypes()</code> 方法的作用就是返回该注解处理器所支持处理的注解集合。在 <code>getSupportedAnnotations()</code> 中我们可以看到一些熟悉的注解，比如 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 等。</p>
<h2 id="process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)"></a>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</h2><p>接下来就是重头戏了，注解处理器中最重要的方法 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 。<code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 的代码看上去没几行，其实大部分都写在其他私有方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扫描所有注解，最后生成 map</span></span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line">	<span class="comment">// 遍历 bindingMap 并且通过 Filer 生成 Java 代码</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">	  TypeElement typeElement = entry.getKey();</span><br><span class="line">	  BindingSet binding = entry.getValue();</span><br><span class="line">	</span><br><span class="line">	  JavaFile javaFile = binding.brewJava(sdk);</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    javaFile.writeTo(filer);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来看 <code>process</code> 方法就干了两件事情：</p>
<ol>
<li>扫描所有的注解，然后生成以 <code>TypeElement</code> 为 key ，<code>BindingSet</code> 为 value 的 Map ；</li>
<li>根据生成的 Map ，遍历后通过 Filter 来生成对应的辅助类源码。PS：<a href="">ButterKnife</a> 使用了 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 来生成 Java 源码。如果对 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 不太熟悉，可以先阅读这篇文章 <a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">《javapoet——让你从重复无聊的代码中解放出来》</a> 。</li>
</ol>
<p>我们慢慢来看，先来分析一下 <code>findAndParseTargets(env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描所有的ButterKnife注解，并且生成以TypeElement为键，BindingSet为值的HashMap</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line">	Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	scanForRClasses(env);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略一堆解析各种注解的源码，这些源码做的事情和下面这个 for 循环一样</span></span><br><span class="line">	<span class="comment">// 所以只要看这个解析 @BindView 就够了</span></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Process each @BindView element.</span></span><br><span class="line">	<span class="comment">// 遍历所有被 @BindView 标注的元素</span></span><br><span class="line">	<span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">	  <span class="comment">// we don't SuperficialValidation.validateElement(element)</span></span><br><span class="line">	  <span class="comment">// so that an unresolved View type can be generated by later processing rounds</span></span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	    logParsingError(element, BindView.class, e);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看关于 <code>BindView</code> 的那个 for 循环，它会遍历所有被 <code>@BindView</code> 注解的属性，然后调用 <code>parseBindView</code> 方法。那么我们就先看到 <code>findAndParseTargets</code> 的前半段，一起跟进 <code>parseBindView</code> 的方法中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span><br><span class="line">      Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到注解 @BindView 元素所在的类元素</span></span><br><span class="line">    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start by verifying common generated code restrictions.</span></span><br><span class="line">    <span class="comment">// ---------- 类型校验逻辑 start ---------------</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在属性上，如果该属性是被 private 或者 static 修饰的，则出错</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在错误的包中，若包名以“android”或者“java”开头，则出错</span></span><br><span class="line">    <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">"fields"</span>, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that the target type extends from View.</span></span><br><span class="line">    TypeMirror elementType = element.asType();</span><br><span class="line">    <span class="keyword">if</span> (elementType.getKind() == TypeKind.TYPEVAR) &#123;</span><br><span class="line">      TypeVariable typeVariable = (TypeVariable) elementType;</span><br><span class="line">      elementType = typeVariable.getUpperBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断元素是不是View及其子类或者Interface</span></span><br><span class="line">    <span class="keyword">if</span> (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elementType.getKind() == TypeKind.ERROR) &#123;</span><br><span class="line">        note(element, <span class="string">"@%s field with unresolved type (%s) "</span></span><br><span class="line">                + <span class="string">"must elsewhere be generated as a View or interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error(element, <span class="string">"@%s fields must extend from View or be an interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">        hasError = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有错误 不执行下面代码</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------- 类型校验逻辑 end -----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assemble information on the field.  //得到被注解的注解值，即 R.id.xxx</span></span><br><span class="line">    <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">    <span class="comment">// 根据所在的类元素去查找 builder</span></span><br><span class="line">    BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">    <span class="comment">// 如果相应的 builder 已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 得到相对应的 View 绑定的属性名</span></span><br><span class="line">      String existingBindingName = builder.findExistingBindingName(getId(id));</span><br><span class="line">      <span class="comment">// 若该属性名已经存在，则说明之前已经绑定过，会报错</span></span><br><span class="line">      <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(element, <span class="string">"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没有对应的 builder ，就通过 getOrCreateBindingBuilder 方法生成，并且放入 builderMap 中</span></span><br><span class="line">      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到注解名</span></span><br><span class="line">    String name = element.getSimpleName().toString();</span><br><span class="line">    <span class="comment">// 得到注解元素的类型</span></span><br><span class="line">    TypeName type = TypeName.get(elementType);</span><br><span class="line">    <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line">    <span class="comment">// 根据 id ，添加相对应的 Field 的绑定信息</span></span><br><span class="line">    builder.addField(getId(id), <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    <span class="comment">// 添加到待 unbind 的序列中</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parseBindView</code> 方法中基本上都加了注释，在方法的开头会对该 <code>element</code> 去做校验。如果校验没通过的话，就没有下面代码的什么事了。若校验通过之后，生成该 <code>element</code> 所在的类元素对应的 builder ，builder 中添加相应的 Field 绑定信息，最后添加到待 unbind 的序列中去。</p>
<p>现在，我们回过头来看看 <code>findAndParseTargets(env)</code> 方法的后半段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 省略前半部分源码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Associate superclass binders with their subclass binders. This is a queue-based tree walk</span></span><br><span class="line">	<span class="comment">// which starts at the roots (superclasses) and walks to the leafs (subclasses).</span></span><br><span class="line">	Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</span><br><span class="line">	    <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entrySet());</span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!entries.isEmpty()) &#123;</span><br><span class="line">	  <span class="comment">// 一个个取出遍历</span></span><br><span class="line">	  Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</span><br><span class="line">	  <span class="comment">// 得到对应的 key 和 value</span></span><br><span class="line">	  TypeElement type = entry.getKey();</span><br><span class="line">	  BindingSet.Builder builder = entry.getValue();</span><br><span class="line">	  <span class="comment">// 找到该类元素的父元素</span></span><br><span class="line">	  TypeElement parentType = findParentType(type, erasedTargetNames);</span><br><span class="line">	  <span class="keyword">if</span> (parentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 生成 BindingSet ，放入 Map 中</span></span><br><span class="line">	    bindingMap.put(type, builder.build());</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    BindingSet parentBinding = bindingMap.get(parentType);</span><br><span class="line">	    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">	      <span class="comment">// 设置父元素的 BindingSet</span></span><br><span class="line">	      builder.setParent(parentBinding);</span><br><span class="line">	      bindingMap.put(type, builder.build());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	      <span class="comment">// Has a superclass binding but we haven't built it yet. Re-enqueue for later.</span></span><br><span class="line">	      <span class="comment">// 有父元素，但是父元素的 BindingSet 还没有被 build 出来，</span></span><br><span class="line">	      <span class="comment">// 所以再放入 entries 中等待遍历 </span></span><br><span class="line">	      entries.addLast(entry);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析结果都会存放在 bindingMap 中</span></span><br><span class="line">	<span class="keyword">return</span> bindingMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>findAndParseTargets(env)</code> 方法的后半段中，主要就是把之前的 <code>builderMap</code> 转换为了 <code>bindingMap</code> 并返回。</p>
<p>到了这里，我们把 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 做的第一件事情搞清楚了，下面就接着来看第二件事情了。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 遍历 <span class="keyword">bindingMap </span>并且通过 Filer 生成 Java 代码</span><br><span class="line"><span class="label">for</span> (<span class="preprocessor">Map</span>.Entry&lt;TypeElement, <span class="keyword">BindingSet&gt; </span><span class="preprocessor">entry</span> : <span class="keyword">bindingMap.entrySet()) </span>&#123;</span><br><span class="line">  TypeElement typeElement = <span class="preprocessor">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">  <span class="keyword">BindingSet </span><span class="keyword">binding </span>= <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  JavaFile javaFile = <span class="keyword">binding.brewJava(sdk);</span><br><span class="line"></span>  try &#123;</span><br><span class="line">    javaFile.writeTo(filer)<span class="comment">;</span></span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage())<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="brewJava_28int_sdk_29"><a href="#brewJava_28int_sdk_29" class="headerlink" title="brewJava(int sdk)"></a>brewJava(int sdk)</h2><p>从上面可以看到，遍历了之前得到的 <code>bindingMap</code> ，然后利用 <code>binding</code> 中的信息生成相应的 Java 源码。所以在 <code>binding.brewJava(sdk)</code> 这个方法是我们重点关注对象。那么就进入 <code>BindingSet</code> (路径：butterknife-compiler/butterknife/compiler/BindingSet.java) 这个类中去看看吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 JavaFile，添加相应的注释</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), createType(sdk))</span><br><span class="line">            .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>brewJava(int sdk)</code> 方法的代码竟然这么短 O_o ，就是利用了 <code>JavaFile.builder</code> 生成了一个 <code>JavaFile</code> 对象而已。但是我们发现其中有一个 <code>createType(int sdk)</code> 方法，隐隐约约感觉一定是这个方法在搞大事情。继续跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TypeSpec <span class="title">createType</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成类名为 bindingClassName 的公共类，比如 MainActivity_ViewBinding</span></span><br><span class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 是否修饰为 final ，默认是 false</span></span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">        result.addModifiers(FINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有父类的话，那么要继承父类</span></span><br><span class="line">        result.superclass(parentBinding.bindingClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有父类，那么实现 Unbinder 接口</span></span><br><span class="line">        result.addSuperinterface(UNBINDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个变量名为target，类型为targetTypeName的成员变量</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        result.addField(targetTypeName, <span class="string">"target"</span>, PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// Add a delegating constructor with a target type + view signature for reflective use.</span></span><br><span class="line">        <span class="comment">// 该生成的构造方法被 @deprecated ，一般作为反射使用</span></span><br><span class="line">        result.addMethod(createBindingViewDelegateConstructor(targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成构造方法，另外 findViewById 类似的代码都在这里生成</span></span><br><span class="line">    <span class="comment">// Xxxx_ViewBinding 一般都是执行这个方法生成构造器</span></span><br><span class="line">    result.addMethod(createBindingConstructor(targetTypeName, sdk));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings() || parentBinding == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//生成unBind方法</span></span><br><span class="line">        result.addMethod(createBindingUnbindMethod(result, targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>createType(int sdk)</code> 方法中，基本构建好了一个类的大概，其中对于构造器以及类似 <code>findViewById</code> 的操作都是在 <code>createBindingConstructor(targetTypeName, sdk)</code> 中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodSpec <span class="title">createBindingConstructor</span><span class="params">(TypeName targetType, <span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建构造方法，方法修饰符为 public ，并且添加注解为UiThread</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">            .addAnnotation(UI_THREAD)</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 如果有方法绑定，比如 @OnClick</span></span><br><span class="line">    <span class="keyword">if</span> (hasMethodBindings()) &#123;</span><br><span class="line">        <span class="comment">// 如果有，那么添加 targetType 类型，final 修饰，参数名为 target 的构造方法参数</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>, FINAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有，和上面比起来就少了一个 final 修饰符</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有注解的 View</span></span><br><span class="line">    <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// 那么添加 View source 参数</span></span><br><span class="line">        constructor.addParameter(VIEW, <span class="string">"source"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则添加 Context context 参数</span></span><br><span class="line">        constructor.addParameter(CONTEXT, <span class="string">"context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasUnqualifiedResourceBindings()) &#123;</span><br><span class="line">        <span class="comment">// Aapt can change IDs out from underneath us, just suppress since all will work at runtime.</span></span><br><span class="line">        constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)</span><br><span class="line">                .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"ResourceType"</span>)</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类，那么会根据不同情况调用不同的 super 语句</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentBinding.constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source.getContext())"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, context)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有绑定 Field 或者方法，那么添加 this.target = target 语句</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">"this.target = target"</span>);</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasViewLocal()) &#123;</span><br><span class="line">            <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">            constructor.addStatement(<span class="string">"$T view"</span>, VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">            <span class="comment">// 为 View 绑定生成类似于 findViewById 之类的代码</span></span><br><span class="line">            addViewBinding(constructor, binding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为 View 的集合或者数组绑定</span></span><br><span class="line">        <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">            constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 resource 资源的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T context = source.getContext()"</span>, CONTEXT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasResourceBindingsNeedingResource(sdk)) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T res = context.getResources()"</span>, RESOURCES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render(sdk));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> constructor.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码就生成了构造器，但是我们还是没有看到具体 <code>findViewById</code> 操作的代码。别急，这些代码都在 <code>addViewBinding(constructor, binding)</code> 里会看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewBinding</span><span class="params">(MethodSpec.Builder result, ViewBinding binding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (binding.isSingleFieldBinding()) &#123;</span><br><span class="line">        <span class="comment">// Optimize the common case where there's a single binding directly to a field.</span></span><br><span class="line">        FieldViewBinding fieldBinding = binding.getFieldBinding();</span><br><span class="line">        <span class="comment">// 注意这里直接使用了 target. 的形式，所以属性肯定是不能 private 的</span></span><br><span class="line">        CodeBlock.Builder builder = CodeBlock.builder()</span><br><span class="line">                .add(<span class="string">"target.$L = "</span>, fieldBinding.getName());</span><br><span class="line">        <span class="comment">// 下面都是 View 绑定的代码</span></span><br><span class="line">        <span class="keyword">boolean</span> requiresCast = requiresCast(fieldBinding.getType());</span><br><span class="line">        <span class="keyword">if</span> (!requiresCast &amp;&amp; !fieldBinding.isRequired()) &#123;</span><br><span class="line">            builder.add(<span class="string">"source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.add(<span class="string">"$T.find"</span>, UTILS);</span><br><span class="line">            builder.add(fieldBinding.isRequired() ? <span class="string">"RequiredView"</span> : <span class="string">"OptionalView"</span>);</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">"AsType"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">"(source, $L"</span>, binding.getId().code);</span><br><span class="line">            <span class="keyword">if</span> (fieldBinding.isRequired() || requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $S"</span>, asHumanDescription(singletonList(fieldBinding)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $T.class"</span>, fieldBinding.getRawType());</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.addStatement(<span class="string">"$L"</span>, builder.build());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</span><br><span class="line">    <span class="keyword">if</span> (requiredBindings.isEmpty()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.isBoundToRoot()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = $T.findRequiredView(source, $L, $S)"</span>, UTILS,</span><br><span class="line">                binding.getId().code, asHumanDescription(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addFieldBinding(result, binding);</span><br><span class="line">    <span class="comment">// OnClick 等监听事件绑定</span></span><br><span class="line">    addMethodBindings(result, binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个 <code>ButterKnifeProcessor</code> 解析注解、生成 Java 代码的流程就走完了。我们来看看生成的代码到底长成什么样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> T target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view2131427413;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> T target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.button, <span class="string">"field 'button' and method 'onClick'"</span>);</span><br><span class="line">    target.button = Utils.castView(view, R.id.button, <span class="string">"field 'button'"</span>, Button.class);</span><br><span class="line">    view2131427413 = view;</span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.onClick(p0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    target.tv = Utils.findRequiredViewAsType(source, R.id.tv, <span class="string">"field 'textView'"</span>, TextView.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="annotation">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line"></span><br><span class="line">    target.button = <span class="keyword">null</span>;</span><br><span class="line">    target.tv = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    view2131427413.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view2131427413 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不赞叹一句，<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 生成的代码跟我们手写的基本上没什么区别。<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 实在是太强大了 *^ο^* 。</p>
<h1 id="0x05_ButterKnife"><a href="#0x05_ButterKnife" class="headerlink" title="0x05 ButterKnife"></a>0x05 ButterKnife</h1><h2 id="bind_28_29"><a href="#bind_28_29" class="headerlink" title="bind()"></a>bind()</h2><p>通过之前介绍 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法，我们知道 View 绑定是通过调用 <code>ButterKnife.bind()</code> 方法来实现的。下面我们来看看其内部原理 (路径：butterknife/butterknife/ButterKnife.java) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">  View sourceView = target.getWindow().getDecorView();</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull View target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29"><a href="#createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29" class="headerlink" title="createBinding(@NonNull Object target, @NonNull View source)"></a>createBinding(@NonNull Object target, @NonNull View source)</h2><p>发现 <code>bind()</code> 方法内都会去调用 <code>createBinding(@NonNull Object target, @NonNull View source)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 target 的类名，比如 MainActivity </span></span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</span><br><span class="line">    <span class="comment">// 找到 target 对应的构造器</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建对应的对象</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Nullable</span> <span class="annotation">@CheckResult</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    <span class="comment">// 对构造器的查找进行了缓存，可以直接从 Map 中获取</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到对应的 class 对象，比如 MainActivity_ViewBinding</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = Class.forName(clsName + <span class="string">"_ViewBinding"</span>);</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="comment">// 得到对应的构造器</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded binding class and constructor."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行缓存</span></span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>createBinding(@NonNull Object target, @NonNull View source)</code> 方法做的事情就是根据 <code>target</code> 创建对应的 <code>targetClassName_ViewBinding</code> 。在 <code>targetClassName_ViewBinding</code> 的构造器中会把对应的 View 进行绑定（具体可以查看上面的 <code>MainActivity_ViewBinding</code> ）。而在 <code>findBindingConstructorForClass(Class&lt;?&gt; cls)</code> 方法中也使用了 <code>Class.forName()</code> 反射来查找 <code>Class</code> ，这也是无法避免的。但是仅限于一个类的第一次查找，之后都会从 <code>BINDINGS</code> 缓存中获取。</p>
<h1 id="0x06__u603B_u7ED3"><a href="#0x06__u603B_u7ED3" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>总体来说，<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 是一款十分优秀的依赖注入框架，方便，高效，减少代码量。最重要的是解放程序员的双手，再也不用去写无聊乏味的 <code>findViewById</code> 了 \(╯-╰)/ 。与 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 原理相似的，还有 <a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="external">androidannotations</a> 框架。感兴趣的同学可以自己研究一下。那么，今天的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 解析到这里就结束了。如果对此有问题或疑惑的同学可以留言，欢迎探讨。</p>
<p>Goodbye !~~</p>
<h1 id="0x07_References"><a href="#0x07_References" class="headerlink" title="0x07 References"></a>0x07 References</h1><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232205&amp;idx=1&amp;sn=6c24e6eef2b18f253284b9dd92ec7efb&amp;chksm=f1d9eaaec6ae63b82fd84f72c66d3759c693f164ff578da5dde45d367f168aea0038bc3cc8e8&amp;scene=0#wechat_redirect" target="_blank" rel="external">浅析ButterKnife</a></li>
<li><a href="http://dev.qq.com/topic/578753c0c9da73584b025875#rd" target="_blank" rel="external">深入理解 ButterKnife，让你的程序学会写代码</a></li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="external">公共技术点之 Java 注解 Annotation</a></li>
<li><a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">javapoet——让你从重复无聊的代码中解放出来</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android项目中集成React Native]]></title>
    <link href="http://yuqirong.me/2016/12/04/Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90React%20Native/"/>
    <id>http://yuqirong.me/2016/12/04/Android项目中集成React Native/</id>
    <published>2016-12-04T13:04:35.000Z</published>
    <updated>2016-12-14T14:52:19.621Z</updated>
    <content type="html"><![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Native的步骤"></a>集成React Native的步骤</h1><ol>
<li><p>运行以下命令 ：</p>
<pre><code>$ npm init
</code></pre><p> 生成 <code>package.json</code> ，下面给出一份 Demo ：</p>
<pre><code>{
  &quot;name&quot;: &quot;HelloWorld&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;main&quot;: &quot;index.android.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,
    &quot;test&quot;: &quot;jest&quot;
  },
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^15.4.1&quot;,
    &quot;react-native&quot;: &quot;^0.39.0&quot;
  }
}
</code></pre></li>
<li><p>运行以下命令安装 React Native , Android 项目根目录就生成了 <code>node_modules/</code> 文件夹：</p>
<pre><code>$ npm install --save react react-native
</code></pre><p> 在 <code>.gitignore</code> 中添加：</p>
<pre><code># node.js
node_modules/
npm-debug.log
</code></pre><p> 执行 <code>react-native upgrade</code> 可以更新已有组件。</p>
</li>
<li><p>运行以下命令生成 <code>.flowconfig</code> 文件：</p>
<pre><code>$ curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig
</code></pre></li>
<li><p>修改 <code>package.json</code> 中 <code>scripts</code> 的 <code>start</code> 部分：</p>
<pre><code>&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;
</code></pre></li>
<li><p>在 Android 项目的根目录下新建 <code>index.android.js</code> ：</p>
<pre><code>&apos;use strict&apos;;

import React from &apos;react&apos;;
import {
  AppRegistry,
  StyleSheet,
  Text,
  View
} from &apos;react-native&apos;;

class HelloWorld extends React.Component {
  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;Hello, World&lt;/Text&gt;
        &lt;Text&gt;Hello, React Native&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
}

AppRegistry.registerComponent(&apos;HelloWorld&apos;, () =&gt; HelloWorld);
</code></pre></li>
<li><p>在 <code>app/build.gradle</code> 中添加：</p>
<pre><code>defaultConfig {
    ...
    ndk {
        abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;
    }
}

dependencies {
    ...
    compile &quot;com.facebook.react:react-native:0.39.0&quot; // From node_modules.
}
</code></pre><p> react-native 依赖的版本和 <code>package.json</code> 中保持一致。</p>
</li>
<li><p>在 Android 项目根目录下的 <code>build.gradle</code> 文件添加如下内容：</p>
<pre><code>allprojects {
    repositories {
        maven {
            // All of React Native (JS, Android binaries) is installed from npm
            url &quot;$rootDir/node_modules/react-native/android&quot;
        }
    }
}
</code></pre></li>
<li><p>新建一个 <code>MyApplication</code> 继承自 <code>Application</code> ，在 <code>AndroidManifest.xml</code> 中修改成相应的 <code>MyApplication</code> ：</p>
<pre><code>public class MyApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage()
            );
        }

    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        SoLoader.init(this, /* native exopackage */ false);
    }

}
</code></pre></li>
<li><p>新建一个 <code>ReactNativeActivity</code> ，用来展示 React Native 的页面：</p>
<pre><code>public class ReactNativeActivity extends ReactActivity {

    @Override
    protected String getMainComponentName() {
        return &quot;HelloWorld&quot;;
    }

}
</code></pre><p> 其中 <code>getMainComponentName()</code> 返回的字符串要和 index.android.js 中的 <code>AppRegistry.registerComponent</code> 中保持一致。</p>
</li>
<li><p>在 <code>AndroidManifest.xml</code> 里需要添加相关内容</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;

&lt;activity android:name=&quot;.ReactNativeActivity&quot; /&gt;
&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;
</code></pre></li>
<li><p>启动服务。debug 模式下需要在 <code>package.json</code> 所在目录下执行 </p>
<pre><code>$ npm start
</code></pre><p>之后按照正常的 Android 程序调试即可。</p>
</li>
<li><p>发布正式包</p>
<p>JS Bundle 打包：</p>
<p>在 <code>app/src/main/</code> 下创建 <code>assets/</code> 文件夹，执行以下命令将 JS Bundle 保存到资源目录下</p>
<pre><code>$ react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/
</code></pre><p>在 <code>app/src/main/assets/</code> 下就会生成 <code>index.android.bundle</code> 文件。图片会生成在 <code>app/sec/main/res/drawable-mdpi/</code> 目录下。之后按照 Android 项目正常打包即可，但别忘了添加 React Native 的混淆：</p>
<pre><code>-dontobfuscate

# React Native

# Keep our interfaces so they can be used by other ProGuard rules.
# See http://sourceforge.net/p/proguard/bugs/466/
-keep,allowobfuscation @interface com.facebook.proguard.annotations.DoNotStrip
-keep,allowobfuscation @interface com.facebook.proguard.annotations.KeepGettersAndSetters
-keep,allowobfuscation @interface com.facebook.common.internal.DoNotStrip

# Do not strip any method/class that is annotated with @DoNotStrip
-keep @com.facebook.proguard.annotations.DoNotStrip class *
-keep @com.facebook.common.internal.DoNotStrip class *
-keepclassmembers class * {
    @com.facebook.proguard.annotations.DoNotStrip *;
    @com.facebook.common.internal.DoNotStrip *;
}

-keepclassmembers @com.facebook.proguard.annotations.KeepGettersAndSetters class * {
  void set*(***);
  *** get*();
}

-keep class * extends com.facebook.react.bridge.JavaScriptModule { *; }
-keep class * extends com.facebook.react.bridge.NativeModule { *; }
-keepclassmembers,includedescriptorclasses class * { native &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.UIProp &lt;fields&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactProp &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactPropGroup &lt;methods&gt;; }

-dontwarn com.facebook.react.**

# okhttp

-keepattributes Signature
-keepattributes *Annotation*
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }
-dontwarn okhttp3.**

# okio

-keep class sun.misc.Unsafe { *; }
-dontwarn java.nio.file.*
-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-dontwarn okio.**
</code></pre></li>
</ol>
<h1 id="u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898"><a href="#u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="在集成React Native中遇到的问题"></a>在集成React Native中遇到的问题</h1><h2 id="Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details"><a href="#Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details" class="headerlink" title="Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details."></a>Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See <a href="http://g.co/androidstudio/app-test-app-conflict" target="_blank" rel="external">http://g.co/androidstudio/app-test-app-conflict</a> for details.</h2><p>在 app/build.gradle 中添加如下：</p>
<pre><code>android {
    ...
    configurations.all {
        resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos;
    }
}
</code></pre><h2 id="Cannot_find_module__u2018invariant_u2019"><a href="#Cannot_find_module__u2018invariant_u2019" class="headerlink" title="Cannot find module ‘invariant’"></a>Cannot find module ‘invariant’</h2><p>在调用 <code>react-native init Test</code> 初始化某个项目时，抛出如下异常：</p>
<pre><code>$ react-native init Test
This may take some time...
This will walk you through creating a new React Native project in C:\Users\Administrator\Desktop\Test
Installing react-native package from npm...
module.js:327
    throw err;
    ^

Error: Cannot find module &apos;invariant&apos;
    at Function.Module._resolveFilename (module.js:325:15)
    at Function.Module._load (module.js:276:25)                
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.&lt;anonymous&gt; (C:/Users/Administrator/Desktop/Test/node_modules/react-native/packager/react-packager/src/node-haste/Module.js:18:19)
    at Module._compile (module.js:409:26)
    at loader (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:144:5)
    at Object.require.extensions.(anonymous function) [as .js] (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:154:7)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
</code></pre><p>解决方案：调用 <code>npm i --save-dev invariant</code> 命令，详见 <a href="https://github.com/facebook/react-native/issues/11327" target="_blank" rel="external">Cannot find module ‘invariant’ - react-native-cli</a></p>
<h2 id="java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019"><a href="#java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019" class="headerlink" title="java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’"></a>java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.<init\>()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’</init\></h2><p>在 React Native 程序运行时，报错：</p>
<pre><code>E/AndroidRuntime: FATAL EXCEPTION: AsyncTask #1
    Process: com.fanwei.reactnativeupdate, PID: 3139
    java.lang.RuntimeException: An error occured while executing doInBackground()
        at android.os.AsyncTask$3.done(AsyncTask.java:304)
        at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:355)
        at java.util.concurrent.FutureTask.setException(FutureTask.java:222)
        at java.util.concurrent.FutureTask.run(FutureTask.java:242)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
        at java.lang.Thread.run(Thread.java:818)
     Caused by: java.lang.IllegalAccessError: Method &apos;void android.support.v4.net.ConnectivityManagerCompat.&lt;init&gt;()&apos; is inaccessible to class &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; (declaration of &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; appears in /data/data/com.fanwei.reactnativeupdate/files/instant-run/dex/slice-com.facebook.react-react-native-0.20.1_3b7c8d9b91d5c989075fbd631ac74b192cee741b-classes.dex)
        at com.facebook.react.modules.netinfo.NetInfoModule.&lt;init&gt;(NetInfoModule.java:55)
        at com.facebook.react.shell.MainReactPackage.createNativeModules(MainReactPackage.java:67)
        at com.facebook.react.ReactInstanceManagerImpl.processPackage(ReactInstanceManagerImpl.java:793)
        at com.facebook.react.ReactInstanceManagerImpl.createReactContext(ReactInstanceManagerImpl.java:730)
        at com.facebook.react.ReactInstanceManagerImpl.access$600(ReactInstanceManagerImpl.java:91)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:184)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:169)
        at android.os.AsyncTask$2.call(AsyncTask.java:292)
        at java.util.concurrent.FutureTask.run(FutureTask.java:237)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231) 
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
        at java.lang.Thread.run(Thread.java:818) 
</code></pre><p>解决方案：修改依赖为 <code>com.android.support:appcompat-v7:23.0.1</code> ，详见 <a href="https://github.com/facebook/react-native/issues/6152" target="_blank" rel="external">Android java.lang.IllegalAccessError Method void android.support.v4.net.ConnectivityManagerCompat</a></p>
<h2 id="ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29"><a href="#ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29" class="headerlink" title="ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)"></a>ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)</h2><p>在调用命令 <code>npm start</code> 时，出现以下错误：</p>
<pre><code>ERROR  EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
{&quot;errno&quot;:-4048,&quot;code&quot;:&quot;EPERM&quot;,&quot;syscall&quot;:&quot;lstat&quot;,&quot;path&quot;:&quot;C:\\Users\\Administrator\\Desktop\\ReactNativeUpdate\\app\\build\\generated\\assets\\shaders\\debug&quot;}
Error: EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
    at Error (native)
</code></pre><p>解决方案：打开项目中 <code>node_modules/react-native/local-cli/server/server.js</code> 找到  <code>process.on(&#39;uncaughtException&#39;, error =&gt; {</code> 这个方法，把最后一句 <code>process.exit(11);</code> 注释掉。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://facebook.github.io/react-native/docs/integration-with-existing-apps.html" target="_blank" rel="external">Integration With Existing Apps</a></li>
<li><a href="http://www.lcode.org/react-native%e7%a7%bb%e6%a4%8d%e5%8e%9f%e7%94%9fandroid%e9%a1%b9%e7%9b%ae-%e5%b7%b2%e6%9b%b4%e6%96%b0%e7%89%88%e6%9c%ac/" target="_blank" rel="external">React Native移植原生Android项目-已更新版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Na]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley框架源码解析]]></title>
    <link href="http://yuqirong.me/2016/11/19/Volley%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/11/19/Volley框架源码解析/</id>
    <published>2016-11-19T13:19:17.000Z</published>
    <updated>2016-11-30T14:46:18.722Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用于网络请求非常频繁但是数据量并不是特别大的情景，正如它的名字一样。Volley 相比其他网络框架而言，采用了在 Android 2.3 以下使用 HttpClient ，而 Android 2.3 及以上使用 HttpUrlConnection 的方案。这是因为在 Android 2.3 以下时，HttpUrlConnection 并不完善，有很多 bug 存在。因此在 Android 2.3 以下最好使用 HttpClient 来进行网络通信；而在 Android 2.3 及以上，HttpUrlConnection 比起 HttpClient 来说更加简单易用，修复了之前的 bug 。所以在 Android 2.3 及以上我们使用 HttpUrlConnection 来进行网络通信。</p>
<p>除此之外，Volley 框架还具有优先级处理、可扩展性强等特点。虽然现在有 Retrofit 、OkHttp 等十分优秀的网络通信框架，但是深入理解 Volley 框架内部的思想可以大大提高我们自身的技术水平，毕竟仅仅停留在只会使用的阶段是不行的哦。那么，下面就进入我们今天的正题吧！（ ps ：本文篇幅过长，可能会引起不适，请在家长的陪同下观看）</p>
<h1 id="0010B"><a href="#0010B" class="headerlink" title="0010B"></a>0010B</h1><h2 id="Volley__u4F7F_u7528_u65B9_u6CD5"><a href="#Volley__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Volley 使用方法"></a>Volley 使用方法</h2><p>在长篇大论地解析 Volley 框架源码之前，我们先来看看平时是怎样使用 Volley 的。（大牛可直接跳过 -_- ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br><span class="line">JsonObjectRequest request = <span class="keyword">new</span> JsonObjectRequest(url, <span class="keyword">null</span>,</span><br><span class="line">        <span class="keyword">new</span> Response.Listener&lt;JSONObject&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line">            	<span class="comment">// TODO </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mQueue.add(request);</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Volley.newRequestQueue(context)</code> 来得到一个请求队列的对象 <code>mQueue</code>，在队列中暂存了我们所有 add 进去的 request ，之后一个个取出 request 来进行网络通信。一般来说，在一个应用程序中，只保持一个请求队列的对象。</p>
<p>之后创建了 JsonObjectRequest 对象用来请求 JSON 数据，并把它加入 <code>mQueue</code> 的队列中。Volley 框架的使用方法非常简单，并且有多种 request 请求方式可以选择，使用方法都是和上面类似的。</p>
<h1 id="0011B"><a href="#0011B" class="headerlink" title="0011B"></a>0011B</h1><p>在这先把 Volley 框架中几个重要的类的作用讲一下，以便看源码时能够更加明白：</p>
<ul>
<li>RequestQueue ：这个大家一看都明白，用来缓存 request 的请求队列，根据优先级高低排列；</li>
<li>Request ：表示网络请求，本身是一个抽象类，子类有 StringRequest 、JsonRequest 、ImageRequest 等；</li>
<li>Response ：表示网络请求后的响应，也是一个抽象类。内部定义了 Listener 、ErrorListener 接口；</li>
<li>NetworkResponse ：对返回的 HttpResponse 内容进行了封装，虽然类名和 Response 差不多，但是不是 Response 的子类；</li>
<li>CacheDispatcher ：一个处理请求缓存的线程。不断从 RequestQueue 中取出 Request ，然后取得该 Request 对应的缓存，若缓存存在就调用 ResponseDelivery 做后续分发处理；如果没有缓存或者缓存失效需要进入 NetworkDispatcher 中从网络上获取结果；</li>
<li>NetworkDispatcher ：一个处理网络请求的线程。和 CacheDispatcher 类似，从网络上得到响应后调用 ResponseDelivery 做后续分发处理。而且根据需求判断是否需要做缓存处理；</li>
<li>ResponseDelivery ：用作分发处理。利用 Handler 把结果回调到主线程中，即 Listener 、ErrorListener 接口。主要实现类为 ExecutorDelivery ；</li>
<li>HttpStack ：主要作用就是发起 Http 请求。子类分为 HurlStack 和 HttpClientStack ，分别对应着 HttpUrlConnection 和 HttpClient ；</li>
<li>Network ：处理 Stack 发起的 Http 请求，把 Request 转换为 Response ，主要实现类为 BasicNetwork ；</li>
<li>RetryPolicy ：请求重试策略。主要实现类为 DefaultRetryPolicy ；</li>
<li>Cache ：网络请求的缓存。在 CacheDispatcher 中获取 Cache ，在 NetworkDispatcher 中判断是否保存 Cache 。主要实现类为 DiskBasedCache ，缓存在磁盘中。</li>
</ul>
<h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h2><p>看完了之后，我们就要开始源码解析。我们入手点就是 <code>Volley.newRequestQueue(context)</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volley</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认的磁盘缓存目录名 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        <span class="comment">// 设置 UA</span></span><br><span class="line">        String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 Android SDK 版本设置 HttpStack ，分为 HurlStack 和 HttpClientStack</span></span><br><span class="line">        <span class="comment">// 分别对应着 HttpUrlConnection 和 HttpClient</span></span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">                <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到 network</span></span><br><span class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">        <span class="comment">// 创建 RequestQueue</span></span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面 Volley 类的源码中可知，Volley 类主要就是用来创建 RequestQueue 的。我们之前使用的 <code>newRequestQueue(Context context)</code> 方法最终会调用 <code>newRequestQueue(Context context, HttpStack stack)</code> 。Volley 允许我们使用自定义的 HttpStack ，从这也可以看出 Volley 具有很强的扩展性。</p>
<h2 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h2><p>接下来继续跟踪 RequestQueue 构造方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认线程池数量为 4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中创建了 ExecutorDelivery 对象，ExecutorDelivery 中传入的 Handler 为主线程的，方便得到 Response 后回调；NetworkDispatcher[] 数组对象，默认数组的长度为 4 ，也就意味着默认处理请求的线程最多为 4 个。</p>
<p>在 <code>Volley.newRequestQueue(Context context, HttpStack stack)</code> 中创建完 RequestQueue 对象 <code>queue</code> 之后，还调用了 <code>queue.start()</code> 方法。主要用于启动 <code>queue</code> 中的 <code>mCacheDispatcher</code> 和 <code>mDispatchers</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 请求缓存队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 网络请求队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// 确保当前 RequestQueue 中的 mCacheDispatcher 和 mDispatchers[] 是关闭的</span></span><br><span class="line">    <span class="comment">// 创建 mCacheDispatcher ，并且开启</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 mDispatchers[] 数组的长度创建 networkDispatcher ，并且开启</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前的 mCacheDispatcher 和 mDispatchers[]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCacheDispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatchers[i].quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove from the set of requests currently being processed.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">// 从 mCurrentRequests 中移除该 request</span></span><br><span class="line">        mCurrentRequests.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 request 是可以被缓存的，那么从 mWaitingRequests 中移除，加入到 mCacheQueue 中 	</span></span><br><span class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">            String cacheKey = request.getCacheKey();</span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</span><br><span class="line">                            waitingRequests.size(), cacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></span><br><span class="line">                <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></span><br><span class="line">                mCacheQueue.addAll(waitingRequests);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么看到这里我们意识到有必要看一下 CacheDispatcher 和 NetworkDispatcher 的代码。我们先暂且放一下，来看看 RequestQueue 的 <code>add</code> 方法。<code>add</code> 方法就是把 Request 加入到 RequestQueue 中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的 Set 集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">//加入到当前请求队列中</span></span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置序列号，该序列号为 AtomInteger 自增的值</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该 request 不该缓存，则直接加入 mNetworkQueue ，跳过下面的步骤</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">        <span class="comment">// 其实 cacheKey 就是 request 的 url</span></span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">// 如果该 mWaitingRequests 已经包含了有该 cacheKey</span></span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 得到该 cacheKey 对应的 Queue</span></span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            <span class="comment">// 把该 request 加入到 mWaitingRequests</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有，那么将该 request 加入到 mCacheQueue 中</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">            mCacheQueue.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>add(Request&lt;T&gt; request)</code> 方法中，额外使用了两个集合来维护 Request ，其中 </p>
<ul>
<li>mCurrentRequests ：用来维护正在做请求操作的 Request；</li>
<li>mWaitingRequests ：主要作用是如果当前有一个 Request 正在请求并且是可以缓存的，那么 Volley 会去 mWaitingRequests 中根据该 cacheKey 查询之前有没有一样的 Request 被加入到 mWaitingRequests 中。若有，那么该 Request 就不需要再被缓存了；若没有就加入到 mCacheQueue 中进行后续操作。</li>
</ul>
<p>现在我们来看看 CacheDispatcher 和 NetworkDispatcher 类的源码。</p>
<h2 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h2><p>首先是 CacheDispatcher 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 mCache ，读取磁盘中的缓存文件，加载到 mCache 中的 map 中</span></span><br><span class="line">        <span class="comment">// 会造成线程阻塞，要在子线程中调用</span></span><br><span class="line">        mCache.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从缓存队列中取出 request ，若没有则会阻塞</span></span><br><span class="line">                <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 被标记为取消，则跳过该 request ，不分发</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 request 的 url 去获得缓存</span></span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                    <span class="comment">// 没有缓存，把 Request 放入网络请求队列中 </span></span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若缓存失效，也放入网络请求队列中</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存存在，把缓存转换为 Response</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">                <span class="comment">// 判断缓存是否需要刷新</span></span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    <span class="comment">// 不需要刷新就直接让 mDelivery 分发</span></span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要刷新缓存</span></span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先设置一个标志，表明该缓存可以先分发，之后需要重新刷新</span></span><br><span class="line">                    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 利用 mDelivery 先把 response 分发下去，之后还要把该 request 加入到 mNetworkQueue 重新请求一遍</span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheDispatcher 类主要的代码就如上面所示了，在主要的 <code>run()</code> 方法中都添加了注释，阅读起来应该比较简单。那么在这里就贡献一张 CacheDispatcher 类的流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161122231354.png" alt="CacheDispatcher 类的流程图"></p>
<h2 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h2><p>然后是 NetworkDispatcher 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTrafficStatsTag</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 取出 request</span></span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否被取消，和 CacheDispatcher 中的步骤一致</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置线程标识</span></span><br><span class="line">                addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理网络请求</span></span><br><span class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果服务端返回 304 并且已经分发了一个响应，那么不再进行二次分发</span></span><br><span class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 得到 response</span></span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 需要进行缓存，那么保存缓存</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记该 request 对应的 response 正在分发中</span></span><br><span class="line">                request.markDelivered();</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 response</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAndDeliverNetworkError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        error = request.parseNetworkError(error);</span><br><span class="line">        mDelivery.postError(request, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，根据 NetworkDispatcher 我们也可以梳理出一张流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161123222635.png" alt="NetworkDispatcher 类的流程图"></p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>到这里，我们把目光转向 Request 。Request 是一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	...<span class="comment">// 省略绝大部分源码-_- !</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> VolleyError <span class="title">parseNetworkError</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> volleyError;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverError</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mErrorListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        mErrorListener.onErrorResponse(error);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// request 完成响应分发后调用 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="comment">// 跳转到 RequestQueue.finish 方法</span></span><br><span class="line">	        mRequestQueue.finish(<span class="keyword">this</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</span><br><span class="line">	        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">	        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">	            <span class="comment">// If we finish marking off of the main thread, we need to</span></span><br><span class="line">	            <span class="comment">// actually do it on the main thread to ensure correct ordering.</span></span><br><span class="line">	            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">	            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	                <span class="annotation">@Override</span></span><br><span class="line">	                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                    mEventLog.add(tag, threadId);</span><br><span class="line">	                    mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;);</span><br><span class="line">	            <span class="keyword">return</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        mEventLog.add(tag, threadId);</span><br><span class="line">	        mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">long</span> requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;</span><br><span class="line">	        <span class="keyword">if</span> (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">	            VolleyLog.d(<span class="string">"%d ms: %s"</span>, requestTime, <span class="keyword">this</span>.toString());</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Request&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">	    Priority left = <span class="keyword">this</span>.getPriority();</span><br><span class="line">	    Priority right = other.getPriority();</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// request 优先级高的比低的排在队列前面，优先被请求</span></span><br><span class="line">	    <span class="comment">// 如果优先级一样，按照 FIFO 的原则排列</span></span><br><span class="line">	    <span class="keyword">return</span> left == right ?</span><br><span class="line">	            <span class="keyword">this</span>.mSequence - other.mSequence :</span><br><span class="line">	            right.ordinal() - left.ordinal();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request 实现了 Comparable 接口，这是因为 Request 是有优先级的，优先级高比优先级低的要先响应，排列在前。默认有四种优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">    LOW,</span><br><span class="line">    NORMAL,</span><br><span class="line">    HIGH,</span><br><span class="line">    IMMEDIATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，子类继承 Request 还要实现两个抽象方法：</p>
<ul>
<li>parseNetworkResponse ：把 NetworkResponse 转换为合适类型的 Response；</li>
<li>deliverResponse ：把解析出来的类型分发给监听器回调。</li>
</ul>
<p>另外，Request 还支持八种请求方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Supported request methods.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEPRECATED_GET_OR_POST = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> GET = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> POST = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PUT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> DELETE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> HEAD = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> OPTIONS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> TRACE = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> PATCH = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Volley 中，Request 的子类众多，有 StringRequest 、JsonObjectRequest(继承自  JsonRequest ) 、JsonArrayRequest(继承自  JsonRequest ) 和 ImageRequest 等。当然这些子类并不能满足全部的场景要求，而这就需要我们开发者自己动手去扩展了。</p>
<p>下面我就分析一下 StringRequest 的源码，其他子类的源码都是类似的，可以回去自行研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Listener&lt;String&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,</span><br><span class="line">            ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到相应的 response 后，回调 Listener 的接口</span></span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">        String parsed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把字节数组转化为字符串</span></span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));(response.headers));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 StringRequest 的源码十分简洁。在 <code>parseNetworkResponse</code> 方法中主要把 response 中的 data 转化为对应的 String 类型。然后回调 <code>Response.success</code> 即可。</p>
<p>看完了 Request 之后，我们来分析一下 Network 。</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Network 是一个接口，里面就一个方法 <code>performRequest(Request&lt;?&gt; request)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光看这个方法的定义就知道这个方法是用来干什么了！就是根据传入的 Request 执行，转换为对应的 NetworkResponse 的，并且该 NetworkResponse 不为空。我们就跳到它的实现类中看看该方法具体是怎么样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = VolleyLog.DEBUG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SLOW_REQUEST_THRESHOLD_MS = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HttpStack mHttpStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteArrayPool mPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 ByteArrayPool 可以实现复用，节约内存</span></span><br><span class="line">        <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">        mHttpStack = httpStack;</span><br><span class="line">        mPool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">            Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 得到请求头</span></span><br><span class="line">                Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                <span class="comment">// 添加缓存头部信息</span></span><br><span class="line">                addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">                httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">                <span class="comment">// 得到响应行</span></span><br><span class="line">                StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">                <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">                <span class="comment">// 转化得到响应头</span></span><br><span class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">                <span class="comment">// 如果返回的状态码是304（即：HttpStatus.SC_NOT_MODIFIED）</span></span><br><span class="line">                <span class="comment">// 那么说明服务端的数据没有变化，就直接从之前的缓存中取</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                            request.getCacheEntry() == <span class="keyword">null</span> ? <span class="keyword">null</span> : request.getCacheEntry().data,</span><br><span class="line">                            responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">                <span class="comment">// 有一些响应可能没有内容，比如，所以要判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把 entiity 转为 byte[]</span></span><br><span class="line">                  responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                  <span class="comment">// no-content request.</span></span><br><span class="line">                  responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS(即 3000ms) ，会打印相应的日志</span></span><br><span class="line">                <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">                <span class="comment">// 响应码不是在 200-299 之间就抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">                NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">                <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                            responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                        <span class="comment">// 启动重试策略, 认证错误</span></span><br><span class="line">                        attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                                request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 如果请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS ，就打印相应的日志</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logSlowRequests</span><span class="params">(<span class="keyword">long</span> requestLifetime, Request&lt;?&gt; request,</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents, StatusLine statusLine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">            VolleyLog.d(<span class="string">"HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], "</span> +</span><br><span class="line">                    <span class="string">"[rc=%d], [retryCount=%s]"</span>, request, requestLifetime,</span><br><span class="line">                    responseContents != <span class="keyword">null</span> ? responseContents.length : <span class="string">"null"</span>,</span><br><span class="line">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 进行重试策略，如果不满足重试的条件会抛出异常</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span><br><span class="line">            VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = request.getRetryPolicy();</span><br><span class="line">        <span class="keyword">int</span> oldTimeout = request.getTimeoutMs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            retryPolicy.retry(exception);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">            request.addMarker(</span><br><span class="line">                    String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在请求行中添加缓存相关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">            headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">            headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(String what, String url, <span class="keyword">long</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">        VolleyLog.v(<span class="string">"HTTP ERROR(%s) %d ms to fetch %s"</span>, what, (now - start), url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**把 HttpEntity 的内容读取到 byte[] 中. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</span><br><span class="line">        PoolingByteArrayOutputStream bytes =</span><br><span class="line">                <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = entity.getContent();</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = mPool.getBuf(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></span><br><span class="line">                entity.consumeContent();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// This can happen if there was an exception above that left the entity in</span></span><br><span class="line">                <span class="comment">// an invalid state.</span></span><br><span class="line">                VolleyLog.v(<span class="string">"Error occured when calling consumingContent"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPool.returnBuf(buffer);</span><br><span class="line">            bytes.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 把 Headers[] 转换为 Map&lt;String, String&gt;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line">            result.put(headers[i].getName(), headers[i].getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把 BasicNetwork 的源码全部看下来，发现 BasicNetwork 干的事情就如下：</p>
<ul>
<li>利用 HttpStack 执行请求，把响应 HttpResponse 封装为 NetworkResponse ;</li>
<li>如果在这过程中出错，会有重试策略。</li>
</ul>
<p>至于 NetworkResponse 的源码在这里就不分析了，主要是一个相对于 HttpResponse 的封装类，可以自己去看其源码。</p>
<p>得到 NetworkResponse 之后，在 NetworkDispatcher 中经过 Request 的 <code>parseNetworkResponse</code> 方法把 NetworkResponse 转化为了 Response 。(具体可参考上面分析的 NetworkDispatcher 和 StringRequest 源码)</p>
<p>那么接下来就把目光转向 Response 吧。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 类的源码比较简单，一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应结果的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** Called when a response is received. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应错误的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Callback method that an error has been occurred with the</span><br><span class="line">         * provided error code and optional user-readable message.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过这个静态方法构造 Response */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">success</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(result, cacheEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过这个静态方法构造错误的 Response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">error</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Parsed response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache metadata for this response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Cache.Entry cacheEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detailed error information if &lt;code&gt;errorCode != OK&lt;/code&gt;. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> VolleyError error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if this response was a soft-expired one and a second one MAY be coming. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> intermediate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 是否成功</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = cacheEntry;</span><br><span class="line">        <span class="keyword">this</span>.error = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Response 类主要通过 <code>success</code> 和 <code>error</code> 两个方法分别来构造正确的响应结果和错误的响应结果。另外，在 Response 类中还有 Listener 和 ErrorListener 两个接口。在最终的回调中会使用到它们。</p>
<p>在得到了 Response 之后，就要使用 ResponseDelivery 来分发了。那下面就轮到 ResponseDelivery 了，go on !!</p>
<h2 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的response ，runnable 会在分发之后执行</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 错误的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 的接口就定义了三个方法，我们需要在其实现类中看看具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 用来分发 Response , 一般都是在主线程中*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 传入的 Handler 为主线程的</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                handler.post(command);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a new response delivery interface, mockable version</span><br><span class="line">     * for testing.</span><br><span class="line">     * <span class="doctag">@param</span> executor For running delivery tasks</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"post-error"</span>);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A Runnable 用来分发 response 到主线程的回调接口中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 request 被标记为取消，那么不用分发</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 mResponse 是否成功来分发到不同的方法</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">            <span class="comment">// and the request can be finished. </span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行 mRunnable</span></span><br><span class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 将根据 mResponse 是否成功来调用不同的方法 <code>mRequest.deliverResponse</code> 和 <code>mRequest.deliverError</code> 。在 <code>mRequest.deliverResponse</code> 中会回调 Listener 的 <code>onResponse</code> 方法；而在 <code>mRequest.deliverError</code> 中会回调 ErrorListener 的 <code>onErrorResponse</code> 方法。至此，一个完整的网络请求及响应流程走完了。</p>
<h2 id="HttpStack"><a href="#HttpStack" class="headerlink" title="HttpStack"></a>HttpStack</h2><p>现在回过头来看看 Volley 框架中是如何发起网络请求的。在本文的开头中说过，Volley 是会根据 Android 的版本来选择对应的 HttpStack。那么下面我们来深入看一下 HttpStack 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过所给的参数执行请求</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpStack 接口中定义的方法就只有一个。我们要分别来看看 HurlStack 和 HttpClientStack 各自的实现。</p>
<p>HurlStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 把请求头放入 map 中</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="comment">// 使用 HttpURLConnection 来发起请求</span></span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求方法</span></span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把响应封装进 response 中</span></span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpClientStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求方法生成对应的 HttpUriRequest</span></span><br><span class="line">    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">    addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">    addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">    onPrepareRequest(httpRequest);</span><br><span class="line">    HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></span><br><span class="line">    <span class="comment">// data collection and possibly different for wifi vs. 3G.</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">5000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">    <span class="keyword">return</span> mClient.execute(httpRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里只给出 HurlStack 和 HttpClientStack 的 <code>performRequest</code> 方法。我们可以看到 HurlStack 和 HttpClientStack 已经把 HttpUrlConnection 和 HttpClient 封装得很彻底了，以后哪里有需要的地方可以直接使用。</p>
<h2 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h2><p>RetryPolicy 接口主要的作用就是定制重试策略，我们从下面的源码可以看出该接口有三个抽象方法：</p>
<ul>
<li>getCurrentTimeout ：得到当前超时时间；</li>
<li>getCurrentRetryCount ：得到当前重试的次数；</li>
<li>retry ：是否进行重试，其中的 <code>error</code> 参数为异常的信息。若在 <code>retry</code> 方法中跑出 <code>error</code> 异常，那 Volley 就会停止重试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current timeout (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current retry count (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Prepares for the next retry by applying a backoff to the timeout.</span><br><span class="line">     * <span class="doctag">@param</span> error The error code of the last attempt.</span><br><span class="line">     * <span class="doctag">@throws</span> VolleyError In the event that the retry could not be performed (for example if we</span><br><span class="line">     * ran out of attempts), the passed in error is thrown.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetryPolicy 接口有一个默认的实现类 DefaultRetryPolicy ，DefaultRetryPolicy 的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The default socket timeout in milliseconds */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default number of retries */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default backoff multiplier */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a new retry policy.</span><br><span class="line"> * <span class="doctag">@param</span> initialTimeoutMs The initial timeout for the policy.</span><br><span class="line"> * <span class="doctag">@param</span> maxNumRetries The maximum number of retries.</span><br><span class="line"> * <span class="doctag">@param</span> backoffMultiplier Backoff multiplier for the policy.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</span><br><span class="line">    mCurrentTimeoutMs = initialTimeoutMs;</span><br><span class="line">    mMaxNumRetries = maxNumRetries;</span><br><span class="line">    mBackoffMultiplier = backoffMultiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，在 Volley 内部已经有一套默认的参数配置了。当然，你也可以通过自定义的形式来设置重试策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="comment">// 重试次数自增</span></span><br><span class="line">    mCurrentRetryCount++;</span><br><span class="line">    <span class="comment">// 超时时间自增，mBackoffMultiplier 为超时时间的因子</span></span><br><span class="line">    mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">    <span class="comment">// 如果超过最大次数，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns true if this policy has attempts remaining, false otherwise.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>分析完了前面这么多的类，终于轮到了最后的 Cache 。Cache 接口中定义了一个内部类 Entry ，还有定义了几个方法：</p>
<ul>
<li>get(String key) ：根据传入的 <code>key</code> 来获取 entry ；</li>
<li>put(String key, Entry entry) ：增加或者替换缓存；</li>
<li>initialize() ：初始化，是耗时的操作，在子线程中调用；</li>
<li>invalidate(String key, boolean fullExpire) ：根据 <code>key</code> 使之对应的缓存失效；</li>
<li>remove(String key) ：根据 <code>key</code> 移除某个缓存；</li>
<li>clear() ：清空缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieves an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@return</span> An &#123;<span class="doctag">@link</span> Entry&#125; or null in the event of a cache miss</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Adds or replaces an entry to the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> entry Data to store and metadata for cache coherency, TTL, etc.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs any potentially long-running actions needed to initialize the cache;</span><br><span class="line">     * will be called from a worker thread.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Invalidates an entry in the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> fullExpire True to fully expire the entry, false to soft expire</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Removes an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Empties the cache.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类 Entry ，Entry 中有一个属性为 etag ，上面的源码中也有 etag 的身影。如果你对 ETag 不熟悉，可以查看这篇文章<a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">《Etag与HTTP缓存机制》</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 缓存中数据，即响应中的 body */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HTTP头部的一个定义，允许客户端进行缓存协商 */</span></span><br><span class="line">    <span class="keyword">public</span> String etag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 服务端响应的时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存过期的时间，若小于当前时间则过期 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存的有效时间，若小于当前时间则可以进行刷新操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 响应的头部信息 */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否有效，若返回 true 则缓存失效. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否需要刷新 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了 Cache 接口之后，我们来看一下实现类 DiskBasedCache 。首先是它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DISK_USAGE_BYTES = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory, <span class="keyword">int</span> maxCacheSizeInBytes)</span> </span>&#123;</span><br><span class="line">    mRootDirectory = rootDirectory;</span><br><span class="line">    mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法中传入的参数可知，Volley 默认最大磁盘缓存为 5M 。</p>
<p>DiskBasedCache 的 <code>get(String key)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到对应的缓存摘要信息</span></span><br><span class="line">    CacheHeader entry = mEntries.get(key);</span><br><span class="line">    <span class="comment">// if the entry does not exist, return.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到缓存文件</span></span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="comment">// CountingInputStream 为自定义的 IO 流，继承自 FilterInputStream</span></span><br><span class="line">    <span class="comment">// 具有记忆已读取的字节数的功能</span></span><br><span class="line">    CountingInputStream cis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cis = <span class="keyword">new</span> CountingInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        CacheHeader.readHeader(cis); <span class="comment">// eat header</span></span><br><span class="line">        <span class="comment">// 得到缓存中的数据 data[] </span></span><br><span class="line">        <span class="keyword">byte</span>[] data = streamToBytes(cis, (<span class="keyword">int</span>) (file.length() - cis.bytesRead));</span><br><span class="line">        <span class="keyword">return</span> entry.toCacheEntry(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"%s: %s"</span>, file.getAbsolutePath(), e.toString());</span><br><span class="line">        <span class="comment">// 若出错则移除缓存</span></span><br><span class="line">        remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 url 分成两半，分别得到对应的 hashcode ，拼接后得到对应的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFilenameForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstHalfLength = key.length() / <span class="number">2</span>;</span><br><span class="line">    String localFilename = String.valueOf(key.substring(<span class="number">0</span>, firstHalfLength).hashCode());</span><br><span class="line">    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">    <span class="keyword">return</span> localFilename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a file object for the given cache key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFileForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(mRootDirectory, getFilenameForKey(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiskBasedCache 的 <code>putEntry(String key, CacheHeader entry)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查磁盘空间是否足够，若不够会删除一些缓存文件</span></span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</span><br><span class="line">        e.writeHeader(fos);</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deleted = file.delete();</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(String key, CacheHeader entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算总缓存的大小</span></span><br><span class="line">    <span class="keyword">if</span> (!mEntries.containsKey(key)) &#123;</span><br><span class="line">        mTotalSize += entry.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHeader oldEntry = mEntries.get(key);</span><br><span class="line">        mTotalSize += (entry.size - oldEntry.size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加或者替换缓存</span></span><br><span class="line">    mEntries.put(key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initialize()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRootDirectory.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRootDirectory.mkdirs()) &#123;</span><br><span class="line">            VolleyLog.e(<span class="string">"Unable to create cache dir %s"</span>, mRootDirectory.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取缓存文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 得到缓存文件的摘要信息</span></span><br><span class="line">            CacheHeader entry = CacheHeader.readHeader(fis);</span><br><span class="line">            entry.size = file.length();</span><br><span class="line">            <span class="comment">// 放入 map 中</span></span><br><span class="line">            putEntry(entry.key, entry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">               file.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>invalidate(String key, boolean fullExpire)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span> </span>&#123;</span><br><span class="line">    Entry entry = get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 有效时间置零</span></span><br><span class="line">        entry.softTtl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fullExpire) &#123;</span><br><span class="line">            entry.ttl = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove(String key)</code> 和 <code>clear()</code> 方法比较简单，就不需要注释了：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> remove(<span class="keyword">String</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">boolean</span> deleted = getFileForKey(<span class="variable">key</span>).delete();</span><br><span class="line">    removeEntry(<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                <span class="variable">key</span>, getFilenameForKey(<span class="variable">key</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.<span class="built_in">clear</span>();</span><br><span class="line">    mTotalSize = <span class="number">0</span>;</span><br><span class="line">    VolleyLog.d(<span class="string">"Cache cleared."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0100B"><a href="#0100B" class="headerlink" title="0100B"></a>0100B</h1><p>至此，Volley 源码解析差不多已经结束了。基本上在整个 Volley 框架中至关重要的类都讲到了。当然，还有一些 NetworkImageView 、ImageLoader 等源码还没解析。由于本篇文章内容太长了(有史以来写过最长的一篇─=≡Σ((( つ•̀ω•́)つ)，只能等到下次有机会再给大家补上了。</p>
<p>在这还给出了一张整个 Volley 框架大致的网络通信流程图，对上面源码没看懂的童鞋可以参考这张图再看一遍：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161130214351.png" alt="Volley网络通信流程图"></p>
<p>最后，只剩下总结了。从头到尾分析了一遍，发现 Volley 真的是一款很优秀的框架，面向接口编程在其中发挥到极致。其中有不少值得我们借鉴的地方，但是 Volley 并不是没有缺点的，对于大文件传输 Volley 就很不擅长，搞不好会 OOM 。另外，在源码中还有不少可以继续优化的地方，有兴趣的同学可以自定义一个属于自己的 Volley 。</p>
<p>好了，如果你对本文哪里有问题或者不懂的地方，欢迎留言一起交流。</p>
<h1 id="0101B"><a href="#0101B" class="headerlink" title="0101B"></a>0101B</h1><p>References</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></li>
<li><a href="http://blog.csdn.net/zoudifei/article/details/45623121" target="_blank" rel="external">volley 框架剖析(四） 之HTTPCache设计</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/17656437" target="_blank" rel="external">Android Volley完全解析(四)，带你从源码的角度理解Volley  
</a></li>
<li><a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">Etag与HTTP缓存机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[热修复框架HotFix源码解析]]></title>
    <link href="http://yuqirong.me/2016/11/06/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6HotFix%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/11/06/热修复框架HotFix源码解析/</id>
    <published>2016-11-06T05:15:59.000Z</published>
    <updated>2016-11-06T11:19:23.626Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>讲起 Android 的热修复，相信大家对其都略知一二。热修复可以说是继插件化之后，又一项新的技术。目前的 Android 热修复框架主要分为了两类：</p>
<ul>
<li>基于 Native Hook：使用 JNI 动态改变方法指针，比如有 <a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a> 、<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a> 等；</li>
<li>基于 Java Dex 分包：改变 dex 加载顺序，比如有 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 、<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a> 、<a href="https://github.com/eleme/Amigo" target="_blank" rel="external">Amigo</a> 等；</li>
</ul>
<p>Native Hook 方案有一定的兼容性问题，并且其热修复是基于方法的；而 Java Dex 分包的方案具有很好的兼容性，被大众所接受。其实早在去年年末，<a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 、 <a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a> 就已经出现了，并且它们的原理是相同的，都是基于 QQ 空间终端开发团队发布的<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1031x2ljgSF4xJGlH1xMCJxO&amp;uin=MjAyNzY1NTU%3D&amp;key=04dce534b3b035ef58d8714d714d36bcc6cc7e136bbd64850522b491d143aafceb62c46421c5965e18876433791d16ec&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020201&amp;lang=zh_CN&amp;pass_ticket=7O%2FVfztuLjqu23ED2WEkvy1SJstQD4eLRqX%2B%2BbCY3uE%3D" target="_blank" rel="external">《安卓App热补丁动态修复技术介绍》</a>文中介绍的思路来实现的。如果没有看过这篇文章的童鞋，强烈建议先阅读一遍。</p>
<p>虽然现在 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 框架已经被作者 <a href="https://github.com/dodola" target="_blank" rel="external">dodola</a> 标注了 Deprecated ，但是这并不妨碍我们解析其源码。那么下面我们就开始进入正题。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>首先来看一下 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 项目的结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106151939.png" alt="HotFix项目结构"></p>
<p>可以看到项目中主要分为四个 module ：</p>
<ul>
<li>app : 里面有一个 HotFix 用法的 Demo ；</li>
<li>buildSrc : 用于编译打包时代码注入的 Gradle 的 Task ；</li>
<li>hackDex : 只有一个 AntilazyLoad 类，独立打成一个 hack.dex ，防止出现 CLASS_ISPREVERIFIED 相关的问题；</li>
<li>hotfixlib : 热修复框架的 lib ；</li>
</ul>
<p>我们就先从 app 入手吧，先来看看 HotfixApplication :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotfixApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        File dexPath = <span class="keyword">new</span> File(getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE), <span class="string">"hackdex_dex.jar"</span>);</span><br><span class="line">		<span class="comment">// 把 assets 中的 hackdex_dex.jar 复制给 dexPath</span></span><br><span class="line">        Utils.prepareDex(<span class="keyword">this</span>.getApplicationContext(), dexPath, <span class="string">"hackdex_dex.jar"</span>);</span><br><span class="line">        HotFix.patch(<span class="keyword">this</span>, dexPath.getAbsolutePath(), <span class="string">"dodola.hackdex.AntilazyLoad"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.getClassLoader().loadClass(<span class="string">"dodola.hackdex.AntilazyLoad"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onCreate()</code> 方法中，代码量很少。一开始使用 <code>Utils.prepareDex</code> 把 assets 中的 hackdex_dex.jar 复制到内部存储中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 把 assets 中的 hack_dex 复制到内部存储中</span><br><span class="line"> * <span class="doctag">@param</span> context</span><br><span class="line"> * <span class="doctag">@param</span> dexInternalStoragePath</span><br><span class="line"> * <span class="doctag">@param</span> dex_file</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">prepareDex</span><span class="params">(Context context, File dexInternalStoragePath, String dex_file)</span> </span>&#123;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream dexWriter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(context.getAssets().open(dex_file));</span><br><span class="line">        dexWriter = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dexInternalStoragePath));</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUF_SIZE];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf, <span class="number">0</span>, BUF_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dexWriter.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        dexWriter.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dexWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dexWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ioe.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ioe.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制完后调用了 <code>HotFix.patch</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patch</span><span class="params">(Context context, String patchDexFile, String patchClassName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (patchDexFile != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(patchDexFile).exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasLexClassLoader()) &#123;</span><br><span class="line">                injectInAliyunOs(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasDexClassLoader()) &#123;</span><br><span class="line">                injectAboveEqualApiLevel14(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                injectBelowApiLevel14(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>patch</code> 方法中，分为了三种情况：</p>
<ol>
<li>阿里云系统；</li>
<li>Android 系统 API Level &gt;= 14 的；</li>
<li>Android 系统 API Level &lt; 14 的；</li>
</ol>
<p>其实阿里云的热修复和 Android系统 API &lt; 14 的代码是差不多的，就是把 .dex 修改为了 .lex 。在这里就不分析，主要来看看 Android 系统 API &gt;= 14 和 Android 系统 API &lt; 14 两种情况。</p>
<h2 id="Android__u7CFB_u7EDF_API_Level__26gt_3B_3D_14"><a href="#Android__u7CFB_u7EDF_API_Level__26gt_3B_3D_14" class="headerlink" title="Android 系统 API Level &gt;= 14"></a>Android 系统 API Level &gt;= 14</h2><p>先来分析 <code>injectAboveEqualApiLevel14</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectAboveEqualApiLevel14</span><span class="params">(Context context, String str, String str2)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">    <span class="comment">// 合并 DexElements[] 数组</span></span><br><span class="line">    Object a = combineArray(getDexElements(getPathList(pathClassLoader)),</span><br><span class="line">        getDexElements(getPathList(</span><br><span class="line">            <span class="keyword">new</span> DexClassLoader(str, context.getDir(<span class="string">"dex"</span>, <span class="number">0</span>).getAbsolutePath(), str, context.getClassLoader()))));</span><br><span class="line">    <span class="comment">// 得到当前 pathClassLoader 中的 pathList</span></span><br><span class="line">   Object a2 = getPathList(pathClassLoader);</span><br><span class="line">    <span class="comment">// 把合并后的 DexElements[] 数组设置给 PathList 中的 dexElements</span></span><br><span class="line">    setField(a2, a2.getClass(), <span class="string">"dexElements"</span>, a);</span><br><span class="line">    pathClassLoader.loadClass(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到当前 <code>context</code> 内部的 <code>pathClassLoader</code> ，然后调用 <code>combineArray(getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList(new DexClassLoader(str, context.getDir(&quot;dex&quot;, 0).getAbsolutePath(), str, context.getClassLoader()))))</code> 。这个 <code>combineArray</code> 方法中嵌套了很多层方法，我们一个一个来看。首先是 <code>getPathList</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getPathList</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException,</span><br><span class="line">    IllegalAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到当前 PathClassLoader 中的 pathList 属性</span></span><br><span class="line">    <span class="keyword">return</span> getField(obj, Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>), <span class="string">"pathList"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getField</span><span class="params">(Object obj, Class cls, String str)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Field declaredField = cls.getDeclaredField(str);</span><br><span class="line">    declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> declaredField.get(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中知道，其实 getPathList 就是获取 BaseDexClassLoader 类的对象中的 pathList 属性。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106163934.png" alt="BaseDexClassLoader源码"></p>
<p>PathClassLoader 类继承自 BaseDexClassLoader：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106163627.png" alt="PathClassLoader源码"></p>
<p>得到了 pathList 之后，调用了 <code>getDexElements</code> 。顾名思义，就是获得了 pathList 中的 dexElements 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getDexElements</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到当前 pathList 中的 dexElements 属性</span></span><br><span class="line">    <span class="keyword">return</span> getField(obj, obj.getClass(), <span class="string">"dexElements"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106164537.png" alt="DexPathList源码"></p>
<p>所以在 <code>combineArray</code> 方法中传入的参数都是 Elements[] 。一个是当前应用程序中的 dexElements，另一个是 hackdex_dex.jar 中的 dexElements 。</p>
<p>下面来看看 <code>combineArray</code> 中的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">combineArray</span><span class="params">(Object obj, Object obj2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 DexElements[] 数组的 class</span></span><br><span class="line">    Class componentType = obj2.getClass().getComponentType();</span><br><span class="line">    <span class="comment">// 得到补丁包中 DexElements[] 数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(obj2);</span><br><span class="line">    <span class="comment">// 全长</span></span><br><span class="line">    <span class="keyword">int</span> length2 = Array.getLength(obj) + length;</span><br><span class="line">    Object newInstance = Array.newInstance(componentType, length2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; length) &#123;</span><br><span class="line">			<span class="comment">// obj2 中的 Element 顺序在 obj 前面</span></span><br><span class="line">            Array.set(newInstance, i, Array.get(obj2, i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Array.set(newInstance, i, Array.get(obj, i - length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要干的事情就是把传入的两个 dexElements 合并成一个 dexElements 。但是要注意的是第二个 obj2 中的 dex 要排在 obj 前面，这样才能达到热修复的效果。</p>
<p>最后我们回过头来看看 <code>injectAboveEqualApiLevel14</code> 方法中剩下的代码：</p>
<pre><code>// 得到当前 pathClassLoader 中的 pathList
Object a2 = getPathList(pathClassLoader);
// 把合并后的 DexElements[] 数组设置给 PathList
setField(a2, a2.getClass(), &quot;dexElements&quot;, a);
// 先加载 dodola.hackdex.AntilazyLoad.class
pathClassLoader.loadClass(str2);
</code></pre><p>这几行代码相信大家都能看懂了。这样 <code>injectAboveEqualApiLevel14</code> 整个流程就走完了。剩下，我们就看看 <code>injectBelowApiLevel14</code> 吧。</p>
<h2 id="Android__u7CFB_u7EDF_API_Level__26lt_3B_14"><a href="#Android__u7CFB_u7EDF_API_Level__26lt_3B_14" class="headerlink" title="Android 系统 API Level &lt; 14"></a>Android 系统 API Level &lt; 14</h2><p><code>injectBelowApiLevel14</code> 方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(<span class="number">14</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectBelowApiLevel14</span><span class="params">(Context context, String str, String str2)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    PathClassLoader obj = (PathClassLoader) context.getClassLoader();</span><br><span class="line">    DexClassLoader dexClassLoader =</span><br><span class="line">        <span class="keyword">new</span> DexClassLoader(str, context.getDir(<span class="string">"dex"</span>, <span class="number">0</span>).getAbsolutePath(), str, context.getClassLoader());</span><br><span class="line">    <span class="comment">// why load class str2</span></span><br><span class="line">    dexClassLoader.loadClass(str2);</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mPaths"</span>,</span><br><span class="line">        appendArray(getField(obj, PathClassLoader.class, <span class="string">"mPaths"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">                <span class="string">"mRawDexPath"</span>)</span><br><span class="line">        ));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mFiles"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mFiles"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">                <span class="string">"mFiles"</span>)</span><br><span class="line">        ));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mZips"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mZips"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">            <span class="string">"mZips"</span>)));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mDexs"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mDexs"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">            <span class="string">"mDexs"</span>)));</span><br><span class="line">    obj.loadClass(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 API Level &lt; 14 中，流程还是那一套流程，和 API Level &gt;= 14 的一致，只不过要合并的属性变多了。主要因为 ClassLoader 源代码有变更，所以要分版本作出兼容。在这里就不分析了，相信看完 <code>injectAboveEqualApiLevel14</code> 之后对 <code>injectBelowApiLevel14</code> 也一定理解了。</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>在 MainActivity 中，进行了热修复，相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备补丁,从assert里拷贝到dex里</span></span><br><span class="line">File dexPath = <span class="keyword">new</span> File(getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE), <span class="string">"path_dex.jar"</span>);</span><br><span class="line">Utils.prepareDex(<span class="keyword">this</span>.getApplicationContext(), dexPath, <span class="string">"path_dex.jar"</span>);</span><br><span class="line"><span class="comment">//                DexInjector.inject(dexPath.getAbsolutePath(), defaultDexOptPath, "dodola.hotfix</span></span><br><span class="line"><span class="comment">// .BugClass");</span></span><br><span class="line"></span><br><span class="line">HotFix.patch(<span class="keyword">this</span>, dexPath.getAbsolutePath(), <span class="string">"dodola.hotfix.BugClass"</span>);</span><br></pre></td></tr></table></figure>
<p>惊奇地发现 MainActivity 中热修复的代码和上面 HotfixApplication 中加载 hackdex_dex.jar 的代码是一模一样的。没错，都是用的同一套流程，所以同样的道理就很容易理解了。</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p><a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 整个逻辑就是上面这样了。但是我们还有一个问题要去解决，那就是我们怎样把 AntilazyLoad 动态引入到构造方法中。<a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 使用 javassist 来做到代码动态注入。具体的代码就是在 buildSrc 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 植入代码</span><br><span class="line"> * <span class="doctag">@param</span> buildDir 是项目的build class目录,就是我们需要注入的class所在地</span><br><span class="line"> * <span class="doctag">@param</span> lib 这个是hackdex的目录,就是AntilazyLoad类的class文件所在地</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String buildDir, String lib)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    println(lib)</span><br><span class="line">    ClassPool classes = ClassPool.getDefault()</span><br><span class="line">    classes.appendClassPath(buildDir)</span><br><span class="line">    classes.appendClassPath(lib)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的操作比较容易理解,在将需要关联的类的构造方法中插入引用代码</span></span><br><span class="line">    CtClass c = classes.getCtClass(<span class="string">"dodola.hotfix.BugClass"</span>)</span><br><span class="line">    <span class="keyword">if</span> (c.isFrozen()) &#123;</span><br><span class="line">        c.defrost()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"====添加构造方法===="</span>)</span><br><span class="line">    def constructor = c.getConstructors()[<span class="number">0</span>];</span><br><span class="line">    constructor.insertBefore(<span class="string">"System.out.println(dodola.hackdex.AntilazyLoad.class);"</span>)</span><br><span class="line">    c.writeFile(buildDir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CtClass c1 = classes.getCtClass(<span class="string">"dodola.hotfix.LoadBugClass"</span>)</span><br><span class="line">    <span class="keyword">if</span> (c1.isFrozen()) &#123;</span><br><span class="line">        c1.defrost()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"====添加构造方法===="</span>)</span><br><span class="line">    def constructor1 = c1.getConstructors()[<span class="number">0</span>];</span><br><span class="line">    constructor1.insertBefore(<span class="string">"System.out.println(dodola.hackdex.AntilazyLoad.class);"</span>)</span><br><span class="line">    c1.writeFile(buildDir)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><p><a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 框架总体就是这样的了，还是比较简单的。现在作者重新写了一个 <a href="https://github.com/dodola/RocooFix" target="_blank" rel="external">RocooFix</a> 框架，主要解决了 Gradle 1.4 以上无法打包的问题。如果有兴趣的童鞋可以关注一下。</p>
<p>那么今天就到这里了，bye bye ！</p>
<h1 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h1><p>References</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1031x2ljgSF4xJGlH1xMCJxO&amp;uin=MjAyNzY1NTU%3D&amp;key=04dce534b3b035ef58d8714d714d36bcc6cc7e136bbd64850522b491d143aafceb62c46421c5965e18876433791d16ec&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020201&amp;lang=zh_CN&amp;pass_ticket=7O%2FVfztuLjqu23ED2WEkvy1SJstQD4eLRqX%2B%2BbCY3uE%3D" target="_blank" rel="external">安卓App热补丁动态修复技术介绍</a></li>
</ul>
<ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/49883661" target="_blank" rel="external">Android 热补丁动态修复框架小结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>讲起 Android 的热修复，相信大家对其都略知一二。热修复可以说是继插件化之后，又一项新的技术。目前的 Android ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React Native热更新集成Code Push]]></title>
    <link href="http://yuqirong.me/2016/11/03/React%20Native%E7%83%AD%E6%9B%B4%E6%96%B0%E9%9B%86%E6%88%90Code%20Push/"/>
    <id>http://yuqirong.me/2016/11/03/React Native热更新集成Code Push/</id>
    <published>2016-11-03T01:30:59.000Z</published>
    <updated>2016-12-14T12:55:50.913Z</updated>
    <content type="html"><![CDATA[<p>Code Push GitHub 地址: <a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">https://github.com/Microsoft/react-native-code-push</a></p>
<h1 id="u57FA_u672C_u5B89_u88C5"><a href="#u57FA_u672C_u5B89_u88C5" class="headerlink" title="基本安装"></a>基本安装</h1><ol>
<li><p>安装 code push cli</p>
<pre><code>npm install -g code-push-cli
</code></pre></li>
<li><p>注册，成功后得到 key 后输入</p>
<pre><code>code-push register
</code></pre></li>
<li><p>在 Code Push 服务器注册 app</p>
<pre><code>code-push app add your_app_name 
</code></pre><p> 查找密钥，有 deployment key 和 staging key 两种</p>
<pre><code>code-push deployment ls your_app_name -k
</code></pre></li>
<li><p>在项目根目录执行以下命令安装react-native-code-push模块</p>
<pre><code>npm install –save react-native-code-push
</code></pre></li>
<li><p>在 Anroid project 中安装插件，CodePush提供了两种方式：RNPM 和 Manual，这里所使用的是RNPM</p>
<pre><code>npm i -g rnpm
</code></pre></li>
<li><p>添加codepush配置，要求输入 deployment key ，可以 ignore</p>
<pre><code>react-native link react-native-code-push
</code></pre><p> 或者<strong>手动配置</strong>，引入项目, 在setting.gradle文件中设置：</p>
<pre><code>include &apos;:react-native-code-push&apos;
project(&apos;:react-native-code-push&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-code-push/android/app&apos;)
</code></pre><p> 在app/build.gradle文件中设置</p>
<pre><code>dependencies {
    ...
    compile project(&apos;:react-native-code-push&apos;)
}
</code></pre><p> 在app/build.gradle文件添加项目依赖：</p>
<pre><code>apply from: &quot;../../node_modules/react-native/react.gradle&quot;
apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot;
</code></pre><p> 在 MainApplication 中添加如下代码：</p>
<pre><code>import com.microsoft.codepush.react.CodePush;

...

@Override

protected String getJSBundleFile() {

    return CodePush.getJSBundleFile();
}
</code></pre></li>
</ol>
<pre><code>@Override

protected List&lt;ReactPackage&gt; getPackages() {

    return Arrays.&lt;ReactPackage&gt;asList(

        new MainReactPackage(),
        // 把 deployment-key-here 替换成你 app 的 key
        new CodePush(&quot;deployment-key-here&quot;, this, BuildConfig.DEBUG)

    );
}
</code></pre><h1 id="JS_u4EE3_u7801"><a href="#JS_u4EE3_u7801" class="headerlink" title="JS代码"></a>JS代码</h1><pre><code>import CodePush from &apos;react-native-code-push&apos;;

CodePush.sync();
</code></pre><h1 id="u4FEE_u6539versionName"><a href="#u4FEE_u6539versionName" class="headerlink" title="修改versionName"></a>修改versionName</h1><p>在 android/app/build.gradle 中有个 android.defaultConfig.versionName 属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。</p>
<pre><code>android{
    defaultConfig{
        versionName &quot;1.0.0&quot;
    }
}
</code></pre><h1 id="u6253_u5305_JS_Bundle"><a href="#u6253_u5305_JS_Bundle" class="headerlink" title="打包 JS Bundle"></a>打包 JS Bundle</h1><ol>
<li><p>在工程目录里面新增 bundles 文件：</p>
<pre><code>mkdir bundles
</code></pre></li>
<li><p>运行命令打包 </p>
<pre><code>react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试
</code></pre><p> 例如:</p>
<pre><code>react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false
</code></pre></li>
</ol>
<h1 id="u53D1_u5E03_u66F4_u65B0"><a href="#u53D1_u5E03_u66F4_u65B0" class="headerlink" title="发布更新"></a>发布更新</h1><p>打包bundle结束后，就可以通过CodePush发布更新了。在终端输入</p>
<pre><code>code-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName &lt;更新环境&gt; --description &lt;更新描述&gt;  --mandatory &lt;是否强制更新&gt;
</code></pre><p>例如:</p>
<pre><code>code-push release AwesomeProject ./bundles/index.android.bundle 1.0.0 --deploymentName Staging --description &quot;1.测试更新&quot; --mandatory false
</code></pre><p><strong>注意</strong>：</p>
<ol>
<li><p>Code Push 默认是更新 staging 环境的，如果是 staging ，则不需要填写 deploymentName 。</p>
</li>
<li><p>如果有 mandatory 则 Code Push 会根据 mandatory 是 true 或 false 来控制应用是否强制更新。默认情况下 mandatory 为 false 即不强制更新。</p>
</li>
<li><p>对应的应用版本（targetBinaryVersion）是指当前 app 的版本(对应build.gradle中设置的versionName “1.0.6”)，也就是说此次更新的 js/images 对应的是 app 的那个版本。不要将其理解为这次 js 更新的版本。</p>
<p> 如客户端版本是 1.0.6，那么我们对1.0.6的客户端更新js/images，targetBinaryVersion填的就是1.0.6。</p>
</li>
<li><p>对于对某个应用版本进行多次更新的情况，Code Push 会检查每次上传的 bundle ，如果在该版本下如 1.0.6 已经存在与这次上传完全一样的 bundle (对应一个版本有两个 bundle 的 md5 完全一样)，那么 CodePush 会拒绝此次更新。</p>
</li>
<li><p>在终端输入 <code>code-push deployment history your_app_name Staging</code> 可以看到 staging 版本更新的时间、描述等等属性。</p>
</li>
</ol>
<h1 id="u76F8_u5173_u95EE_u9898"><a href="#u76F8_u5173_u95EE_u9898" class="headerlink" title="相关问题"></a>相关问题</h1><p>进行编译时报错，具体的原因未知。</p>
<p>错误一：</p>
<pre><code>Execution:failed for task &apos;:app:packageDebug&apos;
outDexFolder must be a folder
</code></pre><p>错误二：</p>
<pre><code>Execution:failed for task &apos;:app:packageDebug&apos;
Failed to create \projectName\android\app\buildintermediates\debug\merging
</code></pre><h1 id="React_Native__u83B7_u53D6_u5E94_u7528_u7248_u672C_u53F7"><a href="#React_Native__u83B7_u53D6_u5E94_u7528_u7248_u672C_u53F7" class="headerlink" title="React Native 获取应用版本号"></a>React Native 获取应用版本号</h1><ol>
<li><p>npm install react-native-device-info –save</p>
</li>
<li><p>react-native link react-native-device-info</p>
</li>
<li><p>import com.learnium.RNDeviceInfo.RNDeviceInfo;</p>
</li>
<li><p>获取应用版本号：DeviceInfo.getVersion()</p>
</li>
</ol>
<h1 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">Code Push GitHub</a></li>
<li><a href="http://www.jianshu.com/p/9e3b4a133bcc" target="_blank" rel="external">React Native热更新部署/热更新-CodePush最新集成总结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Code Push GitHub 地址: <a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">https://github.com/Micr]]>
    </summary>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dynamic-Load-Apk源码解析]]></title>
    <link href="http://yuqirong.me/2016/10/29/Dynamic-Load-Apk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/10/29/Dynamic-Load-Apk源码解析/</id>
    <published>2016-10-29T13:57:12.000Z</published>
    <updated>2016-11-01T15:12:44.828Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架。<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 是任主席主导开发的一款插件化框架，其中心思想主要就是两个字——<strong>代理</strong>。和我之前分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 插件化框架不同的是，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架完全基于在应用层上实现，并不依靠 ActivityThread 、Instrumentation 等。另外，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架在插件化发展历程中诞生较早，对后来不断涌现的插件化框架具有深刻的指导意义。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>注：本文分析的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 为 master 分支，版本为1.0.0；</p>
<p>其实 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的思想很巧妙，大致的思路如下：在宿主中首先申明了一些 ProxyActivity 以及 ProxyService ，插件中的 PluginActivity 要继承指定的 DLBasePluginActivity 。然后启动插件中的 Activity 时，实际上启动的是 ProxyActivity , 之后利用接口回调调用了 PluginActivity 中的生命周期方法。也就是说，PluginActivity 并不是实质上的 Activity ，其实只是一个普通的 Java 类。</p>
<p>在分析源码之前，先在这里简单地说一下 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161029/20161029223619.png" alt="dynamic-load-apk的类结构"></p>
<p>从上面的图中大致可以看出来，整个框架中的 Java 类基本可以分为五种类型：</p>
<ul>
<li><strong>DLPluginManager</strong> ：顾名思义，是整个插件的管理类。主要作用就是加载以及管理插件，启动插件中的Activity、Service等；</li>
<li><strong>DLProxyActivity 、DLProxyFragmentActivity 、DLProxyService</strong> ：代理组件。可以看到有 Activity 、Service 等，在启动插件时实质上启动的是这些代理组件，之后在代理组件中利用接口回调插件的相关“生命周期”；</li>
<li><strong>DLProxyImpl 、DLServiceProxyImpl</strong> ：属于启动插件过程中一些公共逻辑代码。在代理组件连接插件组件时，把一些公共的方法抽取出来放入了这些类中；</li>
<li><strong>DLBasePluginActivity 、DLBasePluginFragmentActivity 、DLBasePluginService</strong> ：插件的基类。用户使用的插件需要继承自这些基类，之后接口才会回调插件的“生命周期”。</li>
<li><strong>DLPlugin 、DLServicePlugin</strong> ：插件“生命周期”定义的接口。在这两个类中定义了 Activity 、Service 相关的生命周期方法。</li>
</ul>
<p>那么接下来我们就一一来解析源码吧。</p>
<h2 id="DLPluginManager-loadApk"><a href="#DLPluginManager-loadApk" class="headerlink" title="DLPluginManager.loadApk"></a>DLPluginManager.loadApk</h2><p>DLPluginManager 是个单例类，我们先来看看它的初始化方法 <code>DLPluginManager.getInstance(Context context)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DLPluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context.getApplicationContext();</span><br><span class="line">    mNativeLibDir = mContext.getDir(<span class="string">"pluginlib"</span>, Context.MODE_PRIVATE).getAbsolutePath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DLPluginManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DLPluginManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> DLPluginManager(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在构造函数中设置了 .so 文件存储的目录。初始化完成后，通过 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 方法来加载插件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DLPluginPackage <span class="title">loadApk</span><span class="params">(<span class="keyword">final</span> String dexPath, <span class="keyword">boolean</span> hasSoLib)</span> </span>&#123;</span><br><span class="line">    mFrom = DLConstants.FROM_EXTERNAL;</span><br><span class="line"></span><br><span class="line">    PackageInfo packageInfo = mContext.getPackageManager().getPackageArchiveInfo(dexPath,</span><br><span class="line">            PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES);</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 得到插件信息封装类</span></span><br><span class="line">    DLPluginPackage pluginPackage = preparePluginEnv(packageInfo, dexPath);</span><br><span class="line">	<span class="comment">// 如果有 .so 文件，则复制到 mNativeLibDir 目录</span></span><br><span class="line">    <span class="keyword">if</span> (hasSoLib) &#123;</span><br><span class="line">        copySoLib(dexPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 主要做了两件事：</p>
<ol>
<li>在 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法中把插件 packageInfo 封装成 pluginPackage ；</li>
<li>复制 .so 文件到 mNativeLibDir 目录，主要流程就是在 SoLibManager 中利用 I/O 流复制文件。在这里就不讲了，代码比较简单，有兴趣的童鞋可以自己回去看源码；</li>
</ol>
<p>那么我们就跟着主流程来看看 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DLPluginPackage <span class="title">preparePluginEnv</span><span class="params">(PackageInfo packageInfo, String dexPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先查看缓存中有没有该 pluginPackage</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageInfo.packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pluginPackage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 ClassLoader</span></span><br><span class="line">    DexClassLoader dexClassLoader = createDexClassLoader(dexPath); </span><br><span class="line">    AssetManager assetManager = createAssetManager(dexPath);</span><br><span class="line">    <span class="comment">// 得到插件 res 资源</span></span><br><span class="line">    Resources resources = createResources(assetManager);</span><br><span class="line">    <span class="comment">// create pluginPackage</span></span><br><span class="line">    pluginPackage = <span class="keyword">new</span> DLPluginPackage(dexClassLoader, resources, packageInfo);</span><br><span class="line">    mPackagesHolder.put(packageInfo.packageName, pluginPackage);</span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码可知，在方法中创建了插件的 ClassLoader ，插件的 res 资源。如果你看过我另一篇插件化框架分析的文章<a href="/2016/10/02/插件化框架android-pluginmgr全解析">《插件化框架android-pluginmgr全解析》</a>，那么想必对这其中的原理已经熟知了：</p>
<ol>
<li>插件的类加载器是 DexClassLoader 或其子类，可以指定加载 dex 的目录。对应着上面的 <code>createDexClassLoader(dexPath)</code> 方法；</li>
<li>插件的 res 资源访问主要通过 AssetManager 的 <code>addAssetPath</code> 方法来获取。需要注意的是，<code>addAssetPath</code> 方法是 @hide 的，需要反射来执行。对应着 <code>createAssetManager(dexPath)</code> 方法；</li>
</ol>
<p>createXxxx 方法具体的代码就不在这里贴出来了，想了解的可以查看源码。通过这些 createXxxx 方法，就把插件的 ClassLoader 和 res 资源问题解决了。最后封装成一个 pluginPackage 对象，方便之后使用。</p>
<h2 id="DLPluginManager-startPluginActivityForResult"><a href="#DLPluginManager-startPluginActivityForResult" class="headerlink" title="DLPluginManager.startPluginActivityForResult"></a>DLPluginManager.startPluginActivityForResult</h2><p>加载完插件之后，我们就要着手于如何启动插件了。想要启动插件，就要调用 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法，而 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法内部又是调用 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法的，所以我们直接查看 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startPluginActivityForResult</span><span class="params">(Context context, DLIntent dlIntent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否宿主内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">        dlIntent.setClassName(context, dlIntent.getPluginClass());</span><br><span class="line">        performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">        <span class="keyword">return</span> DLPluginManager.START_RESULT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String packageName = dlIntent.getPluginPackage();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"disallow null packageName."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件信息</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_PKG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件 Activity 的全类名</span></span><br><span class="line">    <span class="keyword">final</span> String className = getPluginActivityFullPath(dlIntent, pluginPackage);</span><br><span class="line">    <span class="comment">// 得到对应的 class</span></span><br><span class="line">    Class&lt;?&gt; clazz = loadPluginClass(pluginPackage.classLoader, className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据插件 class 继承的是哪个基类，分别得到对应的代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginActivity ，得到的就是 DLProxyActivity 代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginFragmentActivity ，得到的就是 DLProxyFragmentActivity 代理类</span></span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = getProxyActivityClass(clazz);</span><br><span class="line">    <span class="keyword">if</span> (activityClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把插件信息传入 Intent 中</span></span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);</span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);</span><br><span class="line">    <span class="comment">// 这里启动的是上面得到的代理类 Activity</span></span><br><span class="line">    dlIntent.setClass(mContext, activityClass);</span><br><span class="line">    <span class="comment">// 启动 Activity</span></span><br><span class="line">    performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">    <span class="keyword">return</span> START_RESULT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法里基本上都有注释，要明白的是，intent 启动的是代理的 Activity ，并不是我们插件的 Activity 。另外，在 DLPluginManager 里还有启动插件 Service 的相关代码，不过具体的流程和启动插件 Activity 是相似的。如果有想要进一步了解的童鞋可以自行看源码。</p>
<h2 id="DLProxyActivity"><a href="#DLProxyActivity" class="headerlink" title="DLProxyActivity"></a>DLProxyActivity</h2><p>经过上一步之后，我们就启动了代理类 Activity 。代理类 Activity 有两种：DLProxyActivity 和 DLProxyFragmentActivity 。但是其中的逻辑都是一样的。在这里我们只分析 DLProxyActivity 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLProxyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> DLPlugin mRemoteActivity;</span><br><span class="line">    <span class="keyword">private</span> DLProxyImpl impl = <span class="keyword">new</span> DLProxyImpl(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        impl.onCreate(getIntent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类的结构上看到，DLProxyActivity 实现了 DLAttachable 接口。那么 DLAttachable 接口的作用是什么呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * when the proxy impl ( &#123;<span class="doctag">@see</span> DLProxyImpl#launchTargetActivity()&#125; ) launch</span><br><span class="line">     * the plugin activity , dl will call this method to attach the proxy activity</span><br><span class="line">     * and pluginManager to the plugin activity. the proxy activity will load</span><br><span class="line">     * the plugin's resource, so the proxy activity is a resource delegate for</span><br><span class="line">     * plugin activity.</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> proxyActivity a instance of DLPlugin, &#123;<span class="doctag">@see</span> DLBasePluginActivity&#125;</span><br><span class="line">     *            and &#123;<span class="doctag">@see</span> DLBasePluginFragmentActivity&#125;</span><br><span class="line">     * <span class="doctag">@param</span> pluginManager DLPluginManager instance, manager the plugins</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(DLPlugin proxyActivity, DLPluginManager pluginManager)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释的意思是，<code>attach(DLPlugin proxyActivity, DLPluginManager pluginManager)</code> 方法可以在 ProxyImpl 调用 <code>launchTargetActivity()</code> 时把 PluginActivity 和 ProxyActivity 绑定在一起。那样就达到了可以在 ProxyActivity 中使用 PluginActivity 的效果。那么到底在什么时候调用 <code>proxyImpl.launchTargetActivity()</code> 方法呢？我们回到上面的 DLProxyActivity 类中来，看到了 DLProxyActivity 中有一个 <code>impl</code> 成员变量。在 <code>onCreate(Bundle savedInstanceState)</code> 中调用了 <code>impl.onCreate(getIntent())</code> ，我们猜想在 <code>impl.onCreate(getIntent())</code> 的方法里一定会去调用 <code>launchTargetActivity()</code> 方法。下面我们就来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the extra's class loader</span></span><br><span class="line">    intent.setExtrasClassLoader(DLConfigs.sPluginClassloader);</span><br><span class="line">    <span class="comment">// 得到传过来的插件 Activity 包名和全类名</span></span><br><span class="line">    mPackageName = intent.getStringExtra(DLConstants.EXTRA_PACKAGE);</span><br><span class="line">    mClass = intent.getStringExtra(DLConstants.EXTRA_CLASS);</span><br><span class="line">    Log.d(TAG, <span class="string">"mClass="</span> + mClass + <span class="string">" mPackageName="</span> + mPackageName);</span><br><span class="line">    <span class="comment">// 得到插件相关的信息</span></span><br><span class="line">    mPluginManager = DLPluginManager.getInstance(mProxyActivity);</span><br><span class="line">    mPluginPackage = mPluginManager.getPackage(mPackageName);</span><br><span class="line">    mAssetManager = mPluginPackage.assetManager;</span><br><span class="line">    mResources = mPluginPackage.resources;</span><br><span class="line">    <span class="comment">// 得到要启动插件的 activityInfo，设置插件 Activity 的主题</span></span><br><span class="line">    initializeActivityInfo();</span><br><span class="line">    <span class="comment">// 把 DLProxyActivity 的主题设置为插件 Activity 的主题</span></span><br><span class="line">    handleActivityInfo();</span><br><span class="line">    launchTargetActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onCreate(Intent intent)</code> 中得到了之前插件 Activity 相关的信息。然后把 DLProxyActivity 的主题设置为 PluginActivity 的主题。最后调用了  <code>launchTargetActivity()</code> ，说明我们的猜想是正确的。来看看在 <code>launchTargetActivity</code> 方法中到底干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launchTargetActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 得到插件 Activity 的 class</span></span><br><span class="line">        Class&lt;?&gt; localClass = getClassLoader().loadClass(mClass);</span><br><span class="line">        Constructor&lt;?&gt; localConstructor = localClass.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">		<span class="comment">// 创建插件 Activity 的对象</span></span><br><span class="line">        Object instance = localConstructor.newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</span><br><span class="line">        mPluginActivity = (DLPlugin) instance;</span><br><span class="line">		<span class="comment">// 调用 attach 方法，把插件和代理绑定起来</span></span><br><span class="line">        ((DLAttachable) mProxyActivity).attach(mPluginActivity, mPluginManager);</span><br><span class="line">        Log.d(TAG, <span class="string">"instance = "</span> + instance);</span><br><span class="line">        <span class="comment">// attach the proxy activity and plugin package to the mPluginActivity</span></span><br><span class="line">		<span class="comment">// 手动调用插件的 attach 方法</span></span><br><span class="line">        mPluginActivity.attach(mProxyActivity, mPluginPackage);</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putInt(DLConstants.FROM, DLConstants.FROM_EXTERNAL);</span><br><span class="line">		<span class="comment">// 手动调用插件的 onCreate 方法</span></span><br><span class="line">        mPluginActivity.onCreate(bundle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在方法中使用反射创建了插件 Activity 的对象，又因为插件 Activity 必须继承指定的基类，这些基类是实现了 DLPlugin 接口的。所以插件 Activity 可以强转为 DLPlugin 。DLPlugin 接口定义了一系列的 Activity 生命周期方法，之后手动回调了 <code>attach</code> 和 <code>onCreate</code> 方法。</p>
<p>现在我们再回过头来看看 DLProxyActivity 里的其他生命周期方法，发现都有一句 <code>mRemoteActivity.onXxxxx()</code> 。其中的 mRemoteActivity 就是通过 DLAttachable 接口绑定的插件 Activity 对象。所以每当代理 ProxyActivity 回调生命周期方法时，都调用了 DLPlugin 接口一致的生命周期方法，这样就实现了插件 Activity 也有“生命周期”方法。</p>
<h2 id="DLBasePluginActivity"><a href="#DLBasePluginActivity" class="headerlink" title="DLBasePluginActivity"></a>DLBasePluginActivity</h2><p>讲解了 DLProxyActivity 之后，再来看看 DLBasePluginActivity 就发现轻松多了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLBasePluginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.setContentView(layoutResID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProxyActivity.setContentView(layoutResID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DLBasePluginActivity 实现了 DLPlugin 接口，就有了 <code>onCreate()</code> 、<code>onResume()</code> 这些“生命周期”方法。另外在重写的方法中会判断当前否被代理，以此来确定直接走父类逻辑还是代理 Activity 或是空逻辑。</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>讲到这里，整个启动插件 Activity 的流程就走完了。除此之外，还有启动插件 Service 其实也是相似的流程。现在的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架如果实际使用起来可能有比较多的问题，作者也基本上很早就停止更新了。但是这并不妨碍我们分析源码，学习其中的精髓。我想大部分人看完源码都会体会到 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 的核心思想——代理，这也正是和其他插件化框架不同的地方。在这里感谢那些为 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 作出贡献的人。</p>
<p>如果有问题可以留言，Goodbye !</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>Reference：</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">DynamicLoadApk 源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Gradle配置的小结]]></title>
    <link href="http://yuqirong.me/2016/10/23/%E5%85%B3%E4%BA%8EGradle%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yuqirong.me/2016/10/23/关于Gradle配置的小结/</id>
    <published>2016-10-23T07:34:50.000Z</published>
    <updated>2016-11-01T15:12:04.741Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免的，比如配置签名、引入依赖等。那么 Gradle 到底是什么东西呢？ Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言 (DSL) 来声明项目设置，抛弃了基于 XML 的各种繁琐配置 (此定义来自于百度百科-_- !) 。啰里啰唆一堆，幸运的是，一般来说 Android 开发者只要会配置 Gradle 就可以了，并不需要深入了解。那么下面我们就来揭开 Gradle 的面纱吧。</p>
<h1 id="Gradle__u914D_u7F6E"><a href="#Gradle__u914D_u7F6E" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h1><p>首先贴出一张自己项目的文件目录结构图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161023/20161023155409.png" alt="文件目录结构图"></p>
<p>从上图中我们可以看到，与 Gradle 有关的文件基本上分为四种：</p>
<ol>
<li>app 下的 build.gradle (当然其他 module 下也有)；</li>
<li>根目录下的 gradle 文件夹；</li>
<li>根目录下的 build.gradle ；</li>
<li>根目录下的 settings.gradle ；</li>
</ol>
<p>也许有人会说根目录下还有一个 config.gradle 文件呢，其实这是我自定义的 gradle 文件，自定义 Gradle 文件会在下面中讲解，这里先搁置一下。好了，那么我们一个一个地来看看他们的作用吧。</p>
<h2 id="app__u4E0B_u7684_build-gradle"><a href="#app__u4E0B_u7684_build-gradle" class="headerlink" title="app 下的 build.gradle"></a>app 下的 build.gradle</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span> <span class="comment">// 编译sdk版本</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.2"</span> <span class="comment">// 构建工具版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span> <span class="comment">// 开启混淆</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span> <span class="comment">// 对齐zip</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span> <span class="comment">// 删除无用资源</span></span><br><span class="line">            debuggable <span class="keyword">false</span> <span class="comment">// 是否debug</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span> <span class="comment">// 版本命名后缀</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span> <span class="comment">// 混淆文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一句 <code>apply plugin: &#39;com.android.application&#39;</code> 主要用来申明这是一个 Android 程序。而 dependencies 用于引入依赖，这个相信大家都比较了解了。其他的配置比较简单都有注释，就不展开讲了。</p>
<p>当然除了上面的配置之外，还有很多配置也常常写入到 app/build.gradle 中。我们慢慢往下看。</p>
<ul>
<li>签名配置：</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">	</span><br><span class="line">    release &#123; <span class="comment">// 正式版本的签名</span></span><br><span class="line">        storeFile file(<span class="string">"../koku.jks"</span>) <span class="comment">// 密钥文件位置</span></span><br><span class="line">        storePassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 密钥密码</span></span><br><span class="line">        keyAlias <span class="string">"koku"</span> <span class="comment">// 密钥别名</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 别名密码</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">debug</span> &#123; <span class="comment">// debug版本的签名</span></span><br><span class="line">        <span class="comment">// no keystore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时只要在 buildTypes 的 release 中加一句 <code>signingConfig signingConfigs.release</code> 就好了。</p>
<p>如果你觉得把密钥密码和别名密码放在 app/build.gradle 里不安全，那么可以把相关密码放到不加入版本控制系统的 gradle.properties 文件：</p>
<pre><code>KEYSTORE_PASSWORD=xxxxxxxxxx
KEY_PASSWORD=xxxxxxxxx
</code></pre><p>对应的 signingConfigs 配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword KEYSTORE_PASSWORD</span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserDataException(<span class="string">"You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java 编译版本配置：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123; <span class="comment">// java 版本</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意下，如果 Java 编译版本为1.8的话，另外在 defaultConfig 里要配置 Jack 编译器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jackOptions</span> &#123;</span><br><span class="line">    <span class="title">enabled</span> <span class="built_in">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lint 检查配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lintOptions</span> &#123;</span><br><span class="line">    <span class="title">abortOnError</span> <span class="built_in">false</span> // 是否忽略lint报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多渠道信息配置：</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">productFlavors</span> &#123;</span><br><span class="line">    <span class="tag">xiaomi</span> &#123;&#125;</span><br><span class="line">    <span class="tag">googleplay</span> &#123;&#125;</span><br><span class="line">    <span class="tag">wandoujia</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 app/build.gradle 文件配置如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        <span class="comment">// 默认是umeng的渠道</span></span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"umeng"</span>]</span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    java 版本</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// no keystore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 开启混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 对齐zip</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 删除无用资源</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 是否debug</span></span><br><span class="line">            debuggable <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 命名后缀</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span></span><br><span class="line">            <span class="comment">// 签名</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 输出apk名称为koku_v1.0_2015-01-15_wandoujia.apk</span></span><br><span class="line">                        <span class="keyword">def</span> fileName = <span class="string">"koku_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk"</span></span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        googleplay &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对很多渠道</span></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> releaseTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再多嘴一句，有了以上的 build.gradle 配置之后，如果想使用 Gradle 多渠道打包，需要在 AndroidManifest.xml 中申明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data <span class="string">android:</span>name=<span class="string">"UMENG_CHANNEL"</span> <span class="string">android:</span>value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>最后使用命令 <code>gradlew assembleRelease</code> 打包即可。</p>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939" class="headerlink" title="根目录下的 gradle 文件夹"></a>根目录下的 gradle 文件夹</h2><p>gradle 文件夹中主要是 gradle-wrapper.properties 文件比较重要，主要用来声明 Gradle 目录以及 Gradle 下载路径等：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">distributionBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">distributionPath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">zipStoreBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">zipStorePath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">distributionUrl=<span class="value">https\://services.gradle.org/distributions/gradle-<span class="number">2.14</span>.<span class="number">1</span>-all.zip</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_build-gradle"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_build-gradle" class="headerlink" title="根目录下的 build.gradle"></a>根目录下的 build.gradle</h2><p>根目录下的 build.gradle 主要作用就是定义项目中公共属性，比如有依赖仓库、 Gradle 构建版本等：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:2.2.1'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h2><p>setting.gradle 的作用就是一些模块被包含后，会在这里进行申明：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':app'</span></span><br></pre></td></tr></table></figure>
<h2 id="u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6"><a href="#u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6" class="headerlink" title="自定义 Gradle 文件"></a>自定义 Gradle 文件</h2><p>在上面我们留了一个悬念，就是如何添加我们自定义的 Gradle 文件。接下来我们就动手来实践一下。在项目根目录下创建文件 config.gradle 。然后在根目录下的 build.gradle 开头添加一句 <code>apply from: &quot;config.gradle&quot;</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">"config.gradle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这句话就代表着把 config.gradle 添加进来了。然后我们可以在 config.gradle 中申明一些配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line"></span><br><span class="line">    android = [</span><br><span class="line"><span class="label">            compileSdkVersion:</span> <span class="number">23</span>,</span><br><span class="line"><span class="label">            buildToolsVersion:</span> <span class="string">"23.0.3"</span>,</span><br><span class="line">            <span class="string">applicationId    :</span> <span class="string">"com.yuqirong.koku"</span>,</span><br><span class="line">            <span class="string">minSdkVersion    :</span> <span class="number">14</span>,</span><br><span class="line">            <span class="string">targetSdkVersion :</span> <span class="number">23</span>,</span><br><span class="line">            <span class="string">versionCode      :</span> <span class="number">3</span>,</span><br><span class="line">            <span class="string">versionName      :</span> <span class="string">"1.4"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"appcompat-v7"</span>            : <span class="string">'com.android.support:appcompat-v7:23.0.1'</span>,</span><br><span class="line">            <span class="string">"recyclerview-v7"</span>         : <span class="string">'com.android.support:recyclerview-v7:24.2.1'</span>,</span><br><span class="line">            <span class="string">"design"</span>                  : <span class="string">'com.android.support:design:23.0.1'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 app/build.gradle 中去使用：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId rootProject.ext.android.applicationId</span><br><span class="line">        minSdkVersion rootProject.ext.android.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.android.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.android.versionCode</span><br><span class="line">        versionName rootProject.ext.android.versionName</span><br><span class="line"></span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"appcompat-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"recyclerview-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"design"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，我们把一些固定的配置“拎”出来放到 config.gradle 中，这样以后直接更改 config.gradle 就行了，方便多人协作开发。</p>
<h1 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h1><p>关于 Gradle 的平时经常使用方法基本上就上面这些了。其他的一些比如 <code>buildConfigField</code> 之类的可以自行百度，相信聪明的你很快就会了。但是 Gradle 并没有以上讲得那么简单，还需要童鞋们继续努力学习了。</p>
<p>如果对本文有不明白的地方，欢迎留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://stormzhang.com/android/2016/07/02/gradle-for-android-beginners/" target="_blank" rel="external">给 ANDROID 初学者的 GRADLE 知识普及</a></li>
<li><a href="http://stormzhang.com/android/2016/07/15/android-gradle-config/" target="_blank" rel="external">ANDROID 开发你需要了解的 GRADLE 配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yuqirong.me/tags/Gradle/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React Native环境安装流程]]></title>
    <link href="http://yuqirong.me/2016/10/15/React%20Native%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.me/2016/10/15/React Native环境安装流程/</id>
    <published>2016-10-15T00:52:40.000Z</published>
    <updated>2016-12-14T13:00:25.324Z</updated>
    <content type="html"><![CDATA[<h1 id="React_Native__u73AF_u5883_u5B89_u88C5"><a href="#React_Native__u73AF_u5883_u5B89_u88C5" class="headerlink" title="React Native 环境安装"></a>React Native 环境安装</h1><ol>
<li><p>安装 Java 、 Android SDK 。这个应该不用讲了，不会的直接自己百度吧。</p>
</li>
<li><p>安装 Node</p>
<p> React Native 需要使用 Node JS 来做服务器，可以去 Node JS 的官网下载安装：</p>
<p> 下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></p>
<p> 使用 <code>node -v</code> 可以查看 Node JS 安装的版本。</p>
</li>
<li><p>安装 Git</p>
<p> 下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="external">https://git-scm.com/downloads</a></p>
<p> 配置好环境变量后从 GitHub 把 React Native 仓库 clone 下来。</p>
<p> React Native GitHub 地址：<a href="https://github.com/facebook/react-native.git" target="_blank" rel="external">https://github.com/facebook/react-native.git</a></p>
</li>
</ol>
<ol>
<li><p>安装 React Native 命令行工具 react-native-cli</p>
<p> 打开 clone 下来的 React Native 仓库，进入 /react-native-cli 目录，输入命令 <code>npm install -g</code> 安装</p>
</li>
<li><p>创建 React Native 项目</p>
<p> 进入你希望创建项目的目录后，输入 <code>react-native init [项目名]</code> 创建新项目，比如 <code>react-native init AwesomeProject</code>，等待一段时间项目会创建完成。</p>
</li>
<li><p>运行打包的 Node JS 服务器</p>
<p> 在命令行中进入项目目录，输入 <code>react-native start</code> ，等待一段时间即可。</p>
</li>
<li><p>运行项目</p>
<p> 第六步的服务端不要关闭，重新启动一个新的命令行，进入项目目录，输入 <code>react-native run-android</code> 运行 Android 项目。同理，输入 <code>react-native run-ios</code> 运行 iOS 项目。</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.lcode.org/%e5%8f%b2%e4%b8%8a%e6%9c%80%e8%af%a6%e7%bb%86windows%e7%89%88%e6%9c%ac%e6%90%ad%e5%bb%ba%e5%ae%89%e8%a3%85react-native%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae/" target="_blank" rel="external">史上最详细Windows版本搭建安装React Native环境配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="React_Native__u73AF_u5883_u5B89_u88C5"><a href="#React_Native__u73AF_u5883_u5B89_u88C5" class="headerlink" title="React Native 环境安装"]]>
    </summary>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[插件化框架android-pluginmgr全解析]]></title>
    <link href="http://yuqirong.me/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/10/02/插件化框架android-pluginmgr全解析/</id>
    <published>2016-10-02T02:03:34.000Z</published>
    <updated>2016-11-01T15:10:33.159Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD"><a href="#0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD" class="headerlink" title="0x00 前言：插件化的介绍"></a>0x00 前言：插件化的介绍</h1><p>阅读须知：阅读本文的童鞋最好是有过插件化框架使用经历或者对插件化框架有过了解的。前方高能，大牛绕道。</p>
<p>最近一直在关注 Android 插件化方面，所以今天的主题就确定是 Android 中比较热门的“插件化”了。所谓的插件化就是下载 apk 到指定目录，不需要安装该 apk ，就能利用某个已安装的 apk （即“宿主”）调用起该未安装 apk 中的 Activity 、Service 等组件（即“插件”）。</p>
<p>Android 插件化的发展到目前为止也有一段时间了，从一开始任主席的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 到今天要分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 再到360的 <a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">DroidPlugin</a> ，也代表着插件化的思想从顶部的应用层向下到 Framework 层渗入。最早插件化的思想是 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 实现的， <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 在“宿主” ProxyActivity 的生命周期中利用接口回调了“插件” PluginActivity 的“生命周期”，以此来间接实现 PluginActivity 的“生命周期”。也就是说，其实插件中的 “PluginActivity” 并不具有真正 Activity 的性质，实质就是一个普通类，只是利用接口回调了类中的生命周期方法而已。比接口回调更好的方案就是利用 ActivityThread 、Instrumentation 等去动态地 Hook 即将创建的 ProxyActivity ，也就是说表面上创建的是 ProxyActivity ，其实实际上是创建了 PluginActivity 。这种思想相比于 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 而言，插件中 Activity 已经是实质上的 Activity ，具备了生命周期方法。今天我们要解析的 android-pluginmgr 插件化框架就是基于这种思想的。最后就是像 <a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">DroidPlugin</a> 这种插件化框架，改动了 ActivityManagerService 、 PackageManagerService 等 Android 源码，以此来实现插件化。总之，并没有哪种插件化框架是最好的，一切都是要根据自身实际情况而决定的。</p>
<p>熟悉插件化的童鞋都知道，插件化要解决的有三个基本难题：</p>
<ol>
<li>插件中 ClassLoader 的问题；</li>
<li>插件中的资源文件访问问题；</li>
<li>插件中 Activity 组件的生命周期问题。</li>
</ol>
<p>基本上，解决了上面三个问题，就可以算是一个合格的插件化框架了。但是要注意的是，插件化远远不止这三个问题，比如还有插件中 .so 文件加载，支持 Service 插件化等问题。</p>
<p>好了，讲了这么多废话，接下来我们就来分析 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的源码吧。</p>
<h1 id="0x01_PluginManager-init"><a href="#0x01_PluginManager-init" class="headerlink" title="0x01 PluginManager.init"></a>0x01 PluginManager.init</h1><p>注：本文分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 为 master 分支，版本为0.2.2；</p>
<h2 id="android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5"><a href="#android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5" class="headerlink" title="android-pluginmgr的简单用法"></a>android-pluginmgr的简单用法</h2><p>我们先简单地来看一下 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 框架的用法（来自于 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的 <a href="https://github.com/houkx/android-pluginmgr/blob/master/README.md" target="_blank" rel="external">README.md</a> ）：</p>
<ol>
<li><p>declare permission in your <code>AndroidManifest.xml</code>: </p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
</code></pre></li>
<li><p>regist an activity:</p>
<pre><code>&lt;activity android:name=&quot;androidx.pluginmgr.DynamicActivity&quot; /&gt;
</code></pre></li>
<li><p>init PluginMgr in your application:</p>
<pre><code>@Override
public void onCreate(){
   PluginManager.init(this);
   //...
}
</code></pre></li>
<li><p>load plugin from plug apk:</p>
<pre><code>PluginManager pluginMgr = PluginManager.getSingleton();
File myPlug = new File(&quot;/mnt/sdcard/Download/myplug.apk&quot;);
PlugInfo plug = pluginMgr.loadPlugin(myPlug).iterator().next();
</code></pre></li>
<li><p>start activity:</p>
<pre><code>mgr.startMainActivity(context, plug);
</code></pre></li>
</ol>
<p>基本的用法就像以上这五步，另外需要注意的是，“插件”中所需要的权限都要在“宿主”的 AndroidManifest.xml 中进行申明。</p>
<h2 id="PluginManager-init_28this_29_u6E90_u7801"><a href="#PluginManager-init_28this_29_u6E90_u7801" class="headerlink" title="PluginManager.init(this)源码"></a>PluginManager.init(this)源码</h2><p>下面我们来分析下 <code>PluginManager.init(this);</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 初始化插件管理器,请不要传入易变的Context,那将造成内存泄露!</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context Application上下文</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SINGLETON != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Trace.store(<span class="string">"PluginManager have been initialized, YOU needn't initialize it again!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.store(<span class="string">"init PluginManager..."</span>);</span><br><span class="line">    SINGLETON = <span class="keyword">new</span> PluginManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 <code>init(Context context)</code> 中主要创建了一个 <code>SINGLETON</code> 单例，所以我们就要追踪 <code>PluginManager</code> 构造器的源码了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插件管理器私有构造器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context Application上下文</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMainThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException(<span class="string">"PluginManager must init in UI Thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    File optimizedDexPath = context.getDir(Globals.PRIVATE_PLUGIN_OUTPUT_DIR_NAME, Context.MODE_PRIVATE);</span><br><span class="line">    dexOutputPath = optimizedDexPath.getAbsolutePath();</span><br><span class="line">    dexInternalStoragePath = context.getDir(</span><br><span class="line">            Globals.PRIVATE_PLUGIN_ODEX_OUTPUT_DIR_NAME, Context.MODE_PRIVATE</span><br><span class="line">    );</span><br><span class="line">    DelegateActivityThread delegateActivityThread = DelegateActivityThread.getSingleton();</span><br><span class="line">    Instrumentation originInstrumentation = delegateActivityThread.getInstrumentation();</span><br><span class="line">    <span class="keyword">if</span> (!(originInstrumentation <span class="keyword">instanceof</span> PluginInstrumentation)) &#123;</span><br><span class="line">        PluginInstrumentation pluginInstrumentation = <span class="keyword">new</span> PluginInstrumentation(originInstrumentation);</span><br><span class="line">        delegateActivityThread.setInstrumentation(pluginInstrumentation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中做的事情有点多，我们一步步来看下。一开始得到插件 dex opt 输出路径 <code>dexOutputPath</code> 和私有目录中存储插件的路径 <code>dexInternalStoragePath</code> 。这些路径都是在 <code>Global</code> 类中事先定义好的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 私有目录中保存插件文件的文件夹名</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_PLUGIN_OUTPUT_DIR_NAME = <span class="string">"plugins-file"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 私有目录中保存插件odex的文件夹名</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_PLUGIN_ODEX_OUTPUT_DIR_NAME = <span class="string">"plugins-opt"</span>;</span><br></pre></td></tr></table></figure>
<p>但是根据常量定义的名称来看，总感觉作者在 <code>context.getDir()</code> 时把这两个路径搞反了 \(╯-╰)/。</p>
<p>之后在构造器中创建了 <code>DelegateActivityThread</code> 类的单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateActivityThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelegateActivityThread SINGLETON = <span class="keyword">new</span> DelegateActivityThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Reflect activityThreadReflect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegateActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        activityThreadReflect = Reflect.on(ActivityThread.currentActivityThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DelegateActivityThread <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Application <span class="title">getInitialApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityThreadReflect.get(<span class="string">"mInitialApplication"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityThreadReflect.get(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstrumentation</span><span class="params">(Instrumentation newInstrumentation)</span> </span>&#123;</span><br><span class="line">        activityThreadReflect.set(<span class="string">"mInstrumentation"</span>, newInstrumentation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelegateActivityThread 类的主要作用就是使用反射包装了当前的 ActivityThread ，并且一开始在 DelegateActivityThread 中使用 PluginInstrumentation 替换原始的 Instrumentation 。其实 Activity 的生命周期调用都是通过 Instrumentation 来完成的。我们来看看 PluginInstrumentation 的构造器相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginInstrumentation</span> <span class="keyword">extends</span> <span class="title">DelegateInstrumentation</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当前正在运行的插件</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> PlugInfo currentPlugin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> mBase 真正的Instrumentation</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginInstrumentation</span><span class="params">(Instrumentation mBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 PluginInstrumentation 是继承自 DelegateInstrumentation 类的，而 DelegateInstrumentation 本质上就是 Instrumentation 。 DelegateInstrumentation 类中的方法都是直接调用 Instrumentation 类的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> mBase 真正的Instrumentation</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegateInstrumentation</span><span class="params">(Instrumentation mBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = mBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arguments)</span> </span>&#123;</span><br><span class="line">        mBase.onCreate(arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBase.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBase.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，在 <code>PluginManager.init()</code> 方法中大概做的就是这些逻辑了。</p>
<h1 id="0x02_PluginManager-loadPlugin"><a href="#0x02_PluginManager-loadPlugin" class="headerlink" title="0x02 PluginManager.loadPlugin"></a>0x02 PluginManager.loadPlugin</h1><p>看完了上面的 <code>PluginManager.init()</code> 之后，下一步就是调用 <code>pluginManager.loadPlugin</code> 去加载插件。一起来看看相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 加载指定插件或指定目录下的所有插件</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 都使用文件名作为Id</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> pluginSrcDirFile - apk或apk目录</span><br><span class="line"> * <span class="doctag">@return</span> 插件集合</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;PlugInfo&gt; <span class="title">loadPlugin</span><span class="params">(<span class="keyword">final</span> File pluginSrcDirFile)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pluginSrcDirFile == <span class="keyword">null</span> || !pluginSrcDirFile.exists()) &#123;</span><br><span class="line">        Trace.store(<span class="string">"invalidate plugin file or Directory :"</span></span><br><span class="line">                + pluginSrcDirFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pluginSrcDirFile.isFile()) &#123;</span><br><span class="line">        PlugInfo one = buildPlugInfo(pluginSrcDirFile, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (one != <span class="keyword">null</span>) &#123;</span><br><span class="line">            savePluginToMap(one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(one);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">//            pluginPkgToInfoMap.clear();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    File[] pluginApkFiles = pluginSrcDirFile.listFiles(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (pluginApkFiles == <span class="keyword">null</span> || pluginApkFiles.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"could not find plugins in:"</span></span><br><span class="line">                + pluginSrcDirFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File pluginApk : pluginApkFiles) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PlugInfo plugInfo = buildPlugInfo(pluginApk, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (plugInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                savePluginToMap(plugInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pluginPkgToInfoMap.values();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loadPlugin</code> 代码的注释中，我们可以知道加载的插件可以是一个也可以是一个文件夹下的多个。因为会根据传入的 <code>pluginSrcDirFile</code> 参数去判断是文件还是文件夹，其实道理都是一样的，无非就是多了一个 for 循环而已。在这里要注意一下，PluginManager 是实现了 FileFilter 接口的，因此在加载多个插件时，调用 <code>listFiles(this)</code> 会过滤当前文件夹下非 apk 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !pathname.isDirectory() &amp;&amp; pathname.getName().endsWith(<span class="string">".apk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们在 <code>loadPlugin()</code> 的代码中会注意到，无论是加载单个插件还是多个插件都会调用 <code>buildPlugInfo()</code> 方法。顾名思义，就是根据传入的插件文件去加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PlugInfo <span class="title">buildPlugInfo</span><span class="params">(File pluginApk, String pluginId,</span><br><span class="line">                               String targetFileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PlugInfo info = <span class="keyword">new</span> PlugInfo();</span><br><span class="line">    info.setId(pluginId == <span class="keyword">null</span> ? pluginApk.getName() : pluginId);</span><br><span class="line"></span><br><span class="line">    File privateFile = <span class="keyword">new</span> File(dexInternalStoragePath,</span><br><span class="line">            targetFileName == <span class="keyword">null</span> ? pluginApk.getName() : targetFileName);</span><br><span class="line"></span><br><span class="line">    info.setFilePath(privateFile.getAbsolutePath());</span><br><span class="line">    <span class="comment">//Copy Plugin to Private Dir</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginApk.getAbsolutePath().equals(privateFile.getAbsolutePath())) &#123;</span><br><span class="line">        copyApkToPrivatePath(pluginApk, privateFile);</span><br><span class="line">    &#125;</span><br><span class="line">    String dexPath = privateFile.getAbsolutePath();</span><br><span class="line">    <span class="comment">//Load Plugin Manifest</span></span><br><span class="line">    PluginManifestUtil.setManifestInfo(context, dexPath, info);</span><br><span class="line">    <span class="comment">//Load Plugin Res</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager am = AssetManager.class.newInstance();</span><br><span class="line">        am.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class)</span><br><span class="line">                .invoke(am, dexPath);</span><br><span class="line">        info.setAssetManager(am);</span><br><span class="line">        Resources hotRes = context.getResources();</span><br><span class="line">        Resources res = <span class="keyword">new</span> Resources(am, hotRes.getDisplayMetrics(),</span><br><span class="line">                hotRes.getConfiguration());</span><br><span class="line">        info.setResources(res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Resources&amp;Assets for "</span></span><br><span class="line">                + info.getPackageName() + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Load  classLoader for Plugin</span></span><br><span class="line">    PluginClassLoader pluginClassLoader = <span class="keyword">new</span> PluginClassLoader(info, dexPath, dexOutputPath</span><br><span class="line">            , getPluginLibPath(info).getAbsolutePath(), pluginParentClassLoader);</span><br><span class="line">    info.setClassLoader(pluginClassLoader);</span><br><span class="line">    ApplicationInfo appInfo = info.getPackageInfo().applicationInfo;</span><br><span class="line">    Application app = makeApplication(info, appInfo);</span><br><span class="line">    attachBaseContext(info, app);</span><br><span class="line">    info.setApplication(app);</span><br><span class="line">    Trace.store(<span class="string">"Build pluginInfo =&gt; "</span> + info);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中看到， <code>buildPlugInfo()</code> 方法中做的大致有四步：</p>
<ol>
<li>复制插件 apk 到指定目录；</li>
<li>加载插件 apk 的 AndroidManifest.xml 文件；</li>
<li>加载插件 apk 中的资源文件；</li>
<li>为插件 apk 设置 ClassLoader。</li>
</ol>
<h2 id="u590D_u5236_u63D2_u4EF6_apk__u5230_u6307_u5B9A_u76EE_u5F55"><a href="#u590D_u5236_u63D2_u4EF6_apk__u5230_u6307_u5B9A_u76EE_u5F55" class="headerlink" title="复制插件 apk 到指定目录"></a>复制插件 apk 到指定目录</h2><p>下面我们慢慢来分析，第一步，会把传入的插件 apk 复制到 <code>dexInternalStoragePath</code> 路径下，也就是之前在 PluginManager 的构造器中所指定的目录。这部分的代码很简单，就省略了。</p>
<h2 id="u52A0_u8F7D_u63D2_u4EF6_apk__u7684_AndroidManifest-xml__u6587_u4EF6"><a href="#u52A0_u8F7D_u63D2_u4EF6_apk__u7684_AndroidManifest-xml__u6587_u4EF6" class="headerlink" title="加载插件 apk 的 AndroidManifest.xml 文件"></a>加载插件 apk 的 AndroidManifest.xml 文件</h2><p>第二步，根据代码可知，会使用 <code>PluginManifestUtil.setManifestInfo()</code> 去加载 AndroidManifest 里的信息，那就去看下相关的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setManifestInfo</span><span class="params">(Context context, String apkPath, PlugInfo info)</span></span><br><span class="line">		<span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到AndroidManifest文件</span></span><br><span class="line">	ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="keyword">new</span> File(apkPath), ZipFile.OPEN_READ);</span><br><span class="line">	ZipEntry manifestXmlEntry = zipFile.getEntry(XmlManifestReader.DEFAULT_XML);</span><br><span class="line">	<span class="comment">// 解析AndroidManifest文件</span></span><br><span class="line">	String manifestXML = XmlManifestReader.getManifestXMLFromAPK(zipFile,</span><br><span class="line">			manifestXmlEntry);</span><br><span class="line">	<span class="comment">// 创建相应的packageInfo</span></span><br><span class="line">	PackageInfo pkgInfo = context.getPackageManager()</span><br><span class="line">			.getPackageArchiveInfo(</span><br><span class="line">					apkPath,</span><br><span class="line">					PackageManager.GET_ACTIVITIES</span><br><span class="line">							| PackageManager.GET_RECEIVERS<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_PROVIDERS<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_META_DATA<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_SHARED_LIBRARY_FILES<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_SERVICES<span class="comment">//</span></span><br><span class="line">			<span class="comment">// | PackageManager.GET_SIGNATURES//</span></span><br><span class="line">			);</span><br><span class="line">    <span class="keyword">if</span> (pkgInfo == <span class="keyword">null</span> || pkgInfo.activities == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlPullParserException(<span class="string">"No any activity in "</span> + apkPath);</span><br><span class="line">    &#125;</span><br><span class="line">    pkgInfo.applicationInfo.publicSourceDir = apkPath;</span><br><span class="line">    pkgInfo.applicationInfo.sourceDir = apkPath;</span><br><span class="line">	<span class="comment">// 得到libDir，加载.so文件</span></span><br><span class="line">	File libDir = PluginManager.getSingleton().getPluginLibPath(info);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (extractLibFile(zipFile, libDir)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">				pkgInfo.applicationInfo.nativeLibraryDir = libDir.getAbsolutePath();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		zipFile.close();</span><br><span class="line">	&#125;</span><br><span class="line">    info.setPackageInfo(pkgInfo);</span><br><span class="line">    setAttrs(info, manifestXML);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，一开始会通过 apk 得到 AndroidManifest.xml 文件。然后使用 <code>XmlManifestReader</code> 去读取 AndroidManifest 中的信息。在 <code>XmlManifestReader</code> 中会使用 <code>XmlPullParser</code> 去解析 xml ， <code>XmlManifestReader</code> 相关的源码就不贴出来了，想要进一步了解的童鞋可以自己去看，<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/utils/XmlManifestReader.java" target="_blank" rel="external">点击这里查看 XmlManifestReader 源码</a>。接下来根据 <code>apkPath</code> 得到相应的 <code>pkgInfo</code> ，并且若有 libDir 会去加载相应的 .so 文件。最后会调用 <code>setAttrs(info, manifestXML)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAttrs</span><span class="params">(PlugInfo info, String manifestXML)</span></span><br><span class="line">		<span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">	factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">	XmlPullParser parser = factory.newPullParser();</span><br><span class="line">	parser.setInput(<span class="keyword">new</span> StringReader(manifestXML));</span><br><span class="line">	<span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">	String namespaceAndroid = <span class="keyword">null</span>;</span><br><span class="line">	do &#123;</span><br><span class="line">		<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_DOCUMENT: &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">			String tag = parser.getName();</span><br><span class="line">			<span class="keyword">if</span> (tag.equals(<span class="string">"manifest"</span>)) &#123;</span><br><span class="line">				namespaceAndroid = parser.getNamespace(<span class="string">"android"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"activity"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addActivity(info, namespaceAndroid, parser);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"receiver"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addReceiver(info, namespaceAndroid, parser);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"service"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addService(info, namespaceAndroid, parser);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"application"</span>.equals(parser.getName()))&#123;</span><br><span class="line">				parseApplicationInfo(info, namespaceAndroid, parser);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.END_TAG: &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		eventType = parser.next();</span><br><span class="line">	&#125; <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setAttrs(PlugInfo info, String manifestXML)</code> 方法中，使用了 pull 方式去解析 manifest ，并且根据 activity 、 recevicer 、 service 等调用不同的 <code>addXxxx()</code> 方法。这些方法其实本质上是一样的，我们就挑 <code>addActivity()</code> 方法来看一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(PlugInfo info, String namespace,</span><br><span class="line">		XmlPullParser parser)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">	String activityName = parser.getAttributeValue(namespace, <span class="string">"name"</span>);</span><br><span class="line">	String packageName = info.getPackageInfo().packageName;</span><br><span class="line">	activityName = getName(activityName, packageName);</span><br><span class="line">	ResolveInfo act = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">	act.activityInfo = info.findActivityByClassNameFromPkg(activityName);</span><br><span class="line">	do &#123;</span><br><span class="line">		<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">			String tag = parser.getName();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"intent-filter"</span>.equals(tag)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (act.filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">					act.filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"action"</span>.equals(tag)) &#123;</span><br><span class="line">				String actionName = parser.getAttributeValue(namespace,</span><br><span class="line">						<span class="string">"name"</span>);</span><br><span class="line">				act.filter.addAction(actionName);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"category"</span>.equals(tag)) &#123;</span><br><span class="line">				String category = parser.getAttributeValue(namespace,</span><br><span class="line">						<span class="string">"name"</span>);</span><br><span class="line">				act.filter.addCategory(category);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"data"</span>.equals(tag)) &#123;</span><br><span class="line">				<span class="comment">// TODO parse data</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		eventType = parser.next();</span><br><span class="line">	&#125; <span class="keyword">while</span> (!<span class="string">"activity"</span>.equals(parser.getName()));</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	info.addActivity(act);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>addActivity()</code> 代码中的逻辑比较简单，就是创建一个 <code>ResolveInfo</code> 类的对象 <code>act</code> ，把 Activity 相关的信息全部装进去，比如有 ActivityInfo 、 intent-filter 等。最后把 <code>act</code> 添加到 <code>info</code> 中。其他的 <code>addReceiver</code> 和 <code>addService</code> 也是同一个逻辑。而 <code>parseApplicationInfo</code> 也是把 Application 的相关信息封装到 <code>info</code> 中。感兴趣的同学可以看一下相关的源码，<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/utils/PluginManifestUtil.java" target="_blank" rel="external">点击这里查看</a>。到这里，就把加载插件中 AndroidManifest.xml 的代码分析完了。</p>
<h2 id="u52A0_u8F7D_u63D2_u4EF6_apk__u4E2D_u7684_u8D44_u6E90_u6587_u4EF6"><a href="#u52A0_u8F7D_u63D2_u4EF6_apk__u4E2D_u7684_u8D44_u6E90_u6587_u4EF6" class="headerlink" title="加载插件 apk 中的资源文件"></a>加载插件 apk 中的资源文件</h2><p>再回到 <code>buildPlugInfo()</code> 的代码中去，接下来就是第三步，加载插件中的资源文件了。</p>
<p>为了方便，我们把相关的代码复制到这里来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AssetManager am = AssetManager.class.newInstance();</span><br><span class="line">    am.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class)</span><br><span class="line">            .invoke(am, dexPath);</span><br><span class="line">    info.setAssetManager(am);</span><br><span class="line">    Resources hotRes = context.getResources();</span><br><span class="line">    Resources res = <span class="keyword">new</span> Resources(am, hotRes.getDisplayMetrics(),</span><br><span class="line">            hotRes.getConfiguration());</span><br><span class="line">    info.setResources(res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Resources&amp;Assets for "</span></span><br><span class="line">            + info.getPackageName() + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过反射得到 <code>AssetManager</code> 的对象 <code>am</code>，然后通过反射其 <code>addAssetPath</code> 方法传入 <code>dexPath</code> 参数来加载插件的资源文件，接下来就得到相应插件的 <code>Resource</code> 对象 <code>res</code> 了。这样就实现了访问插件中的资源文件了。那么到底  <code>addAssetPath</code> 这个方法有什么魔力呢？我们查看一下 Android 相关的源代码（<a href="https://android.googlesource.com/platform/frameworks/base/+/56a2301/core/java/android/content/res/AssetManager.java" target="_blank" rel="external">android/content/res/AssetManager.java</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Add an additional set of assets to the asset manager.  This can be</span><br><span class="line"> * either a directory or ZIP file.  Not for use by applications.  Returns</span><br><span class="line"> * the cookie of the added asset, or 0 on failure.</span><br><span class="line"> * &#123;<span class="doctag">@hide</span>&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = addAssetPathNative(path);</span><br><span class="line">        makeStringBlocks(mStringBlocks);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看方法的注释我们知道，这个 <code>addAssetPath()</code> 方法就是用来添加额外的资源文件到 AssetManager 中去的，但是已经被 hide 了。所以我们只能通过反射的方式来执行了。这样就解决了加载插件中的资源文件的问题了。</p>
<p>其实，大多数插件化框架都是通过反射 <code>addAssetPath()</code> 的方式来解决加载插件资源问题，基本上已经成为了标准方案了。</p>
<h2 id="u4E3A_u63D2_u4EF6_apk__u8BBE_u7F6E_ClassLoader"><a href="#u4E3A_u63D2_u4EF6_apk__u8BBE_u7F6E_ClassLoader" class="headerlink" title="为插件 apk 设置 ClassLoader"></a>为插件 apk 设置 ClassLoader</h2><p>终于到了最后一个步骤了，如何为插件设置 ClassLoader 呢？其实解决的方案就是通过 <code>DexClassLoader</code> 。我们先来看 <code>buildPlugInfo()</code> 中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PluginClassLoader pluginClassLoader = <span class="keyword">new</span> PluginClassLoader(info, dexPath, dexOutputPath</span><br><span class="line">        , getPluginLibPath(info).getAbsolutePath(), pluginParentClassLoader);</span><br><span class="line">info.setClassLoader(pluginClassLoader);</span><br><span class="line">ApplicationInfo appInfo = info.getPackageInfo().applicationInfo;</span><br><span class="line">Application app = makeApplication(info, appInfo);</span><br><span class="line">attachBaseContext(info, app);</span><br><span class="line">info.setApplication(app);</span><br><span class="line">Trace.store(<span class="string">"Build pluginInfo =&gt; "</span> + info);</span><br></pre></td></tr></table></figure>
<p>在代码中创建了 <code>pluginClassLoader</code> 对象，而 <code>PluginClassLoader</code> 正是继承自 <code>DexClassLoader</code> 的，将 <code>dexPath</code> 、 <code>dexOutputPath</code> 等参数传入后，就可以去加载插件中的类了。 基本上所有的插件化框架都是通过 <code>DexClassLoder</code> 来作为插件 apk 的 ClassLoader 的。</p>
<p>之后在 <code>makeApplication(info, appInfo)</code> 就使用 <code>PluginClassLoader</code> 利用反射去创建插件的 Application 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构造插件的Application</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> plugInfo 插件信息</span><br><span class="line"> * <span class="doctag">@param</span> appInfo 插件ApplicationInfo</span><br><span class="line"> * <span class="doctag">@return</span> 插件App</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Application <span class="title">makeApplication</span><span class="params">(PlugInfo plugInfo, ApplicationInfo appInfo)</span> </span>&#123;</span><br><span class="line">    String appClassName = appInfo.className;</span><br><span class="line">    <span class="keyword">if</span> (appClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Default Application</span></span><br><span class="line">        appClassName = Application.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Application) plugInfo.getClassLoader().loadClass(appClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Application for "</span></span><br><span class="line">                    + plugInfo.getPackageName() + <span class="string">": "</span></span><br><span class="line">                    + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完插件的 Application 之后， 再调用 <code>attachBaseContext(info, app)</code> 方法把 Application 的 mBase 属性替换成 <code>PluginContext</code> 对象，<code>PluginContext</code> 类继承自 <a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/delegate/LayoutInflaterProxyContext.java" target="_blank" rel="external">LayoutInflaterProxyContext</a> ，里面封装了一些插件的信息，比如有插件资源、插件 ClassLoader 等。值得一提的是，在插件中 PluginContext 可以得到“宿主”的 Context ，也就是所谓的“破壳”。具体可查看<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/environment/PluginContext.java" target="_blank" rel="external"> PluginContext 的源码</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(PlugInfo info, Application app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field mBase = ContextWrapper.class.getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">        mBase.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        mBase.set(app, <span class="keyword">new</span> PluginContext(context.getApplicationContext(), info));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲到这里基本上把 <code>buildPlugInfo()</code> 中的逻辑讲完了， <code>pluginManager.loadPlugin</code> 剩下的代码都比较简单，相信大家一看就懂了。 </p>
<h1 id="0x03_PluginManager-startActivity"><a href="#0x03_PluginManager-startActivity" class="headerlink" title="0x03 PluginManager.startActivity"></a>0x03 PluginManager.startActivity</h1><h2 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h2><p>在加载好插件 apk 之后，就可以使用插件了。和平常无异，我们使用 <code>PluginManager.startActivity</code> 来启动插件中的 Activity 。其实 <code>PluginManager</code> 有很多 startActivity 的方法：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161002/201610041161253.jpg" alt="startActivity截图"></p>
<p>但是终于都会调用 <code>startActivity(Context from, PlugInfo plugInfo, ActivityInfo activityInfo, Intent intent)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DynamicActivitySelector activitySelector = DefaultActivitySelector.getDefault();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 启动插件的指定Activity</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> from         fromContext</span><br><span class="line"> * <span class="doctag">@param</span> plugInfo     插件信息</span><br><span class="line"> * <span class="doctag">@param</span> activityInfo 要启动的插件activity信息</span><br><span class="line"> * <span class="doctag">@param</span> intent       通过此Intent可以向插件传参, 可以为null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context from, PlugInfo plugInfo, ActivityInfo activityInfo, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activityInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(<span class="string">"Cannot find ActivityInfo from plugin, could you declare this Activity in plugin?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    &#125;</span><br><span class="line">    CreateActivityData createActivityData = <span class="keyword">new</span> CreateActivityData(activityInfo.name, plugInfo.getPackageName());</span><br><span class="line">    intent.setClass(from, activitySelector.selectDynamicActivity(activityInfo));</span><br><span class="line">    intent.putExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN, createActivityData);</span><br><span class="line">    from.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看代码， <code>CreateActivityData</code> 类是用来存储一个将要创建的插件 Activity 的数据，实现了 <code>Serializable</code> 接口，因此可以被序列化。总之， <code>CreateActivityData</code> 会存储将要创建的插件 Activity 的类名和包名，再把它放入 <code>intent</code> 中。之后， <code>intent</code> 设置要创建的 Activity 为 <code>activitySelector.selectDynamicActivity(activityInfo)</code> ，<code>activitySelector</code> 是 <code>DefaultActivitySelector</code> 类的对象，那么这 <code>DefaultActivitySelector</code> 到底是什么东西呢？一起来看看 <code>DefaultActivitySelector</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultActivitySelector</span> <span class="keyword">implements</span> <span class="title">DynamicActivitySelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DynamicActivitySelector DEFAULT = <span class="keyword">new</span> DefaultActivitySelector();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Activity&gt; selectDynamicActivity(ActivityInfo pluginActivityInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicActivity.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicActivitySelector <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很简单，不管传入的 <code>pluginActivityInfo</code> 参数是什么，返回的都是 <code>DynamicActivity.class</code> 。也就是我们在介绍<a href="/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/#android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5"> android-pluginmgr 简单用法</a>时，第二步在 AndroidManifest 中注册的那个 <code>DynamicActivity</code> 。<br>看到这里的代码，我们一定可以猜到什么。因为这里的 <code>intent</code> 中设置即将启动的 Activity 仍然为 <code>DynamicActivity</code> ，所以在后面的代码中肯定会去动态地替换掉 <code>DynamicActivity</code>。</p>
<h2 id="u52A8_u6001Hook"><a href="#u52A8_u6001Hook" class="headerlink" title="动态Hook"></a>动态Hook</h2><p>之前在 <a href="/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/#PluginManager-init_28this_29_u6E90_u7801">PluginManager.init(this) 源码</a>这一小节中介绍了，当前 <code>ActivityThread</code> 的 <code>Instrumentation</code> 已经被替换成了 <code>PluginInstrumentation</code>。所以在创建 Activity 的时候会去调用 <code>PluginInstrumentation</code> 里面的方法。这样就可以在里面“做手脚”，实现了动态去替换 Activity 的思路。我们先来看一下 <code>PluginInstrumentation</code> 中部分方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceIntentTargetIfNeed</span><span class="params">(Context from, Intent intent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!intent.hasExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN) &amp;&amp; currentPlugin != <span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        ComponentName componentName = intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (componentName != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            String pkgName = componentName.getPackageName();</span><br><span class="line">            String activityName = componentName.getClassName();</span><br><span class="line">            <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                CreateActivityData createActivityData = <span class="keyword">new</span> CreateActivityData(activityName, currentPlugin.getPackageName());</span><br><span class="line">                ActivityInfo activityInfo = currentPlugin.findActivityByClassName(activityName);</span><br><span class="line">                <span class="keyword">if</span> (activityInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    intent.setClass(from, PluginManager.getSingleton().getActivitySelector().selectDynamicActivity(activityInfo));</span><br><span class="line">                    intent.putExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN, createActivityData);</span><br><span class="line">                    intent.setExtrasClassLoader(currentPlugin.getClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Fragment fragment, Intent intent, <span class="keyword">int</span> requestCode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, fragment, intent, requestCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Fragment fragment, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, fragment, intent, requestCode, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, target, intent, requestCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, target, intent, requestCode, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在所有的 <code>execStartActivity()</code> 方法执行前，都加上了 <code>replaceIntentTargetIfNeed(Context from, Intent intent)</code> 这个方法，在方法里面 <code>intent.setClass</code> 中设置的还是 <code>DynamicActivity.class</code> ，把插件信息都检查了一遍。</p>
<p>在这之后，会去执行 <code>PluginInstrumentation.newActivity</code> 方法来创建即将要启动的Activity 。也正是在这里，对之前的 <code>DynamicActivity</code> 进行 Hook ，达到启动插件 Activity 的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException</span><br><span class="line"></span>&#123;</span><br><span class="line">    CreateActivityData activityData = (CreateActivityData) intent.getSerializableExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN);</span><br><span class="line">    <span class="comment">//如果activityData存在,那么说明将要创建的是插件Activity</span></span><br><span class="line">    <span class="keyword">if</span> (activityData != <span class="keyword">null</span> &amp;&amp; PluginManager.getSingleton().getPlugins().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里找不到插件信息就会抛异常的,不用担心空指针</span></span><br><span class="line">        PlugInfo plugInfo;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">            Log.d(getClass().getSimpleName(), <span class="string">"+++ Start Plugin Activity =&gt; "</span> + activityData.pluginPkg + <span class="string">" / "</span> + activityData.activityName);</span><br><span class="line">            <span class="comment">// 得到插件信息类</span></span><br><span class="line">            plugInfo = PluginManager.getSingleton().tryGetPluginInfo(activityData.pluginPkg);</span><br><span class="line">            <span class="comment">// 在该方法中会调用插件的Application.onCreate()</span></span><br><span class="line">            plugInfo.ensureApplicationCreated();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">catch</span> (PluginNotFoundException e)</span><br><span class="line">		&#123;</span><br><span class="line">            PluginManager.getSingleton().dump();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">"Cannot get plugin Info : "</span> + activityData.pluginPkg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (activityData.activityName != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 在这里替换了className，变成了插件Activity的className</span></span><br><span class="line">            className = activityData.activityName;</span><br><span class="line">            <span class="comment">// 替换classloader</span></span><br><span class="line">            cl = plugInfo.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.newActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>newActivity()</code> 方法中，先拿到了插件信息 <code>plugInfo</code> ，然后会确保插件的 <code>Application</code> 已经创建。然后在第25行会去替换掉 <code>className</code> 和 <code>cl</code> 。这样，原本要创建的是 <code>DynamicActivity</code> 就变成了插件的 <code>Activity</code> 了，从而实现了创建插件 Activity 的目的，并且这个 Activity 是真实的 Activity 组件，具备生命周期的。</p>
<p>也许有童鞋会有疑问，如果直接在 <code>startActivity</code> 中设置要启动的 Activity 为插件 Activity ，这样不行吗？答案是肯定的，因为这样就会抛出一个异常：<code>ActivityNotFoundException:...have you declared this activity in your AndroidManifest.xml?</code>我相信这个异常大家很熟悉的吧，在刚开始学习 Android 时，大家都会犯的一个错误。所以，我想我们也明白了为什么要花这么大的一个功夫去动态地替换要创建的 Activity ，就是为了绕过这个 <code>ActivityNotFoundException</code> 异常，达到去“欺骗” Android 系统的效果。</p>
<p>既然创建好了，那么就来看看 <code>PluginInstrumentation</code> 里调用相关生命周期的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    lookupActivityInPlugin(activity);</span><br><span class="line">    <span class="keyword">if</span> (currentPlugin != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化插件Activity</span></span><br><span class="line">        Context baseContext = activity.getBaseContext();</span><br><span class="line">        PluginContext pluginContext = <span class="keyword">new</span> PluginContext(baseContext, currentPlugin);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在许多设备上，Activity自身hold资源</span></span><br><span class="line">                Reflect.on(activity).set(<span class="string">"mResources"</span>, pluginContext.getResources());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field field = ContextWrapper.class.getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(activity, pluginContext);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reflect.on(activity).set(<span class="string">"mApplication"</span>, currentPlugin.getApplication());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ReflectException e) &#123;</span><br><span class="line">                Trace.store(<span class="string">"Application not inject success into : "</span> + activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityInfo activityInfo = currentPlugin.findActivityByClassName(activity.getClass().getName());</span><br><span class="line">        <span class="keyword">if</span> (activityInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据AndroidManifest.xml中的参数设置Theme</span></span><br><span class="line">            <span class="keyword">int</span> resTheme = activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (resTheme != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> hasNotSetTheme = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Field mTheme = ContextThemeWrapper.class</span><br><span class="line">                            .getDeclaredField(<span class="string">"mTheme"</span>);</span><br><span class="line">                    mTheme.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    hasNotSetTheme = mTheme.get(activity) == <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasNotSetTheme) &#123;</span><br><span class="line">                    changeActivityInfo(activityInfo, activity);</span><br><span class="line">                    activity.setTheme(resTheme);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是三星手机，则使用包装的LayoutInflater替换原LayoutInflater</span></span><br><span class="line">        <span class="comment">// 这款手机在解析内置的布局文件时有各种错误</span></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.MODEL.startsWith(<span class="string">"GT"</span>)) &#123;</span><br><span class="line">            Window window = activity.getWindow();</span><br><span class="line">            Reflect windowRef = Reflect.on(window);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LayoutInflater originInflater = window.getLayoutInflater();</span><br><span class="line">                <span class="keyword">if</span> (!(originInflater <span class="keyword">instanceof</span> LayoutInflaterWrapper)) &#123;</span><br><span class="line">                    windowRef.set(<span class="string">"mLayoutInflater"</span>, <span class="keyword">new</span> LayoutInflaterWrapper(originInflater));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.callActivityOnCreate(activity, icicle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查跳转目标是不是来自插件</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> activity Activity</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lookupActivityInPlugin</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = activity.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> PluginClassLoader) &#123;</span><br><span class="line">        currentPlugin = ((PluginClassLoader) classLoader).getPlugInfo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentPlugin = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>callActivityOnCreate()</code> 中先去检查了创建的 Activity 是否来自于插件。如果是，那么会给 Activity 设置 Context 、 设置主题等；如果不是，则直接执行父类方法。在 <code>super.callActivityOnCreate(activity, icicle)</code> 中会去调用 <code>Activity.onCreate()</code>方法。其他的生命周期方法作者没有特殊处理，这里就不讲了。</p>
<p>分析到这，我们终于把 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 插件化实现的方案完整地梳理了一遍。当然，不同的插件化框架会有不同的实现方案，具体的仍然需要自己专心研究。另外我们发现该框架还没有实现启动插件 Service 的功能，如果想要了解，可以参考下其他插件化框架。</p>
<h1 id="0x04__u603B_u7ED3"><a href="#0x04__u603B_u7ED3" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>上面乱七八糟的流程讲了一遍，可能还有一些童鞋不太懂，所以在这里给出一张 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的流程图。不懂的童鞋可以根据这张图再好好看一下源码，相信你会恍然大悟的。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161002/20161005183404.png" alt="android-pluginmgr流程图"></p>
<p>最后，如果对本文哪里有疑问的童鞋，欢迎留言，一起交流。</p>
<h1 id="0x05_References"><a href="#0x05_References" class="headerlink" title="0x05 References"></a>0x05 References</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993300&amp;idx=1&amp;sn=797fa87ef528cff3a50e77806cf9f675&amp;scene=1&amp;srcid=07125lNtkiWhjbu4dp8GhoAf#rd" target="_blank" rel="external">包建强：为什么我说Android插件化从入门到放弃？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD"><a href="#0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD" ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Java实现Android多渠道打包工具]]></title>
    <link href="http://yuqirong.me/2016/09/25/%E7%94%A8Java%E5%AE%9E%E7%8E%B0Android%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>http://yuqirong.me/2016/09/25/用Java实现Android多渠道打包工具/</id>
    <published>2016-09-25T11:52:14.000Z</published>
    <updated>2016-11-01T15:09:12.857Z</updated>
    <content type="html"><![CDATA[<h1 id="0001b"><a href="#0001b" class="headerlink" title="0001b"></a>0001b</h1><p>最近在公司做了一个多渠道打包的工具，趁今天有空就来讲讲 Android 多渠道打包这件小事。众所周知，随着业务的不断增长，APP 的渠道也会越来越多，如果用 Gradle 打多渠道包的话，可能会耗费几个小时的时间才能打出几百个渠道包。所以就必须有一种方法能够解决这种问题。</p>
<p>目前市面上比较好的解决方案就是在 apk 文件中“动手脚”，比如由一位360 Android 工程师提出的“在 apk 文件中添加 comments 多渠道打包方法”，具体的代码在GitHub 上可以找到：<a href="https://github.com/seven456/MultiChannelPackageTool" target="_blank" rel="external">MultiChannelPackageTool</a> 。除此之外，还有美团点评技术团队在博客上发表过一篇<a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">《美团Android自动化之旅—生成渠道包》</a>，里面讲叙了一种在 apk 文件中的 META-INF 目录下添加渠道信息的方法，之后再在程序启动时去动态读取，具体的实现原理可以去美团博客上看，这里就不说了。</p>
<p>我们解压多渠道打出来的 apk 包后，就会发现在 META-INF 目录下多了一个 channel_xxxxx 文件，而这个就是我们的渠道文件：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160925/20160925221513.png" alt="channel文件"></p>
<p>本文所采用的方法就是根据美团提供的思路实现的，当然网上有很多使用 Python 语言实现美团思路的版本，经过测试发现 Python 版本比 Java 版本打渠道包的速度更快一些。但是，在这里只提供 Java 版本实现方案，Python 版本实现的方案会在文末以参考链接的方式给出。</p>
<h1 id="0010b"><a href="#0010b" class="headerlink" title="0010b"></a>0010b</h1><p>在这里先说明一下，Java 编写的多渠道打包工具依赖 commons-io.jar 和 zip4j.jar 。下面我们就开始进入正题吧。</p>
<p>我们先规定一下，渠道文件命名为 channel.txt ，并且要打包的 apk 文件和 channel.txt 与多渠道打包工具在同一目录下。</p>
<p>其中 channel.txt 的格式就是每个渠道独占一行，如下所示：</p>
<pre><code>wandoujia
googleplay
xiaomi
huawei
kumarket
anzhi
</code></pre><p>然后我们先定义几个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渠道文件地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL_FILE_PATH = <span class="string">"./channel.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET_NAME = <span class="string">"UTF-8"</span>;</span><br><span class="line"><span class="comment">// 当前要打包的apk的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_PATH = <span class="string">"./"</span>;</span><br><span class="line"><span class="comment">// 渠道打包后输出的apk文件夹前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_OUT_PATH_PREFIX = <span class="string">"./out_apk_"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br></pre></td></tr></table></figure>
<p>定义好之后，我们下一步就是编写方法去读取 channel.txt 中的渠道信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 从文件中读取channel</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		inputStream = <span class="keyword">new</span> FileInputStream(CHANNEL_FILE_PATH);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream,</span><br><span class="line">				CHARSET_NAME));</span><br><span class="line">		String buffer;</span><br><span class="line">		<span class="keyword">while</span> ((buffer = reader.readLine()) != <span class="keyword">null</span> &amp;&amp; buffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"发现已有渠道 : "</span> + buffer);</span><br><span class="line">			channelList.add(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		System.out.println(<span class="string">"当前目录下未找到channel.txt"</span>);</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">				reader.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					inputStream.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> channelList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 <code>getChannel()</code> 方法中都是简单的 I/O 流操作，相信不需要解释大家都可以看得懂吧。之后我们要做的就是去当前路径下查找有无 apk 文件。在这里说明一下，我们这个多渠道打包小工具是支持多个 apk 文件一起打包的，所以我们要把当前目录下所有 apk 文件的路径存储起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 得到当前目录下的所有apk</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> file</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getApk</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; apkList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	File[] childFiles = file.listFiles();</span><br><span class="line">	<span class="keyword">for</span> (File childFile : childFiles) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!childFile.isDirectory()</span><br><span class="line">				&amp;&amp; childFile.getName().endsWith(APK_SUFFIX)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"发现已有apk : "</span> + childFile.getName());</span><br><span class="line">			apkList.add(childFile.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> apkList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做好上面的步骤后，最后就剩下打包的代码了，一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打包apk</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildApk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; apkList = getApk(<span class="keyword">new</span> File(APK_PATH));</span><br><span class="line">	<span class="keyword">int</span> count = apkList.size();</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"当前目录下没有发现apk文件"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历所有apk文件</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		String name = apkList.get(i);</span><br><span class="line">		<span class="comment">// 得到文件名字</span></span><br><span class="line">		String baseName = apkList.get(i).substring(<span class="number">0</span>,</span><br><span class="line">				name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">		<span class="comment">// apk输出目录</span></span><br><span class="line">		File dictionary = <span class="keyword">new</span> File(APK_OUT_PATH_PREFIX + baseName);</span><br><span class="line">		<span class="keyword">if</span> (!dictionary.exists()) &#123;</span><br><span class="line">			dictionary.mkdir();</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; channelList = getChannel();</span><br><span class="line">		<span class="keyword">if</span> (channelList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"channel.txt文件中没有多渠道信息"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历所有渠道</span></span><br><span class="line">		<span class="keyword">for</span> (String channel : channelList) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String sourceFileName = APK_PATH + name;</span><br><span class="line">				<span class="comment">// 输出的apk名字</span></span><br><span class="line">				String outApkName = baseName + <span class="string">"_"</span> + channel + APK_SUFFIX;</span><br><span class="line">				<span class="comment">// apk包的路径</span></span><br><span class="line">				String outApkFileName = dictionary.getName() + <span class="string">"/"</span> + outApkName;</span><br><span class="line">				<span class="comment">// 复制要打包的apk</span></span><br><span class="line">				copy(sourceFileName, outApkFileName);</span><br><span class="line">				System.out.println(<span class="string">"正在打 "</span> + channel + <span class="string">" 的渠道包 : "</span> + outApkName);</span><br><span class="line">				ZipFile zipFile = <span class="keyword">new</span> ZipFile(outApkFileName);</span><br><span class="line">				ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">				parameters</span><br><span class="line">						.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);</span><br><span class="line">				parameters</span><br><span class="line">						.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL);</span><br><span class="line">				parameters.setRootFolderInZip(<span class="string">"META-INF/"</span>);</span><br><span class="line">				<span class="comment">// 当前目录下创建一个channel_xxxxx文件</span></span><br><span class="line">				File channelFile = <span class="keyword">new</span> File(dictionary.getName() + <span class="string">"/channel_"</span></span><br><span class="line">						+ channel);</span><br><span class="line">				<span class="keyword">if</span> (!channelFile.exists()) &#123;</span><br><span class="line">					channelFile.createNewFile();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 在META-INF文件夹中添加channel_xxxxx文件</span></span><br><span class="line">				zipFile.addFile(channelFile, parameters);</span><br><span class="line">				<span class="comment">// 删除当前目录下的channel_xxxxx文件</span></span><br><span class="line">				channelFile.delete();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ZipException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 复制文件</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> sourceFilePath</span><br><span class="line"> * <span class="doctag">@param</span> copyFilePath</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String sourceFilePath, String copyFilePath)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 这里使用的是 common-io.jar 中的文件复制方法，比原生Java I/O API操作速度要快</span></span><br><span class="line">		FileUtils.copyFile(<span class="keyword">new</span> File(sourceFilePath), <span class="keyword">new</span> File(copyFilePath));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> preTime = System.currentTimeMillis();</span><br><span class="line">	buildApk();</span><br><span class="line">	System.out.println(<span class="string">"多渠道打包完成，耗时 "</span> + (System.currentTimeMillis() - preTime)/<span class="number">1000</span> + <span class="string">" s"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buildApk()</code> 方法中主要做的就是两个 for 循环嵌套。遍历当前目录的 apk 文件，然后遍历渠道信息，最后打包。另外需要注意的是要复制出一个 apk 文件来进行多渠道打包，而不是在原文件的基础上。</p>
<p>在这里打包的部分就结束了，我们还有一个步骤需要完成。那就是在应用程序启动时去读取相应的渠道，可以通过以下方法去读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChannelFromMeta</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ApplicationInfo appinfo = context.getApplicationInfo();</span><br><span class="line">    String sourceDir = appinfo.sourceDir;</span><br><span class="line">    String ret = <span class="string">""</span>;</span><br><span class="line">    ZipFile zipfile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zipfile = <span class="keyword">new</span> ZipFile(sourceDir);</span><br><span class="line">        Enumeration&lt;?&gt; entries = zipfile.entries();</span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            ZipEntry entry = ((ZipEntry) entries.nextElement());</span><br><span class="line">            String entryName = entry.getName();</span><br><span class="line">            <span class="keyword">if</span> (entryName.startsWith(<span class="string">"META-INF/channel_"</span>)) &#123;</span><br><span class="line">                ret = entryName;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zipfile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zipfile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] split = ret.split(<span class="string">"_"</span>);</span><br><span class="line">    <span class="keyword">if</span> (split != <span class="keyword">null</span> &amp;&amp; split.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret.substring(split[<span class="number">0</span>].length() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取渠道之后，我们 APP 可以把相应的渠道号发送给服务器或者第三方统计平台做统计。</p>
<h1 id="0011b"><a href="#0011b" class="headerlink" title="0011b"></a>0011b</h1><p>最后，我们可以把这个多渠道打包的 Java 项目打成一个 jar 包，然后写一个 bat 脚本，这样就通过鼠标双击就可以实现快速打渠道包了。以下是 bat 脚本的内容，要注意的是 bat 脚本要和 jar 包处于同一级目录下才可以哦：</p>
<pre><code>@echo off
echo 欢迎使用多渠道打包工具
echo 请确保当前目录下有要打包的apk文件和渠道信息channel.txt
java -jar AndroidBuildApkTool.jar
echo 按任意键退出
pause&gt;nul
exit
</code></pre><p>通过我们的努力 Java 版的多渠道打包工具就做好了。但是不足的是，测试后发现 Java 版打渠道包的速度没有 Python 版的快，主要是在 apk 文件中添加渠道信息文件这一步操作耗费的时间有点多。如果哪位小伙伴有更好的解决方案，欢迎联系我！</p>
<p>附上多渠道打包工具的源码：</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160925/MultiChannelBuildTool.rar" target="_blank" rel="external">MultiChannelBuildTool.rar</a></p>
<h1 id="0100b"><a href="#0100b" class="headerlink" title="0100b"></a>0100b</h1><p>References：</p>
<ul>
<li><a href="http://www.jianshu.com/p/7236ceca2630" target="_blank" rel="external">Gradle 多渠道打包实践</a></li>
<li><a href="http://www.jianshu.com/p/e0783783d26d" target="_blank" rel="external">快速多渠道打包</a></li>
<li><a href="http://geek.csdn.net/news/detail/76488" target="_blank" rel="external">深入浅出Android打包</a></li>
<li><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团Android自动化之旅—生成渠道包</a></li>
<li><a href="https://github.com/seven456/MultiChannelPackageTool" target="_blank" rel="external">MultiChannelPackageTool</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001b"><a href="#0001b" class="headerlink" title="0001b"></a>0001b</h1><p>最近在公司做了一个多渠道打包的工具，趁今天有空就来讲讲 Android 多渠道打包这件小事。众所周知，随着业务的不断]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于Android日夜间模式实现的探讨]]></title>
    <link href="http://yuqirong.me/2016/09/08/%E5%AF%B9%E4%BA%8EAndroid%E6%97%A5%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
    <id>http://yuqirong.me/2016/09/08/对于Android日夜间模式实现的探讨/</id>
    <published>2016-09-08T10:32:11.000Z</published>
    <updated>2016-11-01T15:08:08.773Z</updated>
    <content type="html"><![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有相关的模式切换。实现日间/夜间模式切换的方案也有许多种，趁着今天有空来讲一下日间/夜间模式切换的几种实现方案，也可以做一个横向的对比来看看哪种方案最好。</p>
<p>在本篇文章中给出了三种实现日间/夜间模式切换的方案：</p>
<ol>
<li>使用 setTheme 的方法让 Activity 重新设置主题；</li>
<li>设置 Android Support Library 中的 UiMode 来支持日间/夜间模式的切换；</li>
<li>通过资源 id 映射，回调自定义 ThemeChangeListener 接口来处理日间/夜间模式的切换。</li>
</ol>
<p>三种方案综合起来可能导致文章的篇幅过长，请耐心阅读。</p>
<h1 id="0x0002"><a href="#0x0002" class="headerlink" title="0x0002"></a>0x0002</h1><h2 id="u4F7F_u7528_setTheme__u65B9_u6CD5"><a href="#u4F7F_u7528_setTheme__u65B9_u6CD5" class="headerlink" title="使用 setTheme 方法"></a>使用 setTheme 方法</h2><p>我们先来看看使用 setTheme 方法来实现日间/夜间模式切换的方案。这种方案的思路很简单，就是在用户选择夜间模式时，Activity 设置成夜间模式的主题，之后再让 Activity 调用 recreate() 方法重新创建一遍就行了。</p>
<p>那就动手吧，在 colors.xml 中定义两组颜色，分别表示日间和夜间的主题色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后在 styles.xml 中定义两组主题，也就是日间主题和夜间主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/black&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"NightAppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"><span class="at_rule"></span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimary"</span>&gt;@color/nightColorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/nightColorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在主题中的 <code>mainBackground</code> 属性是我们自定义的属性，用来表示背景色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"mainBackground"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是看一下布局 activity_main.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"?attr/mainBackground"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"com.yuqirong.themedemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"切换日/夜间模式"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"通过setTheme()的方法"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;RelativeLayout&gt;</code> 的 <code>android:background</code> 属性中，我们使用 <code>&quot;?attr/mainBackground&quot;</code> 来表示，这样就代表着 <code>RelativeLayout</code> 的背景色会去引用在主题中事先定义好的 <code>mainBackground</code> 属性的值。这样就实现了日间/夜间模式切换的换色了。</p>
<p>最后就是 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theme = R.style.AppTheme;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		<span class="comment">// 判断是否有主题存储</span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">            theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">            setTheme(theme);</span><br><span class="line">        &#125;</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                theme = (theme == R.style.AppTheme) ? R.style.NightAppTheme : R.style.AppTheme;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putInt(<span class="string">"theme"</span>, theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中有几点要注意一下：</p>
<ol>
<li><p>调用 <code>recreate()</code> 方法后 Activity 的生命周期会调用 <code>onSaveInstanceState(Bundle outState)</code> 来备份相关的数据，之后也会调用 <code>onRestoreInstanceState(Bundle savedInstanceState)</code> 来还原相关的数据，因此我们把 <code>theme</code> 的值保存进去，以便 Activity 重新创建后使用。</p>
</li>
<li><p>我们在 <code>onCreate(Bundle savedInstanceState)</code> 方法中还原得到了 <code>theme</code> 值后，<code>setTheme()</code> 方法一定要在 <code>setContentView()</code> 方法之前调用，否则的话就看不到效果了。</p>
</li>
<li><p><code>recreate()</code> 方法是在 API 11 中添加进来的，所以在 Android 2.X 中使用会抛异常。</p>
</li>
</ol>
<p>贴完上面的代码之后，我们来看一下该方案实现的效果图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160908/20160909103512.gif" alt="setTheme()效果图gif"></p>
<h2 id="u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5"><a href="#u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5" class="headerlink" title="使用 Android Support Library 中的 UiMode 方法"></a>使用 Android Support Library 中的 UiMode 方法</h2><p>使用 UiMode 的方法也很简单，我们需要把 colors.xml 定义为日间/夜间两种。之后根据不同的模式会去选择不同的 colors.xml 。在 Activity 调用 recreate() 之后，就实现了切换日/夜间模式的功能。</p>
<p>说了这么多，直接上代码。下面是 values/colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 values/colors.xml 之外，我们还要创建一个 values-night/colors.xml 文件，用来设置夜间模式的颜色，其中 <code>&lt;color&gt;</code> 的 name 必须要和 values/colors.xml 中的相对应：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 styles.xml 中去引用我们在 colors.xml 中定义好的颜色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@color/textColor&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/backgroundColor&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>activity_main.xml 布局的内容和上面 setTheme() 方法中的相差无几，这里就不贴出来了。之后的事情就变得很简单了，在 MyApplication 中先选择一个默认的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 默认设置为日间模式</span></span><br><span class="line">        AppCompatDelegate.setDefaultNightMode(</span><br><span class="line">                AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，这里的 Mode 有四种类型可以选择：</p>
<ul>
<li>MODE_NIGHT_NO： 使用亮色(light)主题，不使用夜间模式；</li>
<li>MODE_NIGHT_YES：使用暗色(dark)主题，使用夜间模式；</li>
<li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题；</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO</li>
</ul>
<p>当用户点击按钮切换日/夜间时，重新去设置相应的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;</span><br><span class="line">                getDelegate().setLocalNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO</span><br><span class="line">                        ? AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">                <span class="comment">// 同样需要调用recreate方法使之生效</span></span><br><span class="line">                recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下 UiMode 方案实现的效果图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160908/20160910011353.gif" alt="UiMode的效果图gif"></p>
<p>就前两种方法而言，配置比较简单，最后的实现效果也都基本上是一样的。但是缺点就是需要调用 <code>recreate()</code> 使之生效。而让 Activity 重新创建就必须涉及到一些状态的保存。这就增加了一些难度。所以，我们一起来看看第三种解决方法。</p>
<h2 id="u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3"><a href="#u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3" class="headerlink" title="通过资源 id 映射，回调接口"></a>通过资源 id 映射，回调接口</h2><p>第三种方法的思路就是根据设置的主题去动态地获取资源 id 的映射，然后使用回调接口的方式让 UI 去设置相关的属性值。我们在这里先规定一下：夜间模式的资源在命名上都要加上后缀 “_night” ，比如日间模式的背景色命名为 color_background ，那么相对应的夜间模式的背景资源就要命名为 color_background_night 。好了，下面就是我们的 Demo 所需要用到的 colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark_night"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent_night"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor_night"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到每一项 color 都会有对应的 “_night” 与之匹配。</p>
<p>看到这里，肯定有人会问，为什么要设置对应的 “_night” ？到底是通过什么方式来设置日/夜间模式的呢？下面就由 ThemeManager 来为你解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThemeMode mThemeMode = ThemeMode.DAY;</span><br><span class="line">    <span class="comment">// 主题模式监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;OnThemeChangeListener&gt; mThemeChangeListenerList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间资源的缓存，key : 资源类型, 值&lt;key:资源名称, value:int值&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; sCachedNightResrouces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间模式资源的后缀，比如日件模式资源名为：R.color.activity_bg, 那么夜间模式就为 ：R.color.activity_bg_night</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_SUFFIX = <span class="string">"_night"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式，分为日间模式和夜间模式</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ThemeMode &#123;</span><br><span class="line">        DAY, NIGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 设置主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> themeMode</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThemeMode</span><span class="params">(ThemeMode themeMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeMode != themeMode) &#123;</span><br><span class="line">            mThemeMode = themeMode;</span><br><span class="line">            <span class="keyword">if</span> (mThemeChangeListenerList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (OnThemeChangeListener listener : mThemeChangeListenerList) &#123;</span><br><span class="line">                    listener.onThemeChanged();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的日间模式的resId得到相应主题的resId，注意：必须是日间模式的resId</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> dayResId 日间模式的resId</span><br><span class="line">     * <span class="doctag">@return</span> 相应主题的resId，若为日间模式，则得到dayResId；反之夜间模式得到nightResId</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThemeRes</span><span class="params">(Context context, <span class="keyword">int</span> dayResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getThemeMode() == ThemeMode.DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> dayResId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源名</span></span><br><span class="line">        String entryName = context.getResources().getResourceEntryName(dayResId);</span><br><span class="line">        <span class="comment">// 资源类型</span></span><br><span class="line">        String typeName = context.getResources().getResourceTypeName(dayResId);</span><br><span class="line">        HashMap&lt;String, Integer&gt; cachedRes = sCachedNightResrouces.get(typeName);</span><br><span class="line">        <span class="comment">// 先从缓存中去取，如果有直接返回该id</span></span><br><span class="line">        <span class="keyword">if</span> (cachedRes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedRes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer resId = cachedRes.get(entryName + RESOURCE_SUFFIX);</span><br><span class="line">        <span class="keyword">if</span> (resId != <span class="keyword">null</span> &amp;&amp; resId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果缓存中没有再根据资源id去动态获取</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过资源名，资源类型，包名得到资源int值</span></span><br><span class="line">                <span class="keyword">int</span> nightResId = context.getResources().getIdentifier(entryName + RESOURCE_SUFFIX, typeName, context.getPackageName());</span><br><span class="line">                <span class="comment">// 放入缓存中</span></span><br><span class="line">                cachedRes.put(entryName + RESOURCE_SUFFIX, nightResId);</span><br><span class="line">                sCachedNightResrouces.put(typeName, cachedRes);</span><br><span class="line">                <span class="keyword">return</span> nightResId;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Resources.NotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 反注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unregisterThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 得到主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThemeMode <span class="title">getThemeMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mThemeMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式切换监听器</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 主题切换时回调</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 ThemeManager 的代码基本上都有注释，想要看懂并不困难。其中最核心的就是 <code>getCurrentThemeRes</code> 方法了。在这里解释一下 <code>getCurrentThemeRes</code> 的逻辑。参数中的 dayResId 是日间模式的资源id，如果当前主题是日间模式的话，就直接返回 dayResId 。反之当前主题为夜间模式的话，先根据 dayResId 得到资源名称和资源类型。比如现在有一个资源为 R.color.colorPrimary ，那么资源名称就是 colorPrimary ，资源类型就是 color 。然后根据资源类型和资源名称去获取缓存。如果没有缓存，那么就要动态获取资源了。这里使用方法的是</p>
<pre><code>context.getResources().getIdentifier(String name, String defType, String defPackage)
</code></pre><ul>
<li><code>name</code> 参数就是资源名称，不过要注意的是这里的资源名称还要加上后缀 “_night” ，也就是上面在 colors.xml 中定义的名称；</li>
<li><code>defType</code> 参数就是资源的类型了。比如 color，drawable等；</li>
<li><code>defPackage</code> 就是资源文件的包名，也就是当前 APP 的包名。</li>
</ul>
<p>有了上面的这个方法，就可以通过 R.color.colorPrimary 资源找到对应的 R.color.colorPrimary_night 资源了。最后还要把找到的夜间模式资源加入到缓存中。这样的话以后就直接去缓存中读取，而不用再次去动态查找资源 id 了。</p>
<p>ThemeManager 中剩下的代码应该都是比较简单的，相信大家都可以看得懂了。</p>
<p>现在我们来看看 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ThemeManager</span>.<span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line">    <span class="keyword">private</span> Button btn_theme;</span><br><span class="line">    <span class="keyword">private</span> RelativeLayout relativeLayout;</span><br><span class="line">    <span class="keyword">private</span> ActionBar supportActionBar;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ThemeManager.registerThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        supportActionBar = getSupportActionBar();</span><br><span class="line">        btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        relativeLayout = (RelativeLayout) findViewById(R.id.relativeLayout);</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ThemeManager.setThemeMode(ThemeManager.getThemeMode() == ThemeManager.ThemeMode.DAY</span><br><span class="line">                        ? ThemeManager.ThemeMode.NIGHT : ThemeManager.ThemeMode.DAY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        btn_theme.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        relativeLayout.setBackgroundColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.backgroundColor)));</span><br><span class="line">        <span class="comment">// 设置标题栏颜色</span></span><br><span class="line">        <span class="keyword">if</span>(supportActionBar != <span class="keyword">null</span>)&#123;</span><br><span class="line">            supportActionBar.setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置状态栏颜色</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            Window window = getWindow();</span><br><span class="line">            window.setStatusBarColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initTheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ThemeManager.unregisterThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中实现了 OnThemeChangeListener 接口，这样就可以在主题改变的时候执行回调方法。然后在 <code>initTheme()</code> 中去重新设置 UI 的相关颜色属性值。还有别忘了要在 <code>onDestroy()</code> 中移除 ThemeChangeListener 。</p>
<p>最后就来看看第三种方法的效果吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160908/20160910114556.gif" alt="动态获取资源id的效果图gif"></p>
<p>也许有人会说和前两种方法的效果没什么差异啊，但是仔细看就会发现前面两种方法在切换模式的瞬间会有短暂黑屏现象存在，而第三种方法没有。这是因为前两种方法都要调用 <code>recreate()</code> 。而第三种方法不需要 Activity 重新创建，使用回调的方法来实现。</p>
<h1 id="0x0003"><a href="#0x0003" class="headerlink" title="0x0003"></a>0x0003</h1><p>到了这里，按照套路应该是要总结的时候了。那么就根据上面给的三种方法来一个简单的对比吧：</p>
<ol>
<li><p>setTheme 方法：可以配置多套主题，比较容易上手。除了日/夜间模式之外，还可以有其他五颜六色的主题。但是需要调用 recreate() ，切换瞬间会有黑屏闪现的现象；</p>
</li>
<li><p>UiMode 方法：优点就是 Android Support Library 中已经支持，简单规范。但是也需要调用 recreate() ，存在黑屏闪现的现象；</p>
</li>
<li><p>动态获取资源 id ，回调接口：该方法使用起来比前两个方法复杂，另外在回调的方法中需要设置每一项 UI 相关的属性值。但是不需要调用 recreate() ，没有黑屏闪现的现象。</p>
</li>
</ol>
<p>三种方法整体的对比就如上所示了。当然除了上面的三种方法实现日/夜间模式切换之外，还有比如动态换肤等也都可以实现。方法有很多种，重要的是要根据自身情况选择合适的方法去实现。在下面我会给出其他几种实现日/夜间模式切换方法的链接，可以参考一下。</p>
<p>好了，到了说再见的时候了。</p>
<p>Goodbye !</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160908/ThemeDemo_setTheme.rar" target="_blank" rel="external">setTheme方法的Demo下载</a></p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160908/ThemeDemo_UiMode.rar" target="_blank" rel="external">UiMode方法的Demo下载</a></p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160908/ThemeDemo_thememanager.rar" target="_blank" rel="external">动态获取资源id方法的Demo下载</a></p>
<h1 id="0x0004"><a href="#0x0004" class="headerlink" title="0x0004"></a>0x0004</h1><p><a href="https://segmentfault.com/a/1190000005736047?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">android 实现【夜晚模式】的另外一种思路</a></p>
<p><a href="http://www.diycode.cc/topics/269" target="_blank" rel="external">知乎和简书的夜间模式实现套路</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/08/06/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/08/06/《Android开发艺术探索》笔记(下)/</id>
    <published>2016-08-05T16:12:02.000Z</published>
    <updated>2016-11-01T15:03:28.650Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager" class="headerlink" title="第八章：理解Window和WindowManager"></a>第八章：理解Window和WindowManager</h1><h2 id="8-1_Window_u548CWindowManager"><a href="#8-1_Window_u548CWindowManager" class="headerlink" title="8.1 Window和WindowManager"></a>8.1 Window和WindowManager</h2><p>Window是抽象类，具体实现是PhoneWindow，通过WindowManager就可以创建Window。WindowManager是外界访问Window的入口，但是Window的具体实现是在WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。所有的视图例如Activity、Dialog、Toast都是附加在Window上的。因此，Window是实际上View的直接管理者。</p>
<p>WindowManager.LayoutParams中的flags参数解析：</p>
<ul>
<li>FLAG_NOT_FOCUSABLE：表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</li>
<li>FLAG_NOT_TOUCH_MODAL：在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</li>
<li>FLAG_SHOW_WHEN_LOCKED：开启此模式可以让Window显示在锁屏的界面上。</li>
</ul>
<p>type参数表示window的类型，window共有三种类型：应用window，子window和系统window。应用window对应着一个Activity，子window不能独立存在，需要附属在特定的父window之上，比如Dialog就是子window。系统window是需要声明权限才能创建的window，比如Toast和系统状态栏这些都是系统window，需要声明的权限是<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code>。</p>
<p>window是分层的，每个window都对应着z-ordered，层级大的会覆盖在层级小的上面，应用window的层级范围是1~99，子window的层级范围是1000~1999，系统window的层级范围是2000~2999。</p>
<p>WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="8-2_Window_u7684_u5185_u90E8_u673A_u5236"><a href="#8-2_Window_u7684_u5185_u90E8_u673A_u5236" class="headerlink" title="8.2 Window的内部机制"></a>8.2 Window的内部机制</h2><p>Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
<p>Window的添加、删除和更新过程都是IPC过程。WindowManager的实现类(即：WindowManagerImpl)对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots，其他的还有mParams和mDyingViews等。</p>
<p><strong>Window的添加过程</strong>：</p>
<ol>
<li>WindowManagerGlobal中的addView；</li>
<li>检查参数是否合法，如果子Window还需要调节布局参数；</li>
<li>创建ViewRootImpl并将View添加到列表中；</li>
<li>通过ViewRootImpl的setView来更新界面并完成Window的添加过程。在setView内部会调用requestLayout来完成异步刷新请求。在requestLayout中的scheduleTraversals是View绘制的入口，最终通过WindowSession来完成Window的添加过程，注意其实这里是个IPC过程，最终会通过WindowManagerService的addWindow方法来实现Window的添加。 </li>
</ol>
<p><strong>Window的删除过程</strong>：</p>
<ol>
<li>WinodwManagerGlobal中的removeView；</li>
<li>findViewLocked来查找待删除待View的索引，再调用removeViewLocked来做进一步删除；</li>
<li>removeViewLocked通过ViewRootImpl的die方法来完成删除操作，包括同步和异步两种方式，同步方式可能会导致意外的错误，不推荐，一般使用异步的方式，其实就是通过handler发送了一个删除请求，将View添加到mDyingViews中；</li>
<li>die方法本质调用了doDie方法，真正删除View的逻辑在该方法的dispatchDetachedFromWindow方法中，主要做了四件事：垃圾回收，通过Session的remove方法删除Window，调用View的dispatchDetachedFromWindow方法同时会回调View的onDetachedFromWindow以及onDetachedFromWindowInternal，调用WindowManagerGlobal的doRemoveView刷新数据。 </li>
</ol>
<p><strong>Window的更新过程</strong>：</p>
<ol>
<li>WindowManagerGlobal的updateViewLayout；</li>
<li>更新View的LayoutParams；</li>
<li>更新ViewImple的LayoutParams，实现对View的重新测量，布局，重绘；</li>
<li>通过WindowSession更新Window的视图，WindowManagerService.relayoutWindow()。</li>
</ol>
<h2 id="8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B"><a href="#8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B" class="headerlink" title="8.3 Window的创建过程"></a>8.3 Window的创建过程</h2><p><strong>Activity的window创建过程</strong>：</p>
<ol>
<li>Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</li>
<li>Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</li>
<li>Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</li>
<li>Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</li>
<li>还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewManager vm = getWindowManager();</span><br><span class="line">vm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">mWindowAdded = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Dialog的Window创建过程</strong>：</p>
<p>过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。解决的方案就是通过<code>dialog.getWindow.setType</code>方法设置成系统级别的type，记得在manifest中设置权限。</p>
<p><strong>Toast的Window创建过程</strong>：</p>
<ol>
<li>Toast内部有两类IPC：Toast访问NotificationManagerService；NotificationManagerService（下文简称NMS）访问Toast的TN接口；</li>
<li>Toast属于系统Window，内部视图mNextView一种为系统默认样式，另一种通过setView方法来指定一个自定义View。</li>
<li>TN是一个Binder类，NMS处理Toast的显示隐藏请求时会跨进程回调TN中的方法，所以TN运行在Binder线程池中，所以需要handler切换到当前发送Toast请求的线程中，也就是说没有Looper的线程是无法弹出Toast的。</li>
<li>Toast的show方法调用了NMS的enqueueToast方法，该方法先将Toast请求封装成ToastRecord并丢入mToastQueue队列中（非系统应用最多塞50个）。</li>
<li>NMS通过showNextToastLocked方法来显示当前View，Toast显示由ToastRecord的callback方法中的show方法完成，callback其实就是TN对象的远程Binder，所以最终调用的是TN中的方法，并运行在发起Toast请求应用的Binder线程池中。</li>
<li>显示以后，NMS通过scheduleTimeoutLocked方法发送延时消息，延时后NMS通过cancelToastLocked方法来隐藏Toast并从队列中移除，隐藏依然通过ToastRecord的callback中的hide方法实现。</li>
<li>callback回调TN的show和hide方法后，会通过handler发送两个Runnable，里面的handleShow和handleHide方法是真正完成显示和隐藏Toast的地方。handleShow方法中将Toast的视图添加到Window中，handleHide方法将Toast视图从Window中移除。</li>
</ol>
<h1 id="u7B2C_u5341_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236"><a href="#u7B2C_u5341_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236" class="headerlink" title="第十章 Android的消息机制"></a>第十章 Android的消息机制</h1><h2 id="10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0"><a href="#10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0" class="headerlink" title="10.1 Android消息机制概述"></a>10.1 Android消息机制概述</h2><p>Android的消息机制主要是指Handler的运行机制，其底层需要MessageQueue和Looper的支撑。MessageQueue是以单链表的数据结构存储消息列表但是以队列的形式对外提供插入和删除消息操作的消息队列。MessageQueue只是消息的存储单元，而Looper则是以无限循环的形式去查找是否有新消息，如果有的话就去处理消息，否则就一直等待着。</p>
<p>Handler的主要作用是将一个任务切换到某个指定的线程中去执行。</p>
<ul>
<li>为什么要提供这个功能呢？</li>
</ul>
<p>Android规定UI操作只能在主线程中进行，ViewRootImpl的checkThread方法会验证当前线程是否可以进行UI操作。</p>
<ul>
<li>为什么不允许子线程访问UI呢？</li>
</ul>
<p>这是因为UI组件不是线程安全的，如果在多线程中并发访问可能会导致UI组件处于不可预期的状态。另外，如果对UI组件的访问进行加锁机制的话又会降低UI访问的效率，所以还是采用单线程模型来处理UI事件。</p>
<p>Handler的创建会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程中不存在Looper的话就会报错。Handler可以用post方法将一个Runnable投递到消息队列中，也可以用send方法发送一个消息投递到消息队列中，其实post最终还是调用了send方法。</p>
<h2 id="10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790"><a href="#10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790" class="headerlink" title="10.2 Android的消息机制分析"></a>10.2 Android的消息机制分析</h2><p>(1).ThreadLocal的工作原理</p>
<ol>
<li>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用ThreadLocal。 对于Handler来说，它需要获取当前线程的Looper，而Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以实现Looper在线程中的存取了。</li>
<li>ThreadLocal的原理：不同线程访问同一个ThreadLocal的get方法时，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同线程中维护一套数据的副本并且彼此互不干扰。</li>
<li><p>ThreadLocal是一个泛型类public class ThreadLocal<t>，下面是它的set方法</t></p>
<pre><code>public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}
</code></pre><p> Values是Thread类内部专门用来存储线程的ThreadLocal数据的，它内部有一个数组private Object[] table，ThreadLocal的值就存在这个table数组中。如果values的值为null，那么就需要对其进行初始化然后再将ThreadLocal的值进行存储。<br> ThreadLocal数据的存储规则：ThreadLocal的值在table数组中的存储位置总是ThreadLocal的索引+1的位置。</p>
</li>
</ol>
<p>(2).MessageQueue的工作原理</p>
<ol>
<li>MessageQueue其实是通过单链表来维护消息列表的，它包含两个主要操作enqueueMessage和next，前者是插入消息，后者是取出一条消息并移除。</li>
<li>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将它从链表中移除。</li>
</ol>
<p>(3).Looper的工作原理</p>
<ol>
<li><p>为一个线程创建Looper的方法，代码如下所示</p>
<pre><code>new Thread(&quot;test&quot;){
    @Override
    public void run() {
        Looper.prepare();//创建looper
        Handler handler = new Handler();//可以创建handler了
        Looper.loop();//开始looper循环
    }
}.start();
</code></pre></li>
<li><p>Looper的prepareMainLooper方法主要是给主线程也就是ActivityThread创建Looper使用的，本质也是调用了prepare方法。</p>
</li>
<li>Looper的quit和quitSafely方法的区别是：前者会直接退出Looper，后者只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出之后，通过Handler发送的消息就会失败，这个时候Handler的send方法会返回false。<br>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</li>
<li>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null。也就是说，Looper必须退出，否则loop方法就会无限循环下去。Looper的loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞着在那里，这也导致了loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg)，其中的msg.target就是发送这条消息的Handler对象。</li>
</ol>
<p>(4).Handler的工作原理</p>
<ol>
<li>Handler就是处理消息的发送和接收之后的处理；</li>
<li><p>Handler处理消息的过程</p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);//当message是runnable的情况，也就是Handler的post方法传递的参数，这种情况下直接执行runnable的run方法
    } else {
        if (mCallback != null) {//如果创建Handler的时候是给Handler设置了Callback接口的实现，那么此时调用该实现的handleMessage方法
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);//如果是派生Handler的子类，就要重写handleMessage方法，那么此时就是调用子类实现的handleMessage方法
    }
}

private static void handleCallback(Message message) {
        message.callback.run();
}

/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
}
</code></pre></li>
<li><p>Handler还有一个特殊的构造方法，它可以通过特定的Looper来创建Handler。</p>
<pre><code>public Handler(Looper looper){
  this(looper, null, false);
}
</code></pre></li>
</ol>
<h2 id="10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF"><a href="#10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF" class="headerlink" title="10.3 主线程的消息循环"></a>10.3 主线程的消息循环</h2><p>Android的主线程就是ActivityThread，主线程的入口方法就是main，其中调用了Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()方法来开启主线程的消息循环。主线程内有一个Handler，即ActivityThread.H，它定义了一组消息类型，主要包含了四大组件的启动和停止等过程，例如LAUNCH_ACTIVITY等。</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方法完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
<h1 id="u7B2C_u5341_u4E00_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60"><a href="#u7B2C_u5341_u4E00_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60" class="headerlink" title="第十一章 Android的线程和线程池"></a>第十一章 Android的线程和线程池</h1><h2 id="11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B"><a href="#11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B" class="headerlink" title="11.1 主线程和子线程"></a>11.1 主线程和子线程</h2><ol>
<li>在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</li>
<li>在Android中除了Thread，还有HandlerThread、AsyncTask以及IntentService等也都扮演着线程的角色，只是它们具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</li>
<li>从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</li>
<li>AsyncTask是一个抽象泛型类，它提供了Params、Progress、Result三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为Void。下面是它的四个核心方法，其中doInBackground不是在主线程执行的。<br>onPreExecute、doInBackground、onProgressUpdate、onPostResult</li>
</ol>
<h2 id="11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001"><a href="#11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001" class="headerlink" title="11.2 Android中的线程形态"></a>11.2 Android中的线程形态</h2><ol>
<li><p>AsyncTask的使用过程中的条件限制：</p>
<p> (1).AsyncTask的类必须在主线程中加载，这个过程在Android 4.1及以上版本中已经被系统自动完成。</p>
<p> (2).AsyncTask对象必须在主线程中创建，execute方法必须在UI线程中调用。</p>
<p> (3).一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。</p>
<p> (4).在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android 3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android 3.0新添加的方法，并不能在低版本上使用。</p>
</li>
<li><p>AsyncTask的原理：</p>
<p> (1).AsyncTask中有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池；后者用于真正执行任务。AsyncTask中还有一个Handler，即InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</p>
<p> (2).AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable；接着将FutureTask交给SerialExecutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。</p>
</li>
<li><p>HandlerThread就是一种可以使用Handler的Thread，它的实现就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了，外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的quit或者quitSafely方法来终止线程的执行。HandlerThread的最主要的应用场景就是用在IntentService中。</p>
</li>
<li><p>IntentService是一个继承自Service的抽象类，要使用它就要创建它的子类。IntentService适合执行一些高优先级的后台任务，这样不容易被系统杀死。IntentService的onCreate方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的handleMessage方法中会调用IntentService的抽象方法onHandleIntent，所以IntentService的子类都要是实现这个方法。</p>
</li>
</ol>
<h2 id="11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60"><a href="#11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60" class="headerlink" title="11.3 Android中的线程池"></a>11.3 Android中的线程池</h2><p><strong>使用线程池的好处</strong>：</p>
<ol>
<li>重用线程，避免线程的创建和销毁带来的性能开销；</li>
<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<p>Executor只是一个接口，真正的线程池是ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，Android的线程池都是通过Executors提供的工厂方法得到的。</p>
<p><strong>ThreadPoolExecutor的构造参数</strong>：</p>
<ol>
<li>corePoolSize：核心线程数，默认情况下，核心线程会在线程中一直存活；</li>
<li>maximumPoolSize：最大线程数，当活动线程数达到这个数值后，后续的任务将会被阻塞；</li>
<li>keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收；</li>
<li>unit：用于指定keepAliveTime参数的时间单位，有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等；</li>
<li>workQueue：任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中；</li>
<li>threadFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，它只有一个方法Thread newThread(Runnable r)；</li>
<li>RejectedExecutionHandler：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的rejectedExecution方法来通知调用者，默认情况下，rejectedExecution会直接抛出一个rejectedExecutionException。</li>
</ol>
<p><strong>ThreadPoolExecutor执行任务的规则</strong>：</p>
<ol>
<li>如果线程池中的线程数未达到核心线程的数量，那么会直接启动一个核心线程来执行任务；</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在步骤2中无法将任务插入到的任务队列中，可能是任务队列已满，这个时候如果线程数量没有达到规定的最大值，那么会立刻启动非核心线程来执行这个任务；</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<p><strong>AsyncTask的THREAD_POOL_EXECUTOR线程池的配置</strong>：</p>
<ol>
<li>corePoolSize=CPU核心数+1；</li>
<li>maximumPoolSize=2倍的CPU核心数+1；</li>
<li>核心线程无超时机制，非核心线程在闲置时间的超时时间为1s；</li>
<li>任务队列的容量为128。</li>
</ol>
<p><strong>Android中常见的4类具有不同功能特性的线程池</strong>：</p>
<ol>
<li>FixedThreadPool：线程数量固定的线程池，它只有核心线程；</li>
<li>CachedThreadPool：线程数量不固定的线程池，它只有非核心线程；</li>
<li>ScheduledThreadPool：核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务；</li>
<li>SingleThreadPool：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。</li>
</ol>
<h1 id="u7B2C_u5341_u4E8C_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache"><a href="#u7B2C_u5341_u4E8C_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache" class="headerlink" title="第十二章 Bitmap的加载和Cache"></a>第十二章 Bitmap的加载和Cache</h1><h2 id="12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D"><a href="#12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D" class="headerlink" title="12.1 Bitmap的高速加载"></a>12.1 Bitmap的高速加载</h2><ol>
<li><p>Bitmap是如何加载的？</p>
<p> BitmapFactory类提供了四类方法：decodeFile、decodeResource、decodeStream和decodeByteArray从不同来源加载出一个Bitmap对象，最终的实现是在底层实现的。</p>
</li>
<li><p>如何高效加载Bitmap？</p>
<p> 采用BitmapFactory.Options按照一定的采样率来加载所需尺寸的图片，因为imageview所需的图片大小往往小于图片的原始尺寸。</p>
</li>
<li><p>BitmapFactory.Options的inSampleSize参数，即采样率<br>官方文档指出采样率的取值应该是2的指数，例如k，那么采样后的图片宽高均为原图片大小的 1/k。<br>如何获取采样率？</p>
<p> 下面是常用的获取采样率的代码片段：</p>
<pre><code>public Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {
    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}

public int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    if (reqWidth == 0 || reqHeight == 0) {
        return 1;
    }

    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    Log.d(TAG, &quot;origin, w= &quot; + width + &quot; h=&quot; + height);
    int inSampleSize = 1;

    if (height &gt; reqHeight || width &gt; reqWidth) {
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and
        // keeps both height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) {
            inSampleSize *= 2;
        }
    }

    Log.d(TAG, &quot;sampleSize:&quot; + inSampleSize);
    return inSampleSize;
}
</code></pre><p> 将inJustDecodeBounds设置为true的时候，BitmapFactory只会解析图片的原始宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。需要注意的是，这个时候BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，这都会导致BitmapFactory获取到不同的结果。</p>
</li>
</ol>
<h2 id="12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565"><a href="#12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565" class="headerlink" title="12.2 Android中的缓存策略"></a>12.2 Android中的缓存策略</h2><ol>
<li>最常用的缓存算法是LRU，核心是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，系统中采用LRU算法的缓存有两种：LruCache(内存缓存)和DiskLruCache(磁盘缓存)。</li>
<li>LruCache是Android 3.1才有的，通过support-v4兼容包可以兼容到早期的Android版本。LruCache类是一个线程安全的泛型类，它内部采用一个LinkedHashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</li>
<li>DiskLruCache磁盘缓存，它不属于Android sdk的一部分，<a href="http://ofytl4mzu.bkt.clouddn.com/20160826/DiskLruCache.java" target="_blank" rel="external">它的源码可以在这里下载</a><br>DiskLruCache的创建、缓存查找和缓存添加操作</li>
<li>ImageLoader的实现 具体内容看源码，<a href="http://ofytl4mzu.bkt.clouddn.com/20160826/ImageLoader.java" target="_blank" rel="external">点击下载</a><br>功能：图片的同步/异步加载，图片压缩，内存缓存，磁盘缓存，网络拉取</li>
</ol>
<h2 id="12-3_ImageLoader_u7684_u4F7F_u7528"><a href="#12-3_ImageLoader_u7684_u4F7F_u7528" class="headerlink" title="12.3 ImageLoader的使用"></a>12.3 ImageLoader的使用</h2><p>避免发生列表item错位的解决方法：给显示图片的imageview添加tag属性，值为要加载的图片的目标url，显示的时候判断一下url是否匹配。<br>优化列表的卡顿现象</p>
<ol>
<li>不要在getView中执行耗时操作，不要在getView中直接加载图片，否则肯定会导致卡顿；</li>
<li>控制异步任务的执行频率：在列表滑动的时候停止加载图片，等列表停下来以后再加载图片；</li>
<li>使用硬件加速来解决莫名的卡顿问题，给Activity添加配置<code>android:hardwareAccelerated=&quot;true&quot;</code>。</li>
</ol>
<h1 id="u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F"><a href="#u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F" class="headerlink" title="第十三章：综合技术"></a>第十三章：综合技术</h1><h2 id="13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F"><a href="#13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F" class="headerlink" title="13.1 使用CrashHandler来获取应用的Crash信息"></a>13.1 使用CrashHandler来获取应用的Crash信息</h2><p>应用发生Crash在所难免，但是如何采集crash信息以供后续开发处理这类问题呢？利用Thread类的setDefaultUncaughtExceptionHandler方法！defaultUncaughtHandler是Thread类的静态成员变量，所以如果我们将自定义的UncaughtExceptionHandler设置给Thread的话，那么当前进程内的所有线程都能使用这个UncaughtExceptionHandler来处理异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler handler)</span> </span>&#123;</span><br><span class="line">    Thread.defaultUncaughtHandler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实现了一个简易版本的UncaughtExceptionHandler类的子类<a href="http://ofytl4mzu.bkt.clouddn.com/20160826/CrashHandler.java" target="_blank" rel="external">CrashHandler，点击下载</a>。</p>
<p>CrashHandler的使用方式就是在Application的onCreate方法中设置一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里为应用设置异常处理程序，然后我们的程序才能捕获未处理的异常</span></span><br><span class="line">CrashHandler crashHandler = CrashHandler.getInstance();</span><br><span class="line">crashHandler.init(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h2 id="13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C"><a href="#13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C" class="headerlink" title="13.2 使用multidex来解决方法数越界"></a>13.2 使用multidex来解决方法数越界</h2><p>在Android中单个dex文件所能够包含的最大方法数是65536，这包含Android Framework、依赖的jar以及应用本身的代码中的所有方法。如果方法数超过了最大值，那么编译会报错<code>DexIndexOverflowException: method ID not in [0, 0xffff]:65536</code>。</p>
<p>有时方法数没有超过最大值，但是安装在低版本手机上时应用异常终止了，报错：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E/<span class="string">dalvikvm :</span> Optimization failed</span><br><span class="line">E<span class="regexp">/installed : dexopt failed on '/</span>data<span class="regexp">/dalvik-cache/</span>data<span class="annotation">@app</span><span class="annotation">@com</span>.ryg.multidextest-<span class="number">2.</span>apk<span class="annotation">@classes</span>.dex<span class="string">' res=65280</span></span><br></pre></td></tr></table></figure>
<p>这是因为应用在安装的时候，系统会通过dexopt程序来优化dex文件，在优化的过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法的信息，这个缓冲区就是LinearAlloc。LinearAlloc缓冲区在新版本的Android系统中大小是8MB或者16MB，但是在Android 2.2和2.3中却只有5MB，当待安装的应用的方法数比较多的时候，尽管它还没有达到最大方法数，但是它的存储空间仍然有可能超过5MB，这种情况下dexopt就会报错导致安装失败。</p>
<p>如何解决方法数越界的问题呢？ Google在2014年提出了简单方便的multidex的解决方案。<br>在Android 5.0之前使用multidex需要引入android-support-multidex.jar包，从Android 5.0开始，系统默认支持了multidex，它可以从apk中加载多个dex。这里Multidex方案主要针对AndroidStudio和Gradle编译环境。</p>
<p>使用Multidex的步骤：</p>
<ol>
<li><p>在build.gradle文件中添加multiDexEnabled true</p>
<pre><code>android {
    ...

    defaultConfig {
        ...

        multiDexEnabled true // [添加的配置] enable multidex support
    }
    ...
}
</code></pre></li>
<li><p>添加对multidex的依赖</p>
<pre><code>compile &apos;com.android.support:multidex:1.0.0&apos;
</code></pre></li>
<li><p>在代码中添加对multidex的支持，这里有三种方案：</p>
<p> ① 在AndroidManifest文件中指定Application为MultiDexApplication；</p>
<pre><code>&lt;application android:name=&quot;android.support.multidex.MultiDexApplication&quot;
...
&lt;/application&gt;
</code></pre><p> ② 让应用的Application继承自MultiDexApplication；</p>
<p> ③ 重写Application的attachBaseContext方法，这个方法要先于onCreate方法执行；</p>
<pre><code>public class TestApplication extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
</code></pre></li>
</ol>
<p>采用上面的配置之后，如果应用的方法数没有越界，那么Gradle并不会生成多个dex文件；如果方法数越界后，Gradle就会在apk中打包2个或者多个dex文件，具体会打包多少个dex文件要看当前项目的代码规模。在有些情况下，可能需要指定主dex文件中所要包含的类，这个可以通过–main-dex-list选项来实现这个功能。</p>
<p>build.gradle：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"afterEvaluate"</span></span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">'dex'</span>)</span><br><span class="line">    &#125;.<span class="keyword">each</span> &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">def</span> listFile = <span class="keyword">project</span>.rootDir.absolutePath + <span class="string">'/app/maindexlist.txt'</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"root dir:"</span> + <span class="keyword">project</span>.rootDir.absolutePath</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"dex task found: "</span> + dx.name</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        dx.additionalParameters += <span class="string">'--multi-dex'</span></span><br><span class="line">        dx.additionalParameters += <span class="string">'--main-dex-list='</span> + listFile</span><br><span class="line">        dx.additionalParameters += <span class="string">'--minimal-main-dex'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>maindexlist.txt：</p>
<pre><code>com/ryg/multidextest/TestApplication.class
com/ryg/multidextest/MainActivity.class

// multidex
android/support/multidex/MultiDex.class
android/support/multidex/MultiDexApplication.class
android/support/multidex/MultiDexExtractor.class
android/support/multidex/MultiDexExtractor$1.class
android/support/multidex/MultiDex$V4.class
android/support/multidex/MultiDex$V14.class
android/support/multidex/MultiDex$V19.class
android/support/multidex/ZipUtil.class
android/support/multidex/ZipUtil$CentralDirectory.class
</code></pre><p>–multi-dex表明当方法数越界时生成多个dex文件，–main-dex-list指定了要在主dex中打包的类的列表，–minimal-main-dex表明只有–main-dex-list所指定的类才能打包到主dex中。multidex的jar包中的9个类必须要打包到主dex中，其次不能在Application中成员以及代码块中访问其他dex中的类，否个程序会因为无法加载对应的类而中止执行。</p>
<p>Multidex方案可能带来的问题：</p>
<ol>
<li>应用启动速度会降低，因为应用启动的时候会加载额外的dex文件，甚至可能出现ANR现象。所以要避免生成较大的dex文件；</li>
<li>需要做大量的兼容性测试，因为Dalvik LinearAlloc的bug，可能导致使用multidex的应用无法在Android 4.0以前的手机上运行。同时由于Dalvik linearAlloc的bug，有可能会出现应用在运行中由于采用了multidex方案从而产生大量的内存消耗的情况，这会导致奔溃。</li>
</ol>
<p>在实际项目中，1.中的现象是客观存在的，但是2.中的现象目前极少遇到。</p>
<h2 id="13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F"><a href="#13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F" class="headerlink" title="13.3 Android的动态加载技术"></a>13.3 Android的动态加载技术</h2><p>动态加载技术又称插件化技术，将应用插件化可以减轻应用的内存和CPU占用，还可以在不发布新版本的情况下更新某些模块。不同的插件化方案各有特色，但是都需要解决三个基础性问题：资源访问，Activity生命周期管理和插件ClassLoader的管理。</p>
<p>宿主和插件：宿主是指普通的apk，插件是经过处理的dex或者apk。在主流的插件化框架中多采用特殊处理的apk作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。</p>
<p>三个基础性问题的解决方案：</p>
<ol>
<li>资源访问：宿主程序调起未安装的插件apk，插件中凡是R开头的资源都不能访问了，因为宿主程序中并没有插件的资源，通过R来访问插件的资源是行不通的。<br>Activity的资源访问是通过ContextImpl来完成的，它有两个方法getAssets()和getResources()方法是用来加载资源的。<br>具体实现方式是通过反射，调用AssetManager的addAssetPath方法添加插件的路径，然后将插件apk中的资源加载到Resources对象中即可。</li>
<li>Activity生命周期管理：有两种常见的方式，反射方式和接口方式。反射方式就是通过反射去获取Activity的各个生命周期方法，然后在代理Activity中去调用插件Activity对应的生命周期方法即可。<br>反射方式代码繁琐，性能开销大。接口方式将Activity的生命周期方法提取出来作为一个接口，然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理。</li>
<li>插件ClassLoader的管理：为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引起的类型转换错误。</li>
</ol>
<p>其他详细信息看作者插件化框架 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">singwhatiwanna/dynamic-load-apk</a></p>
<h2 id="13-4__u53CD_u7F16_u8BD1_u521D_u6B65"><a href="#13-4__u53CD_u7F16_u8BD1_u521D_u6B65" class="headerlink" title="13.4 反编译初步"></a>13.4 反编译初步</h2><p>反编译可查看<a href="/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/">Android安全机制之反编译</a></p>
<p>二次打包：</p>
<pre><code>apktool.bat b [解包后文件所在的位置] [二次打包之后的文件名]
</code></pre><p>签名：</p>
<pre><code>java -jar signapk.jar testkey.x509.pem testkey.pk8 [未签名apk] [已签名apk]
</code></pre><h1 id="u7B2C_u5341_u4E94_u7AE0_Android_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u4E94_u7AE0_Android_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十五章 Android性能优化"></a>第十五章 Android性能优化</h1><p>2015年Google关于Android性能优化典范的专题视频：</p>
<p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Youtube视频地址</a></p>
<h2 id="15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5"><a href="#15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5" class="headerlink" title="15.1 Android的性能优化方法"></a>15.1 Android的性能优化方法</h2><ol>
<li><p>布局优化</p>
<p> (1).删除布局中无用的组件和层级，有选择地使用性能较低的ViewGroup；</p>
<p> (2).使用<include>、<merge>、<viewstub>等标签：<include>标签主要用于布局重用，<merge>标签一般和<include>配合使用，它可以减少布局中的层级；<viewstub>标签则提供了按需加载的功能，当需要的时候才会将ViewStub中的布局加载到内存，提供了程序的初始化效率。</viewstub></include></merge></include></viewstub></merge></include></p>
<p> (3).<include>标签只支持android:layout_开头的属性，android:id属性例外。</include></p>
<p> (4).ViewStub继承自View，它非常轻量级且宽高都为0，它本身不参与任何的布局和绘制过程。实际开发中，很多布局文件在正常情况下不会显示，例如网络异常时的界面，这个时候就没有必要在整个界面初始化的时候加载进行，通过ViewStub可以做到在需要的时候再加载。<br> 如下面示例，android:id是ViewStub的id，而android:inflatedId是布局的根元素的id。</p>
<pre><code>&lt;ViewStub android:id=&quot;@+id/xxx&quot;
  android:inflatedId=&quot;@+id/yyy&quot;
  android:layout=&quot;@layout/zzz&quot;
  ...
&lt;/ViewStub&gt;
</code></pre></li>
<li><p>绘制优化</p>
<p> (1).在onDraw中不要创建新的布局对象，因为onDraw会被频繁调用；<br> (2).onDraw方法中不要指定耗时任务，也不能执行成千上万次的循环操作。</p>
</li>
<li><p>内存泄露优化</p>
<p> 可能导致内存泄露的场景很多，例如静态变量、单例模式、属性动画、AsyncTask、Handler等等</p>
</li>
<li><p>响应速度优化和ANR日志分析</p>
<p> (1).ANR出现的情况：Activity如果5s内没有响应屏幕触摸事件或者键盘输入事件就会ANR，而BroadcastReceiver如果10s内没有执行完操作也会出现ANR。</p>
<p> (2).当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位ANR的原因。</p>
</li>
<li><p>ListView和Bitmap优化</p>
<p> (1).ListView优化：采用ViewHolder并避免在getView方法中执行耗时操作；根据列表的滑动状态来绘制任务的执行频率；可以尝试开启硬件加速来使ListView的滑动更加流畅。</p>
<p> (2).Bitmap优化：根据需要对图片进行采样，详情请看第12章 Bitmap的加载和Cache。</p>
</li>
<li><p>线程优化</p>
<p> 采用线程池，详情请看第11章 Android的线程和线程池。</p>
</li>
<li><p>一些性能优化建议</p>
<p> (1).不要过多使用枚举，枚举占用的内存空间要比整型大；</p>
<p> (2).常量请使用static final来修饰；</p>
<p> (3).使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能；</p>
<p> (4).适当使用软引用和弱引用；</p>
<p> (5).采用内存缓存和磁盘缓存；</p>
<p> (6).尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</p>
</li>
</ol>
<h2 id="15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177"><a href="#15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177" class="headerlink" title="15.2 内存泄露分析之MAT工具"></a>15.2 内存泄露分析之MAT工具</h2><p>MAT是功能强大的内存分析工具，主要有Histograms和Dominator Tree等功能。</p>
<p>详细的可以查看 <a href="http://gold.xitu.io/entry/563b341e60b20bd506b55592" target="_blank" rel="external">内存泄露从入门到精通三部曲</a>。</p>
<h2 id="15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027"><a href="#15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027" class="headerlink" title="15.3 提高程序的可维护性"></a>15.3 提高程序的可维护性</h2><ol>
<li>命名规范。比如私有成员变量以m开头，静态成员变量以s开头，常量全部以大写字母表示；</li>
<li>代码的排版上需要留出合理的空白来区分不同的代码块；</li>
<li>仅为非常关键的代码添加注释，其他地方不用注释。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步步深入解析AIDL]]></title>
    <link href="http://yuqirong.me/2016/07/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90AIDL/"/>
    <id>http://yuqirong.me/2016/07/28/一步步深入解析AIDL/</id>
    <published>2016-07-28T14:55:37.000Z</published>
    <updated>2016-11-01T14:58:49.729Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需要在两个进程之间进行一些数据的交换。而在深入学习 Android 的过程中难免会遇到 IPC 的相关问题，比如常见的有在自己的应用程序中读取手机联系人的信息，这就涉及到 IPC 了。因为自己的应用程序是一个进程，通讯录也是一个进程，只不过获取通讯录的数据信息是通过 Content Provider 的方式来实现的。</p>
<p>对于初学者来说，在一开始接触 IPC 时可能会摸不着头脑，因为网上很多博客在讲 Android IPC 时通常都是长篇大论，没有从例子着手。基于以上种种原因以及希望对 AIDL 有一个更深入的理解，本篇博文就诞生了。在 Android 系统中，IPC 的方式有很多种，比如有 Messenger 、AIDL 和 ContentProvider 等。我们今天就来讲讲其中的 AIDL ，AIDL 也是比较常见和经常使用的一种 IPC 方式。希望读者在看完本篇之后对于 AIDL 有一个比较深入的理解。</p>
<h1 id="u4EC0_u4E48_u662F_AIDL"><a href="#u4EC0_u4E48_u662F_AIDL" class="headerlink" title="什么是 AIDL"></a>什么是 AIDL</h1><p>首先我们对于新的事物都会有一个疑问，那就是什么是 AIDL？</p>
<p>AIDL 的全称是 Android Interface Definition Language(即 Android 接口定义语言)。通常对于 AIDL 的使用有三步流程：</p>
<ol>
<li>定义 AIDL 接口；</li>
<li>在 Service 中创建对应的 Stub 对象；</li>
<li>将该服务暴露给其他进程调用；</li>
</ol>
<p>讲完了流程，我们就又有一个疑问了，Android系统中实现 IPC 有这么多方式，到底应该在什么情况下使用 AIDL 呢？</p>
<p>Android 官方文档给出的答案是：</p>
<p>Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.</p>
<p>使用AIDL只有在你允许来自不同应用的客户端跨进程通信访问你的Service，并且想要在你的Service种处理多线程的时候才是必要的。 简单地来说，就是多个客户端，多个线程并发的情况下要使用 AIDL 。官方文档还指出，如果你的 IPC 不需要适用于多个客户端的，那就使用 Binder ；如果你的想要 IPC ，但是不需要多线程，那就选择 Messenger 。</p>
<p>相信大家到这里对于 AIDL 有一个初步的概念了，那么下面我们就来举个例子讲解一下 AIDL 。</p>
<h1 id="AIDL_u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#AIDL_u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="AIDL的使用方法"></a>AIDL的使用方法</h1><p>我们来模拟一下需要进行 IPC 的情况，现在有客户端和服务端，客户端通过 AIDL 来和服务端进行 IPC 。我们假定现在客户端需要传一个 Person 类的对象给服务端，之后服务端回传给客户端一个 Person 类的集合。</p>
<p>先来看看服务端的相关代码，以下 Person.aidl 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>
<p>注意在 IPC 机制中传递的自定义对象需要序列化，所以要实现 Parcelable 接口。在 AIDL 文件中使用 <code>parcelable</code> 关键字声明。有了 Person.aidl 之后，我们就要创建 AIDL 接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="keyword">import</span> com.yuqirong.aidldemo.Person;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(in Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 IMyAidlInterface.aidl 里，主要声明一个用于添加 Person 对象的抽象方法。另外，需要注意以下几点：</p>
<ol>
<li>Person 类需要手动去 import ，在 AIDL 文件中不能自动导包；</li>
<li>在 <code>addPerson</code> 方法里需要声明参数是 in 的，用来表示该参数是传入的。除了 in 之外，还有 out 和 inout ；</li>
</ol>
<p>下面我们要创建一个 Service 用于和客户端进行 IPC 。这里还要把该 Service 运行在一个新的进程里。我们只要在 AndroidManifest.xml 中声明 <code>android:process=&quot;:remote&quot;</code> 就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Nullable</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"bind success"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="comment">// 需要同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (persons)&#123;</span><br><span class="line">                persons.add(person);</span><br><span class="line">                <span class="keyword">return</span> persons;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们可以看到在 <code>onBind(Intent intent)</code> 方法中返回了 mBinder ，而客户端正是通过这个 mBinder 来和服务端进行 IPC 的。mBinder 是 IMyAidlInterface.Stub 匿名类的对象，IMyAidlInterface.Stub 其实是一个抽象类，继承自 Binder ，实现 <code>addPerson</code> 方法。这里要注意以下，在 <code>addPerson</code> 的方法中需要将 persons 同步，这是因为在服务端 AIDL 是运行在 Binder 线程池中的，有可能会有多个客户端同时连接，这时候就需要同步以防止数据出错。</p>
<p>服务端的代码差不多就这些，下面我们来看看客户端的，客户端也是需要 AIDL 文件的，可以从服务端中复制过来。需要注意的是包名和 AIDL 文件都要和服务端保持一致，否则在客户端反序列化的时候会出错。以下只截取了客户端部分关键代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端用来和服务端IPC的接口</span></span><br><span class="line"><span class="keyword">private</span> IMyAidlInterface aidlInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务端的服务，并进行绑定</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yuqirong.aidldemo"</span>, <span class="string">"com.yuqirong.aidldemo.MyService"</span>));</span><br><span class="line">bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里得到了和服务端进行通信的接口</span></span><br><span class="line">        aidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        aidlInterface = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端通过 Intent 启动并绑定服务端的 Service ，在 <code>onServiceConnected</code> 中通过 binder 对象得到了 aidlInterface 。之后客户端就可以使用 aidlInterface 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Person&gt; list = aidlInterface.addPerson(<span class="keyword">new</span> Person(<span class="string">"yuqirong"</span>, <span class="number">21</span>, <span class="string">"13567891023"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>我们注意到，在客户端调用 AIDL 接口方法时是新创建了一个子线程去执行的，这是因为在服务端在处理 AIDL 时有可能是很耗时的。如果在主线程中去执行，那么就有可能出现 ANR 的问题。所以为了避免 ANR ，在客户端调用 AIDL 的代码最好在子线程去执行。</p>
<p>整套 AIDL 的流程基本上就是这样的。通过这个简单的例子，相信对于 AIDL 有了一个初步的了解。下面我们就要去揭开 AIDL 是如何实现 IPC 的神秘面纱。</p>
<h1 id="u89E3_u6790AIDL"><a href="#u89E3_u6790AIDL" class="headerlink" title="解析AIDL"></a>解析AIDL</h1><p>现在我们终于要来看看 AIDL 是如何工作的？我们可以在工程中的 gen 目录下找到对应 AIDL 编译后的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.yuqirong.aidldemo.IMyAidlInterface"</span>;</span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.yuqirong.aidldemo.IMyAidlInterface interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.yuqirong.aidldemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.yuqirong.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.yuqirong.aidldemo.IMyAidlInterface)iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.yuqirong.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addPerson:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.yuqirong.aidldemo.Person _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.yuqirong.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result = <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">            Proxy(android.os.IBinder remote)</span><br><span class="line">            &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">            &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((person!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.yuqirong.aidldemo.Person.CREATOR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到编译后的 IMyAidlInterface.aidl 变成了一个接口，继承自 IInterface 。在 IMyAidlInterface 接口中我们发现主要分成两部分结构：抽象类 Stub 和原来 aidl 中声明的 <code>addPerson</code> 方法。</p>
<p>重点在于 Stub 类，下面我们来分析一下。从 Stub 类中我们可以看到是继承自 Binder 并且实现了 IMyAidlInterface 接口。 Stub 类的基本结构如下：</p>
<ul>
<li><code>asInterface(android.os.IBinder obj)</code> 方法；</li>
<li><code>asBinder()</code> 方法；</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法；</li>
<li>静态类 <code>Proxy</code>，主要方法是 <code>addPerson(com.yuqirong.aidldemo.Person person)</code> ；</li>
<li>静态常量 <code>TRANSACTION_addPerson</code> ；</li>
</ul>
<p><strong>asInterface(android.os.IBinder obj)</strong></p>
<p>我们先从 <code>asInterface(android.os.IBinder obj)</code> 方法入手，在上面的代码中可以看到，主要的作用就是根据传入的Binder对象转换成客户端需要的 IMyAidlInterface 接口。如果服务端和客户端处于同一个进程，那么该方法得到的就是服务端 Stub 对象本身，也就是上面 AIDL 例子 MyService 中的 mBinder 对象；否则返回的是系统封装后的 Stub.Proxy ，也就是一个代理类，在这个代理中实现跨进程通信。</p>
<p><strong>asBinder()</strong></p>
<p>该方法就是返回当前的 Binder 对象。</p>
<p><strong>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</strong></p>
<p>在 <code>onTransact</code> 方法中，根据传入的 code 值会去执行服务端相对应的方法。其中静态变量 <code>TRANSACTION_addPerson</code> 就是其中的 code 值之一(在 AIDL 文件中声明的方法有多少个就有多少个对应的 code )。其中 data 就是服务端方法中所需要的参数，执行完后，最后把方法的返回结果放入 reply 中传递给客户端。若该方法返回 false ，那么客户端请求失败。</p>
<p><strong>Proxy中的addPerson(com.yuqirong.aidldemo.Person person)</strong></p>
<p>Proxy 类是实现了 IMyAidlInterface 接口，把其中的 <code>addPerson</code> 方法进行了重写。在方法中一开始创建了两个 Parcel 对象，其中一个用来把方法的参数装入，然后调用 <code>transact</code> 方法执行服务端的代码，执行完后把返回的结果装入另外一个 Parcel 对象中返回。</p>
<p>看完上面方法的介绍，我们回过头来看看 AIDL 例子中实现的流程。在客户端中通过 Intent 去绑定一个服务端的 Service 。在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 方法中通过返回的 service 可以得到对应的 AIDL 接口的实例。这是调用了 <code>asInterface(android.os.IBinder obj)</code> 方法来完成的。</p>
<p>客户端在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 中得到的 service 正是服务端中的 mBinder 。当客户端调用 AIDL 接口时，AIDL 通过 Proxy 类中的 <code>addPerson</code> 来调用 <code>transact</code> 方法，<code>transact</code> 方法又会去调用服务端的 <code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法。 <code>onTransact</code> 方法是运行在服务端的 Binder 线程池中的。在 <code>onTransact</code> 中根据 code 执行相关 AIDL 接口的方法，方法的参数从 data 中获取。执行完毕之后把结果装入 reply 中返回给客户端。 AIDL 的流程基本上就是这样子了。</p>
<p>到了这里，大家就会发现 AIDL 底层的实现就是依靠 Binder 来完成的。为了方便大家的理解，这里给出一张 AIDL 机制的原理图( PS :该图来自于《Android开发艺术探索》，感谢任主席)：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160728/20160728201234.png" alt="AIDL机制原理图"></p>
<h1 id="u7ED3_u5C3E"><a href="#u7ED3_u5C3E" class="headerlink" title="结尾"></a>结尾</h1><p>写到这里本篇博文就临近末尾了。 AIDL 在 Android IPC 机制中算得上是很重要的一部分，AIDL 主要是通过 Binder 来实现进程通信的。其实另一种 IPC 的方式 Messenger 底层也是通过 AIDL 来实现的。所以 AIDL 的重要性就不言而喻了。如果有兴趣的同学可以在理解 AIDL 的基础上去看看 Messenger 的源码。当然在上面的 AIDL 例子中的代码是很简单的，没有涉及到死亡代理、权限验证等功能，童鞋们可以自己去把这些相关的去学习下。</p>
<p>好了，最后附上 AIDL 例子的源码：</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160728/AIDLDemo.rar" target="_blank" rel="external">AIDLDemo.rar</a></p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="/2016/03/31/《Android开发艺术探索》笔记(上)/">《Android开发艺术探索》笔记(上) —— 第二章：IPC机制</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="IPC" scheme="http://yuqirong.me/tags/IPC/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现炫酷的滑动返回效果]]></title>
    <link href="http://yuqirong.me/2016/07/07/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/07/07/简单实现炫酷的滑动返回效果/</id>
    <published>2016-07-06T16:25:04.000Z</published>
    <updated>2016-11-01T14:56:59.400Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功能，那就是滑动返回。比如知乎、百度贴吧等，用户在使用这一类的 app 都可以滑动返回上一个页面。不得不说这个设计很赞，是不是心动了呢？那就继续往下看吧！</p>
<p>在GitHub上有实现该效果的开源库 <a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a> ，可以看到该库发展得已经非常成熟了。仔细看源码你会惊奇地发现其中的奥秘，没错，正是借助了 ViewDragHelper 来实现滑动返回的效果。ViewDragHelper 我想不必多说了，在我的博客中有很多的效果都是通过它来实现的。那么，下面我们就使用 ViewDragHelper 来实现这个效果吧。</p>
<h1 id="u81EA_u5B9A_u4E49_u5C5E_u6027"><a href="#u81EA_u5B9A_u4E49_u5C5E_u6027" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>首先，我们应该先定义几个自定义属性，比如说支持用户从左边或者右边滑动返回，丰富用户的选择性。所以现在 attrs.xml 中定义如下属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SwipeBackLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"swipe_mode"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的 xml 中可知，定义了一个枚举属性，左边为0，右边为1。</p>
<p>然后主角 SwipeBackLayout 就要登场了。</p>
<pre><code>public class SwipeBackLayout extends FrameLayout {

    private ViewDragHelper mViewDragHelper;
    // 主界面
    private View mainView;
    // 主界面的宽度
    private int mainViewWidth;
    // 模式，默认是左滑
    private int mode = MODE_LEFT;
    // 监听器
    private SwipeBackListener listener;
    // 是否支持边缘滑动返回, 默认是支持
    private boolean isEdge = true;

    private int mEdge;
    // 阴影Drawable
    private Drawable shadowDrawable;
    // 阴影Drawable固有宽度
    private int shadowDrawbleWidth;
    // 已经滑动的百分比
    private float movePercent;
    // 滑动的总长度
    private int totalWidth;
    // 默认的遮罩透明度
    private static final int DEFAULT_SCRIM_COLOR = 0x99000000;
    // 遮罩颜色
    private int scrimColor = DEFAULT_SCRIM_COLOR;
    // 透明度
    private static final int ALPHA = 255;

    private Paint mPaint;
    /**
     * 滑动的模式，左滑
     */
    public static final int MODE_LEFT = 0;
    /**
     * 滑动的模式，右滑
     */
    public static final int MODE_RIGHT = 1;
    // 最小滑动速度
    private static final int MINIMUM_FLING_VELOCITY = 400;

    private static final String TAG = &quot;SwipeBackLayout&quot;;

    public SwipeBackLayout(Context context) {
        this(context, null);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeBackLayout);
        // 得到滑动模式，默认左滑
        mode = a.getInt(R.styleable.SwipeBackLayout_swipe_mode, MODE_LEFT);
        a.recycle();
        initView();
    }

    ...

}
</code></pre><h1 id="initView"><a href="#initView" class="headerlink" title="initView"></a>initView</h1><p>在构造器主要做的就是得到滑动模式，默认是左边滑动。之后调用 <code>initView()</code> 。那么我们来看看 <code>initView()</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阴影Drawable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShadowView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right, getContext().getTheme());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shadowDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shadowDrawbleWidth = shadowDrawable.getIntrinsicWidth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> density = getResources().getDisplayMetrics().density;</span><br><span class="line">	<span class="comment">// 最小滑动速度</span></span><br><span class="line">    <span class="keyword">float</span> minVel = density * MINIMUM_FLING_VELOCITY;</span><br><span class="line">    initShadowView();</span><br><span class="line">    mViewDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="keyword">new</span> ViewDragHelper.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mainView == child; <span class="comment">// 只有是主界面时才可以被滑动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据模式区分</span></span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:  <span class="comment">// 左边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:  <span class="comment">// 右边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    movePercent = left * <span class="number">1f</span> / totalWidth;  <span class="comment">// 滑动的进度</span></span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    movePercent = Math.abs(left) * <span class="number">1f</span> / totalWidth;</span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == MODE_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(totalWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -totalWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &gt; -mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;  <span class="comment">// 如果当前已经滑动超过子View宽度的一半，并且速度符合预期设置</span></span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);  <span class="comment">// 把当前界面finish</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &gt; mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();  <span class="comment">// 当前界面回到原位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &lt; mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &lt; -mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置最小滑动速度</span></span><br><span class="line">    mViewDragHelper.setMinVelocity(minVel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// 子View只能有一个</span></span><br><span class="line">        <span class="comment">// 获取子view</span></span><br><span class="line">        mainView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the child of swipebacklayout can not be empty and must be the one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 得到主界面的宽度</span></span><br><span class="line">    mainViewWidth = w;</span><br><span class="line">    <span class="comment">//总长度，包含了mainView的宽度以及阴影图片的宽度</span></span><br><span class="line">    totalWidth = mainViewWidth + shadowDrawbleWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initView()</code> 中，设置了 mViewDragHelper 的最小滑动速度，并且设置了 mViewDragHelper 回调的接口。回调接口中的方法都有注释，相信大家应该都能看懂。另外在 <code>initView()</code> 中初始化了阴影图片，以备下面中使用。</p>
<h1 id="drawChild"><a href="#drawChild" class="headerlink" title="drawChild"></a>drawChild</h1><p>想要阴影在滑动中绘制出来，我们必须重写 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法，并且在 <code>onTouchEvent(MotionEvent event)</code> 里 <code>invalidate()</code> ,保证用户滑动过程中调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">""</span> + (mViewDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE));</span><br><span class="line">    <span class="keyword">if</span> (child == mainView &amp;&amp; mViewDragHelper.getViewDragState() != ViewDragHelper.STATE_IDLE) &#123;</span><br><span class="line">        <span class="comment">// 绘制阴影</span></span><br><span class="line">        drawShadowDrawable(canvas, child);</span><br><span class="line">        <span class="comment">// 绘制遮罩层</span></span><br><span class="line">        drawScrimColor(canvas, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="comment">// 重绘，保证在滑动的时候可以绘制阴影</span></span><br><span class="line">    invalidate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中调用 <code>drawShadowDrawable(Canvas canvas, View child)</code> 来绘制阴影以及 <code>drawScrimColor(Canvas canvas, View child)</code> 来绘制遮罩层。下面分别是两个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制阴影</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadowDrawable</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    Rect drawableRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">// 得到mainView的矩形</span></span><br><span class="line">    child.getHitRect(drawableRect);</span><br><span class="line">    <span class="comment">// 设置shadowDrawable绘制的矩形</span></span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.left - shadowDrawbleWidth, drawableRect.top, drawableRect.left, drawableRect.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.right, drawableRect.top, drawableRect.right + shadowDrawbleWidth, drawableRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置shadowDrawable的透明度,最低为0.3</span></span><br><span class="line">    shadowDrawable.setAlpha((<span class="keyword">int</span>) ((<span class="number">1</span> - movePercent &gt; <span class="number">0.3</span> ? <span class="number">1</span> - movePercent : <span class="number">0.3</span>) * ALPHA));</span><br><span class="line">    <span class="comment">// 将shadowDrawable绘制在canvas上</span></span><br><span class="line">    shadowDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制遮罩层</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawScrimColor</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据滑动进度动态设置透明度</span></span><br><span class="line">    <span class="keyword">int</span> baseAlpha = (scrimColor &amp; <span class="number">0xFF000000</span>) &gt;&gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (baseAlpha * (<span class="number">1</span> - movePercent));</span><br><span class="line">    <span class="keyword">int</span> color = alpha &lt;&lt; <span class="number">24</span> | (scrimColor &amp; <span class="number">0xffffff</span>);</span><br><span class="line">    <span class="comment">// 设置绘制矩形区域</span></span><br><span class="line">    Rect rect;</span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, child.getLeft(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(child.getRight(), <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(color);</span><br><span class="line">    canvas.drawRect(rect, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mainView 、阴影、遮罩层的关系示意图如下：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160707/20160707211516.png" alt="relatives_pic"></p>
<h1 id="onViewReleased"><a href="#onViewReleased" class="headerlink" title="onViewReleased"></a>onViewReleased</h1><p>看完了上面的两个方法的代码，最后就是当用户手指抬起时判断逻辑的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动返回，结束该View</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToFinish</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, finalLeft, finalTop)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onSwipeBackFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动回归到原位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToRestore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SwipeBackListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 该方法会在滑动返回完成的时候回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipeBackFinish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置滑动返回监听器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> listener</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwipeBackListener</span><span class="params">(SwipeBackListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的代码还是比较简单的，主要使用了 <code>smoothSlideViewTo(View view, int left, int top)</code> 的方法来滑动到指定位置。若是结束当前界面的话，回调监听器的接口。</p>
<p>啰嗦了这么多，我们来看看运行时的效果图吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160707/20160707212521.gif" alt="SwipeBackDemo Screenshot"></p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>好了，SwipeBackLayout 大致的逻辑就是上面这样子的。整体来说还是比较通俗易懂的，而且对 ViewDragHelper 熟悉的人会发现，使用 ViewDragHelper 自定义一些 ViewGroup 的套路都是大同小异的。以后想要自定义一些 ViewGroup 都是得心应手了。</p>
<p>如果对此有疑问的话可以在下面留言。</p>
<p>最后，国际惯例，附上 SwipeBackLayout Demo 的源码：</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160707/SwipeBackDemo.rar" target="_blank" rel="external">SwipeBackDemo.rar</a></p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CursorAdapter中的filter机制]]></title>
    <link href="http://yuqirong.me/2016/07/03/%E8%AF%A6%E8%A7%A3CursorAdapter%E4%B8%AD%E7%9A%84filter%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2016/07/03/详解CursorAdapter中的filter机制/</id>
    <published>2016-07-03T12:35:51.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天为什么讲 CursorAdapter 的原因，是因为之前在工作的时候有遇到 CursorAdapter 中 filter 的相关问题，于是就想把 CursorAdapter 中的 filter 机制流程好好梳理一下。出于这样的目的，本篇博文就诞生了。</p>
<p>在阅读本文之前，最好已经有写过 CursorAdapter 中 filter 相关代码的经历，这样可以帮助你更好地理解其中的原理。如果你准备好了，那么接下来就一起来看看吧。</p>
<h1 id="CursorAdapter__u7C7B"><a href="#CursorAdapter__u7C7B" class="headerlink" title="CursorAdapter 类"></a>CursorAdapter 类</h1><p>首先我们来看一下 CursorAdapter 的继承以及实现关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CursorAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">Filterable</span>, <span class="title">CursorFilter</span>.<span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CursorAdapter 继承自 BaseAdapter ，相信大家都可以理解。之后又实现了 Filterable 和 CursorFilter.CursorFilterClient 接口。</p>
<p>Filterable 的接口很简单，只有一个 <code>getFilter()</code> 方法，用来返回 filter 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Returns a filter that can be used to constrain data with a filtering</span><br><span class="line">     * pattern.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is usually implemented by &#123;<span class="doctag">@link</span> android.widget.Adapter&#125;</span><br><span class="line">     * classes.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> a filter used to constrain data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Filter <span class="title">getFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 CursorFilter.CursorFilterClient 的接口是定义在 CursorFilter 类里面的。而 CursorFilter 类是默认修饰符，也就是说我们在外部无法访问到它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line">    <span class="function">CharSequence <span class="title">convertToString</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 CursorFilterClient 接口中的抽象方法。根据方法名我们大概都能猜出该方法需要做的事情。 <code>convertToString(Cursor cursor)</code> 方法主要的功能就是根据传入的 cursor 参数返回某个字段；<code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法的意思就是根据传入的 constraint 字符序列去搜索得到 cursor；而 <code>getCursor()</code>就是返回 cursor；<code>changeCursor(Cursor cursor)</code> 就是根据传入的新的 cursor 去替换旧的 cursor 。</p>
<h1 id="filter__u7684_u7528_u6CD5"><a href="#filter__u7684_u7528_u6CD5" class="headerlink" title="filter 的用法"></a>filter 的用法</h1><p>好了，我们来想想平时我们是怎么样使用 CursorAdapter 中的 filter ？</p>
<p>第一步，我们会使用自定义的 adapter 继承自 CursorAdapter ，并且实现 FilterQueryProvider 和 FilterListener 接口。最后别忘了调用 <code>setFilterQueryProvider(FilterQueryProvider filterQueryProvider)</code> 方法。</p>
<p>然后，第二步我们会使用CursorAdapter的 <code>getFilter()</code> 方法来得到 filter 。对，没错，就是实现 Filterable 接口的那个 <code>getFilter</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">getFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCursorFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCursorFilter = <span class="keyword">new</span> CursorFilter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCursorFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CursorAdapter 的源码中，判断了 mCursorFilter 是否为空。若为空，则创建一个新的 CursorFilter 对象。否则直接返回 mCursorFilter 。在这里要说明一下 CursorFilter 是 Filter 的子类。</p>
<p>而在 CursorFilter 的构造器中，主要是设置了 client (CursorAdapter 实现了 CursorFilterClient 接口)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CursorFilter(CursorFilterClient client) &#123;</span><br><span class="line">    mClient = client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二步得到了 filter 之后，第三步就可以使用 <code>filter.filter(CharSequence constraint)</code> 或者 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法了。constraint 参数就是要过滤的关键词；而 FilterListener 是一个 Filter 类的内部接口，会在过滤完成之后回调其中的 <code>onFilterComplete(int count)</code> 方法。</p>
<h1 id="filter__u7684_u539F_u7406"><a href="#filter__u7684_u539F_u7406" class="headerlink" title="filter 的原理"></a>filter 的原理</h1><p>大致使用 filter 的步骤就是像上面这样的了。下面我们就来揭开这其中神秘的面纱吧！</p>
<p>我们的入手点就是 Filter 的 filter 方法了。其中的 <code>filter.filter(CharSequence constraint)</code> 方法内部会调用 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法。所以我们只需要看下<code>filter.filter(CharSequence constraint, FilterListener listener)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Starts an asynchronous filtering operation. Calling this method</span><br><span class="line"> * cancels all previous non-executed filtering requests and posts a new</span><br><span class="line"> * filtering request that will be executed later.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Upon completion, the listener is notified.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint used to filter the data</span><br><span class="line"> * <span class="doctag">@param</span> listener a listener notified upon completion of the operation</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #filter(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #performFiltering(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #publishResults(CharSequence, android.widget.Filter.FilterResults)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(CharSequence constraint, FilterListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HandlerThread thread = <span class="keyword">new</span> HandlerThread(</span><br><span class="line">                    THREAD_NAME, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            thread.start();</span><br><span class="line">            mThreadHandler = <span class="keyword">new</span> RequestHandler(thread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = (mDelayer == <span class="keyword">null</span>) ? <span class="number">0</span> : mDelayer.getPostingDelay(constraint);</span><br><span class="line">        </span><br><span class="line">        Message message = mThreadHandler.obtainMessage(FILTER_TOKEN);</span><br><span class="line"></span><br><span class="line">        RequestArguments args = <span class="keyword">new</span> RequestArguments();</span><br><span class="line">        <span class="comment">// make sure we use an immutable copy of the constraint, so that</span></span><br><span class="line">        <span class="comment">// it doesn't change while the filter operation is in progress</span></span><br><span class="line">        args.constraint = constraint != <span class="keyword">null</span> ? constraint.toString() : <span class="keyword">null</span>;</span><br><span class="line">        args.listener = listener;</span><br><span class="line">        message.obj = args;</span><br><span class="line"></span><br><span class="line">        mThreadHandler.removeMessages(FILTER_TOKEN);</span><br><span class="line">        mThreadHandler.removeMessages(FINISH_TOKEN);</span><br><span class="line">        mThreadHandler.sendMessageDelayed(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中我们可以看到，主要做的就是在一开始创建一个 HandlerThread 线程，并且创建了一个 RequestHandler 的对象 mThreadHandler 。之后创建了一个 RequestArguments 的对象 args，然后把 constraint 和 listener 传到 args 中去，而 RequestArguments 类还有一个成员变量就是 results ，主要用于存储 filter 过滤之后的结果，这会在下面的代码中用到。然后用 mThreadHandler 将该消息发送出去。</p>
<p>那么我们接下来就要来看看 RequestHandler 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Worker thread handler. When a new filtering request is posted from</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.Filter#filter(CharSequence, android.widget.Filter.FilterListener)&#125;,</span><br><span class="line"> * it is sent to this handler.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Handles filtering requests by calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#performFiltering&#125; and then sending a message</span><br><span class="line">     * with the results to the results handler.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering request</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> what = msg.what;</span><br><span class="line">        Message message;</span><br><span class="line">        <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> FILTER_TOKEN:</span><br><span class="line">                RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args.results = performFiltering(args.constraint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">                    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    message = mResultHandler.obtainMessage(what);</span><br><span class="line">                    message.obj = args;</span><br><span class="line">                    message.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Message finishMessage = mThreadHandler.obtainMessage(FINISH_TOKEN);</span><br><span class="line">                        mThreadHandler.sendMessageDelayed(finishMessage, <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINISH_TOKEN:</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mThreadHandler.getLooper().quit();</span><br><span class="line">                        mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 case FILTER_TOKEN 中我们可以看到，会先去调用 <code>performFiltering(CharSequence constraint)</code> 方法。而该方法在 Filter 类中是抽象方法，需要在子类中去实现。那么我们就来看看 CursorFilter 的 <code>performFiltering(CharSequence constraint)</code> 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FilterResults <span class="title">performFiltering</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = mClient.runQueryOnBackgroundThread(constraint);</span><br><span class="line"></span><br><span class="line">    FilterResults results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        results.count = cursor.getCount();</span><br><span class="line">        results.values = cursor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        results.count = <span class="number">0</span>;</span><br><span class="line">        results.values = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performFiltering(CharSequence constraint)</code> 方法中又会去调用  mClient 的 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，而 mClient 就是之前的 CursorAdapter ，所以我们又要跳到 CursorAdapter 类去看相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Runs a query with the specified constraint. This query is requested</span><br><span class="line"> * by the filter attached to this adapter.</span><br><span class="line"> *</span><br><span class="line"> * The query is provided by a</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.FilterQueryProvider&#125;.</span><br><span class="line"> * If no provider is specified, the current cursor is not filtered and returned.</span><br><span class="line"> *</span><br><span class="line"> * After this method returns the resulting cursor is passed to &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;</span><br><span class="line"> * and the previous cursor is closed.</span><br><span class="line"> *</span><br><span class="line"> * This method is always executed on a background thread, not on the</span><br><span class="line"> * application's main thread (or UI thread.)</span><br><span class="line"> * </span><br><span class="line"> * Contract: when constraint is null or empty, the original results,</span><br><span class="line"> * prior to any filtering, must be returned.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint with which the query must be filtered</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> a Cursor representing the results of the new query</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #getFilter()</span><br><span class="line"> * <span class="doctag">@see</span> #getFilterQueryProvider()</span><br><span class="line"> * <span class="doctag">@see</span> #setFilterQueryProvider(android.widget.FilterQueryProvider)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilterQueryProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFilterQueryProvider.runQuery(constraint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到会去调用 mFilterQueryProvider 的 <code>runQuery(CharSequence constraint)</code> 方法。 FilterQueryProvider 其实就是一个接口而已，当我们需要使用 filter 时就要实现该接口。在上面的 filter 用法中已经提到过了。其中的 <code>runQuery(CharSequence constraint)</code> 方法就是需要我们自己去实现的。当然，这里还有另外一种方法，就是不用实现 FilterQueryProvider 接口。而是在子类中去重写 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，也是达到了一样的效果。</p>
<p>假定我们已经在 <code>runQuery(CharSequence constraint)</code> 实现了相关的操作，并且返回了查询出来的 cursor 。那样我们又要跳回到 RequestHandler 的源码中了(这里只截取部分代码，完整代码请查看上面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    args.results = performFiltering(args.constraint);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    message = mResultHandler.obtainMessage(what);</span><br><span class="line">    message.obj = args;</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里把返回的 cursor 传给了 args.results 。并且又使用了 mResultHandler 发送了消息。这样我们又要来看一下 ResultHandler 的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Handles the results of a filtering operation. The results are</span><br><span class="line"> * handled in the UI thread.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultsHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Messages received from the request handler are processed in the</span><br><span class="line">     * UI thread. The processing involves calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#publishResults(CharSequence,</span><br><span class="line">     * android.widget.Filter.FilterResults)&#125;</span><br><span class="line">     * to post the results back in the UI and then notifying the listener,</span><br><span class="line">     * if any.&lt;/p&gt; </span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering results</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line"></span><br><span class="line">        publishResults(args.constraint, args.results);</span><br><span class="line">        <span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">            args.listener.onFilterComplete(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>handleMessage(Message msg)</code> 中，调用了 <code>publishResults(CharSequence constraint, FilterResults results)</code> 方法。在 Filter 类中 <code>publishResults(CharSequence constraint, FilterResults results)</code> 又是抽象的，所以还得去 CursorFilter 类中查看相关的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishResults</span><span class="params">(CharSequence constraint, FilterResults results)</span> </span>&#123;</span><br><span class="line">    Cursor oldCursor = mClient.getCursor();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (results.values != <span class="keyword">null</span> &amp;&amp; results.values != oldCursor) &#123;</span><br><span class="line">        mClient.changeCursor((Cursor) results.values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码里表示了会去调用 CursorAdapter 的 <code>changeCursor(Cursor cursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Change the underlying cursor to a new cursor. If there is an existing cursor it will be</span><br><span class="line"> * closed.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cursor The new cursor to be used</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span> </span>&#123;</span><br><span class="line">    Cursor old = swapCursor(cursor);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        old.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>changeCursor(Cursor cursor)</code> 中，又调用了 <code>swapCursor(Cursor newCursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Swap in a new Cursor, returning the old Cursor.  Unlike</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;, the returned old Cursor is &lt;em&gt;not&lt;/em&gt;</span><br><span class="line"> * closed.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> newCursor The new cursor to be used.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the previously set Cursor, or null if there wasa not one.</span><br><span class="line"> * If the given new Cursor is the same instance is the previously set</span><br><span class="line"> * Cursor, null is also returned.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">swapCursor</span><span class="params">(Cursor newCursor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newCursor == mCursor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor oldCursor = mCursor;</span><br><span class="line">    <span class="keyword">if</span> (oldCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) oldCursor.unregisterContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) oldCursor.unregisterDataSetObserver(mDataSetObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    mCursor = newCursor;</span><br><span class="line">    <span class="keyword">if</span> (newCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) newCursor.registerContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) newCursor.registerDataSetObserver(mDataSetObserver);</span><br><span class="line">        mRowIDColumn = newCursor.getColumnIndexOrThrow(<span class="string">"_id"</span>);</span><br><span class="line">        mDataValid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the new cursor</span></span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRowIDColumn = -<span class="number">1</span>;</span><br><span class="line">        mDataValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the lack of a data set</span></span><br><span class="line">        notifyDataSetInvalidated();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>swapCursor(Cursor newCursor)</code> 中主要的工作就是把 oldCursor 替换成 newCursor ，并且调用了 <code>notifyDataSetChanged();</code> 来更新 ListView 。从上面的源码中还可以看到， <code>swapCursor(Cursor newCursor)</code> 方法中返回的 oldCursor 是没有关闭的。</p>
<p>完成了替换 Cursor 的工作后，我们还要回过头来看看 ResultsHandler 剩余部分的代码(只截取了部分代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">    args.listener.onFilterComplete(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在最后回调了 FilterListener 的 <code>onFilterComplete(int count)</code> 方法。其中的 count 参数是查询出来结果的总数。</p>
<p>至此，一个完整的 filter 流程终于走完了。这其中虽然看似很绕，其实原理还是比较简单的。</p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>看完上面分析，相信大家对 CursorAdapter 的 filter 机制已经有了一个大致的了解了吧。主要原理基本上还是 Handler 异步消息机制以及各个接口回调等。从中可以发现其实源码并不难，只要有耐心慢慢分析，一定会有所突破的。如果对这整个流程有问题的童鞋可以在下面留言。</p>
<p>那么，今天就到这了。Goodbye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Pro Git》笔记]]></title>
    <link href="http://yuqirong.me/2016/06/18/%E3%80%8APro%20Git%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/06/18/《Pro Git》笔记/</id>
    <published>2016-06-17T16:29:14.000Z</published>
    <updated>2016-08-18T15:09:33.879Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E"><a href="#1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E" class="headerlink" title="1.5 初次运行 Git 前的配置"></a>1.5 初次运行 Git 前的配置</h2><ul>
<li><p>Git 配置用户名：</p>
<p>  git config –global user.name “yuqirong”</p>
</li>
<li><p>Git 配置电子邮箱：</p>
<p>  git config –global user.email “yuqirong@myhexin.com”</p>
</li>
<li><p>查看 Git 配置情况：</p>
<p>  git config –list</p>
</li>
<li><p>设置默认使用的文本编辑器：</p>
<p>  git config –global core.editor emacs</p>
</li>
<li><p>设置默认使用的差异分析工具</p>
<p>  git config –global merge.tool vimdiff</p>
</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_Git__u57FA_u7840"><a href="#u7B2C_u4E8C_u7AE0_Git__u57FA_u7840" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h1><h2 id="2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93"><a href="#2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93" class="headerlink" title="2.1 取得项目的 Git 仓库"></a>2.1 取得项目的 Git 仓库</h2><ul>
<li><p>对某个项目进行 Git 管理：</p>
<p>  git init</p>
</li>
<li><p>对某个仓库进行克隆：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“</p>
</li>
<li><p>或者对克隆下来的仓库进行改名：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“ yuqirong</p>
</li>
<li><p>Git 添加某个文件：</p>
<p>  git add src/com/yuqirong/Test/a.java</p>
</li>
</ul>
<h2 id="2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93"><a href="#2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h2><ul>
<li><p>检查当前文件状态：</p>
<p>  git status</p>
</li>
<li><p>查看已暂存的更新：</p>
<p>  git diff –cached</p>
</li>
<li><p>查看未暂存的更新：</p>
<p>  git diff</p>
</li>
<li><p>提交更新：</p>
<p>  git commit<br>  或<br>  git commit -m “add new file”</p>
</li>
<li><p>跳过使用暂存区域的提交更新：</p>
<p>  git commit -a -m “add new file”</p>
</li>
<li><p>移除文件：</p>
<p>  git rm abc.txt</p>
</li>
<li><p>强制移除文件：</p>
<p>  git rm -f abc.txt</p>
</li>
<li><p>文件保存在当前目录中但从跟踪清单中移除：</p>
<p>  git rm –cached abc.txt</p>
</li>
<li><p>移动文件：</p>
<p>  git mv file_from file_to</p>
</li>
</ul>
<h2 id="2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="2.3 查看提交历史"></a>2.3 查看提交历史</h2><ul>
<li><p>查看提交历史：</p>
<p>  git log</p>
</li>
<li><p>查看提交历史中每次提交的内容差异：</p>
<p>  git log -patch</p>
</li>
<li><p>查看提交历史但仅显示简要的增改行数统计：</p>
<p>  git log –stat</p>
</li>
<li><p>查看提交历史并限制输出长度：</p>
<p>  git log -2<br>  或<br>  git log –since=2.weeks</p>
</li>
</ul>
<h2 id="2-4__u64A4_u6D88_u64CD_u4F5C"><a href="#2-4__u64A4_u6D88_u64CD_u4F5C" class="headerlink" title="2.4 撤消操作"></a>2.4 撤消操作</h2><ul>
<li><p>修改最后一次提交：</p>
<p>  git commit –amend</p>
</li>
<li><p>取消已经暂存的文件：</p>
<p>  git reset HEAD abc.txt</p>
</li>
<li><p>取消对文件的修改：</p>
<p>  git checkout – abc.txt (ps:该命令对已经add的文件无效)</p>
</li>
</ul>
<h2 id="2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528"><a href="#2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528" class="headerlink" title="2.5 远程仓库的使用"></a>2.5 远程仓库的使用</h2><ul>
<li><p>查看当前的远程库：</p>
<p>  git remote</p>
</li>
<li><p>查看当前远程库对应的克隆地址：</p>
<p>  git remote -v</p>
</li>
<li><p>添加远程仓库：</p>
<p>  git remote add [short-name] [url]</p>
</li>
<li><p>从远程仓库抓取数据：</p>
<p>  git fetch [remote-name] (fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。)</p>
</li>
<li><p>从远程仓库抓取数据，自动合并到本地仓库中：</p>
<p>  git pull [remote-name]</p>
</li>
<li><p>推送数据到远程仓库中：</p>
<p>  git push [remote-name] [branch-name]</p>
</li>
<li><p>查看远程仓库信息:</p>
<p>  git remote show [remote-name]</p>
</li>
<li><p>远程仓库的重命名:</p>
<p>  git remote rename [old-name] [new-name]</p>
</li>
<li><p>远程仓库的删除:</p>
<p>  git remote rm [remote-name]</p>
</li>
</ul>
<h2 id="2-6__u6253_u6807_u7B7E"><a href="#2-6__u6253_u6807_u7B7E" class="headerlink" title="2.6 打标签"></a>2.6 打标签</h2><ul>
<li><p>列出现有的标签：</p>
<p>  git tag</p>
</li>
<li><p>新建标签：</p>
<p>  git tag -a v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>查看相应标签的版本信息：</p>
<p>  git show v1.0</p>
</li>
<li><p>签署标签：</p>
<p>  git tag -s v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>轻量级标签：</p>
<p>  git tag v1.0</p>
</li>
<li><p>验证标签：</p>
<p>  git tag -v [tag-name]</p>
</li>
<li><p>分享标签:</p>
<p>  git push origin v1.0</p>
</li>
<li><p>推送所有的标签：</p>
<p>  git push origin –tags</p>
</li>
</ul>
<h2 id="2-7__u6280_u5DE7_u548C_u7A8D_u95E8"><a href="#2-7__u6280_u5DE7_u548C_u7A8D_u95E8" class="headerlink" title="2.7 技巧和窍门"></a>2.7 技巧和窍门</h2><ul>
<li><p>设置 Git 命令别名：</p>
<p>  git config –global alias.co checkout</p>
</li>
</ul>
<h1 id="u7B2C_u4E09_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E09_u7AE0__u8D77_u6B65" class="headerlink" title="第三章 起步"></a>第三章 起步</h1><h2 id="3-1__u4F55_u8C13_u5206_u652F"><a href="#3-1__u4F55_u8C13_u5206_u652F" class="headerlink" title="3.1 何谓分支"></a>3.1 何谓分支</h2><ul>
<li><p>创建一个新的分支：</p>
<p>  git branch [branch-name]</p>
</li>
<li><p>克隆一个远程服务器上的分支：</p>
<p>  git clone -b [branch-name] [remote-url]</p>
</li>
<li><p>切换分支：</p>
<p>  git checkout [branch-name]</p>
</li>
</ul>
<h2 id="3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76"><a href="#3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76" class="headerlink" title="3.2 基本的分支与合并"></a>3.2 基本的分支与合并</h2><ul>
<li><p>新建一个分支并切换到该分支上：</p>
<p>  git checkout -b [branch-name]</p>
</li>
<li><p>合并分支：</p>
<p>  git merge [branch-name]</p>
</li>
<li><p>删除分支：</p>
<p>  git branch -d [branch-name]</p>
</li>
<li><p>调用可视化的合并工具来解决冲突：</p>
<p>  git mergetool</p>
</li>
</ul>
<h2 id="3-3__u5206_u652F_u7BA1_u7406"><a href="#3-3__u5206_u652F_u7BA1_u7406" class="headerlink" title="3.3 分支管理"></a>3.3 分支管理</h2><ul>
<li><p>列出所有分支：</p>
<p>  git branch</p>
</li>
<li><p>查看分支最后一次 commit 信息：</p>
<p>  git branch -v</p>
</li>
<li><p>查看哪些分支已经被并入：</p>
<p>  git branch –merged</p>
</li>
<li><p>查看哪些分支没有被并入：</p>
<p>  git branch –no-merged</p>
</li>
</ul>
<h2 id="3-5__u8FDC_u7A0B_u5206_u652F"><a href="#3-5__u8FDC_u7A0B_u5206_u652F" class="headerlink" title="3.5 远程分支"></a>3.5 远程分支</h2><ul>
<li><p>跟踪分支</p>
<p>  git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</p>
</li>
<li><p>删除远程分支：</p>
<p>  git push [remote-name] :[remote-branch-name]</p>
</li>
</ul>
<h2 id="3-6__u884D_u5408"><a href="#3-6__u884D_u5408" class="headerlink" title="3.6 衍合"></a>3.6 衍合</h2><ul>
<li><p>衍合分支：</p>
<p>  git rebase [branch-name]</p>
</li>
</ul>
<h1 id="u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git"><a href="#u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git" class="headerlink" title="第4章 服务器上的 Git"></a>第4章 服务器上的 Git </h1><h1 id="u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git"><a href="#u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git" class="headerlink" title="第5章 分布式 Git"></a>第5章 分布式 Git</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1]]>
    </summary>
    
      <category term="Git" scheme="http://yuqirong.me/tags/Git/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android 6.0的运行时权限处理]]></title>
    <link href="http://yuqirong.me/2016/06/08/%E5%85%B3%E4%BA%8EAndroid%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2016/06/08/关于Android M的运行权限处理/</id>
    <published>2016-06-08T14:12:20.000Z</published>
    <updated>2016-11-01T14:54:14.215Z</updated>
    <content type="html"><![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问题的原因大家都知道，是 Android 6.0 新引入了在运行时权限申请(Runtime Permissions)的功能。那么这所谓的运行时申请权限究竟是怎么一回事呢，一起来看看吧！</p>
<p>在 Android 6.0 中，app 如果想要获得某些权限，会在应用中弹出一个对话框，让用户确认是否授予该权限。具体的截图如下：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160608/20160608161439.png" alt="Runtime Permissions screenshot"></p>
<p>这要做的好处就是运行一个 app 时可以拒绝其中的某些权限，防止 app 触及到你的隐私(比如说通讯录、短信之类的)。而在 Android 6.0 之前，若同意安装 app ，就意味着该 app 可以获取权限列表中的所有权限。(注：这里所指的都是原生 Android 系统，比如 MIUI 之类的第三方 ROM 很早就具备了这种功能。)</p>
<p>接下来就来看看相关的 API 吧，首先我们来看看 <code>Context.checkSelfPermission(String permission)</code> 方法，该方法主要用于检测该 app 是否已经被赋予了某权限，传入的参数有。如果已被赋予，则返回 <code>PERMISSION_GRANTED</code> ，否则返回 <code>PERMISSION_DENIED</code> 。</p>
<p>若返回了 <code>PERMISSION_DENIED</code> ，那么我们就要去申请该权限了。这时就要用到  <code>Activity.requestPermissions(String[] permissions, int requestCode)</code> 这个方法了。顾名思义，该方法的作用就是申请某些权限了。第一个参数就是要申请的权限，可以看到参数形式是一个数组，也就是说可以一次申请多个权限。而第二个参数就是申请权限的代号，主要用于在之后的回调中选择。</p>
<p>当用户在权限申请的对话框中作出选择后，就会回调 <code>onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)</code> 方法。第一个参数就是上面的权限代号；第二个参数是申请的权限数组；第三个参数就是权限申请的结果。</p>
<p>结合上面的几个方法，可以写出如下所示的权限申请代码模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_CONTACTS_REQUEST_CODE = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果权限没有被授予</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.READ_CONTACTS) !=</span><br><span class="line">        PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 申请权限</span></span><br><span class="line">    ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;, READ_CONTACTS_REQUEST_CODE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 权限已经被授予</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> READ_CONTACTS_REQUEST_CODE:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// TODO 用户已经授予了权限</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// TODO 用户拒绝授予权限</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，还有一个方法需要注意下，那就是 <code>shouldShowRequestPermissionRationale (Activity activity, String permission)</code> 方法。这个方法的作用就是当用户拒绝了某个权限之后，下一次就会显示出需要该权限的说明。</p>
<p>关于运行时申请权限基本就这样了，值得提醒的是，并不是所有的权限都需要运行时申请，只有“危险”的权限才通过运行时来申请。比如说读取联系人、获取位置信息、读写SD卡等等都为“危险权限”，而比如振动、联网、蓝牙等就是普通权限了，就不需要运行时申请了。</p>
<p>说完了运行时申请权限后，另外还有一点需要注意的是，在 Android 6.0 显示悬浮窗也有一个“坑”。如果调用平常的显示悬浮窗的方法，会抛出 “permission denied for this window type” 异常。解决的方案就是在显示悬浮窗之前，需要调用一下 <code>Settings.canDrawOverlays(context)</code> 这个方法。若该方法返回 true ，则说明用户同意创建悬浮窗；否则可以跳转到相关的设置页面。具体的代码模版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Settings.canDrawOverlays(context)) &#123;</span><br><span class="line">        <span class="comment">// 显示悬浮窗</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 跳转到相关的设置页面</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 版本低于Android 6.0，直接显示悬浮窗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，就到这里吧。</p>
<p>GoodBye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易实现Android九宫格解锁]]></title>
    <link href="http://yuqirong.me/2016/05/10/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Android%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/"/>
    <id>http://yuqirong.me/2016/05/10/简易实现Android九宫格解锁/</id>
    <published>2016-05-10T12:09:19.000Z</published>
    <updated>2016-11-01T14:53:08.127Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等。因为九宫格可以保护用户的隐私，所以它的应用面很广泛。那么今天我们就来自定义一个属于自己的九宫格吧！</p>
<p>首先我们来分析一下实现九宫格解锁的思路：当用户的手指触摸到某一个点时，先判断该点是否在九宫格的某一格范围之内，若在范围内，则该格变成选中的状态；之后用户手指滑动的时候，以该格的圆心为中心，用户手指为终点，两点连线。最后当用户手指抬起时，判断划过的九宫格密码是否和原先的密码匹配。</p>
<p>大致的思路流程就是上面这样的了，下面我们可以来实践一下。</p>
<h1 id="Point__u7C7B"><a href="#Point__u7C7B" class="headerlink" title="Point 类"></a>Point 类</h1><p>我们先来创建一个 <code>Point</code> 类，用来表示九宫格锁的九个格子。除了坐标 <code>x</code> ，<code>y</code> 之外，还有三种模式：正常模式、按下模式和错误模式。根据模式不同该格子的颜色会有所不同，这会在下面中说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> y;</span><br><span class="line">    <span class="comment">// 正常模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按下模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRESSED_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 错误模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = NORMAL_MODE;</span><br><span class="line">    <span class="comment">// 表示该格的密码，比如“1”、“2”等</span></span><br><span class="line">    <span class="keyword">private</span> String mark;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMark</span><span class="params">(String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RotateDegrees_u7C7B"><a href="#RotateDegrees_u7C7B" class="headerlink" title="RotateDegrees类"></a>RotateDegrees类</h1><p>有了上面的 <code>Point</code> 类之后，我们还要创建一个 <code>RotateDegrees</code> 类，主要作用是计算两个 <code>Point</code> 坐标之间的角度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RotateDegrees &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的point计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> degrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> aX = a.getX();</span><br><span class="line">        <span class="keyword">float</span> aY = a.getY();</span><br><span class="line">        <span class="keyword">float</span> bX = b.getX();</span><br><span class="line">        <span class="keyword">float</span> bY = b.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aX == bX) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aY &lt; bY) &#123;</span><br><span class="line">                degrees = <span class="number">90</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">270</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bY == aY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &lt; bX) &#123;</span><br><span class="line">                degrees = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &gt; bX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第三象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> + (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第四象限</span></span><br><span class="line">                    degrees = <span class="number">360</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一象限</span></span><br><span class="line">                    degrees = (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据point和(x,y)计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param bX</span><br><span class="line">     * @param bY</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, <span class="keyword">float</span> bX, <span class="keyword">float</span> bY)</span> </span>&#123;</span><br><span class="line">        Point b = <span class="keyword">new</span> Point(bX, bY, null);</span><br><span class="line">        <span class="keyword">return</span> getDegrees(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ScreenLockView__u7C7B"><a href="#ScreenLockView__u7C7B" class="headerlink" title="ScreenLockView 类"></a>ScreenLockView 类</h1><p>然后我们要先准备好关于九宫格的几张图片，比如在九宫格的格子中，<code>NORMAL_MODE</code> 模式下是蓝色的，被手指按住时九宫格的格子是绿色的，也就是对应着上面 Point 类的中 <code>PRESSED_MODE</code> 模式，还有 <code>ERROR_MODE</code> 模式下是红色的。另外还有圆点之间的连线，也是根据模式不同颜色也会不同。在这里我就不把图片贴出来了，想要的童鞋可以下载源码从中获取。</p>
<p>有了图片资源之后，我们要做的就是先在构造器中加载图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ScreenLockView"</span>;</span><br><span class="line">    <span class="comment">// 错误格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap errorBitmap;</span><br><span class="line">    <span class="comment">// 正常格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap normalBitmap;</span><br><span class="line">    <span class="comment">// 手指按下时格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap pressedBitmap;</span><br><span class="line">    <span class="comment">// 错误时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap lineErrorBitmap;</span><br><span class="line">    <span class="comment">// 手指按住时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap linePressedBitmap;</span><br><span class="line">    <span class="comment">// 偏移量，使九宫格在屏幕中央</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// 九宫格的九个格子是否已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init;</span><br><span class="line">    <span class="comment">// 格子的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="comment">// 九个格子</span></span><br><span class="line">    <span class="keyword">private</span> Point[][] points = <span class="keyword">new</span> Point[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveY = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手指在移动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isMove;</span><br><span class="line">    <span class="comment">// 是否可以触摸，当用户抬起手指，划出九宫格的密码不正确时为不可触摸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用来存储记录被按下的点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; pressedPoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 屏幕解锁监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnScreenLockListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        errorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_error);</span><br><span class="line">        normalBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_normal);</span><br><span class="line">        pressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_pressed);</span><br><span class="line">        lineErrorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_error);</span><br><span class="line">        linePressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_pressed);</span><br><span class="line">        radius = normalBitmap.getWidth() / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中我们主要就是把图片加载完成，并且得到了格子的半径，即图片宽度的一半。</p>
<p>之后我们来看看 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSize &gt; heightSize) &#123;</span><br><span class="line">        offset = (widthSize - heightSize) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        offset = (heightSize - widthSize) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法中，主要得到对应的偏移量，以便在下面的 <code>onDraw(Canvas canvas)</code> 把九宫格绘制在屏幕中央。</p>
<p>下面就是 <code>onDraw(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        width = getWidth();</span><br><span class="line">        height = getHeight();</span><br><span class="line">        initPoint();</span><br><span class="line">        init = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画九宫格的格子</span></span><br><span class="line">    drawPoint(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moveX != -<span class="number">1</span> &amp;&amp; moveY != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 画直线</span></span><br><span class="line">        drawLine(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断了是否为第一次调用 <code>onDraw(Canvas canvas)</code> 方法，若为第一次则对 points 进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"0"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">4</span>, <span class="string">"1"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"3"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">2</span>, <span class="string">"4"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">2</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"6"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"7"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initPoint()</code> 方法中主要创建了九个格子，并设置了相应的位置和密码。初始化完成之后把 init 置为 false ,下次不会再调用。</p>
<p>回过头再看看 <code>onDraw(Canvas canvas)</code> 中其他的逻辑，接下来调用了 <code>drawPoint(canvas)</code> 来绘制格子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画九宫格的格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> state = points[i][j].getState();</span><br><span class="line">            <span class="keyword">if</span> (state == Point.NORMAL_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(normalBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == Point.PRESSED_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(pressedBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.drawBitmap(errorBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绘制格子还是很简单的，主要分为了三种：普通模式下的格子、按下模式下的格子以及错误模式下的格子。</p>
<h1 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h1><p>在绘制好了格子之后，我们先不看最后的 <code>drawLine(canvas)</code> 方法，因为绘制直线是和用户手指的触摸事件息息相关的，所以我们先把目光转向 <code>onTouchEvent(MotionEvent event)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 判断用户触摸的点是否在九宫格的任意一个格子之内</span></span><br><span class="line">                point = isPoint(x, y);</span><br><span class="line">                <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    point.setState(Point.PRESSED_MODE);  <span class="comment">// 切换为按下模式</span></span><br><span class="line">                    pressedPoint.add(point);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (pressedPoint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    point = isPoint(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!crossPoint(point)) &#123;</span><br><span class="line">                            point.setState(Point.PRESSED_MODE);</span><br><span class="line">                            pressedPoint.add(point);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveX = x;</span><br><span class="line">                    moveY = y;</span><br><span class="line">                    isMove = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                isMove = <span class="keyword">false</span>;</span><br><span class="line">                String tempPwd = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                    tempPwd += p.getMark();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.getStringPassword(tempPwd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tempPwd.equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                        p.setState(Point.ERROR_MODE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    isTouch = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.postDelayed(runnable, <span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScreenLockListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStringPassword</span><span class="params">(String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPassword</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScreenLockListener</span><span class="params">(OnScreenLockListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MotionEvent.ACTION_DOWN</code> 中，先在 <code>isPoint(float x, float y)</code> 方法内判断了用户触摸事件的坐标点是否在九宫格的任意一格之内。如果是，则需要把该九宫格的格子添加到 <code>pressedPoint</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该触摸点是否为格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">isPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            point = points[i][j];</span><br><span class="line">            <span class="keyword">if</span> (isContain(point, x, y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该点(x，y)是否被包含</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Point point, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该点的(x,y)与格子圆心的距离若小于半径就是被包含了</span></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x - point.getX(), <span class="number">2f</span>) + Math.pow(y - point.getY(), <span class="number">2f</span>)) &lt;= radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是要看 <code>MotionEvent.ACTION_MOVE</code> 的逻辑了。一开始判断了用户触摸的点是否为九宫格的某个格子。但是比 <code>MotionEvent.ACTION_DOWN</code> 还多了一个步骤：若用户触摸了某个格子，还要判断该格子是否已经被包含在 <code>pressedPoint</code> 里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否该格子已经被包含在pressedPoint里面了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">crossPoint</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pressedPoint.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看 <code>MotionEvent.ACTION_UP</code> ，把 <code>pressedPoint</code> 里保存的格子遍历后得到用户划出的密码，再和预先设置的密码比较，若相同则回调 <code>OnScreenLockListener</code> 监听器；不相同则把 <code>pressedPoint</code> 中的所有格子的模式设置为错误模式，并在 <code>runnable</code> 中调用 <code>reset()</code> 清空 <code>pressedPoint</code> ，重绘视图，再回调监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isTouch = <span class="keyword">true</span>;</span><br><span class="line">        reset();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            points[i][j].setState(Point.NORMAL_MODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pressedPoint.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们回过头来看看之前在 <code>onDraw(Canvas canvas)</code> 里面的 <code>drawLine(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画直线</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pressedPoint中的所有格子依次遍历，互相连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pressedPoint.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 得到当前格子</span></span><br><span class="line">        Point point = pressedPoint.get(i);</span><br><span class="line">        <span class="comment">// 得到下一个格子</span></span><br><span class="line">        Point nextPoint = pressedPoint.get(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 旋转画布</span></span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        <span class="comment">// 根据距离设置拉伸的长度</span></span><br><span class="line">        matrix.setScale(getDistance(point, nextPoint) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 进行平移</span></span><br><span class="line">        matrix.postTranslate(point.getX(), point.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point.getState() == Point.PRESSED_MODE) &#123;</span><br><span class="line">            canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.drawBitmap(lineErrorBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把画布旋转回来</span></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是手指在移动的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">        Point lastPoint = pressedPoint.get(pressedPoint.size() - <span class="number">1</span>);</span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        Log.i(TAG, <span class="string">"the distance : "</span> + getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth());</span><br><span class="line">        matrix.setScale(getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        matrix.postTranslate(lastPoint.getX(), lastPoint.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line">        canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据point和坐标点计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, <span class="keyword">float</span> moveX, <span class="keyword">float</span> moveY)</span> </span>&#123;</span><br><span class="line">    Point b = <span class="keyword">new</span> Point(moveX,moveY,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> getDistance(point,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个point计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, Point nextPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) Math.sqrt(Math.pow(nextPoint.getX() - point.getX(), <span class="number">2f</span>) + Math.pow(nextPoint.getY() - point.getY(), <span class="number">2f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawLine(Canvas canvas)</code> 整体的逻辑并不复杂，首先将 <code>pressedPoint</code> 中的所有格子依次遍历，将它们连线。之后若是用户的手指还有滑动的话，把最后一个格子和用户手指触摸的点连线。</p>
<h1 id="u6587_u672B"><a href="#u6587_u672B" class="headerlink" title="文末"></a>文末</h1><p><code>ScreenLockView</code> 中的代码差不多就是这些了，既然讲解完了那就一起来看看效果吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160510/20160510151253.gif" alt="ScreenShot"></p>
<p>效果还算不错吧，当然你也可以自己设置喜欢的九宫格图片，只要替换一下就可以了。如果对本篇文章有问题，可以留言。</p>
<p>老规矩，附上源码下载链接：</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160510/ScreenLockView.rar" target="_blank" rel="external">ScreenLockView.rar</a></p>
<p>Goodbye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现ViewPager指示器]]></title>
    <link href="http://yuqirong.me/2016/04/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8/"/>
    <id>http://yuqirong.me/2016/04/27/自定义实现ViewPager指示器/</id>
    <published>2016-04-27T12:09:19.000Z</published>
    <updated>2016-11-01T14:51:15.098Z</updated>
    <content type="html"><![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="external">ViewPagerIndicator</a> ，到现在 Material Design 中的 TabLayout 。GitHub 上还有其他形形色色的指示器。那么肯定有人会问：既然有了这么多的指示器可以用，那为什么还要自己自定义呢？其实，我们学习了自定义指示器之后，可以知道 ViewPager 指示器的原理，还可以提高我们代码的水平哦！那还等什么，一起来学习吧。</p>
<p>首先放上一张效果图，亮亮眼：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20160427/20160427152924.gif" alt="这里写图片描述"></p>
<p>接下来我们来大致地分析一下思路： ViewPager 指示器我们可以看作是一个横向的 LinearLayout ，相对应的 Tab 可以直接使用 TextView 来实现。而 LinearLayout 中有许多个 TextView ，当我们点击其中的 TextView 时， ViewPager 就切换到对应的 item 上。而当我们手动滑动 ViewPager 时，根据 OnPageChangeListener 来动态地改变指示器。好了，基本上思路就是这样了，下面就来看看代码了。</p>
<p>自定义的属性 attrs.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ViewPagerIndicator"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab可见的数量 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"visible_tab_num"</span> <span class="attribute">format</span>=<span class="value">"integer"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab未选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"unselected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab中字体的大小 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时横线的高度 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"indicator_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义的属性基本上就以上几种，如果自己有其他的需求，可以另外添加。</p>
<p>之后我们就创建一个类，名字就叫 ViewPagerIndicator 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPagerIndicator</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab可见数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visibleTabNum;</span><br><span class="line">    <span class="comment">// 选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectedColor;</span><br><span class="line">    <span class="comment">// 未选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unselectedColor;</span><br><span class="line">    <span class="comment">// 屏幕宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> screenWidth;</span><br><span class="line">    <span class="comment">// tab的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tabWidth;</span><br><span class="line">    <span class="comment">// 横线的偏移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> offset;</span><br><span class="line">    <span class="comment">// 画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">// 横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> indicatorHeight;</span><br><span class="line">    <span class="comment">// 默认横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultIndicatorHeight;</span><br><span class="line">    <span class="comment">// viewpager当前页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentItem;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> textSize;</span><br><span class="line">    <span class="comment">// 默认字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultTextSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager mViewPager;</span><br><span class="line">    <span class="comment">// 滑动的最小距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> touchSlop;</span><br><span class="line">    <span class="comment">// 上次触摸的x轴坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewPagerIndicator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="comment">// 设置横向</span></span><br><span class="line">        setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewPagerIndicator);</span><br><span class="line">        selectedColor = a.getColor(R.styleable.ViewPagerIndicator_selected_color, Color.BLUE);</span><br><span class="line">        unselectedColor = a.getColor(R.styleable.ViewPagerIndicator_unselected_color, Color.WHITE);</span><br><span class="line">        visibleTabNum = a.getInt(R.styleable.ViewPagerIndicator_visible_tab_num, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认字体大小</span></span><br><span class="line">        defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="number">10</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        textSize = a.getDimension(R.styleable.ViewPagerIndicator_text_size, defaultTextSize);</span><br><span class="line">        <span class="comment">// 默认下划横线高度</span></span><br><span class="line">        defaultIndicatorHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">4</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        indicatorHeight = a.getDimension(R.styleable.ViewPagerIndicator_indicator_height, defaultIndicatorHeight);</span><br><span class="line">        a.recycle();</span><br><span class="line">        screenWidth = context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">        tabWidth = screenWidth / visibleTabNum;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(selectedColor);</span><br><span class="line">        mPaint.setStrokeWidth(indicatorHeight);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">// 得到touchSlop</span></span><br><span class="line">        touchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要是初始化了自定义属性，还有得到了 tabWidth 以便后面使用。</p>
<p>当然，如果用户旋转了屏幕，那么 tabWidth 是会改变的。所以我们应该在 <code>onSizeChanged</code> 里重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 当大小改变时，得到一个tab的宽度</span></span><br><span class="line">    tabWidth = w / visibleTabNum;</span><br><span class="line">    height = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论是横屏还是竖屏，在屏幕上可见的 Tab 数量永远是固定的(即 visibleTabNum 的值)。之后，我们先来“画”出 Tab 被选中时底下的那条横线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">// 绘制横线</span></span><br><span class="line">        canvas.drawLine(offset, height - indicatorHeight, offset + tabWidth, height - indicatorHeight, mPaint);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置offset</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOffset</span><span class="params">(<span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mViewPager 的赋值是在<code>setViewPager(ViewPager viewPager)</code>方法中完成的，这个方法放在下面去讲。而其中的 offset 是偏移量。当用户滑动切换 ViewPager 时，Tab 底下的横线应该也要做相应的位移，而这就是由 offset 来完成的。调用 <code>setOffset(float offset)</code> 方法，可以引起视图重绘。另外横线的高度 indicatorHeight 可以由用户自定义的，这里的代码还是比较简单的，相信大家都可以看懂的。</p>
<p>到这就来讲讲 setViewPager 方法了。当我们想要把 ViewPager 和 ViewPagerIndicator 关联起来时，可以给外部设置一个 <code>setViewPager(ViewPager viewPager)</code> 方法，那下面就是该方法的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置ViewPager， 请确保在设置了adapter之后调用该方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> viewPager</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewPager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mViewPager = viewPager;</span><br><span class="line">    <span class="comment">// 得到适配器</span></span><br><span class="line">    PagerAdapter adapter = viewPager.getAdapter();</span><br><span class="line">    <span class="comment">// adapter不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the adapter of viewpager must be not null.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先移除所有的子view</span></span><br><span class="line">    <span class="keyword">this</span>.removeAllViews();</span><br><span class="line">    <span class="comment">// 添加Textview</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapter.getCount(); i++) &#123;</span><br><span class="line">        createTextView(adapter.getPageTitle(i).toString(), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurrentItem = viewPager.getCurrentItem();</span><br><span class="line">    ((TextView) getChildAt(mCurrentItem)).setTextColor(selectedColor);</span><br><span class="line">    viewPager.addOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置了横线的偏移，并引起重绘</span></span><br><span class="line">            setOffset((position + positionOffset) * tabWidth);</span><br><span class="line">            <span class="comment">// tab也要进行相应的移动，若当前的tab是倒数第二个，则不移动。</span></span><br><span class="line">            <span class="keyword">if</span> (position + positionOffset + <span class="number">1</span> &gt; visibleTabNum - <span class="number">1</span> &amp;&amp; position + positionOffset + <span class="number">1</span> &lt;= getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">                scrollTo((<span class="keyword">int</span>) ((position + positionOffset - visibleTabNum + <span class="number">2</span>) * tabWidth), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 字体颜色改变</span></span><br><span class="line">            ((TextView) getChildAt(mCurrentItem)).setTextColor(unselectedColor);</span><br><span class="line">            ((TextView) getChildAt(position)).setTextColor(selectedColor);</span><br><span class="line">            mCurrentItem = position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法内部可以看出，我们要得到 ViewPager 的 adapter 。如果 adapter 为空则抛出异常。之后根据 adapter 的 count 数量去创建相对应的 TextView 作为 Tab 。下面为 <code>createTextView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加textview到ViewPagerIndicator中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTextView</span><span class="params">(String title, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">    LinearLayout.LayoutParams params = <span class="keyword">new</span> LayoutParams(tabWidth, LayoutParams.MATCH_PARENT);</span><br><span class="line">    tv.setLayoutParams(params);</span><br><span class="line">    tv.setText(title);</span><br><span class="line">    tv.setGravity(Gravity.CENTER);</span><br><span class="line">    tv.setTextColor(unselectedColor);</span><br><span class="line">    tv.setTag(i);</span><br><span class="line">    tv.setTextSize(textSize);</span><br><span class="line">    tv.setOnClickListener(tvClickListener);</span><br><span class="line">    <span class="keyword">this</span>.addView(tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// textview的点击监听器</span></span><br><span class="line">OnClickListener tvClickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewPager.setCurrentItem(i, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>createTextView</code> 方法中，使用了addView 来动态地添加 Tab 。这里有一处比较巧妙的地方：我们把当前 TextView 的索引 i 存储到了 Tag 中。而当用户点击 Tab 时，在监听器中我们取出那个 Tag 值，这样就知道了用户点击的是哪个 Tab 了，并且让 ViewPager 切换到那个页面下。</p>
<p>好了，我们再回过头继续看之前的 <code>setViewPager(ViewPager viewPager)</code> 方法，我们看到给 viewPager 设置了 OnPageChangeListener 。在 OnPageChangeListener 的 onPageScrolled 方法中，根据当前的 position 和 positionOffset 就可以完成选中时那条横线的移动。并且为了选中的 Tab 出现在屏幕中，ViewPagerIndicator 也要用 scrollTo 方法来做相应地移动。而在 onPageSelected 方法中，我们把选中的 Tab 中的字体颜色更改为已选中的颜色，之前选中的改成未选中颜色。</p>
<p>到这里，整体完成得差不多了。但是如果我们想让 ViewPagerIndicator 可以滑动的话，还要重写 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent event)</code> 两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = ev.getX();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = ev.getX() - lastX;</span><br><span class="line">            <span class="comment">// 当移动大于touchSlop时，拦截该触摸事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(offsetX) &gt;= touchSlop) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"onInterceptTouchEvent result = "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = x - lastX;</span><br><span class="line">            <span class="comment">// 滑动相应的距离</span></span><br><span class="line">            scrollBy(-(<span class="keyword">int</span>) offsetX, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 最左边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &gt; tabWidth * (getChildCount() - visibleTabNum)) &#123;</span><br><span class="line">                scrollTo(tabWidth * (getChildCount() - visibleTabNum), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onInterceptTouchEvent(MotionEvent ev)</code> 中，若滑动的距离超过 touchSlop ，则拦截该触摸事件自己处理，否则传递给子View。而在 <code>onTouchEvent(MotionEvent event)</code> 中，使用了 scrollBy 来处理滑动，并且设置了边界值的检查。</p>
<p>在这里，整体代码讲解完成了。其实 ViewPagerIndicator 本质就是使用了 OnPageChangeListener 以及当用户点击时切换 ViewPager 到指定页面，并没有太难的地方。以后我们自己也可以实现各种炫酷的 ViewPagerIndicator 了！</p>
<p>下面提供源码的下载链接：</p>
<p><a href="http://ofytl4mzu.bkt.clouddn.com/20160427/ViewPagerIndicator.rar" target="_blank" rel="external">ViewPagerIndicator.rar</a></p>
<p>have a nice day !~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blan]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
