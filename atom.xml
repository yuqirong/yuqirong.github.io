<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-08-18T15:09:34.082Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[简单实现炫酷的滑动返回效果]]></title>
    <link href="http://yuqirong.me/2016/07/07/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/07/07/简单实现炫酷的滑动返回效果/</id>
    <published>2016-07-06T16:25:04.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功能，那就是滑动返回。比如知乎、百度贴吧等，用户在使用这一类的 app 都可以滑动返回上一个页面。不得不说这个设计很赞，是不是心动了呢？那就继续往下看吧！</p>
<p>在GitHub上有实现该效果的开源库 <a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a> ，可以看到该库发展得已经非常成熟了。仔细看源码你会惊奇地发现其中的奥秘，没错，正是借助了 ViewDragHelper 来实现滑动返回的效果。ViewDragHelper 我想不必多说了，在我的博客中有很多的效果都是通过它来实现的。那么，下面我们就使用 ViewDragHelper 来实现这个效果吧。</p>
<h1 id="u81EA_u5B9A_u4E49_u5C5E_u6027"><a href="#u81EA_u5B9A_u4E49_u5C5E_u6027" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>首先，我们应该先定义几个自定义属性，比如说支持用户从左边或者右边滑动返回，丰富用户的选择性。所以现在 attrs.xml 中定义如下属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SwipeBackLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"swipe_mode"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的 xml 中可知，定义了一个枚举属性，左边为0，右边为1。</p>
<p>然后主角 SwipeBackLayout 就要登场了。</p>
<pre><code>public class SwipeBackLayout extends FrameLayout {

    private ViewDragHelper mViewDragHelper;
    // 主界面
    private View mainView;
    // 主界面的宽度
    private int mainViewWidth;
    // 模式，默认是左滑
    private int mode = MODE_LEFT;
    // 监听器
    private SwipeBackListener listener;
    // 是否支持边缘滑动返回, 默认是支持
    private boolean isEdge = true;

    private int mEdge;
    // 阴影Drawable
    private Drawable shadowDrawable;
    // 阴影Drawable固有宽度
    private int shadowDrawbleWidth;
    // 已经滑动的百分比
    private float movePercent;
    // 滑动的总长度
    private int totalWidth;
    // 默认的遮罩透明度
    private static final int DEFAULT_SCRIM_COLOR = 0x99000000;
    // 遮罩颜色
    private int scrimColor = DEFAULT_SCRIM_COLOR;
    // 透明度
    private static final int ALPHA = 255;

    private Paint mPaint;
    /**
     * 滑动的模式，左滑
     */
    public static final int MODE_LEFT = 0;
    /**
     * 滑动的模式，右滑
     */
    public static final int MODE_RIGHT = 1;
    // 最小滑动速度
    private static final int MINIMUM_FLING_VELOCITY = 400;

    private static final String TAG = &quot;SwipeBackLayout&quot;;

    public SwipeBackLayout(Context context) {
        this(context, null);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeBackLayout);
        // 得到滑动模式，默认左滑
        mode = a.getInt(R.styleable.SwipeBackLayout_swipe_mode, MODE_LEFT);
        a.recycle();
        initView();
    }

    ...

}
</code></pre><h1 id="initView"><a href="#initView" class="headerlink" title="initView"></a>initView</h1><p>在构造器主要做的就是得到滑动模式，默认是左边滑动。之后调用 <code>initView()</code> 。那么我们来看看 <code>initView()</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阴影Drawable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShadowView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right, getContext().getTheme());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shadowDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shadowDrawbleWidth = shadowDrawable.getIntrinsicWidth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> density = getResources().getDisplayMetrics().density;</span><br><span class="line">	<span class="comment">// 最小滑动速度</span></span><br><span class="line">    <span class="keyword">float</span> minVel = density * MINIMUM_FLING_VELOCITY;</span><br><span class="line">    initShadowView();</span><br><span class="line">    mViewDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="keyword">new</span> ViewDragHelper.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mainView == child; <span class="comment">// 只有是主界面时才可以被滑动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据模式区分</span></span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:  <span class="comment">// 左边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:  <span class="comment">// 右边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    movePercent = left * <span class="number">1f</span> / totalWidth;  <span class="comment">// 滑动的进度</span></span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    movePercent = Math.abs(left) * <span class="number">1f</span> / totalWidth;</span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == MODE_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(totalWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -totalWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &gt; -mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;  <span class="comment">// 如果当前已经滑动超过子View宽度的一半，并且速度符合预期设置</span></span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);  <span class="comment">// 把当前界面finish</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &gt; mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();  <span class="comment">// 当前界面回到原位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &lt; mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &lt; -mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置最小滑动速度</span></span><br><span class="line">    mViewDragHelper.setMinVelocity(minVel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// 子View只能有一个</span></span><br><span class="line">        <span class="comment">// 获取子view</span></span><br><span class="line">        mainView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the child of swipebacklayout can not be empty and must be the one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 得到主界面的宽度</span></span><br><span class="line">    mainViewWidth = w;</span><br><span class="line">    <span class="comment">//总长度，包含了mainView的宽度以及阴影图片的宽度</span></span><br><span class="line">    totalWidth = mainViewWidth + shadowDrawbleWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initView()</code> 中，设置了 mViewDragHelper 的最小滑动速度，并且设置了 mViewDragHelper 回调的接口。回调接口中的方法都有注释，相信大家应该都能看懂。另外在 <code>initView()</code> 中初始化了阴影图片，以备下面中使用。</p>
<h1 id="drawChild"><a href="#drawChild" class="headerlink" title="drawChild"></a>drawChild</h1><p>想要阴影在滑动中绘制出来，我们必须重写 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法，并且在 <code>onTouchEvent(MotionEvent event)</code> 里 <code>invalidate()</code> ,保证用户滑动过程中调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">""</span> + (mViewDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE));</span><br><span class="line">    <span class="keyword">if</span> (child == mainView &amp;&amp; mViewDragHelper.getViewDragState() != ViewDragHelper.STATE_IDLE) &#123;</span><br><span class="line">        <span class="comment">// 绘制阴影</span></span><br><span class="line">        drawShadowDrawable(canvas, child);</span><br><span class="line">        <span class="comment">// 绘制遮罩层</span></span><br><span class="line">        drawScrimColor(canvas, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="comment">// 重绘，保证在滑动的时候可以绘制阴影</span></span><br><span class="line">    invalidate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中调用 <code>drawShadowDrawable(Canvas canvas, View child)</code> 来绘制阴影以及 <code>drawScrimColor(Canvas canvas, View child)</code> 来绘制遮罩层。下面分别是两个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制阴影</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadowDrawable</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    Rect drawableRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">// 得到mainView的矩形</span></span><br><span class="line">    child.getHitRect(drawableRect);</span><br><span class="line">    <span class="comment">// 设置shadowDrawable绘制的矩形</span></span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.left - shadowDrawbleWidth, drawableRect.top, drawableRect.left, drawableRect.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.right, drawableRect.top, drawableRect.right + shadowDrawbleWidth, drawableRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置shadowDrawable的透明度,最低为0.3</span></span><br><span class="line">    shadowDrawable.setAlpha((<span class="keyword">int</span>) ((<span class="number">1</span> - movePercent &gt; <span class="number">0.3</span> ? <span class="number">1</span> - movePercent : <span class="number">0.3</span>) * ALPHA));</span><br><span class="line">    <span class="comment">// 将shadowDrawable绘制在canvas上</span></span><br><span class="line">    shadowDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制遮罩层</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawScrimColor</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据滑动进度动态设置透明度</span></span><br><span class="line">    <span class="keyword">int</span> baseAlpha = (scrimColor &amp; <span class="number">0xFF000000</span>) &gt;&gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (baseAlpha * (<span class="number">1</span> - movePercent));</span><br><span class="line">    <span class="keyword">int</span> color = alpha &lt;&lt; <span class="number">24</span> | (scrimColor &amp; <span class="number">0xffffff</span>);</span><br><span class="line">    <span class="comment">// 设置绘制矩形区域</span></span><br><span class="line">    Rect rect;</span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, child.getLeft(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(child.getRight(), <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(color);</span><br><span class="line">    canvas.drawRect(rect, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mainView 、阴影、遮罩层的关系示意图如下：</p>
<p><img src="/uploads/20160707/20160707211516.png" alt="relatives_pic"></p>
<h1 id="onViewReleased"><a href="#onViewReleased" class="headerlink" title="onViewReleased"></a>onViewReleased</h1><p>看完了上面的两个方法的代码，最后就是当用户手指抬起时判断逻辑的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动返回，结束该View</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToFinish</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, finalLeft, finalTop)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onSwipeBackFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动回归到原位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToRestore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SwipeBackListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 该方法会在滑动返回完成的时候回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipeBackFinish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置滑动返回监听器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> listener</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwipeBackListener</span><span class="params">(SwipeBackListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的代码还是比较简单的，主要使用了 <code>smoothSlideViewTo(View view, int left, int top)</code> 的方法来滑动到指定位置。若是结束当前界面的话，回调监听器的接口。</p>
<p>啰嗦了这么多，我们来看看运行时的效果图吧：</p>
<p><img src="/uploads/20160707/20160707212521.gif" alt="SwipeBackDemo Screenshot"></p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>好了，SwipeBackLayout 大致的逻辑就是上面这样子的。整体来说还是比较通俗易懂的，而且对 ViewDragHelper 熟悉的人会发现，使用 ViewDragHelper 自定义一些 ViewGroup 的套路都是大同小异的。以后想要自定义一些 ViewGroup 都是得心应手了。</p>
<p>如果对此有疑问的话可以在下面留言。</p>
<p>最后，国际惯例，附上 SwipeBackLayout Demo 的源码：</p>
<p><a href="/uploads/20160707/SwipeBackDemo.rar">SwipeBackDemo.rar</a></p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CursorAdapter中的filter机制]]></title>
    <link href="http://yuqirong.me/2016/07/03/%E8%AF%A6%E8%A7%A3CursorAdapter%E4%B8%AD%E7%9A%84filter%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2016/07/03/详解CursorAdapter中的filter机制/</id>
    <published>2016-07-03T12:35:51.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天为什么讲 CursorAdapter 的原因，是因为之前在工作的时候有遇到 CursorAdapter 中 filter 的相关问题，于是就想把 CursorAdapter 中的 filter 机制流程好好梳理一下。出于这样的目的，本篇博文就诞生了。</p>
<p>在阅读本文之前，最好已经有写过 CursorAdapter 中 filter 相关代码的经历，这样可以帮助你更好地理解其中的原理。如果你准备好了，那么接下来就一起来看看吧。</p>
<h1 id="CursorAdapter__u7C7B"><a href="#CursorAdapter__u7C7B" class="headerlink" title="CursorAdapter 类"></a>CursorAdapter 类</h1><p>首先我们来看一下 CursorAdapter 的继承以及实现关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CursorAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">Filterable</span>, <span class="title">CursorFilter</span>.<span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CursorAdapter 继承自 BaseAdapter ，相信大家都可以理解。之后又实现了 Filterable 和 CursorFilter.CursorFilterClient 接口。</p>
<p>Filterable 的接口很简单，只有一个 <code>getFilter()</code> 方法，用来返回 filter 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Returns a filter that can be used to constrain data with a filtering</span><br><span class="line">     * pattern.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is usually implemented by &#123;<span class="doctag">@link</span> android.widget.Adapter&#125;</span><br><span class="line">     * classes.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> a filter used to constrain data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Filter <span class="title">getFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 CursorFilter.CursorFilterClient 的接口是定义在 CursorFilter 类里面的。而 CursorFilter 类是默认修饰符，也就是说我们在外部无法访问到它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line">    <span class="function">CharSequence <span class="title">convertToString</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 CursorFilterClient 接口中的抽象方法。根据方法名我们大概都能猜出该方法需要做的事情。 <code>convertToString(Cursor cursor)</code> 方法主要的功能就是根据传入的 cursor 参数返回某个字段；<code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法的意思就是根据传入的 constraint 字符序列去搜索得到 cursor；而 <code>getCursor()</code>就是返回 cursor；<code>changeCursor(Cursor cursor)</code> 就是根据传入的新的 cursor 去替换旧的 cursor 。</p>
<h1 id="filter__u7684_u7528_u6CD5"><a href="#filter__u7684_u7528_u6CD5" class="headerlink" title="filter 的用法"></a>filter 的用法</h1><p>好了，我们来想想平时我们是怎么样使用 CursorAdapter 中的 filter ？</p>
<p>第一步，我们会使用自定义的 adapter 继承自 CursorAdapter ，并且实现 FilterQueryProvider 和 FilterListener 接口。最后别忘了调用 <code>setFilterQueryProvider(FilterQueryProvider filterQueryProvider)</code> 方法。</p>
<p>然后，第二步我们会使用CursorAdapter的 <code>getFilter()</code> 方法来得到 filter 。对，没错，就是实现 Filterable 接口的那个 <code>getFilter</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">getFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCursorFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCursorFilter = <span class="keyword">new</span> CursorFilter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCursorFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CursorAdapter 的源码中，判断了 mCursorFilter 是否为空。若为空，则创建一个新的 CursorFilter 对象。否则直接返回 mCursorFilter 。在这里要说明一下 CursorFilter 是 Filter 的子类。</p>
<p>而在 CursorFilter 的构造器中，主要是设置了 client (CursorAdapter 实现了 CursorFilterClient 接口)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CursorFilter(CursorFilterClient client) &#123;</span><br><span class="line">    mClient = client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二步得到了 filter 之后，第三步就可以使用 <code>filter.filter(CharSequence constraint)</code> 或者 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法了。constraint 参数就是要过滤的关键词；而 FilterListener 是一个 Filter 类的内部接口，会在过滤完成之后回调其中的 <code>onFilterComplete(int count)</code> 方法。</p>
<h1 id="filter__u7684_u539F_u7406"><a href="#filter__u7684_u539F_u7406" class="headerlink" title="filter 的原理"></a>filter 的原理</h1><p>大致使用 filter 的步骤就是像上面这样的了。下面我们就来揭开这其中神秘的面纱吧！</p>
<p>我们的入手点就是 Filter 的 filter 方法了。其中的 <code>filter.filter(CharSequence constraint)</code> 方法内部会调用 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法。所以我们只需要看下<code>filter.filter(CharSequence constraint, FilterListener listener)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Starts an asynchronous filtering operation. Calling this method</span><br><span class="line"> * cancels all previous non-executed filtering requests and posts a new</span><br><span class="line"> * filtering request that will be executed later.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Upon completion, the listener is notified.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint used to filter the data</span><br><span class="line"> * <span class="doctag">@param</span> listener a listener notified upon completion of the operation</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #filter(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #performFiltering(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #publishResults(CharSequence, android.widget.Filter.FilterResults)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(CharSequence constraint, FilterListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HandlerThread thread = <span class="keyword">new</span> HandlerThread(</span><br><span class="line">                    THREAD_NAME, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            thread.start();</span><br><span class="line">            mThreadHandler = <span class="keyword">new</span> RequestHandler(thread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = (mDelayer == <span class="keyword">null</span>) ? <span class="number">0</span> : mDelayer.getPostingDelay(constraint);</span><br><span class="line">        </span><br><span class="line">        Message message = mThreadHandler.obtainMessage(FILTER_TOKEN);</span><br><span class="line"></span><br><span class="line">        RequestArguments args = <span class="keyword">new</span> RequestArguments();</span><br><span class="line">        <span class="comment">// make sure we use an immutable copy of the constraint, so that</span></span><br><span class="line">        <span class="comment">// it doesn't change while the filter operation is in progress</span></span><br><span class="line">        args.constraint = constraint != <span class="keyword">null</span> ? constraint.toString() : <span class="keyword">null</span>;</span><br><span class="line">        args.listener = listener;</span><br><span class="line">        message.obj = args;</span><br><span class="line"></span><br><span class="line">        mThreadHandler.removeMessages(FILTER_TOKEN);</span><br><span class="line">        mThreadHandler.removeMessages(FINISH_TOKEN);</span><br><span class="line">        mThreadHandler.sendMessageDelayed(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中我们可以看到，主要做的就是在一开始创建一个 HandlerThread 线程，并且创建了一个 RequestHandler 的对象 mThreadHandler 。之后创建了一个 RequestArguments 的对象 args，然后把 constraint 和 listener 传到 args 中去，而 RequestArguments 类还有一个成员变量就是 results ，主要用于存储 filter 过滤之后的结果，这会在下面的代码中用到。然后用 mThreadHandler 将该消息发送出去。</p>
<p>那么我们接下来就要来看看 RequestHandler 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Worker thread handler. When a new filtering request is posted from</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.Filter#filter(CharSequence, android.widget.Filter.FilterListener)&#125;,</span><br><span class="line"> * it is sent to this handler.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Handles filtering requests by calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#performFiltering&#125; and then sending a message</span><br><span class="line">     * with the results to the results handler.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering request</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> what = msg.what;</span><br><span class="line">        Message message;</span><br><span class="line">        <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> FILTER_TOKEN:</span><br><span class="line">                RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args.results = performFiltering(args.constraint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">                    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    message = mResultHandler.obtainMessage(what);</span><br><span class="line">                    message.obj = args;</span><br><span class="line">                    message.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Message finishMessage = mThreadHandler.obtainMessage(FINISH_TOKEN);</span><br><span class="line">                        mThreadHandler.sendMessageDelayed(finishMessage, <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINISH_TOKEN:</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mThreadHandler.getLooper().quit();</span><br><span class="line">                        mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 case FILTER_TOKEN 中我们可以看到，会先去调用 <code>performFiltering(CharSequence constraint)</code> 方法。而该方法在 Filter 类中是抽象方法，需要在子类中去实现。那么我们就来看看 CursorFilter 的 <code>performFiltering(CharSequence constraint)</code> 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FilterResults <span class="title">performFiltering</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = mClient.runQueryOnBackgroundThread(constraint);</span><br><span class="line"></span><br><span class="line">    FilterResults results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        results.count = cursor.getCount();</span><br><span class="line">        results.values = cursor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        results.count = <span class="number">0</span>;</span><br><span class="line">        results.values = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performFiltering(CharSequence constraint)</code> 方法中又会去调用  mClient 的 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，而 mClient 就是之前的 CursorAdapter ，所以我们又要跳到 CursorAdapter 类去看相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Runs a query with the specified constraint. This query is requested</span><br><span class="line"> * by the filter attached to this adapter.</span><br><span class="line"> *</span><br><span class="line"> * The query is provided by a</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.FilterQueryProvider&#125;.</span><br><span class="line"> * If no provider is specified, the current cursor is not filtered and returned.</span><br><span class="line"> *</span><br><span class="line"> * After this method returns the resulting cursor is passed to &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;</span><br><span class="line"> * and the previous cursor is closed.</span><br><span class="line"> *</span><br><span class="line"> * This method is always executed on a background thread, not on the</span><br><span class="line"> * application's main thread (or UI thread.)</span><br><span class="line"> * </span><br><span class="line"> * Contract: when constraint is null or empty, the original results,</span><br><span class="line"> * prior to any filtering, must be returned.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint with which the query must be filtered</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> a Cursor representing the results of the new query</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #getFilter()</span><br><span class="line"> * <span class="doctag">@see</span> #getFilterQueryProvider()</span><br><span class="line"> * <span class="doctag">@see</span> #setFilterQueryProvider(android.widget.FilterQueryProvider)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilterQueryProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFilterQueryProvider.runQuery(constraint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到会去调用 mFilterQueryProvider 的 <code>runQuery(CharSequence constraint)</code> 方法。 FilterQueryProvider 其实就是一个接口而已，当我们需要使用 filter 时就要实现该接口。在上面的 filter 用法中已经提到过了。其中的 <code>runQuery(CharSequence constraint)</code> 方法就是需要我们自己去实现的。当然，这里还有另外一种方法，就是不用实现 FilterQueryProvider 接口。而是在子类中去重写 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，也是达到了一样的效果。</p>
<p>假定我们已经在 <code>runQuery(CharSequence constraint)</code> 实现了相关的操作，并且返回了查询出来的 cursor 。那样我们又要跳回到 RequestHandler 的源码中了(这里只截取部分代码，完整代码请查看上面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    args.results = performFiltering(args.constraint);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    message = mResultHandler.obtainMessage(what);</span><br><span class="line">    message.obj = args;</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里把返回的 cursor 传给了 args.results 。并且又使用了 mResultHandler 发送了消息。这样我们又要来看一下 ResultHandler 的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Handles the results of a filtering operation. The results are</span><br><span class="line"> * handled in the UI thread.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultsHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Messages received from the request handler are processed in the</span><br><span class="line">     * UI thread. The processing involves calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#publishResults(CharSequence,</span><br><span class="line">     * android.widget.Filter.FilterResults)&#125;</span><br><span class="line">     * to post the results back in the UI and then notifying the listener,</span><br><span class="line">     * if any.&lt;/p&gt; </span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering results</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line"></span><br><span class="line">        publishResults(args.constraint, args.results);</span><br><span class="line">        <span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">            args.listener.onFilterComplete(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>handleMessage(Message msg)</code> 中，调用了 <code>publishResults(CharSequence constraint, FilterResults results)</code> 方法。在 Filter 类中 <code>publishResults(CharSequence constraint, FilterResults results)</code> 又是抽象的，所以还得去 CursorFilter 类中查看相关的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishResults</span><span class="params">(CharSequence constraint, FilterResults results)</span> </span>&#123;</span><br><span class="line">    Cursor oldCursor = mClient.getCursor();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (results.values != <span class="keyword">null</span> &amp;&amp; results.values != oldCursor) &#123;</span><br><span class="line">        mClient.changeCursor((Cursor) results.values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码里表示了会去调用 CursorAdapter 的 <code>changeCursor(Cursor cursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Change the underlying cursor to a new cursor. If there is an existing cursor it will be</span><br><span class="line"> * closed.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cursor The new cursor to be used</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span> </span>&#123;</span><br><span class="line">    Cursor old = swapCursor(cursor);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        old.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>changeCursor(Cursor cursor)</code> 中，又调用了 <code>swapCursor(Cursor newCursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Swap in a new Cursor, returning the old Cursor.  Unlike</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;, the returned old Cursor is &lt;em&gt;not&lt;/em&gt;</span><br><span class="line"> * closed.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> newCursor The new cursor to be used.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the previously set Cursor, or null if there wasa not one.</span><br><span class="line"> * If the given new Cursor is the same instance is the previously set</span><br><span class="line"> * Cursor, null is also returned.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">swapCursor</span><span class="params">(Cursor newCursor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newCursor == mCursor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor oldCursor = mCursor;</span><br><span class="line">    <span class="keyword">if</span> (oldCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) oldCursor.unregisterContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) oldCursor.unregisterDataSetObserver(mDataSetObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    mCursor = newCursor;</span><br><span class="line">    <span class="keyword">if</span> (newCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) newCursor.registerContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) newCursor.registerDataSetObserver(mDataSetObserver);</span><br><span class="line">        mRowIDColumn = newCursor.getColumnIndexOrThrow(<span class="string">"_id"</span>);</span><br><span class="line">        mDataValid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the new cursor</span></span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRowIDColumn = -<span class="number">1</span>;</span><br><span class="line">        mDataValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the lack of a data set</span></span><br><span class="line">        notifyDataSetInvalidated();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>swapCursor(Cursor newCursor)</code> 中主要的工作就是把 oldCursor 替换成 newCursor ，并且调用了 <code>notifyDataSetChanged();</code> 来更新 ListView 。从上面的源码中还可以看到， <code>swapCursor(Cursor newCursor)</code> 方法中返回的 oldCursor 是没有关闭的。</p>
<p>完成了替换 Cursor 的工作后，我们还要回过头来看看 ResultsHandler 剩余部分的代码(只截取了部分代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">    args.listener.onFilterComplete(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在最后回调了 FilterListener 的 <code>onFilterComplete(int count)</code> 方法。其中的 count 参数是查询出来结果的总数。</p>
<p>至此，一个完整的 filter 流程终于走完了。这其中虽然看似很绕，其实原理还是比较简单的。</p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>看完上面分析，相信大家对 CursorAdapter 的 filter 机制已经有了一个大致的了解了吧。主要原理基本上还是 Handler 异步消息机制以及各个接口回调等。从中可以发现其实源码并不难，只要有耐心慢慢分析，一定会有所突破的。如果对这整个流程有问题的童鞋可以在下面留言。</p>
<p>那么，今天就到这了。Goodbye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Pro Git》笔记]]></title>
    <link href="http://yuqirong.me/2016/06/18/%E3%80%8APro%20Git%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/06/18/《Pro Git》笔记/</id>
    <published>2016-06-17T16:29:14.000Z</published>
    <updated>2016-08-18T15:09:33.879Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E"><a href="#1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E" class="headerlink" title="1.5 初次运行 Git 前的配置"></a>1.5 初次运行 Git 前的配置</h2><ul>
<li><p>Git 配置用户名：</p>
<p>  git config –global user.name “yuqirong”</p>
</li>
<li><p>Git 配置电子邮箱：</p>
<p>  git config –global user.email “yuqirong@myhexin.com”</p>
</li>
<li><p>查看 Git 配置情况：</p>
<p>  git config –list</p>
</li>
<li><p>设置默认使用的文本编辑器：</p>
<p>  git config –global core.editor emacs</p>
</li>
<li><p>设置默认使用的差异分析工具</p>
<p>  git config –global merge.tool vimdiff</p>
</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_Git__u57FA_u7840"><a href="#u7B2C_u4E8C_u7AE0_Git__u57FA_u7840" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h1><h2 id="2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93"><a href="#2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93" class="headerlink" title="2.1 取得项目的 Git 仓库"></a>2.1 取得项目的 Git 仓库</h2><ul>
<li><p>对某个项目进行 Git 管理：</p>
<p>  git init</p>
</li>
<li><p>对某个仓库进行克隆：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“</p>
</li>
<li><p>或者对克隆下来的仓库进行改名：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“ yuqirong</p>
</li>
<li><p>Git 添加某个文件：</p>
<p>  git add src/com/yuqirong/Test/a.java</p>
</li>
</ul>
<h2 id="2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93"><a href="#2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h2><ul>
<li><p>检查当前文件状态：</p>
<p>  git status</p>
</li>
<li><p>查看已暂存的更新：</p>
<p>  git diff –cached</p>
</li>
<li><p>查看未暂存的更新：</p>
<p>  git diff</p>
</li>
<li><p>提交更新：</p>
<p>  git commit<br>  或<br>  git commit -m “add new file”</p>
</li>
<li><p>跳过使用暂存区域的提交更新：</p>
<p>  git commit -a -m “add new file”</p>
</li>
<li><p>移除文件：</p>
<p>  git rm abc.txt</p>
</li>
<li><p>强制移除文件：</p>
<p>  git rm -f abc.txt</p>
</li>
<li><p>文件保存在当前目录中但从跟踪清单中移除：</p>
<p>  git rm –cached abc.txt</p>
</li>
<li><p>移动文件：</p>
<p>  git mv file_from file_to</p>
</li>
</ul>
<h2 id="2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="2.3 查看提交历史"></a>2.3 查看提交历史</h2><ul>
<li><p>查看提交历史：</p>
<p>  git log</p>
</li>
<li><p>查看提交历史中每次提交的内容差异：</p>
<p>  git log -patch</p>
</li>
<li><p>查看提交历史但仅显示简要的增改行数统计：</p>
<p>  git log –stat</p>
</li>
<li><p>查看提交历史并限制输出长度：</p>
<p>  git log -2<br>  或<br>  git log –since=2.weeks</p>
</li>
</ul>
<h2 id="2-4__u64A4_u6D88_u64CD_u4F5C"><a href="#2-4__u64A4_u6D88_u64CD_u4F5C" class="headerlink" title="2.4 撤消操作"></a>2.4 撤消操作</h2><ul>
<li><p>修改最后一次提交：</p>
<p>  git commit –amend</p>
</li>
<li><p>取消已经暂存的文件：</p>
<p>  git reset HEAD abc.txt</p>
</li>
<li><p>取消对文件的修改：</p>
<p>  git checkout – abc.txt (ps:该命令对已经add的文件无效)</p>
</li>
</ul>
<h2 id="2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528"><a href="#2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528" class="headerlink" title="2.5 远程仓库的使用"></a>2.5 远程仓库的使用</h2><ul>
<li><p>查看当前的远程库：</p>
<p>  git remote</p>
</li>
<li><p>查看当前远程库对应的克隆地址：</p>
<p>  git remote -v</p>
</li>
<li><p>添加远程仓库：</p>
<p>  git remote add [short-name] [url]</p>
</li>
<li><p>从远程仓库抓取数据：</p>
<p>  git fetch [remote-name] (fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。)</p>
</li>
<li><p>从远程仓库抓取数据，自动合并到本地仓库中：</p>
<p>  git pull [remote-name]</p>
</li>
<li><p>推送数据到远程仓库中：</p>
<p>  git push [remote-name] [branch-name]</p>
</li>
<li><p>查看远程仓库信息:</p>
<p>  git remote show [remote-name]</p>
</li>
<li><p>远程仓库的重命名:</p>
<p>  git remote rename [old-name] [new-name]</p>
</li>
<li><p>远程仓库的删除:</p>
<p>  git remote rm [remote-name]</p>
</li>
</ul>
<h2 id="2-6__u6253_u6807_u7B7E"><a href="#2-6__u6253_u6807_u7B7E" class="headerlink" title="2.6 打标签"></a>2.6 打标签</h2><ul>
<li><p>列出现有的标签：</p>
<p>  git tag</p>
</li>
<li><p>新建标签：</p>
<p>  git tag -a v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>查看相应标签的版本信息：</p>
<p>  git show v1.0</p>
</li>
<li><p>签署标签：</p>
<p>  git tag -s v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>轻量级标签：</p>
<p>  git tag v1.0</p>
</li>
<li><p>验证标签：</p>
<p>  git tag -v [tag-name]</p>
</li>
<li><p>分享标签:</p>
<p>  git push origin v1.0</p>
</li>
<li><p>推送所有的标签：</p>
<p>  git push origin –tags</p>
</li>
</ul>
<h2 id="2-7__u6280_u5DE7_u548C_u7A8D_u95E8"><a href="#2-7__u6280_u5DE7_u548C_u7A8D_u95E8" class="headerlink" title="2.7 技巧和窍门"></a>2.7 技巧和窍门</h2><ul>
<li><p>设置 Git 命令别名：</p>
<p>  git config –global alias.co checkout</p>
</li>
</ul>
<h1 id="u7B2C_u4E09_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E09_u7AE0__u8D77_u6B65" class="headerlink" title="第三章 起步"></a>第三章 起步</h1><h2 id="3-1__u4F55_u8C13_u5206_u652F"><a href="#3-1__u4F55_u8C13_u5206_u652F" class="headerlink" title="3.1 何谓分支"></a>3.1 何谓分支</h2><ul>
<li><p>创建一个新的分支：</p>
<p>  git branch [branch-name]</p>
</li>
<li><p>克隆一个远程服务器上的分支：</p>
<p>  git clone -b [branch-name] [remote-url]</p>
</li>
<li><p>切换分支：</p>
<p>  git checkout [branch-name]</p>
</li>
</ul>
<h2 id="3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76"><a href="#3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76" class="headerlink" title="3.2 基本的分支与合并"></a>3.2 基本的分支与合并</h2><ul>
<li><p>新建一个分支并切换到该分支上：</p>
<p>  git checkout -b [branch-name]</p>
</li>
<li><p>合并分支：</p>
<p>  git merge [branch-name]</p>
</li>
<li><p>删除分支：</p>
<p>  git branch -d [branch-name]</p>
</li>
<li><p>调用可视化的合并工具来解决冲突：</p>
<p>  git mergetool</p>
</li>
</ul>
<h2 id="3-3__u5206_u652F_u7BA1_u7406"><a href="#3-3__u5206_u652F_u7BA1_u7406" class="headerlink" title="3.3 分支管理"></a>3.3 分支管理</h2><ul>
<li><p>列出所有分支：</p>
<p>  git branch</p>
</li>
<li><p>查看分支最后一次 commit 信息：</p>
<p>  git branch -v</p>
</li>
<li><p>查看哪些分支已经被并入：</p>
<p>  git branch –merged</p>
</li>
<li><p>查看哪些分支没有被并入：</p>
<p>  git branch –no-merged</p>
</li>
</ul>
<h2 id="3-5__u8FDC_u7A0B_u5206_u652F"><a href="#3-5__u8FDC_u7A0B_u5206_u652F" class="headerlink" title="3.5 远程分支"></a>3.5 远程分支</h2><ul>
<li><p>跟踪分支</p>
<p>  git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</p>
</li>
<li><p>删除远程分支：</p>
<p>  git push [remote-name] :[remote-branch-name]</p>
</li>
</ul>
<h2 id="3-6__u884D_u5408"><a href="#3-6__u884D_u5408" class="headerlink" title="3.6 衍合"></a>3.6 衍合</h2><ul>
<li><p>衍合分支：</p>
<p>  git rebase [branch-name]</p>
</li>
</ul>
<h1 id="u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git"><a href="#u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git" class="headerlink" title="第4章 服务器上的 Git"></a>第4章 服务器上的 Git </h1><h1 id="u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git"><a href="#u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git" class="headerlink" title="第5章 分布式 Git"></a>第5章 分布式 Git</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1]]>
    </summary>
    
      <category term="Git" scheme="http://yuqirong.me/tags/Git/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android 6.0的运行时权限处理]]></title>
    <link href="http://yuqirong.me/2016/06/08/%E5%85%B3%E4%BA%8EAndroid%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2016/06/08/关于Android M的运行权限处理/</id>
    <published>2016-06-08T14:12:20.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问题的原因大家都知道，是 Android 6.0 新引入了在运行时权限申请(Runtime Permissions)的功能。那么这所谓的运行时申请权限究竟是怎么一回事呢，一起来看看吧！</p>
<p>在 Android 6.0 中，app 如果想要获得某些权限，会在应用中弹出一个对话框，让用户确认是否授予该权限。具体的截图如下：</p>
<p><img src="/uploads/20160608/20160608161439.png" alt="Runtime Permissions screenshot"></p>
<p>这要做的好处就是运行一个 app 时可以拒绝其中的某些权限，防止 app 触及到你的隐私(比如说通讯录、短信之类的)。而在 Android 6.0 之前，若同意安装 app ，就意味着该 app 可以获取权限列表中的所有权限。(注：这里所指的都是原生 Android 系统，比如 MIUI 之类的第三方 ROM 很早就具备了这种功能。)</p>
<p>接下来就来看看相关的 API 吧，首先我们来看看 <code>Context.checkSelfPermission(String permission)</code> 方法，该方法主要用于检测该 app 是否已经被赋予了某权限，传入的参数有。如果已被赋予，则返回 <code>PERMISSION_GRANTED</code> ，否则返回 <code>PERMISSION_DENIED</code> 。</p>
<p>若返回了 <code>PERMISSION_DENIED</code> ，那么我们就要去申请该权限了。这时就要用到  <code>Activity.requestPermissions(String[] permissions, int requestCode)</code> 这个方法了。顾名思义，该方法的作用就是申请某些权限了。第一个参数就是要申请的权限，可以看到参数形式是一个数组，也就是说可以一次申请多个权限。而第二个参数就是申请权限的代号，主要用于在之后的回调中选择。</p>
<p>当用户在权限申请的对话框中作出选择后，就会回调 <code>onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)</code> 方法。第一个参数就是上面的权限代号；第二个参数是申请的权限数组；第三个参数就是权限申请的结果。</p>
<p>结合上面的几个方法，可以写出如下所示的权限申请代码模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_CONTACTS_REQUEST_CODE = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果权限没有被授予</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.READ_CONTACTS) !=</span><br><span class="line">        PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 申请权限</span></span><br><span class="line">    ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;, READ_CONTACTS_REQUEST_CODE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 权限已经被授予</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> READ_CONTACTS_REQUEST_CODE:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// TODO 用户已经授予了权限</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// TODO 用户拒绝授予权限</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，还有一个方法需要注意下，那就是 <code>shouldShowRequestPermissionRationale (Activity activity, String permission)</code> 方法。这个方法的作用就是当用户拒绝了某个权限之后，下一次就会显示出需要该权限的说明。</p>
<p>关于运行时申请权限基本就这样了，值得提醒的是，并不是所有的权限都需要运行时申请，只有“危险”的权限才通过运行时来申请。比如说读取联系人、获取位置信息、读写SD卡等等都为“危险权限”，而比如振动、联网、蓝牙等就是普通权限了，就不需要运行时申请了。</p>
<p>说完了运行时申请权限后，另外还有一点需要注意的是，在 Android 6.0 显示悬浮窗也有一个“坑”。如果调用平常的显示悬浮窗的方法，会抛出 “permission denied for this window type” 异常。解决的方案就是在显示悬浮窗之前，需要调用一下 <code>Settings.canDrawOverlays(context)</code> 这个方法。若该方法返回 true ，则说明用户同意创建悬浮窗；否则可以跳转到相关的设置页面。具体的代码模版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Settings.canDrawOverlays(context)) &#123;</span><br><span class="line">        <span class="comment">// 显示悬浮窗</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 跳转到相关的设置页面</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 版本低于Android 6.0，直接显示悬浮窗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，就到这里吧。</p>
<p>GoodBye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易实现Android九宫格解锁]]></title>
    <link href="http://yuqirong.me/2016/05/10/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Android%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/"/>
    <id>http://yuqirong.me/2016/05/10/简易实现Android九宫格解锁/</id>
    <published>2016-05-10T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等。因为九宫格可以保护用户的隐私，所以它的应用面很广泛。那么今天我们就来自定义一个属于自己的九宫格吧！</p>
<p>首先我们来分析一下实现九宫格解锁的思路：当用户的手指触摸到某一个点时，先判断该点是否在九宫格的某一格范围之内，若在范围内，则该格变成选中的状态；之后用户手指滑动的时候，以该格的圆心为中心，用户手指为终点，两点连线。最后当用户手指抬起时，判断划过的九宫格密码是否和原先的密码匹配。</p>
<p>大致的思路流程就是上面这样的了，下面我们可以来实践一下。</p>
<h1 id="Point__u7C7B"><a href="#Point__u7C7B" class="headerlink" title="Point 类"></a>Point 类</h1><p>我们先来创建一个 <code>Point</code> 类，用来表示九宫格锁的九个格子。除了坐标 <code>x</code> ，<code>y</code> 之外，还有三种模式：正常模式、按下模式和错误模式。根据模式不同该格子的颜色会有所不同，这会在下面中说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> y;</span><br><span class="line">    <span class="comment">// 正常模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按下模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRESSED_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 错误模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = NORMAL_MODE;</span><br><span class="line">    <span class="comment">// 表示该格的密码，比如“1”、“2”等</span></span><br><span class="line">    <span class="keyword">private</span> String mark;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMark</span><span class="params">(String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RotateDegrees_u7C7B"><a href="#RotateDegrees_u7C7B" class="headerlink" title="RotateDegrees类"></a>RotateDegrees类</h1><p>有了上面的 <code>Point</code> 类之后，我们还要创建一个 <code>RotateDegrees</code> 类，主要作用是计算两个 <code>Point</code> 坐标之间的角度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RotateDegrees &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的point计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> degrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> aX = a.getX();</span><br><span class="line">        <span class="keyword">float</span> aY = a.getY();</span><br><span class="line">        <span class="keyword">float</span> bX = b.getX();</span><br><span class="line">        <span class="keyword">float</span> bY = b.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aX == bX) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aY &lt; bY) &#123;</span><br><span class="line">                degrees = <span class="number">90</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">270</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bY == aY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &lt; bX) &#123;</span><br><span class="line">                degrees = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &gt; bX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第三象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> + (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第四象限</span></span><br><span class="line">                    degrees = <span class="number">360</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一象限</span></span><br><span class="line">                    degrees = (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据point和(x,y)计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param bX</span><br><span class="line">     * @param bY</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, <span class="keyword">float</span> bX, <span class="keyword">float</span> bY)</span> </span>&#123;</span><br><span class="line">        Point b = <span class="keyword">new</span> Point(bX, bY, null);</span><br><span class="line">        <span class="keyword">return</span> getDegrees(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ScreenLockView__u7C7B"><a href="#ScreenLockView__u7C7B" class="headerlink" title="ScreenLockView 类"></a>ScreenLockView 类</h1><p>然后我们要先准备好关于九宫格的几张图片，比如在九宫格的格子中，<code>NORMAL_MODE</code> 模式下是蓝色的，被手指按住时九宫格的格子是绿色的，也就是对应着上面 Point 类的中 <code>PRESSED_MODE</code> 模式，还有 <code>ERROR_MODE</code> 模式下是红色的。另外还有圆点之间的连线，也是根据模式不同颜色也会不同。在这里我就不把图片贴出来了，想要的童鞋可以下载源码从中获取。</p>
<p>有了图片资源之后，我们要做的就是先在构造器中加载图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ScreenLockView"</span>;</span><br><span class="line">    <span class="comment">// 错误格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap errorBitmap;</span><br><span class="line">    <span class="comment">// 正常格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap normalBitmap;</span><br><span class="line">    <span class="comment">// 手指按下时格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap pressedBitmap;</span><br><span class="line">    <span class="comment">// 错误时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap lineErrorBitmap;</span><br><span class="line">    <span class="comment">// 手指按住时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap linePressedBitmap;</span><br><span class="line">    <span class="comment">// 偏移量，使九宫格在屏幕中央</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// 九宫格的九个格子是否已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init;</span><br><span class="line">    <span class="comment">// 格子的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="comment">// 九个格子</span></span><br><span class="line">    <span class="keyword">private</span> Point[][] points = <span class="keyword">new</span> Point[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveY = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手指在移动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isMove;</span><br><span class="line">    <span class="comment">// 是否可以触摸，当用户抬起手指，划出九宫格的密码不正确时为不可触摸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用来存储记录被按下的点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; pressedPoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 屏幕解锁监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnScreenLockListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        errorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_error);</span><br><span class="line">        normalBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_normal);</span><br><span class="line">        pressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_pressed);</span><br><span class="line">        lineErrorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_error);</span><br><span class="line">        linePressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_pressed);</span><br><span class="line">        radius = normalBitmap.getWidth() / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中我们主要就是把图片加载完成，并且得到了格子的半径，即图片宽度的一半。</p>
<p>之后我们来看看 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSize &gt; heightSize) &#123;</span><br><span class="line">        offset = (widthSize - heightSize) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        offset = (heightSize - widthSize) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法中，主要得到对应的偏移量，以便在下面的 <code>onDraw(Canvas canvas)</code> 把九宫格绘制在屏幕中央。</p>
<p>下面就是 <code>onDraw(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        width = getWidth();</span><br><span class="line">        height = getHeight();</span><br><span class="line">        initPoint();</span><br><span class="line">        init = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画九宫格的格子</span></span><br><span class="line">    drawPoint(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moveX != -<span class="number">1</span> &amp;&amp; moveY != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 画直线</span></span><br><span class="line">        drawLine(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断了是否为第一次调用 <code>onDraw(Canvas canvas)</code> 方法，若为第一次则对 points 进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"0"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">4</span>, <span class="string">"1"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"3"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">2</span>, <span class="string">"4"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">2</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"6"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"7"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initPoint()</code> 方法中主要创建了九个格子，并设置了相应的位置和密码。初始化完成之后把 init 置为 false ,下次不会再调用。</p>
<p>回过头再看看 <code>onDraw(Canvas canvas)</code> 中其他的逻辑，接下来调用了 <code>drawPoint(canvas)</code> 来绘制格子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画九宫格的格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> state = points[i][j].getState();</span><br><span class="line">            <span class="keyword">if</span> (state == Point.NORMAL_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(normalBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == Point.PRESSED_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(pressedBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.drawBitmap(errorBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绘制格子还是很简单的，主要分为了三种：普通模式下的格子、按下模式下的格子以及错误模式下的格子。</p>
<h1 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h1><p>在绘制好了格子之后，我们先不看最后的 <code>drawLine(canvas)</code> 方法，因为绘制直线是和用户手指的触摸事件息息相关的，所以我们先把目光转向 <code>onTouchEvent(MotionEvent event)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 判断用户触摸的点是否在九宫格的任意一个格子之内</span></span><br><span class="line">                point = isPoint(x, y);</span><br><span class="line">                <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    point.setState(Point.PRESSED_MODE);  <span class="comment">// 切换为按下模式</span></span><br><span class="line">                    pressedPoint.add(point);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (pressedPoint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    point = isPoint(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!crossPoint(point)) &#123;</span><br><span class="line">                            point.setState(Point.PRESSED_MODE);</span><br><span class="line">                            pressedPoint.add(point);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveX = x;</span><br><span class="line">                    moveY = y;</span><br><span class="line">                    isMove = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                isMove = <span class="keyword">false</span>;</span><br><span class="line">                String tempPwd = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                    tempPwd += p.getMark();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.getStringPassword(tempPwd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tempPwd.equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                        p.setState(Point.ERROR_MODE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    isTouch = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.postDelayed(runnable, <span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScreenLockListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStringPassword</span><span class="params">(String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPassword</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScreenLockListener</span><span class="params">(OnScreenLockListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MotionEvent.ACTION_DOWN</code> 中，先在 <code>isPoint(float x, float y)</code> 方法内判断了用户触摸事件的坐标点是否在九宫格的任意一格之内。如果是，则需要把该九宫格的格子添加到 <code>pressedPoint</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该触摸点是否为格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">isPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            point = points[i][j];</span><br><span class="line">            <span class="keyword">if</span> (isContain(point, x, y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该点(x，y)是否被包含</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Point point, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该点的(x,y)与格子圆心的距离若小于半径就是被包含了</span></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x - point.getX(), <span class="number">2f</span>) + Math.pow(y - point.getY(), <span class="number">2f</span>)) &lt;= radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是要看 <code>MotionEvent.ACTION_MOVE</code> 的逻辑了。一开始判断了用户触摸的点是否为九宫格的某个格子。但是比 <code>MotionEvent.ACTION_DOWN</code> 还多了一个步骤：若用户触摸了某个格子，还要判断该格子是否已经被包含在 <code>pressedPoint</code> 里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否该格子已经被包含在pressedPoint里面了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">crossPoint</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pressedPoint.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看 <code>MotionEvent.ACTION_UP</code> ，把 <code>pressedPoint</code> 里保存的格子遍历后得到用户划出的密码，再和预先设置的密码比较，若相同则回调 <code>OnScreenLockListener</code> 监听器；不相同则把 <code>pressedPoint</code> 中的所有格子的模式设置为错误模式，并在 <code>runnable</code> 中调用 <code>reset()</code> 清空 <code>pressedPoint</code> ，重绘视图，再回调监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isTouch = <span class="keyword">true</span>;</span><br><span class="line">        reset();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            points[i][j].setState(Point.NORMAL_MODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pressedPoint.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们回过头来看看之前在 <code>onDraw(Canvas canvas)</code> 里面的 <code>drawLine(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画直线</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pressedPoint中的所有格子依次遍历，互相连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pressedPoint.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 得到当前格子</span></span><br><span class="line">        Point point = pressedPoint.get(i);</span><br><span class="line">        <span class="comment">// 得到下一个格子</span></span><br><span class="line">        Point nextPoint = pressedPoint.get(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 旋转画布</span></span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        <span class="comment">// 根据距离设置拉伸的长度</span></span><br><span class="line">        matrix.setScale(getDistance(point, nextPoint) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 进行平移</span></span><br><span class="line">        matrix.postTranslate(point.getX(), point.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point.getState() == Point.PRESSED_MODE) &#123;</span><br><span class="line">            canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.drawBitmap(lineErrorBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把画布旋转回来</span></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是手指在移动的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">        Point lastPoint = pressedPoint.get(pressedPoint.size() - <span class="number">1</span>);</span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        Log.i(TAG, <span class="string">"the distance : "</span> + getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth());</span><br><span class="line">        matrix.setScale(getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        matrix.postTranslate(lastPoint.getX(), lastPoint.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line">        canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据point和坐标点计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, <span class="keyword">float</span> moveX, <span class="keyword">float</span> moveY)</span> </span>&#123;</span><br><span class="line">    Point b = <span class="keyword">new</span> Point(moveX,moveY,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> getDistance(point,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个point计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, Point nextPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) Math.sqrt(Math.pow(nextPoint.getX() - point.getX(), <span class="number">2f</span>) + Math.pow(nextPoint.getY() - point.getY(), <span class="number">2f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawLine(Canvas canvas)</code> 整体的逻辑并不复杂，首先将 <code>pressedPoint</code> 中的所有格子依次遍历，将它们连线。之后若是用户的手指还有滑动的话，把最后一个格子和用户手指触摸的点连线。</p>
<h1 id="u6587_u672B"><a href="#u6587_u672B" class="headerlink" title="文末"></a>文末</h1><p><code>ScreenLockView</code> 中的代码差不多就是这些了，既然讲解完了那就一起来看看效果吧：</p>
<p><img src="/uploads/20160510/20160510151253.gif" alt="ScreenShot"></p>
<p>效果还算不错吧，当然你也可以自己设置喜欢的九宫格图片，只要替换一下就可以了。如果对本篇文章有问题，可以留言。</p>
<p>老规矩，附上源码下载链接：</p>
<p><a href="/uploads/20160510/ScreenLockView.rar">ScreenLockView.rar</a></p>
<p>Goodbye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现ViewPager指示器]]></title>
    <link href="http://yuqirong.me/2016/04/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8/"/>
    <id>http://yuqirong.me/2016/04/27/自定义实现ViewPager指示器/</id>
    <published>2016-04-27T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="external">ViewPagerIndicator</a> ，到现在 Material Design 中的 TabLayout 。GitHub 上还有其他形形色色的指示器。那么肯定有人会问：既然有了这么多的指示器可以用，那为什么还要自己自定义呢？其实，我们学习了自定义指示器之后，可以知道 ViewPager 指示器的原理，还可以提高我们代码的水平哦！那还等什么，一起来学习吧。</p>
<p>首先放上一张效果图，亮亮眼：</p>
<p><img src="/uploads/20160427/20160427152924.gif" alt="这里写图片描述"></p>
<p>接下来我们来大致地分析一下思路： ViewPager 指示器我们可以看作是一个横向的 LinearLayout ，相对应的 Tab 可以直接使用 TextView 来实现。而 LinearLayout 中有许多个 TextView ，当我们点击其中的 TextView 时， ViewPager 就切换到对应的 item 上。而当我们手动滑动 ViewPager 时，根据 OnPageChangeListener 来动态地改变指示器。好了，基本上思路就是这样了，下面就来看看代码了。</p>
<p>自定义的属性 attrs.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ViewPagerIndicator"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab可见的数量 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"visible_tab_num"</span> <span class="attribute">format</span>=<span class="value">"integer"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab未选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"unselected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab中字体的大小 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时横线的高度 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"indicator_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义的属性基本上就以上几种，如果自己有其他的需求，可以另外添加。</p>
<p>之后我们就创建一个类，名字就叫 ViewPagerIndicator 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPagerIndicator</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab可见数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visibleTabNum;</span><br><span class="line">    <span class="comment">// 选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectedColor;</span><br><span class="line">    <span class="comment">// 未选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unselectedColor;</span><br><span class="line">    <span class="comment">// 屏幕宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> screenWidth;</span><br><span class="line">    <span class="comment">// tab的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tabWidth;</span><br><span class="line">    <span class="comment">// 横线的偏移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> offset;</span><br><span class="line">    <span class="comment">// 画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">// 横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> indicatorHeight;</span><br><span class="line">    <span class="comment">// 默认横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultIndicatorHeight;</span><br><span class="line">    <span class="comment">// viewpager当前页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentItem;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> textSize;</span><br><span class="line">    <span class="comment">// 默认字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultTextSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager mViewPager;</span><br><span class="line">    <span class="comment">// 滑动的最小距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> touchSlop;</span><br><span class="line">    <span class="comment">// 上次触摸的x轴坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewPagerIndicator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="comment">// 设置横向</span></span><br><span class="line">        setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewPagerIndicator);</span><br><span class="line">        selectedColor = a.getColor(R.styleable.ViewPagerIndicator_selected_color, Color.BLUE);</span><br><span class="line">        unselectedColor = a.getColor(R.styleable.ViewPagerIndicator_unselected_color, Color.WHITE);</span><br><span class="line">        visibleTabNum = a.getInt(R.styleable.ViewPagerIndicator_visible_tab_num, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认字体大小</span></span><br><span class="line">        defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="number">10</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        textSize = a.getDimension(R.styleable.ViewPagerIndicator_text_size, defaultTextSize);</span><br><span class="line">        <span class="comment">// 默认下划横线高度</span></span><br><span class="line">        defaultIndicatorHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">4</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        indicatorHeight = a.getDimension(R.styleable.ViewPagerIndicator_indicator_height, defaultIndicatorHeight);</span><br><span class="line">        a.recycle();</span><br><span class="line">        screenWidth = context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">        tabWidth = screenWidth / visibleTabNum;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(selectedColor);</span><br><span class="line">        mPaint.setStrokeWidth(indicatorHeight);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">// 得到touchSlop</span></span><br><span class="line">        touchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要是初始化了自定义属性，还有得到了 tabWidth 以便后面使用。</p>
<p>当然，如果用户旋转了屏幕，那么 tabWidth 是会改变的。所以我们应该在 <code>onSizeChanged</code> 里重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 当大小改变时，得到一个tab的宽度</span></span><br><span class="line">    tabWidth = w / visibleTabNum;</span><br><span class="line">    height = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论是横屏还是竖屏，在屏幕上可见的 Tab 数量永远是固定的(即 visibleTabNum 的值)。之后，我们先来“画”出 Tab 被选中时底下的那条横线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">// 绘制横线</span></span><br><span class="line">        canvas.drawLine(offset, height - indicatorHeight, offset + tabWidth, height - indicatorHeight, mPaint);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置offset</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOffset</span><span class="params">(<span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mViewPager 的赋值是在<code>setViewPager(ViewPager viewPager)</code>方法中完成的，这个方法放在下面去讲。而其中的 offset 是偏移量。当用户滑动切换 ViewPager 时，Tab 底下的横线应该也要做相应的位移，而这就是由 offset 来完成的。调用 <code>setOffset(float offset)</code> 方法，可以引起视图重绘。另外横线的高度 indicatorHeight 可以由用户自定义的，这里的代码还是比较简单的，相信大家都可以看懂的。</p>
<p>到这就来讲讲 setViewPager 方法了。当我们想要把 ViewPager 和 ViewPagerIndicator 关联起来时，可以给外部设置一个 <code>setViewPager(ViewPager viewPager)</code> 方法，那下面就是该方法的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置ViewPager， 请确保在设置了adapter之后调用该方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> viewPager</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewPager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mViewPager = viewPager;</span><br><span class="line">    <span class="comment">// 得到适配器</span></span><br><span class="line">    PagerAdapter adapter = viewPager.getAdapter();</span><br><span class="line">    <span class="comment">// adapter不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the adapter of viewpager must be not null.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先移除所有的子view</span></span><br><span class="line">    <span class="keyword">this</span>.removeAllViews();</span><br><span class="line">    <span class="comment">// 添加Textview</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapter.getCount(); i++) &#123;</span><br><span class="line">        createTextView(adapter.getPageTitle(i).toString(), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurrentItem = viewPager.getCurrentItem();</span><br><span class="line">    ((TextView) getChildAt(mCurrentItem)).setTextColor(selectedColor);</span><br><span class="line">    viewPager.addOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置了横线的偏移，并引起重绘</span></span><br><span class="line">            setOffset((position + positionOffset) * tabWidth);</span><br><span class="line">            <span class="comment">// tab也要进行相应的移动，若当前的tab是倒数第二个，则不移动。</span></span><br><span class="line">            <span class="keyword">if</span> (position + positionOffset + <span class="number">1</span> &gt; visibleTabNum - <span class="number">1</span> &amp;&amp; position + positionOffset + <span class="number">1</span> &lt;= getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">                scrollTo((<span class="keyword">int</span>) ((position + positionOffset - visibleTabNum + <span class="number">2</span>) * tabWidth), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 字体颜色改变</span></span><br><span class="line">            ((TextView) getChildAt(mCurrentItem)).setTextColor(unselectedColor);</span><br><span class="line">            ((TextView) getChildAt(position)).setTextColor(selectedColor);</span><br><span class="line">            mCurrentItem = position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法内部可以看出，我们要得到 ViewPager 的 adapter 。如果 adapter 为空则抛出异常。之后根据 adapter 的 count 数量去创建相对应的 TextView 作为 Tab 。下面为 <code>createTextView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加textview到ViewPagerIndicator中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTextView</span><span class="params">(String title, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">    LinearLayout.LayoutParams params = <span class="keyword">new</span> LayoutParams(tabWidth, LayoutParams.MATCH_PARENT);</span><br><span class="line">    tv.setLayoutParams(params);</span><br><span class="line">    tv.setText(title);</span><br><span class="line">    tv.setGravity(Gravity.CENTER);</span><br><span class="line">    tv.setTextColor(unselectedColor);</span><br><span class="line">    tv.setTag(i);</span><br><span class="line">    tv.setTextSize(textSize);</span><br><span class="line">    tv.setOnClickListener(tvClickListener);</span><br><span class="line">    <span class="keyword">this</span>.addView(tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// textview的点击监听器</span></span><br><span class="line">OnClickListener tvClickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewPager.setCurrentItem(i, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>createTextView</code> 方法中，使用了addView 来动态地添加 Tab 。这里有一处比较巧妙的地方：我们把当前 TextView 的索引 i 存储到了 Tag 中。而当用户点击 Tab 时，在监听器中我们取出那个 Tag 值，这样就知道了用户点击的是哪个 Tab 了，并且让 ViewPager 切换到那个页面下。</p>
<p>好了，我们再回过头继续看之前的 <code>setViewPager(ViewPager viewPager)</code> 方法，我们看到给 viewPager 设置了 OnPageChangeListener 。在 OnPageChangeListener 的 onPageScrolled 方法中，根据当前的 position 和 positionOffset 就可以完成选中时那条横线的移动。并且为了选中的 Tab 出现在屏幕中，ViewPagerIndicator 也要用 scrollTo 方法来做相应地移动。而在 onPageSelected 方法中，我们把选中的 Tab 中的字体颜色更改为已选中的颜色，之前选中的改成未选中颜色。</p>
<p>到这里，整体完成得差不多了。但是如果我们想让 ViewPagerIndicator 可以滑动的话，还要重写 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent event)</code> 两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = ev.getX();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = ev.getX() - lastX;</span><br><span class="line">            <span class="comment">// 当移动大于touchSlop时，拦截该触摸事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(offsetX) &gt;= touchSlop) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"onInterceptTouchEvent result = "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = x - lastX;</span><br><span class="line">            <span class="comment">// 滑动相应的距离</span></span><br><span class="line">            scrollBy(-(<span class="keyword">int</span>) offsetX, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 最左边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &gt; tabWidth * (getChildCount() - visibleTabNum)) &#123;</span><br><span class="line">                scrollTo(tabWidth * (getChildCount() - visibleTabNum), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onInterceptTouchEvent(MotionEvent ev)</code> 中，若滑动的距离超过 touchSlop ，则拦截该触摸事件自己处理，否则传递给子View。而在 <code>onTouchEvent(MotionEvent event)</code> 中，使用了 scrollBy 来处理滑动，并且设置了边界值的检查。</p>
<p>在这里，整体代码讲解完成了。其实 ViewPagerIndicator 本质就是使用了 OnPageChangeListener 以及当用户点击时切换 ViewPager 到指定页面，并没有太难的地方。以后我们自己也可以实现各种炫酷的 ViewPagerIndicator 了！</p>
<p>下面提供源码的下载链接：</p>
<p><a href="/uploads/20160427/ViewPagerIndicator.rar">ViewPagerIndicator.rar</a></p>
<p>have a nice day !~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blan]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造带有视差效果的ListView]]></title>
    <link href="http://yuqirong.me/2016/04/19/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%B8%A6%E6%9C%89%E8%A7%86%E5%B7%AE%E6%95%88%E6%9E%9C%E7%9A%84ListView/"/>
    <id>http://yuqirong.me/2016/04/19/快速打造带有视差效果的ListView/</id>
    <published>2016-04-19T05:35:32.000Z</published>
    <updated>2016-08-18T15:09:33.989Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/20160419141952.gif" alt="这里写图片描述"></p>
<p>我们可以看到 ListView 的 HeaderView 会跟随 ListView 的滑动而变大，HeaderView里的图片会有缩放效果。这些可以使用属性动画来实现。接下来我们就来动手吧！</p>
<p>首先自定义几个属性，在之后可以用到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ZoomListView"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView的高度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- headerView的最大高度 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView里面的图片最大的伸缩量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_scale"</span> <span class="attribute">format</span>=<span class="value">"float"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后创建 ZoomListView 类，继承自 ListView ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最大的伸缩量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> defaultHeaderMaxScale = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="comment">// 头部最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxHeight;</span><br><span class="line">    <span class="comment">// 头部初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerHeight;</span><br><span class="line">    <span class="comment">// 头部默认初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderHeight;</span><br><span class="line">    <span class="comment">// 头部默认最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderMaxHeight;</span><br><span class="line">    <span class="keyword">private</span> ImageView headerView;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup.LayoutParams layoutParams;</span><br><span class="line">    <span class="keyword">private</span> LinearLayout linearLayout;</span><br><span class="line">    <span class="comment">// 最大的缩放值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxScale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        defaultHeaderHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">160</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        defaultHeaderMaxHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">240</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ZoomListView);</span><br><span class="line">        headerHeight = a.getDimension(R.styleable.ZoomListView_header_height, defaultHeaderHeight);</span><br><span class="line">        headerMaxHeight = a.getDimension(R.styleable.ZoomListView_header_max_height, defaultHeaderMaxHeight);</span><br><span class="line">        headerMaxScale = a.getFloat(R.styleable.ZoomListView_header_max_scale, defaultHeaderMaxScale);</span><br><span class="line">        a.recycle();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里都是按部就班式的，设置好自定义属性的初始值，之后调用 <code>initView()</code> ，那就来看看 <code>initView()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    headerView = <span class="keyword">new</span> ImageView(getContext());</span><br><span class="line">    headerView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">    linearLayout = <span class="keyword">new</span> LinearLayout(getContext());</span><br><span class="line">    linearLayout.addView(headerView);</span><br><span class="line">    layoutParams = headerView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">        layoutParams = <span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (<span class="keyword">int</span>) headerHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutParams.width = ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        layoutParams.height = (<span class="keyword">int</span>) headerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    headerView.setLayoutParams(layoutParams);</span><br><span class="line">    addHeaderView(linearLayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    headerView.setImageResource(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在 <code>initView()</code> 里我们创建了 headerView ，并添加到了ListView的头部。而 <code>setDrawableId(int id)</code> 就是给 headerView 设置相关图片的。</p>
<p>下面就是视差效果的主要实现代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">overScrollBy</span><span class="params">(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY, <span class="keyword">int</span> scrollX, <span class="keyword">int</span> scrollY, <span class="keyword">int</span> scrollRangeX, <span class="keyword">int</span> scrollRangeY, <span class="keyword">int</span> maxOverScrollX, <span class="keyword">int</span> maxOverScrollY, <span class="keyword">boolean</span> isTouchEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span> &amp;&amp; isTouchEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headerView.getHeight() &lt; headerMaxHeight) &#123;</span><br><span class="line">            <span class="keyword">int</span> newHeight = headerView.getHeight()</span><br><span class="line">                    + Math.abs(deltaY / <span class="number">3</span>);</span><br><span class="line">            headerView.getLayoutParams().height = newHeight;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">            <span class="keyword">float</span> temp = <span class="number">1</span> + (headerMaxScale - <span class="number">1f</span>) * (headerView.getHeight() - headerHeight) / (headerMaxHeight - headerHeight);</span><br><span class="line">            headerView.animate().scaleX(temp)</span><br><span class="line">                    .scaleY(temp).setDuration(<span class="number">0</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 <code>overScrollBy()</code> 方法，当 deltaY 小于0时(即 ListView 已经到顶端，但是用户手势还是向下拉)，去动态地设置 headerView 的高度以及 headerView 的 scale 值。这样就可以产生 headerView 变高以及图片放大的效果了。</p>
<p>接下来要考虑的问题就是当用户松开手指时，要恢复回原来的样子。所以我们应该在 <code>onTouchEvent(MotionEvent ev)</code> 里去实现相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                startAnim();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行动画</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(headerView.getHeight(), headerHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.getLayoutParams().height = (<span class="keyword">int</span>) fraction;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line"></span><br><span class="line">    ValueAnimator animator2 = ValueAnimator.ofFloat(headerView.getScaleX(), <span class="number">1f</span>);</span><br><span class="line">    animator2.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.setScaleX(fraction);</span><br><span class="line">            headerView.setScaleY(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator2.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator2.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">    animator.start();</span><br><span class="line">    animator2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码简单点来说，就是在 ACTION_UP 时，去开始两个属性动画，一个属性动画是将 headerView 的高度恢复成原来的值，另一个属性动画就是把 headerView 的 scale 重新恢复为1f。相信大家都可以看懂的。</p>
<p>ZoomListView 整体的代码就这些了，很简短。下面附上下载的链接：</p>
<p><a href="/uploads/20160419/ZoomListView.rar">ZoomListView.rar</a></p>
<p>good luck ! ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你实现仿美团的下拉刷新]]></title>
    <link href="http://yuqirong.me/2016/04/18/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BB%BF%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://yuqirong.me/2016/04/18/带你实现仿美团的下拉刷新/</id>
    <published>2016-04-18T07:34:03.000Z</published>
    <updated>2016-08-18T15:09:33.973Z</updated>
    <content type="html"><![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="这里写图片描述"></p>
<p>我们可以大致地分析一下：首先根据下拉改变的 paddingTop 来动态地缩放“绿色椭圆物”,然后当 headerView 的 paddingTop 大于0时，播放美团小人出现的帧动画，最后就是手指松开时播放刷新中的帧动画了。</p>
<p>基本上思路就是上面分析的那样了，那么我们下面一步就是要获取帧动画的素材了。我们先下载好美团的 apk ，解压后在 res/drawable-xhdpi-v4 里，我们可以得到相关的图片了。如果嫌麻烦，文末有本 Demo 的下载链接，里面就有素材图片。</p>
<p>有了图片后我们先写个帧动画的 drawable.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animation-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_01"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_02"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_03"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_04"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_05"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一共有两个 drawable.xml ，另外一个和这个类似，就不贴出来了。</p>
<p>现在开始编写代码了，创建一个 MeiTuanListView ，继承自 ListView :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiTuanListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通状态模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE_MODE = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PULL_DOWN_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可松开刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RELEASE_REFRESH_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 刷新中模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REFRESHING_MODE = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mode = NONE_MODE;</span><br><span class="line">	<span class="comment">// 阻值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RATIO = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新头部</span></span><br><span class="line">    <span class="keyword">private</span> View headerRefreshView;</span><br><span class="line">    <span class="comment">// 头部高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refreshViewHeight;</span><br><span class="line">    <span class="comment">// 手指按下的Y值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> downY;</span><br><span class="line">    <span class="comment">// 刷新监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnRefreshListener listener;</span><br><span class="line">    <span class="comment">// “绿色椭圆物”的自定义View</span></span><br><span class="line">    <span class="keyword">private</span> MeiTuanOvalView mtOvalView;</span><br><span class="line">    <span class="comment">// 帧动画的ImageView</span></span><br><span class="line">    <span class="keyword">private</span> ImageView aniImageView;</span><br><span class="line">    <span class="comment">// 动画是否已经开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStart;</span><br><span class="line">    <span class="comment">// 只有在listview顶端时下拉才可以刷新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canRefresh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MeiTuanListView"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setOverScrollMode(View.OVER_SCROLL_NEVER);</span><br><span class="line">        headerRefreshView = LayoutInflater.from(getContext()).inflate(R.layout.layout_header, <span class="keyword">null</span>);</span><br><span class="line">        mtOvalView = (MeiTuanOvalView) headerRefreshView.findViewById(R.id.mtFirstView);</span><br><span class="line">        aniImageView = (ImageView) headerRefreshView.findViewById(R.id.iv);</span><br><span class="line">        <span class="comment">// 去测量</span></span><br><span class="line">        headerRefreshView.measure(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        refreshViewHeight = headerRefreshView.getMeasuredHeight();</span><br><span class="line">        headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        addHeaderView(headerRefreshView, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initView()</code>中，初始化了下拉刷新的头部，并且设置了 setPadding (关于 ListView 下拉刷新的原理大家应该都懂吧？！)。</p>
<p>layout_header.xml 的布局如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:gravity</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">com.yuqirong.meituanlistview.view.MeiTuanOvalView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/mtFirstView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_anim"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:visibility</span>=<span class="value">"gone"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MeiTuanOvalView 这个是关于“绿色椭圆物”的自定义View，会根据 <code>headerView.getPaddingTop()</code> 的值自动缩放，这里就不讲解了，源码还是比较简单的，相关代码可以下载 Demo 查看。而 <code>iv_anim</code> 主要是用来播放帧动画的 ImageView 。</p>
<p>下拉刷新的主要代码都在 <code>onTouchEvent(MotionEvent ev)</code> 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 在listview顶端时才可下拉刷新</span></span><br><span class="line">            <span class="keyword">if</span> (getFirstVisiblePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"canRefresh : "</span> + canRefresh);</span><br><span class="line">				<span class="comment">// 记录手指按下的Y坐标</span></span><br><span class="line">                downY = ev.getY();</span><br><span class="line">                canRefresh = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">float</span> moveY = ev.getY();</span><br><span class="line">                <span class="keyword">float</span> offsetY = moveY - downY;</span><br><span class="line">				<span class="comment">// 动态改变paddingTop值</span></span><br><span class="line">                headerRefreshView.setPadding(<span class="number">0</span>, (<span class="keyword">int</span>) (headerRefreshView.getPaddingTop() + offsetY / RATIO), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = PULL_DOWN_MODE;</span><br><span class="line">                    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">                    aniImageView.setVisibility(GONE);</span><br><span class="line">                    mtOvalView.setScale((refreshViewHeight + headerRefreshView.getPaddingTop()) * <span class="number">1f</span> / refreshViewHeight);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = RELEASE_REFRESH_MODE;</span><br><span class="line">                    <span class="keyword">if</span> (!isStart) &#123;</span><br><span class="line">                        mtOvalView.setVisibility(GONE);</span><br><span class="line">                        aniImageView.setVisibility(VISIBLE);</span><br><span class="line">                        aniImageView.setImageResource(R.drawable.pull_end_imag_frame);</span><br><span class="line">                        AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                        <span class="comment">// 只执行一次动画</span></span><br><span class="line">                        animationDrawable.setOneShot(<span class="keyword">true</span>);</span><br><span class="line">                        animationDrawable.start();</span><br><span class="line">                        isStart = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                downY = moveY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = REFRESHING_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    aniImageView.setImageResource(R.drawable.refreshing_image_frame);</span><br><span class="line">                    AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                    animationDrawable.start();</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.refreshing();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = NONE_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    mtOvalView.setScale(<span class="number">0f</span>);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的代码逻辑还是比较简单的：</p>
<ul>
<li>ACTION_DOWN ：首先判断了当 ListView 在顶端时才可以下拉刷新，并且记录了手指按下的Y坐标；</li>
<li>ACTION_MOVE ：根据滑动的 offsetY 来动态地设置 headerView 的 paddingTop 。我们可以看到在 <code>if (headerRefreshView.getPaddingTop() &lt;= 0)</code> 里面根据 paddingTop 的值来动态地设置 <code>mtOvalView</code> 的 scale ，并且在 <code>setScale()</code> 方法里面会调用 <code>invalidate()</code> ，从而让 <code>mtOvalView</code> 去重绘。不然 <code>headerRefreshView.getPaddingTop()</code> 大于0时就播放了美团小人出场的动画。</li>
<li>ACTION_UP ：当手指松开的时候，还是判断了 <code>headerRefreshView.getPaddingTop()</code> 的值。若大于0则把 headerView 全部显示出来，播放刷新中的动画，并且回调了刷新监听器的接口；小于0则把 headerView 重新隐藏起来。并重置相关的值。</li>
</ul>
<p>要注意的一点是，在 <code>onTouchEvent(MotionEvent ev)</code> 里要返回 <code>super.onTouchEvent(ev)</code> 。不能是直接返回 <code>true</code> 。因为在 <code>super.onTouchEvent(ev)</code> 里处理了 ListView 滑动的相关逻辑。</p>
<p>当获取到最新数据后，可以调用<code>notifyRefreshFinished()</code>方法完成下拉刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnRefreshListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnRefreshListener</span><span class="params">(OnRefreshListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新完成后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyRefreshFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mode = NONE_MODE;</span><br><span class="line">    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    aniImageView.setVisibility(GONE);</span><br><span class="line">    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">    isStart = <span class="keyword">false</span>;</span><br><span class="line">    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是附上效果图了：</p>
<p><img src="/uploads/20160418/20160418165251.gif" alt="这里写图片描述"></p>
<p>到这里整体就讲解得差不多了，至于 MeiTuanListView 的使用示例以及 MeiTuanOvalView 的源码可以在 Demo 里查看。</p>
<p>Demo下载链接：</p>
<p><a href="/uploads/20160418/MeiTuanListView.rar">MeiTuanListView.rar</a></p>
<p>good bye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FloatingActionButton在滚动时显示或隐藏]]></title>
    <link href="http://yuqirong.me/2016/04/10/FloatingActionButton%E5%9C%A8%E6%BB%9A%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F/"/>
    <id>http://yuqirong.me/2016/04/10/FloatingActionButton在滚动时显示或隐藏/</id>
    <published>2016-04-10T11:51:22.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>其实关于FAB的显示和隐藏，Google官方就提供了其中一种方案：<code>fab.hidden()</code>和<code>fab.show()</code>。但是自带的是FAB缩放的效果。并不是上下移动的效果。</p>
<p>那么我们就来看看如何实现FAB上下移动的效果吧！</p>
<p>首先在你想要滑动的View(比如说RecyclerView等)的布局上加上：</p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>然后再附上FAB的xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">   <span class="attribute">android:id</span>=<span class="value">"@+id/fab"</span></span><br><span class="line">   <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_gravity</span>=<span class="value">"bottom|end"</span></span><br><span class="line">   <span class="attribute">android:layout_margin</span>=<span class="value">"@dimen/fab_margin"</span></span><br><span class="line">   <span class="attribute">app:layout_behavior</span>=<span class="value">"com.yuqirong.rxnews.ui.view.ScrollAwareFABBehavior"</span></span><br><span class="line">   <span class="attribute">android:src</span>=<span class="value">"@android:drawable/ic_dialog_email"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意其中的layout_behavior，是我们自己实现的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollAwareFABBehavior</span> <span class="keyword">extends</span> <span class="title">FloatingActionButton</span>.<span class="title">Behavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator INTERPOLATOR = <span class="keyword">new</span> FastOutSlowInInterpolator();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScrollAwareFABBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                                       <span class="keyword">final</span> View directTargetChild, <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ensure we react to vertical scrolling</span></span><br><span class="line">        <span class="keyword">return</span> nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">                || <span class="keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                               <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> dxConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyConsumed,</span><br><span class="line">                               <span class="keyword">final</span> <span class="keyword">int</span> dxUnconsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line">        <span class="keyword">if</span> (dyConsumed &gt; <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled down and the FAB is currently visible -&gt; hide the FAB</span></span><br><span class="line">            animateOut(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyConsumed &lt; <span class="number">0</span> &amp;&amp; child.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled up and the FAB is currently not visible -&gt; show the FAB</span></span><br><span class="line">            animateIn(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateOut</span><span class="params">(<span class="keyword">final</span> FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer()</span><br><span class="line">                    .setListener(<span class="keyword">new</span> ViewPropertyAnimatorListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                            view.setVisibility(View.GONE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateIn</span><span class="params">(FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        button.setVisibility(View.VISIBLE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(<span class="number">0</span>)</span><br><span class="line">                    .setInterpolator(INTERPOLATOR).withLayer().setListener(<span class="keyword">null</span>)</span><br><span class="line">                    .start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMarginBottom</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> marginBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = v.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> ViewGroup.MarginLayoutParams) &#123;</span><br><span class="line">            marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> marginBottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看<code>onNestedScroll()</code>这个方法，在方法里主要判断了一下是向上滑还是向下滑。再分别去调用<code>animateOut()</code>和<code>animateIn()</code>。那我们就来看看<code>animateOut()</code>。(<code>animateIn()</code>和<code>animateOut()</code>的原理一样的，我们只看<code>animateOut()</code>吧)</p>
<p>在<code>animateOut()</code>根据SDK的版本判断，若大于或等于14使用属性动画；不然就是使用了自带的<code>hide()</code>方法。代码还是比较简单的，相信大家都能看得懂。当然如下想在SDK 14以下使用上下移动的效果，那就要用NineOldAndroids这个库了。</p>
<p>效果就是如下所示了：</p>
<p><img src="/uploads/20160413/20160413202356.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这了。bye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入解析Scroller滚动原理]]></title>
    <link href="http://yuqirong.me/2016/04/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Scroller%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2016/04/05/深入解析Scroller滚动原理/</id>
    <published>2016-04-05T12:21:10.000Z</published>
    <updated>2016-08-18T15:09:34.051Z</updated>
    <content type="html"><![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括为“三部曲”：</p>
<ol>
<li><p>创建一个Scroller对象，一般在View的构造器中创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    mScroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写View的computeScroll()方法，下面的代码基本是不会变化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用startScroll()方法，startX和startY为开始滚动的坐标点，dx和dy为对应的偏移量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mScroller.startScroll (<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy);</span><br><span class="line">invalidate();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的三步就是Scroller的基本用法了。那接下来的任务就是解析Scroller的滚动原理了。</p>
<p>而在这之前，我们还有一件事要办，那就是搞清楚scrollTo()和scrollBy()的原理。scrollTo()和scrollBy()的区别我这里就不重复叙述了，不懂的可以自行google或百度。下面贴出scrollTo()的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置好mScrollX和mScrollY之后，调用了<code>onScrollChanged(mScrollX, mScrollY, oldX, oldY);</code>，View就会被重新绘制。这样就达到了滑动的效果。</p>
<p>下面我们再来看看scrollBy()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样简短的代码相信大家都懂了，原来scrollBy()内部是调用了scrollTo()的。但是scrollTo()/scrollBy()的滚动都是瞬间完成的，怎么样才能实现平滑滚动呢。</p>
<p>不知道大家有没有这样一种想法：如果我们把要滚动的偏移量分成若干份小的偏移量，当然这份量要大。然后用scrollTo()/scrollBy()每次都滚动小份的偏移量。在一定的时间内，不就成了平滑滚动了吗？没错，Scroller正是借助这一原理来实现平滑滚动的。下面我们就来看看源码吧！</p>
<p>根据“三部曲”中第一部，先来看看Scroller的构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context, Interpolator interpolator, <span class="keyword">boolean</span> flywheel)</span> </span>&#123;</span><br><span class="line">    mFinished = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (interpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> ViscousFluidInterpolator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = interpolator;</span><br><span class="line">    &#125;</span><br><span class="line">    mPpi = context.getResources().getDisplayMetrics().density * <span class="number">160.0f</span>;</span><br><span class="line">    mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());</span><br><span class="line">    mFlywheel = flywheel;</span><br><span class="line"></span><br><span class="line">    mPhysicalCoeff = computeDeceleration(<span class="number">0.84f</span>); <span class="comment">// look and feel tuning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造器中做的主要就是指定了插补器，如果没有指定插补器，那么就用默认的ViscousFluidInterpolator。</p>
<p>我们再来看看Scroller的startScroll()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mMode = SCROLL_MODE;</span><br><span class="line">    mFinished = <span class="keyword">false</span>;</span><br><span class="line">    mDuration = duration;</span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">    mStartX = startX;</span><br><span class="line">    mStartY = startY;</span><br><span class="line">    mFinalX = startX + dx;</span><br><span class="line">    mFinalY = startY + dy;</span><br><span class="line">    mDeltaX = dx;</span><br><span class="line">    mDeltaY = dy;</span><br><span class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，在startScroll()里面并没有开始滚动，而是设置了一堆变量的初始值，那么到底是什么让View开始滚动的？我们应该把目标集中在startScroll()的下一句<code>invalidate();</code>身上。我们可以这样理解：首先在startScroll()设置好了一堆初始值，之后调用了<code>invalidate();</code>让View重新绘制，这里又有一个很重要的点，在draw()中会调用<code>computeScroll()</code>这个方法！</p>
<p>源码太长了，在这里就不贴出来了。想看的童鞋在View类里面搜<code>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>这个方法就能看到了。通过ViewGroup.drawChild()方法就会调用子View的draw()方法。而在View类里面的<code>computeScroll()</code>是一个空的方法，需要我们去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called by a parent to request that a child update its values for mScrollX</span><br><span class="line"> * and mScrollY if necessary. This will typically be done if the child is</span><br><span class="line"> * animating a scroll using a &#123;<span class="doctag">@link</span> android.widget.Scroller Scroller&#125;</span><br><span class="line"> * object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在上面“三部曲”的第二部中，我们就已经实现了<code>computeScroll()</code>。首先判断了<code>computeScrollOffset()</code>，我们来看看相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Call this when you want to know the new location.  If it returns true,</span><br><span class="line"> * the animation is not yet finished.</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SCROLL_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLING_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</span><br><span class="line">            <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</span><br><span class="line">            <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</span><br><span class="line">                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</span><br><span class="line">                distanceCoef = d_inf + (t - t_inf) * velocityCoef;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</span><br><span class="line">            </span><br><span class="line">            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</span><br><span class="line">            <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></span><br><span class="line">            mCurrX = Math.min(mCurrX, mMaxX);</span><br><span class="line">            mCurrX = Math.max(mCurrX, mMinX);</span><br><span class="line">            </span><br><span class="line">            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</span><br><span class="line">            <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></span><br><span class="line">            mCurrY = Math.min(mCurrY, mMaxY);</span><br><span class="line">            mCurrY = Math.max(mCurrY, mMinY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mCurrX = mFinalX;</span><br><span class="line">        mCurrY = mFinalY;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的返回值有讲究，若返回true则说明Scroller的滑动没有结束；若返回false说明Scroller的滑动结束了。再来看看内部的代码：先是计算出了已经滑动的时间，若已经滑动的时间小于总滑动的时间，则说明滑动没有结束；不然就说明滑动结束了，设置标记<code>mFinished = true;</code>。而在滑动未结束里面又分为了两个mode，不过这两个mode都干了差不多的事，大致就是根据刚才的时间<code>timePassed</code>和插补器来计算出该时间点滚动的距离<code>mCurrX</code>和<code>mCurrY</code>。也就是上面“三部曲”中第二部的mScroller.getCurrX(), mScroller.getCurrY()的值。</p>
<p>然后在第二部曲中调用scrollTo()方法滚动到指定点(即上面的<code>mCurrX</code>, <code>mCurrY</code>)。之后又调用了<code>postInvalidate();</code>，让View重绘并重新调用<code>computeScroll()</code>以此循环下去，一直到View滚动到指定位置为止，至此Scroller滚动结束。</p>
<p>其实Scroller的原理还是比较通俗易懂的。我们再来理清一下思路，以一张图的形式来终结今天的Scroller解析：</p>
<p><img src="/uploads/20160405/20160405235023.png" alt="这里写图片描述"></p>
<p>好了，如果有什么问题可以在下面留言。</p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android安全机制之反编译]]></title>
    <link href="http://yuqirong.me/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://yuqirong.me/2016/04/03/Android安全机制之反编译/</id>
    <published>2016-04-02T16:59:11.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米修斯方法”以及“宙斯类”(不得不感慨开发小哥的智商)。之后就是在阅读《Android群英传》时也有相关反编译的内容，觉得有必要记录一下。所以这就是本片写博文的起源了。</p>
<p>首先关于反编译，我们先要准备几个工具：</p>
<ul>
<li>apktool：aoktool主要是用来反编译资源文件的，也就是XML了。</li>
<li>Dex2jar：Dex2jar就是反编译源代码的，会把源代码反编译成一个jar包。</li>
<li>jd-gui ：在上面Dex2jar反编译出来的jar包，放入jd-gui中，就可以查看源代码了。</li>
</ul>
<p>关于上面的三个工具，我会在文末放出下载链接，大家可以去下载。</p>
<p>好了，那接下来我们就开始反编译之旅吧！</p>
<p>至于要反编译的apk，我只能选择自己的<a href="https://github.com/yuqirong/Koku" target="_blank" rel="external">Koku</a>了，<a href="http://www.wandoujia.com/apps/com.yuqirong.koku/download" target="_blank" rel="external">点击此处下载</a>。</p>
<p>我们把上面下载下来的apk用winrar打开(当然你也可以用其他的解压工具)，我们可以看到里面的文件内容如下图所示：</p>
<p><img src="/uploads/20160403/20160403112646.png" alt="这里写图片描述"></p>
<p>我们发现classes.dex这个文件，其实classes.dex反编译出来就是源代码。然后我们把Dex2jar解压出来，发现里面有d2j-dex2jar.bat，这就是主角了。</p>
<p><img src="/uploads/20160403/20160403124449.png" alt="这里写图片描述"></p>
<p>在Dex2jar解压出来的目录下，打开命令提示符输入：</p>
<pre><code>d2j-dex2jar.bat classes.dex所在的路径
</code></pre><p>比如：</p>
<p><img src="/uploads/20160403/20160403124911.png" alt="这里写图片描述"></p>
<p>运行后，我们发现在Dex2jar解压出来的目录下多了一个classes-dex2jar.jar。</p>
<p><img src="/uploads/20160403/20160403125136.png" alt="这里写图片描述"></p>
<p>然后我们把下载下来的jd-gui.zip解压，里面会有jd-gui.exe。相信大家都懂吧。用jd-gui.exe打开上面的classes-dex2jar.jar，你会惊喜地发现源代码就在你眼前！</p>
<p><img src="/uploads/20160403/20160403125619.png" alt="这里写图片描述"></p>
<p>看上面的代码截图，我们会发现比如说<code>setContentView()</code>里面是一串数字。不过别怕，我们都知道R文件是用来关联资源文件的，把上面的那串数字复制下来，再打开R.class，查找一下：</p>
<p><img src="/uploads/20160403/20160403130002.png" alt="这里写图片描述"></p>
<p>原来那串数字就代表了activity_my_favorite.xml这个layout。那么问题来了，我们如何反编译XML文件呢？那就要用到上面的apktool了。</p>
<p>打开apktool的所在目录，把koku.apk移动到apktool的同一目录下，输入命令符：</p>
<pre><code>java -jar apktool_2.1.0.jar d koku.apk
</code></pre><p>如果你配置了Java环境变量，则可以直接输入：</p>
<pre><code>apktool_2.1.0.jar d koku.apk
</code></pre><p>运行完成之后，我们可以发现在目录下多了一个名字叫koku的文件夹，而这就是我们反编译出来的XML文件了。</p>
<p><img src="/uploads/20160403/20160403131154.png" alt="这里写图片描述"></p>
<p>我们打开里面的AndroidManifest.xml：</p>
<p><img src="/uploads/20160403/20160403131326.png" alt="这里写图片描述"></p>
<p>里面真的有<uses-permission\>、<activity\>等信息！然后我们打开res里面的layout文件夹，会发现里面有我们上面提到的activity_my_favorite.xml：</activity\></uses-permission\></p>
<p><img src="/uploads/20160403/20160403131658.png" alt="这里写图片描述"></p>
<p>里面的布局一目了然。到这里，这样一个apk的基本的源代码我们都可以看得到。当然，反编译别人的apk应该是以学习为主，而不是恶意地二次打包以及破坏。</p>
<p>在这里额外多说一句，如果要反编译的apk经过了代码混淆，那么反编译出来的就变成了a.class、b.class、c.class等等，所以代码混淆可以有效地阻止apk反编译。</p>
<p>而如果你想要将代码混淆，只要打开项目中的build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能。proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><p>好了，差不多该讲的都讲完了，今天就到这里了。</p>
<p>下面给出反编译工具的下载链接：</p>
<p><a href="/uploads/20160403/apktool_2.1.0.jar">apktool_2.1.0.jar</a></p>
<p><a href="/uploads/20160403/dex2jar-2.0.zip">dex2jar-2.0.zip</a></p>
<p><a href="/uploads/20160403/jd-gui-0.3.5.windows.zip">jd-gui-0.3.5.windows.zip</a></p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/03/31/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/03/31/《Android开发艺术探索》笔记(上)/</id>
    <published>2016-03-31T11:49:28.000Z</published>
    <updated>2016-08-18T15:09:33.832Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="第一章：Activity的生命周期和启动模式"></a>第一章：Activity的生命周期和启动模式</h1><h2 id="1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790"><a href="#1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790" class="headerlink" title="1.1 Activity的生命周期全面分析"></a>1.1 Activity的生命周期全面分析</h2><p><strong>典型情况下的生命周期分析</strong></p>
<p>onStart()和onStop()是从Activity是否可见这个角度来回调的，而onResume()和onPause()是从Activity是否位于前台这个角度来回调的。</p>
<p>Activity A打开Activity B时，为了不影响B的显示，最好不要在Activity A的onPause()里执行一些耗时操作，可以考虑将这些操作放到onStop()里，这时B已经可见了。</p>
<p><strong>异常情况下的生命周期分析</strong></p>
<p>由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用时机是在onStop()之前，但它和onPause()没有既定的时序关系，它既可能在onPause()之前调用，也可能在onPause()之后调用。需要强调的一点是，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会调用onSaveInstanceState()这个方法。</p>
<p>当Activity被重新创建后，系统会调用onRestoreInstanceState()，并且把Activity销毁时onSaveInstanceState()方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState()和onCreate()方法。因此我们可以通过onRestoreInstanceState()和onCreate()方法来判断Activity是否重建了。如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart()之后。</p>
<p>和Activity一样，每个View都有onSaveInstanceState()和onRestoreInstanceState()这两个方法。关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorWindow。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父层委托子元素去处理一件事情。至于数据恢复过程也是类似的，这里就不再重复介绍了。</p>
<p>Activity按照优先级从高到低，可以分为如下三种：</p>
<ul>
<li>前台Activity——正在和用户交互的Activity，优先级最高。</li>
<li>可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。</li>
<li>后台Activity——已经被暂停的Activity，比如说执行了onStop，优先级最低。</li>
</ul>
<p>如果不想Activity在屏幕旋转的时候重新创建，则：</p>
<pre><code>android:configChanges=&quot;orientation&quot;
</code></pre><p>另外，若minSdkVersion和targetSdkVersion其中有一个低于13，则要在上面的基础上，加上screenSize，即：</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre><h2 id="1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F"><a href="#1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h2><p><strong>Activity的launchMode</strong></p>
<ul>
<li><p>standard 标准模式。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity就运行在启动仪它的那个Activity所在的栈里。另外要注意的是，当我们用ApplicationContext去启动standard模式的Activity的时候会报错，错误如下</p>
<pre><code>E/AndroidRuntime(674):andriod.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.Is this really what you want?
</code></pre><p>  这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈，所以这就有问题了。解决这个问题的方法是为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动Activity实际上是以singleTask模式启动的。</p>
</li>
<li><p>singleTop 栈顶复用模式。若该Activity已经位于任务栈的栈顶，那么该Activity不会被重新创建，同时它的onNewIntent()方法会被回调，通过此方法的参数我们可以取出当前请求的信息。而且它的onCreate()和onStart()并不会被调用。执行的是onPause() –&gt; onNewIntent() –&gt; onResume()。 如果该Activity已存在但不是位于栈顶，则该Activity仍然会被重新创建。</p>
</li>
<li><p>singleTask 栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewsIntent()。具体一点，当一个具有singleTask模式的Activity请求启动后，比如说Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在把A所需的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶(会把在栈中所有处于A之上的Activity全部出栈)并调用它的onNewsIntent()方法，如果实例不存在，就创建A的实例并把A压入栈中。</p>
<p>  设ActivityA的 android:launchMode=”singleTask” 方式，且ActivityA正处于栈中，但不是栈顶，栈顶为ActivityB，点击按钮启动ActivityA，则：<br>  B: onPause() -&gt; A: onNewIntent() -&gt; A:onRestart() -&gt; A: onStart() -&gt; A:onResume() -&gt; B: onStop() -&gt; B: onDestroy()</p>
</li>
<li><p>singleInstance 单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity。除非这个独特的任务栈被系统销毁了。</p>
</li>
</ul>
<p><code>android:taskAffinity</code>：可以翻译为任务相关性。这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为报名。当然，我们可以为每个Activity都单独制定TaskAffinity属性，这个属性必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>
<ul>
<li><p>当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。</p>
</li>
<li><p>当TaskAffinity和allowTaskReparenting结合的时候，这种情况比较复杂，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。</p>
</li>
</ul>
<p><strong>Activity的Flags</strong></p>
<ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性<code>android:excludeFromRecents=&quot;true&quot;</code>。</p>
</li>
</ul>
<h2 id="1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219"><a href="#1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219" class="headerlink" title="1.3 IntentFilter的匹配规则"></a>1.3 IntentFilter的匹配规则</h2><ul>
<li>action匹配规则：要求intent中的action 存在 且 必须和过滤规则中的其中一个相同 区分大小写；</li>
<li>category匹配规则：系统会默认加上一个android.intent.category.DEAFAULT，所以intent中可以不存在category，但如果存在就必须匹配其中一个；</li>
<li>data匹配规则：data由两部分组成，mimeType和URI，要求和action相似。如果没有指定URI，URI但默认值为content和file（schema）。如果要为intent指定完整的data，必须要调用setDataAndType方法。</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236"><a href="#u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236" class="headerlink" title="第二章：IPC机制"></a>第二章：IPC机制</h1><h2 id="2-1_Android_IPC_u7B80_u4ECB"><a href="#2-1_Android_IPC_u7B80_u4ECB" class="headerlink" title="2.1 Android IPC简介"></a>2.1 Android IPC简介</h2><h2 id="2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="2.2 Android中的多进程模式"></a>2.2 Android中的多进程模式</h2><p><strong>开启多进程模式</strong></p>
<p>在Android中使用多进程只有一个办法，那就是给四大组件(Activity、Service、Receiver、ContentProvider)在AndroidMenifest中指定android:process属性。另外还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程。</p>
<p>进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局过程，其他应用可以通过ShareUID方式和它跑在同一个进程中。</p>
<p>我们知道Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。这里要说明的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说他们看起来就像是一个应用的两个部分。</p>
<p><strong>多进程模式的运行机制</strong></p>
<p>Android会为每一个应用分配一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。</p>
<p>一般来说，使用多进程会造成如下几方面的问题：</p>
<ol>
<li>静态成员和单例模式完全失效；</li>
<li>线程同步机制完全失效；</li>
<li>SharedPreferences的可靠性下降；</li>
<li>Application会多次创建。</li>
</ol>
<h2 id="2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD"><a href="#2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD" class="headerlink" title="2.3 IPC基础概念介绍"></a>2.3 IPC基础概念介绍</h2><p><strong>Serializable接口</strong></p>
<p>Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，通过Serializable来实现对象的序列化和反序列化(User类实现了Serializable接口)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>,<span class="string">"jake"</span>,<span class="keyword">true</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>))；</span><br><span class="line">User newUser = (User)in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p>恢复的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>原则上序列化后的数据中的serialVerionUID只有和当前类的serialVersionUID相同才能够正常地被反序列化。</p>
<p>serialVersionUID的详细工作机制：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUID的值。</p>
<p>有两个需要注意一下：</p>
<ul>
<li>静态成员变量属于类不属于对像，所以不会参与序列化过程；</li>
<li>用transient关键字标记的成员变量不参与序列化过程。</li>
</ul>
<p><strong>Parcelable接口</strong></p>
<p>Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，因此推荐使用Parcelable。Parcelable接口可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(bookId);</span><br><span class="line">        out.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现反序列化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;<span class="comment">//创建指定长度的原始对象数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Binder</strong></p>
<p>Binder是Android的一个类，它继承了IBinder接口。从IPC的角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包含普通服务和基于AIDL的服务。</p>
<p>在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。</p>
<p>AIDL工具根据AIDL文件自动生成的Java接口的解析：首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。</p>
<p>AIDL接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>
<ul>
<li><code>DESCRIPTOR</code>:Binder的唯一标识，一般用当前Binder的类名表示，比如“com.example.android.MyAIDLInterface”。</li>
<li><code>asInterface(android.os.IBinder obj)</code>：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>
<li><code>asBinder()</code>：返回当前Binder对象。</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code>：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是<code>public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</code>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</li>
<li><code>Proxy#[Method]</code>：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</li>
</ul>
<p>Binder的工作机制原理图：</p>
<p><img src="/uploads/20160809/20160814201234.png" alt="Binder的工作机制原理图"></p>
<p>Binder的两个重要方法linkToDeath和unlinkToDeath：<br>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。<br>如何给Binder设置死亡代理呢？</p>
<p>(一). 声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteBookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">        mRemoteBookManager = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>这里重新绑定远程Service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(二). 在客户端绑定远程服务成功之后，给binder设置死亡代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-4_IPC_u65B9_u5F0F"><a href="#2-4_IPC_u65B9_u5F0F" class="headerlink" title="2.4 IPC方式"></a>2.4 IPC方式</h2><ol>
<li><p>使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。</p>
</li>
<li><p>使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。</p>
<p> SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。</p>
</li>
<li><p>使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形。</p>
<p> Messenger的工作原理：</p>
<p> <img src="/uploads/20160809/20160809234757.png" alt="Messenger的工作原理图"></p>
</li>
<li><p>使用AIDL:首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。</p>
<p> AIDL使用的注意点：</p>
<p> (1). AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；<br> (2). 某些类即使和AIDL文件在同一个包中也要显式import进来；<br> (3). AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；<br> (4). AIDL接口中支持方法，不支持声明静态变量；<br> (5). 为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。<br> (6). AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以要在AIDL方法中处理线程同步。<br> (7). RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。<br> (8). 客户端调用远程服务方法时，因为远程方法运行在服务端的binder线程池中，同时客户端线程会被挂起，所以如果该方法过于耗时，而客户端又是UI线程，会导致ANR，所以当确认该远程方法是耗时操作时，应避免客户端在UI线程中调用该方法。同理，当服务器调用客户端的listener方法时，该方法也运行在客户端的binder线程池中，所以如果该方法也是耗时操作，请确认运行在服务端的非UI线程中。另外，因为客户端的回调listener运行在binder线程池中，所以更新UI需要用到handler。<br> (9). 客户端通过IBinder.DeathRecipient来监听Binder死亡，也可以在onServiceDisconnected中监听并重连服务端。区别在于前者是在binder线程池中，访问UI需要用Handler，后者则是UI线程。<br> (10). AIDL可通过自定义权限在onBind或者onTransact中进行权限验证。</p>
</li>
<li><p>使用ContentProvider<br>1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；<br>2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；<br>3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；<br>4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</p>
</li>
<li><p>使用Socket<br>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。</p>
</li>
</ol>
<h2 id="2-5_Binder_u8FDE_u63A5_u6C60"><a href="#2-5_Binder_u8FDE_u63A5_u6C60" class="headerlink" title="2.5 Binder连接池"></a>2.5 Binder连接池</h2><p>(1). 当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。<br>Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>
<p>(2). 作者实现的Binder连接池BinderPool的<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/binderpool/BinderPool.java" target="_blank" rel="external">实现源码</a>，建议在AIDL开发工作中引入BinderPool机制。</p>
<h2 id="2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F"><a href="#2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F" class="headerlink" title="2.6 选用合适的IPC方式"></a>2.6 选用合适的IPC方式</h2><p><img src="/uploads/20160809/20160814191325.png" alt="选用合适的IPC方式"></p>
<p>// TODO</p>
<h1 id="u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB"><a href="#u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h1><h2 id="3-1_View_u57FA_u7840_u77E5_u8BC6"><a href="#3-1_View_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="3.1 View基础知识"></a>3.1 View基础知识</h2><p><strong>View的位置参数</strong></p>
<ul>
<li>View的宽高和坐标关系：width = right - left，height = top - bottom。</li>
<li>View在平移过程中，top和left表示的是原始左上角的位置信息，其值不会改变，发生改变的是x、y、translationX、translationY这四个参数。x是View左上角的坐标，translation是view移动后相对于父容器的偏移量，所以有x = left + translationX。y的原理相同。</li>
</ul>
<p><strong>MotionEvent和TouchSlop</strong></p>
<p>TouchSlop是系统所能识别出的被认为是滑动的最小距离。这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>。当两次滑动事件的滑动距离小于TouchSlop时就可以认为不是滑动。</p>
<p><strong>VelocityTracker、GestureDetector和Scroller</strong></p>
<p>1.VelocityTracker</p>
<p>速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。首先，在View的onTouchEvent方法中追踪当前单击事件的速度。</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></pre><p>获取当前的速度：</p>
<pre><code>velocityTracker.computeCurrentVelocity(1000); //表示的是一个时间单元或者说时间间隔
int xVelocity = (int) velocityTracker.getXVelocity();
int yVelocity = (int) velocityTracker.getYVelocity();
</code></pre><p>当不用它的时候，需要调用clear()方法来重置并回收内存：</p>
<pre><code>velocityTracker.clear();
velocityTracker.recycle();
</code></pre><p>2.GestureDetector</p>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行动。</p>
<p>首先，需要创建一个GestureDetector对象并实现OnGestureListener接口，根据需要我们还可以实现OnDoubleTapListener从而能够监听双击行为：</p>
<pre><code>GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false)；
</code></pre><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加如下实现：</p>
<pre><code>boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre><p>做完了上面两步，我们就可以有选择地实现OnGestureListener和OnDoubleTapListener中的方法了。</p>
<p>3.Scroller</p>
<p>在3.2节中详细介绍。</p>
<h2 id="3-2_View_u7684_u6ED1_u52A8"><a href="#3-2_View_u7684_u6ED1_u52A8" class="headerlink" title="3.2 View的滑动"></a>3.2 View的滑动</h2><ul>
<li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p>
</li>
<li><p>使用动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</p>
</li>
<li><p>改变布局参数：操作稍微复杂，使用于有交互的View</p>
</li>
</ul>
<h2 id="3-3__u5F39_u6027_u6ED1_u52A8"><a href="#3-3__u5F39_u6027_u6ED1_u52A8" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><ul>
<li><p>使用Scroller</p>
</li>
<li><p>通过动画</p>
</li>
<li><p>使用Handler延时策略</p>
</li>
</ul>
<h2 id="3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236"><a href="#3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236" class="headerlink" title="3.4 View的事件分发机制"></a>3.4 View的事件分发机制</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View。即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>主要过程：Activity的dispatchTouchEvent–&gt;Window的superDispatchTouchEvent(Window实际上是一个抽象类，而它的实现类为PhoneWindow)–&gt;DecorView的superDispatchTouchEvent(DecorView是继承自FrameLayout，是Activity的根View)–&gt;分发到子View中(即分发到contentView中)。</p>
<p>注意点：</p>
<ul>
<li><p>如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
</li>
<li><p>某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。</p>
</li>
<li><p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</p>
</li>
<li><p>通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
<li><p>ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</p>
</li>
</ul>
<h2 id="3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81"><a href="#3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81" class="headerlink" title="3.5 View的滑动冲突"></a>3.5 View的滑动冲突</h2><p><strong>常见的滑动冲突场景</strong></p>
<p>常见的滑动冲突场景可以简单分为如下三种：</p>
<ul>
<li>场景1——外部滑动方向和内部滑动方向不一致</li>
<li>场景2——外部滑动方向和内部滑动方向一致</li>
<li>场景3——上面两种情况的嵌套</li>
</ul>
<p><strong>滑动冲突处理规则</strong></p>
<p>可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等</p>
<p><strong>滑动冲突的解决方式</strong></p>
<p>外部拦截法：点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。</p>
<p>伪代码如下：</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastXIntercept;
        int deltaY = y - mLastYIntercept;
        if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }

    mLastXIntercept = x;
    mLastYIntercept = y;

    return intercepted;
}
</code></pre><p>内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。</p>
<p>伪代码如下：</p>
<p>子元素：</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            getParent().requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre><p>父元素：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    int action = event.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        return false;
    }else{
        return true;
    }
}
</code></pre><h1 id="u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406"><a href="#u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="第四章：View的工作原理"></a>第四章：View的工作原理</h1><h2 id="4-1__u521D_u8BC6ViewRoot_u548CDecorView"><a href="#4-1__u521D_u8BC6ViewRoot_u548CDecorView" class="headerlink" title="4.1 初识ViewRoot和DecorView"></a>4.1 初识ViewRoot和DecorView</h2><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，这个过程可参看如下源码：</p>
<pre><code>root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
</code></pre><h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790" class="headerlink" title="第七章：Android动画深入分析"></a>第七章：Android动画深入分析</h1><h2 id="7-1_View_u52A8_u753B"><a href="#7-1_View_u52A8_u753B" class="headerlink" title="7.1 View动画"></a>7.1 View动画</h2><p>(1)Android动画可分为三大类：view动画、帧动画和属性动画，属性动画是API 11(Android 3.0)的新特性，帧动画一般也认为是view动画。<br>(2)AnimationSet的属性android:shareInterpolator表示集合中的动画是否共享同一个插值器，如果集合不指定插值器，那么子动画需要单独指定所需的插值器或者使用默认值。<br>(3)自定义动画需要继承Animation抽象类，并重新它的initialize和applyTransformation方法，在initialize方法中做一些初始化工作，在applyTransformation方法中进行相应的矩阵变换，很多时候需要采用Camera类来简化矩阵变换的过程。<br>(4)帧动画使用比较简单，但是容易引起OOM，所以在使用的时候应尽量避免使用过多尺寸较大的图片。</p>
<h2 id="7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F"><a href="#7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F" class="headerlink" title="7.2 View动画的特殊使用场景"></a>7.2 View动画的特殊使用场景</h2><p><strong>Activity的切换效果</strong></p>
<p><code>overridePendingTransition(int enterAnim, int exitAnim)</code>这个方法必须在<code>startActivity(Intent)</code>或者<code>finish()</code>之后被调用才能生效。</p>
<p>Fragment也可以添加切换动画，可以通过FragmentTransaction中的setCustomAnimations()方法来添加切换动画，这个切换动画需要是View动画。</p>
<h2 id="7-3__u5C5E_u6027_u52A8_u753B"><a href="#7-3__u5C5E_u6027_u52A8_u753B" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h2><p><strong>使用属性动画</strong></p>
<p>动画默认时间间隔为300ms，默认帧率为10ms/帧。</p>
<p>nineoldandroids对属性动画做了兼容，在API 11以前的版本其内部是通过代理View动画来实现的，因此在Android低版本上，他的本质还是View动画，尽管使用方法看起来是属性动画。</p>
<p><strong>对任意属性做动画</strong></p>
<p>属性动画的原理：属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。总结一下，我们对object的属性abc做动画，如果想让动画生效，要同时满足两个条件：</p>
<p>(1). object必须提供setAbc方法，如果动画的时候没有传递初始值，那么还要提供getAbc方法，因为系统要去取abc属性的初始值(如果这条不满足，程序直接Crash)</p>
<p>(2). object的setAbc对属性abc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类(如果这条不满足，动画无效果但不会Crash)</p>
<p>如果有时动画不生效的原因只满足条件1而未满足条件2，官方文档上告诉我们有3种解决方法：</p>
<ul>
<li>给你的对象加上get和set方法，如果你有权限的话；</li>
<li>用一个类来包装原始对象，间接为其提供get和set方法；</li>
<li>采用ValueAnimator，监听动画过程，自己实现属性的改变。</li>
</ul>
<p><strong>属性动画的工作原理</strong></p>
<h2 id="7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879"><a href="#7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879" class="headerlink" title="7.4 使用动画的注意事项"></a>7.4 使用动画的注意事项</h2><ul>
<li>OOM：尽量避免使用帧动画，使用的话应尽量避免使用过多尺寸较大的图片；</li>
<li>内存泄露：属性动画中的无限循环动画需要在Activity退出的时候及时停止，否则将导致Activity无法释放而造成内存泄露。view动画不存在这个问题；</li>
<li>兼容性问题：某些动画在3.0以下系统上有兼容性问题；</li>
<li>view动画的问题：view动画是对view的影像做动画，并不是真正的改变view的状态，因此有时候动画完成之后view无法隐藏，即setVisibility(View.GONE)失效了，此时需要调用view.clearAnimation()清除view动画才行。</li>
<li>不要使用px；</li>
<li>动画元素的交互：在android3.0以前的系统上，view动画和属性动画，新位置均无法触发点击事件，同时，老位置仍然可以触发单击事件。从3.0开始，属性动画的单击事件触发位置为移动后的位置，view动画仍然在原位置；</li>
<li>硬件加速：使用动画的过程中，建议开启硬件加速，这样会提高动画的流畅性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探MD式转场动画]]></title>
    <link href="http://yuqirong.me/2016/03/23/%E5%88%9D%E6%8E%A2MD%E5%BC%8F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yuqirong.me/2016/03/23/初探MD式转场动画/</id>
    <published>2016-03-23T08:44:22.000Z</published>
    <updated>2016-08-18T15:09:33.926Z</updated>
    <content type="html"><![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是Google在SDK中已经给我们提供了。<code>ActivityOptions</code>是 Android 5.0 及以上使用的，但是也提供了<code>ActivityOptionsCompat</code>向下兼容。</p>
<p>下面我们就来看看吧：</p>
<p>layout_item.xml(ListView的item布局)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@android:color/white"</span></span><br><span class="line">    <span class="attribute">android:padding</span>=<span class="value">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"90dip"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"65dip"</span></span><br><span class="line">        <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">        <span class="attribute">android:padding</span>=<span class="value">"1dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"2dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:singleLine</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Subhead"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"2"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_time"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentRight</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"1"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"2016-02-25 11:22:23"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorSecondary"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"12sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们会注意到在ImageView里有<code>android:transitionName=&quot;photos&quot;</code>，这正是后面需要用到的。在这里的<code>photos</code>可以任意取名。也就是说你想让哪个View在转场时表现出动画，就在哪个View的xml中添加<code>android:transitionName</code>。</p>
<p>之后就是我们点击Item时应该跳转到另一个Activity中(这里就跳转到NewsDetailActivity了)，这其中的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 5.0 使用转场动画</span></span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    ActivityOptions options = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(getActivity(),</span><br><span class="line">                    itemView.findViewById(R.id.iv_img), <span class="string">"photos"</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//让新的Activity从一个小的范围扩大到全屏</span></span><br><span class="line">    ActivityOptionsCompat options = ActivityOptionsCompat</span><br><span class="line">            .makeScaleUpAnimation(itemView, itemView.getWidth() / <span class="number">2</span>,</span><br><span class="line">                    itemView.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在Android 5.0时使用的<code>makeSceneTransitionAnimation()</code>方法中的第三个参数正是上面的<code>&quot;photos&quot;</code>。当然在5.0版本以下我们只能使用兼容的<code>ActivityOptionsCompat</code>了。</p>
<p>最后在要跳转的Activity的布局中也添加<code>android:transitionName=&quot;photos&quot;</code>，这样就形成了一个MD式转场动画了。</p>
<p>以下是NewsDetailActivity的布局xml(只截取了部分)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/iv_album"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"256dp"</span></span><br><span class="line">    <span class="attribute">android:scaleType</span>=<span class="value">"centerCrop"</span></span><br><span class="line">    <span class="attribute">android:src</span>=<span class="value">"@drawable/thumbnail_default"</span></span><br><span class="line">    <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseMode</span>=<span class="value">"parallax"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseParallaxMultiplier</span>=<span class="value">"0.7"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>好了，这样就完成了，如果你需要在NewsDetailActivity执行finish时也出现转场动画，你只需要这样做(这里只给出了<code>onBackPressed()</code>的样例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        finishAfterTransition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实关于<code>ActivityOptions</code>和<code>ActivityOptionsCompat</code>转场动画还有更多选择，可以深入研究一下。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.lxway.com/895445426.htm" target="_blank" rel="external">你所不知道的Activity转场动画——ActivityOptions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造仿Android联系人界面]]></title>
    <link href="http://yuqirong.me/2016/03/22/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E4%BB%BFAndroid%E8%81%94%E7%B3%BB%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <id>http://yuqirong.me/2016/03/22/快速打造仿Android联系人界面/</id>
    <published>2016-03-22T07:53:24.000Z</published>
    <updated>2016-08-18T15:09:33.973Z</updated>
    <content type="html"><![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这里写图片描述"></p>
<p>我们可以看到在右侧有一个支持快速索引的栏。接下来，我们就要实现这种索引栏。</p>
<p>首先是<code>attrs.xml</code>，定义了三个自定义属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"QuickIndexBar"</span>&gt;</span></span><br><span class="line">        // 字体的颜色</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"font_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        // 选中时字体的颜色</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_font_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        // 字体的大小</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"font_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后我们创建一个类继承自<code>View</code>，类名就叫<code>QuickIndexBar</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultFontColor = Color.WHITE;</span><br><span class="line"><span class="comment">// 默认选中字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultSelectedFontColor = Color.GRAY;</span><br><span class="line"><span class="comment">// 字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> fontColor;</span><br><span class="line"><span class="comment">// 选中字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> selectedFontColor;</span><br><span class="line"><span class="comment">// 字体大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> fontSize;</span><br><span class="line"><span class="comment">// 默认字体大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultfontSize = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 上次触摸的字母单元格</span></span><br><span class="line"><span class="keyword">int</span> lastSelected = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这次触摸的字母单元格</span></span><br><span class="line"><span class="keyword">int</span> selected = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.QuickIndexBar);</span><br><span class="line">    fontColor = a.getColor(R.styleable.QuickIndexBar_font_color, defaultFontColor);</span><br><span class="line">    selectedFontColor = a.getColor(R.styleable.QuickIndexBar_selected_font_color, defaultSelectedFontColor);</span><br><span class="line">    fontSize = a.getDimension(R.styleable.QuickIndexBar_font_size,</span><br><span class="line">            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, defaultfontSize,</span><br><span class="line">                    getContext().getResources().getDisplayMetrics()));</span><br><span class="line">    a.recycle();</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(fontColor);</span><br><span class="line">    mPaint.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class="line">    mPaint.setTextSize(fontSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是在构造器中初始化了自定义属性，大家应该都能看懂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速索引的字母</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] INDEX_ARRAYS = <span class="keyword">new</span> String[]&#123;<span class="string">"#"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>,</span><br><span class="line">        <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>,</span><br><span class="line">        <span class="string">"P"</span>, <span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>&#125;;</span><br><span class="line"><span class="comment">// 控件的宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"><span class="comment">// 控件的高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="comment">// 字母单元格的宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 得到控件的大小</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    width = getMeasuredWidth();</span><br><span class="line">    height = getMeasuredHeight();</span><br><span class="line">    <span class="comment">//  得到字母单元格的高度</span></span><br><span class="line">    cellHeight = height * <span class="number">1.0f</span> / INDEX_ARRAYS.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>中获取<code>width</code>和<code>height</code>。还要计算<code>cellHeight</code>,也就是<code>INDEX_ARRAYS</code>中每个字符串所占用的高度，以便在<code>onDraw(Canvas canvas)</code>中使用。</p>
<p>我们来看看<code>onDraw(Canvas canvas)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历画出index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INDEX_ARRAYS.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 测出字体的宽度</span></span><br><span class="line">        <span class="keyword">float</span> x = width / <span class="number">2</span> - mPaint.measureText(INDEX_ARRAYS[i]) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 得到字体的高度</span></span><br><span class="line">        Paint.FontMetrics fm = mPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">double</span> fontHeight = Math.ceil(fm.descent - fm.ascent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> y = (<span class="keyword">float</span>) ((i + <span class="number">1</span>) * cellHeight - cellHeight / <span class="number">2</span> + fontHeight / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == selected) &#123;</span><br><span class="line">            mPaint.setColor(lastSelected == -<span class="number">1</span> ? fontColor : selectedFontColor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPaint.setColor(fontColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绘制索引的字母 (x,y)为字母左下角的坐标</span></span><br><span class="line">        canvas.drawText(INDEX_ARRAYS[i], x, y, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中去遍历<code>INDEX_ARRAYS</code>，测量出字母的宽度和高度。这里要注意的是，<code>canvas.drawText(String text, float x, float y, Paint paint)</code>中的 x,y 指的是字母左下角的坐标，并不是“原点”。</p>
<p>别忘了我们还要对<code>QuickIndexBar</code>的触摸事件作出处理。所以我们要重写onTouchEvent(MotionEvent event)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置当索引改变的监听器</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnIndexChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当索引改变</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> selectIndex 索引值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onIndexChange</span><span class="params">(<span class="keyword">int</span> selectIndex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当手指抬起</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActionUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnIndexChangeListener</span><span class="params">(OnIndexChangeListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            y = event.getY();</span><br><span class="line">            <span class="comment">// 计算出触摸的是哪个字母单元格</span></span><br><span class="line">            selected = (<span class="keyword">int</span>) (y / cellHeight);</span><br><span class="line">            <span class="keyword">if</span> (selected &gt;= <span class="number">0</span> &amp;&amp; selected &lt; INDEX_ARRAYS.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selected != lastSelected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onIndexChange(selected); <span class="comment">// 回调监听器的方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.i(TAG, INDEX_ARRAYS[selected]);</span><br><span class="line">                &#125;</span><br><span class="line">                lastSelected = selected;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="comment">// 把上次的字母单元格重置</span></span><br><span class="line">            lastSelected = -<span class="number">1</span>;</span><br><span class="line">            listener.onActionUp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate(); <span class="comment">// 重绘视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ACTION_DOWN</code>和<code>ACTION_MOVE</code>计算出了触摸的y值对应的是索引中的哪个字母，然后回调了监听器；而在<code>ACTION_UP</code>中重置了<code>lastSelected</code>，回调了监听器。</p>
<p>这样，我们就把<code>QuickIndexBar</code>写好了，关于<code>QuickIndexBar</code>使用的代码就不贴出来了，太长了。如果有需要，可以下载下面的Demo，里面都有注释。Demo的效果图如下：</p>
<p><img src="/uploads/20160322/20160322211942.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这里了。have fun!</p>
<p>源码下载：</p>
<p><a href="/uploads/20160322/ContactPicker.rar">ContactPicker.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/ContactPicker" target="_blank" rel="external">ContactPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[夜半一忆]]></title>
    <link href="http://yuqirong.me/2016/03/17/%E5%A4%9C%E5%8D%8A%E4%B8%80%E5%BF%86/"/>
    <id>http://yuqirong.me/2016/03/17/夜半一忆/</id>
    <published>2016-03-17T15:13:58.000Z</published>
    <updated>2016-08-18T15:09:33.942Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>素时锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈何岁月，流于昨日。雁过一鸣，惊于何人？花开花谢，润土无声。</p>
<p>繁华落尽，只道是人间凄凉。穷极一生，只为还清一世业障。</p>
<p>高山流水，静谧成寂。秋风落叶，随风飘散。</p>
<p>别时易，相逢难，烈酒灼心，忆似水年华。</p>
<p>乍暖还寒，大梦初醒，此夜无眠。</p>
<p>仰天大笑，岂是蓬蒿人？</p>
<p>————记于开题答辩之日</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=0&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>素时锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/03/08/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/03/08/《Android群英传》笔记(下)/</id>
    <published>2016-03-08T12:22:27.000Z</published>
    <updated>2016-08-18T15:09:33.864Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7" class="headerlink" title="第六章：Android绘图机制与处理技巧"></a>第六章：Android绘图机制与处理技巧</h1><h2 id="6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F"><a href="#6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F" class="headerlink" title="6.1 屏幕的尺寸信息"></a>6.1 屏幕的尺寸信息</h2><p>系统屏幕密度如下</p>
<ul>
<li>ldpi—120—240X320分辨率</li>
<li>mdpi—160—320X480分辨率</li>
<li>hdpi—240—480X800分辨率</li>
<li>xhdpi—320—720X1280分辨率</li>
<li>xxhdpi—480—1080X1920分辨率</li>
</ul>
<p>Android系统使用mdpi即密度值为160的屏幕作为标准，在这屏幕上1px = 1dp。</p>
<p>所以各个分辨率直接的换算比例，即ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12</p>
<p>下面给出单位转换的源码：</p>
<pre><code>public class DisplayUtil {

    /**
     * 把px值转换为dip或dp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2dip(Context context, float pxValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (pxValue / scale + 0.5f);
    }

    /**
     * 把dip值或dp值转换为px值
     *
     * @param context
     * @param dipValue
     * @return
     */
    public static int dip2px(Context context, float dipValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (dipValue * scale + 0.5f);
    }

    /**
     * 将px值转换为sp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2sp(Context context, float pxValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (pxValue / fontScale + 0.5f);
    }

    /**
     * 将sp值转换为px值
     * @param context
     * @param spValue
     * @return
     */
    public static int sp2px(Context context, float spValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (spValue * fontScale + 0.5f);
    }

}
</code></pre><h2 id="6-2_2D_u7ED8_u56FE_u57FA_u7840"><a href="#6-2_2D_u7ED8_u56FE_u57FA_u7840" class="headerlink" title="6.2 2D绘图基础"></a>6.2 2D绘图基础</h2><p>Paint类的一些属性和对应的功能：</p>
<ul>
<li>setAntiAlias(); //设置画笔的锯齿效果</li>
<li>setColor(); //设置画笔的颜色</li>
<li>setARGB(); //设置画笔的A,R,G,B的值</li>
<li>setAlpha(); //设置画笔的Alpha值</li>
<li>setTextSize(); //设置字体的尺寸</li>
<li>setStyle(); //设置画笔的风格（空心或者实心）</li>
<li>setStrokeWidth(); //设置空心边框的宽度</li>
</ul>
<p>Canvas类主要的绘画功能：</p>
<ul>
<li>canvas.drawPoint(x,y,paint); //绘制点</li>
<li>canvas.drawLine(startX,startY,endX,endY,paint); //绘制直线</li>
<li>canvas.drawRect(left,top,right,bottom,paint); //绘制矩形</li>
<li>canvas.drawRoundRect(left,top,right,bottom,radiusX,radiusY,paint); //绘制圆角矩形</li>
<li>canvas.drawCircle(circleX,circleY,radius,paint); //绘制圆</li>
<li>canvas.drawOval(left,top,right,bottom,paint); //通过椭圆的外接矩形来绘制椭圆</li>
<li>canvas.drawText(text,startX,startY,paint); //绘制文字</li>
<li>canvas.drawPosText(text,new float[]{x1,y1,…,xn,yn},paint); //指定位置绘制文本</li>
</ul>
<h2 id="6-3_Android_XML_u7ED8_u56FE"><a href="#6-3_Android_XML_u7ED8_u56FE" class="headerlink" title="6.3 Android XML绘图"></a>6.3 Android XML绘图</h2><ul>
<li><p>Bitmap：</p>
<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:src=&quot;@drawable/ic_launcher&quot;/&gt;
</code></pre><p>  这样就能直接将图片转成bitmap在程序中使用了。</p>
</li>
<li><p>Shape:</p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:shape=&quot;line|oval|ring|rectangle&quot;&gt;
  &lt;!--默认为rectangle--&gt;
  &lt;corners
      android:bottomLeftRadius=&quot;integer&quot;
      android:bottomRightRadius=&quot;integer&quot;
      android:radius=&quot;integer&quot;
      android:topLeftRadius=&quot;integer&quot;
      android:topRightRadius=&quot;integer&quot; /&gt;
  &lt;!--当shape为rectangle时才有，radius默认为1dp--&gt;

  &lt;gradient
      android:angle=&quot;integer&quot;
      android:centerColor=&quot;color&quot;
      android:centerX=&quot;integer&quot;
      android:centerY=&quot;integer&quot;
      android:endColor=&quot;color&quot;
      android:gradientRadius=&quot;integer&quot;
      android:startColor=&quot;color&quot;
      android:type=&quot;linear|radial|sweep&quot;
      android:useLevel=&quot;boolean&quot; /&gt;

  &lt;padding
      android:bottom=&quot;integer&quot;
      android:left=&quot;integer&quot;
      android:right=&quot;integer&quot;
      android:top=&quot;integer&quot; /&gt;

  &lt;size
      android:width=&quot;integer&quot;
      android:height=&quot;integer&quot; /&gt;
  &lt;!--指定大小，一般用在imageview配合scaleType使用--&gt;

  &lt;solid android:color=&quot;color&quot; /&gt;
  &lt;!--填充颜色--&gt;
  &lt;stroke
      android:width=&quot;integer&quot;
      android:color=&quot;color&quot;
      android:dashGap=&quot;integer&quot;
      android:dashWidth=&quot;integer&quot; /&gt;
  &lt;!--边框,dashGap为虚线间隔宽度，dashWidth为虚线宽度--&gt;
&lt;/shape&gt;
</code></pre></li>
<li><p>Layer:实现类似Photoshop中图层的概念。</p>
<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:drawable=&quot;@mipmap/ic_launcher&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;10dp&quot;
      android:top=&quot;10dp&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;20dp&quot;
      android:top=&quot;20dp&quot; /&gt;
&lt;/layer-list&gt;
</code></pre></li>
<li><p>Selector：通常用于view的触摸反馈。</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:state_pressed=&quot;true&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#334444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
  &lt;item android:state_pressed=&quot;false&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#444444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
&lt;/selector&gt;
</code></pre></li>
</ul>
<h2 id="6-4_Android_u7ED8_u56FE_u6280_u5DE7"><a href="#6-4_Android_u7ED8_u56FE_u6280_u5DE7" class="headerlink" title="6.4 Android绘图技巧"></a>6.4 Android绘图技巧</h2><ul>
<li><p>Canvas.save():保存画布。它的作用就是将之前的所有已绘制图像保存起来，让后续的操作就好像在一个新的图层上操作一样。</p>
</li>
<li><p>Canvas.restore():合并图层操作。它的作用就是将我们在save()之后绘制的所有图像与save()之前的图像进行合并。</p>
</li>
<li><p>Canvas.translate():画布平移，可理解为坐标系的平移。如在之前绘制的坐标系原点在(0,0)。在translate(x,y)之后，坐标原点在(x,y)。要注意的是，并不是移动至(x,y)点，而是在原先的基础上加上x和y。比如原先canvas位于(100,200)，translate(x,y)后，canvas位于(100+x,200+y)</p>
</li>
<li><p>Canvas.rotate():画布翻转，可理解为坐标系的翻转。canvas.rotate(30);为按照坐标系的原点顺时针旋转30度。canvas.rotate(30,x,y);为按照坐标系的(x,y)点顺时针旋转30度。</p>
</li>
<li><p>Canvas.saveLayer()、Canvas.saveLayerAlpha():将一个图层入栈。</p>
</li>
<li><p>Canvas.restore()、Canvas.restoreToCount():将一个图层出栈。</p>
</li>
</ul>
<h2 id="6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406"><a href="#6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406" class="headerlink" title="6.5 Android图像处理之色彩特效处理"></a>6.5 Android图像处理之色彩特效处理</h2><ul>
<li><p>色调：<code>setRotate(int axis,float degree)</code>设置颜色的色调。第一个参数，系统分别使用0、1、2来代表Red、Green、Blue三种颜色的处理。而第二个参数就是需要处理的值。</p>
<pre><code>ColorMatrix hueMatrix = new ColorMatrix();
hueMatrix.setRotate(0, hue0);
hueMatrix.setRotate(1, hue1);
hueMatrix.setRotate(2, hue2);
</code></pre></li>
</ul>
<p>通过上面的方法，可以为RGB三种颜色分量分别重新设置了不同的色调值。</p>
<ul>
<li><p>饱和度：<code>setSaturation(float sat)</code>方法来设置颜色的饱和度，参数即代表设置颜色饱和度的值，代码如下所示。当饱和度为0时，图像就变成灰色图像了。</p>
<pre><code>ColorMatrix saturationMatrix = new ColorMatrix();
saturationMatrix.setSaturation(saturation);
</code></pre></li>
<li><p>亮度：当三原色以相同的比例进行混合的时候，就会显示出白色。系统也正是使用这个原理来改变一个图像的亮度的，代码如下所示。当亮度为0时，图像就变成全黑了。</p>
<pre><code>ColorMatrix lumMatrix = new ColorMatrix();
lumMatrix.setScale(lum,lum,lum,1);
</code></pre></li>
<li><p><code>postConcat()</code>方法将矩阵的作用效果混合，从而叠加处理效果，代码如下：</p>
<pre><code>ColorMatrix imageMatrix = new ColorMatrix();
imageMatrix.postConcat(hueMatrix);
imageMatrix.postConcat(saturationMatrix);
imageMatrix.postConcat(lumMatrix);
</code></pre></li>
</ul>
<h2 id="6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406"><a href="#6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h2><ul>
<li>matrix.setRotate()——旋转变换</li>
<li>matrix.setTranslate()——平移变换</li>
<li>matrix.setScale()——缩放变换</li>
<li>matrix.setSkew()——错切变换</li>
<li>pre()和post()——提供矩阵的前乘和后乘运算</li>
</ul>
<h2 id="6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406"><a href="#6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406" class="headerlink" title="6.7 Android图像处理之画笔特效处理"></a>6.7 Android图像处理之画笔特效处理</h2><pre><code>mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
</code></pre><p>可以实现圆形ImageView。</p>
<p>// TODO</p>
<p><strong>Shader</strong></p>
<p>Shader又称之为着色器、渲染器，它用来实现一系列的渐变、渲染效果。在Android中的Shader包括以下几种：</p>
<ul>
<li>BitmapShader 位图Shader</li>
<li>LinearGradient 线性Shader</li>
<li>RadialGradient 光束Shader</li>
<li>SweepGradient 梯度Shader</li>
<li>ComposeShader 混合Shader</li>
</ul>
<p>除第一个Shader以外 其他Shader都实现了名副其实的渐变。BitmapShader产生的是一个位图，它的作用就是通过Paint对画布进行指定Bitmap的填充，填充有以下几种模式可以选择：</p>
<ul>
<li>CLAMP拉伸——拉伸的是图片最后一个像素 不断重复</li>
<li>REPEAT重复——横向纵向不断重复</li>
<li>MIRROR镜像——横向不断翻转重复，纵向不断翻转重复</li>
</ul>
<p><strong>PathEffect</strong></p>
<p>PathEffect是指用各种笔触效果来绘制一个路径。</p>
<ul>
<li>ConrnerPathEffect 就是将拐角变得圆滑，具体圆滑的程度，则由参数决定</li>
<li>DiscretePathEffect 使用这个效果后，线段上就会产生许多杂点。</li>
<li>DashPathEffect 这个效果可以用来绘制虚线，用一个数组来设置各个点之间的间隔。另一个参数phase则用来控制绘制时数组的一个偏移量。通常可以通过设置值来实现路径的动态效果。</li>
<li>PathDashPathEffect 与前面的DashPathEffect类似，只不过它的功能更加强大，可以设置显示点的图形，即方形点的虚线，圆形点的虚线。</li>
<li>ComposePathEffect 组合PathEffect，将任意两种路径特性组合起来形成一种新的效果。</li>
</ul>
<h2 id="6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView"><a href="#6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView" class="headerlink" title="6.8 View之孪生兄弟——SurfaceView"></a>6.8 View之孪生兄弟——SurfaceView</h2><p>SurfaceView与view的区别：  </p>
<ul>
<li>View主要适用于主动更新的情况下，而SurfaceView 主要适用于被动更新，例如频繁的刷新。</li>
<li>View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新。 </li>
<li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了双缓冲。</li>
</ul>
<p>总结成一句话就是，如果你的自定义View需要频繁刷新，或者刷新时数据处理量比较大，那你就可以考虑使用SurfaceView来取代View了。</p>
<p>SurfaceView模版代码：</p>
<pre><code>public class MySurfaceView extends SurfaceView implements Runnable, SurfaceHolder.Callback {
  //SurfaceHolder
  private SurfaceHolder mSurfaceHolder;
  //用于绘图的Canvas
  private Canvas mCanvas;
  //子线程标志位
  private boolean mIsDrawing;

  public MySurfaceView(Context context) {
      super(context);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs) {
      super(context, attrs);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      init();
  }
  private void init() {
      mSurfaceHolder = getHolder();
      mSurfaceHolder.addCallback(this);
      setFocusable(true);
      setFocusableInTouchMode(true);
      this.setKeepScreenOn(true);
      //mSurfaceHolder.setFormat(PixelFormat.OPAQUE);
  }
  @Override
  public void surfaceCreated(SurfaceHolder holder) {
      mIsDrawing = true;
      new Thread(this).start();
  }
  @Override
  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
  }
  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
      mIsDrawing = false;
  }
  @Override
  public void run() {
      while (mIsDrawing) {
          draw();
      }
  }
  private void draw() {
      try {
          //每次获得的canvas对象都是上次的 因此上次的绘画操作都会保存
          mCanvas = mSurfaceHolder.lockCanvas();
          //draw here
      } catch (Exception e) {

      } finally {
          if (mCanvas != null) {
              // 对画布内容进行提交
              mSurfaceHolder.unlockCanvasAndPost(mCanvas);
          }
      }

  }
}
</code></pre><h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第七章：Android动画机制与使用技巧"></a>第七章：Android动画机制与使用技巧</h1><h2 id="7-1_Android_View_u52A8_u753B_u6846_u67B6"><a href="#7-1_Android_View_u52A8_u753B_u6846_u67B6" class="headerlink" title="7.1 Android View动画框架"></a>7.1 Android View动画框架</h2><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，而且控制的是整个View，实现的原理是绘制视图时 View 所在的 ViewGroup 中的 drawChild 函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix()),通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
<ul>
<li>透明度动画：AlphaAnimation</li>
<li>旋转动画：RotateAnimation</li>
<li>位移动画：TranslateAnimation</li>
<li>缩放动画：ScaleAnimation</li>
</ul>
<p>动画集合：AnimationSet</p>
<p>动画监听器：setAnimationListener(new Animation.AnimationListener(){…})</p>
<h2 id="7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790"><a href="#7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790" class="headerlink" title="7.2 Android属性动画分析"></a>7.2 Android属性动画分析</h2><p><strong>ObjectAnimator</strong>：属性动画框架中最重要的实行类。</p>
<p>用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.setDuration(300);
animator.start();
</code></pre><p>注意：操纵的属性(即上面的“translationX”)必须具有get、set方法，不然ObjectAnimator就无法起效。因为内部会通过Java反射机制来调用set函数修改对象属性值。</p>
<p>常用属性值：</p>
<ul>
<li>translationX和translationY</li>
<li>rotation、rotationX和rotationY</li>
<li>scaleX和scaleY</li>
<li>pivotX和pivotY</li>
<li>x和y</li>
<li>alpha</li>
</ul>
<p><strong>PropertyValuesHolder</strong>：类似于视图动画中的AnimationSet。在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</p>
<p>用法：</p>
<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;,300f);
PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0,1f);
PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;,1f,0,1f);
ObjectAnimator.ofPropertyValuesHolder(view,pvh1,pvh2,pvh3).setDuration(1000).start();
</code></pre><p><strong>ValueAnimator</strong>：ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</p>
<p>用法：</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0,100);
animator.setTarget(view);
animator.setDuration(1000).start();
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Float value = (Float) animation.getAnimatedValue();
        // TODO use the value
    }
});
</code></pre><p>在ValueAnimator的AnimatorUpdateListener中监听数值的变换，从而完成动画的变换。</p>
<p><strong>AnimatorListener和AnimatorListenerAdapter</strong>：动画事件的监听。</p>
<p>AnimatorListener用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
});
</code></pre><p>AnimatorListenerAdapter用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><p><strong>AnimatorSet</strong>：AnimatorSet不仅能实现一个属性同时作用多个属性动画效果，同时也能实现更为精确的顺序控制。</p>
<p>用法(实现上面使用PropertyValuesHolder的动画效果)：</p>
<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
    ObjectAnimator animator2 = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1f,0f,1f);
    ObjectAnimator animator3 = ObjectAnimator.ofFloat(view,&quot;scaleY&quot;,1f,0f,1f);
    AnimatorSet set = new AnimatorSet();
    set.setDuration(1000);
    set.playTogether(animator1,animator2,animator3);
    set.start();
</code></pre><p>还有playTogether()、playSequentially()、animSet.play()、with()、before()、after()来协同工作。</p>
<p><strong>在XML中使用属性动画</strong>：在res里新建文件夹animator。</p>
<p>anim_scalex.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:propertyName=&quot;scaleX&quot;
    android:valueFrom=&quot;1.0&quot;
    android:valueTo=&quot;2.0&quot;
    android:valueType=&quot;floatType&quot;&gt;
&lt;/objectAnimator&gt; 
</code></pre><p>在代码中加载xml属性动画：</p>
<pre><code>public void scaleX(View view) {
    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.anim_scalex);  
    anim.setTarget(view);  
    anim.start();
}
</code></pre><p>另附 XML文件中定义两个objectAnimator：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:ordering=&quot;together&quot; &gt;  

    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleX&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  
    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleY&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  

&lt;/set&gt; 
</code></pre><p><strong>View的animate方法</strong>：可以认为是属性动画的一种简写方式。</p>
<p>用法：</p>
<pre><code>view.animate()
    .alpha(0)
    .y(300)
    .setDuration(300)
    .withStartAction(new Runnable() {
        @Override
        public void run() {

        }
    }).withEndAction(new Runnable() {
        @Override
        public void run() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {

                }
            });
        }
    }).start();
</code></pre><h2 id="7-3_Android_u5E03_u5C40_u52A8_u753B"><a href="#7-3_Android_u5E03_u5C40_u52A8_u753B" class="headerlink" title="7.3 Android布局动画"></a>7.3 Android布局动画</h2><p>最简单的布局动画是在ViewGroup的XML中，使用以下打开布局动画。<br><code>android:animateLayoutChanges=&quot;true&quot;</code><br>通过上面的代码，当ViewGroup添加View时，子View会呈现逐渐显示的过渡效果，是Android默认的显示的过渡效果。</p>
<p><strong>LayoutAnimationController</strong></p>
<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);
// 设置过渡动画
ScaleAnimation scaleAnimation = new ScaleAnimation(0,1,0,1);
scaleAnimation.setDuration(2000);
// 设置布局动画的显示属性
LayoutAnimationController lac = new LayoutAnimationController(scaleAnimation,0.5f);
lac.setOrder(LayoutAnimationController.ORDER_NORMAL);
ll.setLayoutAnimation(lac);
</code></pre><p>LayoutAnimationController的第一个参数是作用的动画，第二个参数是每个View显示的delay时间。当delay时间不为0时，可以设置子View显示的顺序，如下所示。</p>
<ul>
<li>LayoutAnimationController.ORDER_NORMAL  顺序</li>
<li>LayoutAnimationController.ORDER_RANDOM  随机</li>
<li>LayoutAnimationController.ORDER_REVERSE 反序</li>
</ul>
<h2 id="7-4_Interpolators_28_u63D2_u503C_u5668_29"><a href="#7-4_Interpolators_28_u63D2_u503C_u5668_29" class="headerlink" title="7.4 Interpolators(插值器)"></a>7.4 Interpolators(插值器)</h2><h2 id="7-5__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#7-5__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="7.5 自定义动画"></a>7.5 自定义动画</h2><p>首先继承Animation类，实现<code>applyTransformation(float interpolatedTime, Transformation t)</code>的逻辑。不过通常情况下，还要覆盖父类的<code>initialize(int width, int height, int parentWidth, int parentHeight)</code>实现一些初始化的工作。</p>
<p><code>applyTransformation(float interpolatedTime, Transformation t)</code>第一个参数是插值器的时间因子，这个因子由动画当前完成的百分比和当前时间所对应的插值所计算得来的，取值为0到1.0。第二个参数是矩阵的封装类，一般使用这个类来获取当前的矩阵对象，代码如下：</p>
<pre><code>final Matrix matrix = t.getMatrix();
</code></pre><p>下面给出电视机关闭效果的动画：</p>
<pre><code>@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    final Matrix matrix = t.getMatrix();
    matrix.preScale(1, 1 - interpolatedTime, mCenterWidth, mCenterHeight);
}
</code></pre><p>//TODO</p>
<h2 id="7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236"><a href="#7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236" class="headerlink" title="7.6 Android 5.X SVG 矢量动画机制"></a>7.6 Android 5.X SVG 矢量动画机制</h2><p>Google在Android 5.X中提供了下面两个新的API来帮助支持SVG：</p>
<ul>
<li>VectorDrawable</li>
<li>AnimatedVectorDrawable</li>
</ul>
<p>下面给出SVG图形：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:width=&quot;200dp&quot;
    android:height=&quot;200dp&quot;
    android:viewportHeight=&quot;100&quot;
    android:viewportWidth=&quot;100&quot;&gt;

    &lt;group
        android:name=&quot;test&quot;
        android:rotation=&quot;0&quot;&gt;
        &lt;path
            android:fillColor=&quot;@android:color/holo_blue_light&quot;
            android:pathData=&quot;M 25 50
            a 25,25 0 1,0 50,0&quot; /&gt;
    &lt;/group&gt;

&lt;/vector&gt;
</code></pre><p> //TODO</p>
<h1 id="u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790"><a href="#u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790" class="headerlink" title="第八章：Activity与Activity调用栈分析"></a>第八章：Activity与Activity调用栈分析</h1><h2 id="8-1_Activity"><a href="#8-1_Activity" class="headerlink" title="8.1 Activity"></a>8.1 Activity</h2><p>Activity的形态：</p>
<ul>
<li><p>Active/Running : 这时候Activity处于Activity栈的最顶层，可见，并与用户进行交互。</p>
</li>
<li><p>Paused : 当Activity失去焦点，被一个新的非全屏的Activity或者一个透明的Activity放置在栈顶时，Activity就转化为Paused形态。但它只是失去了与用户交互的能力，所有状态信息、成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。</p>
</li>
<li><p>Stopped : 如果一个Activity被另一个Activity完全覆盖，那么Activity就会进入Stopped形态，此时，它不再可见，但却依然保持了所有状态信息和成员变量。</p>
</li>
<li><p>Killed : 当Activity被系统回收掉或者Activity从来没有创建过，Activity就处于Killed状态。</p>
</li>
</ul>
<p>Activity启动与销毁过程：</p>
<ul>
<li><p>onCreate() ： 创建基本的UI元素。</p>
</li>
<li><p>onPause()和onStop() ： 清除Activity的资源，避免浪费。</p>
</li>
<li><p>onDestory() ： 因为引用会在Activity销毁的时候销毁，而线程不会，所以清除开启的线程。</p>
</li>
</ul>
<p>Activity的暂停与恢复过程：</p>
<ul>
<li><p>onPause() ： 释放系统资源，如Camera、sensor、receivers。</p>
</li>
<li><p>onResume() ： 需要重新初始化在onPause()中释放资源。</p>
</li>
</ul>
<p>Activity的停止过程：</p>
<ul>
<li><p>由部分不可见到完全不可见 ： onPause() -&gt; onStop()</p>
</li>
<li><p>由部分不可见到可见： onPause() -&gt; onStop() -&gt; onRestart() -&gt; onStart() -&gt; onResume()</p>
</li>
</ul>
<p>Activity的重新创建过程：</p>
<p>如果用户finish()方法结束了Activity，则不会调用onSaveInstanceState()。</p>
<h2 id="8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB"><a href="#8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB" class="headerlink" title="8.2 Android任务栈简介"></a>8.2 Android任务栈简介</h2><p>一个Task中的Activity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</p>
<h2 id="8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F"><a href="#8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.3 AndroidMainifest启动模式"></a>8.3 AndroidMainifest启动模式</h2><ul>
<li><p>standard ： 默认的启动模式，每次都会创建新的实例</p>
</li>
<li><p>singleTop ：   通常适用于接收到消息后显示的界面</p>
</li>
<li><p>singleTask ： 通常可以用来退出整个应用：将主Activity设为singleTask模式，然后在要退出的Activity中转到主Activity，从而将主Activity之上的Activity都清除，然后重写主Activity的onNewIntent()方法，在方法中加上一句finish()，将最后一个Activity结束掉。</p>
</li>
<li><p>singleInstance ： 申明为singleInstance的Activity会出现在一个新的任务栈中，而且该任务栈中只存在这一个Activity。举个例子，如果应用A的任务栈中创建了MainActivity的实例，且启动模式为singleInstance，如果应用B的也要激活MainActivity，则不需要创建，两个应用共享该Activity实例。这种启动模式常用于需要与程序分离的界面。</p>
</li>
</ul>
<p>关于singleTop和singleInstance这两种启动模式还有一点需要特殊说明：如果在一个singleTop或者singleInstance的Activity A中通过startActivityForResult()方法来启动另一个Activity B，那么直接返回Activity.RESULT_CANCELED而不会再去等待返回。这是由于系统在Framework层做了对这两种启动模式的限制，因为Android开发者认为，不同Task之间，默认是不能传递数据的，如果一定要传递，那么只能通过Intent来绑定数据。</p>
<h2 id="8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F"><a href="#8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.4 Intent Flag启动模式"></a>8.4 Intent Flag启动模式</h2><ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于在Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：使用singleTask模式来启动一个Activity，与指定android:launchMode=”singleTask”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_NO_HISTORY：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。例如A-B，B中以这种模式启动C，C再启动D，则当前Activity栈为ABD。</p>
</li>
</ul>
<h2 id="8-5__u6E05_u7A7A_u4EFB_u52A1_u6808"><a href="#8-5__u6E05_u7A7A_u4EFB_u52A1_u6808" class="headerlink" title="8.5 清空任务栈"></a>8.5 清空任务栈</h2><ul>
<li><p>clearTaskOnLaunch：每次返回该Activity时，都将该Activity之上的所有Activity都清除。通过这个属性，可以让这个Task每次在初始化的时候，都只有这一个Activity。</p>
</li>
<li><p>finishOnTaskLaunch：finishOnTaskLaunch属性与clearTaskOnLaunch属性类似，只不过clearTaskOnLaunch作用在别人身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所处的Task，那么用户再返回时，该Activity就会被finish掉。</p>
</li>
<li><p>alwaysRetainTaskState：如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。</p>
</li>
</ul>
<h1 id="u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236"><a href="#u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236" class="headerlink" title="第九章：Android系统信息与安全机制"></a>第九章：Android系统信息与安全机制</h1><h2 id="9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6"><a href="#9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6" class="headerlink" title="9.1 Android系统信息获取"></a>9.1 Android系统信息获取</h2><p>要获取系统的配置信息，通常可以从以下两个方面获取：</p>
<ul>
<li>android.os.Build</li>
<li>SystemProperty</li>
</ul>
<p>下面列举了android.os.Build一些常用的信息：</p>
<ul>
<li>Build.BOARD // 主板</li>
<li>Build.BRAND // Android系统定制商</li>
<li>Build.SUPPORTED_ABIS // CPU指令集</li>
<li>Build.DEVICE // 设备参数</li>
<li>Build.DISPLAY // 显示屏参数</li>
<li>Build.FINGERPRINT // 唯一编号</li>
<li>Build.SERIAL // 硬件序列号</li>
<li>Build.ID // 修订版本列表</li>
<li>Build.MANUFACTURER // 硬件制造商</li>
<li>Build.MODEL // 版本</li>
<li>Build.HARDWARE // 硬件名</li>
<li>Build.PRODUCT // 手机产品名</li>
<li>Build.TAGS // 描述Build的标签</li>
<li>Build.TYPE // Builder类型</li>
<li>Build.VERSION.CODENAME // 当前开发代号</li>
<li>Build.VERSION.INCREMENTAL // 源码控制版本号</li>
<li>Build.VERSION.RELEASE // 版本字符串</li>
<li>Build.VERSION.SDK_INT // 版本号</li>
<li>Build.HOST // Host值</li>
<li>Build.USER // User名</li>
<li>Build.TIME // 编译时间</li>
</ul>
<p>下面列举了SystemProperty常用的信息：</p>
<ul>
<li>os.version // OS版本</li>
<li>os.name // OS名称</li>
<li>os.arch // OS架构</li>
<li>user.home // Home属性</li>
<li>user.name // Name属性</li>
<li>user.dir //Dir属性</li>
<li>user.timezone // 时区</li>
<li>path.separator // 路径分隔符</li>
<li>line.separator // 行分隔符</li>
<li>file.separator // 文件分隔符</li>
<li>java.vendor.url // Java Vendor URL 属性</li>
<li>java.class.path // Java Class 路径</li>
<li>java.class.version Java Class 版本</li>
<li>java.vendor // Java Vendor 属性</li>
<li>java.version // Java 版本</li>
<li>java.home // Java Home 属性</li>
</ul>
<p>我们可以访问到系统的属性值，代码如下所示：</p>
<pre><code>String board = Build.BOARD;
String brand = Build.BRAND;

String os_version = System.getProperty(&quot;os.version&quot;);
String os_name = System.getProperty(&quot;os.name&quot;);
</code></pre><h2 id="9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager"><a href="#9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager" class="headerlink" title="9.2 Android Apk应用信息获取之PackageManager"></a>9.2 Android Apk应用信息获取之PackageManager</h2><p>Android系统提供了PackageManager来负责管理所有已安装的App。其中封装的信息如下：</p>
<ul>
<li>ActivityInfo：Mainfest文件中<activity\></activity\>和<receiver\></receiver\>之间的所有信息，包括name、icon、label、launchmode等。</li>
<li>ServiceInfo：封装了<service\></service\>之间的所有信息。</li>
<li>ApplicationInfo：封装了<application\></application\>之间的信息，不过特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在SDCard上的应用等，通过这些Flag，可以很方便的判断应用类型。</li>
<li>PackageInfo：PackageInfo与前面三个Info类似，都是用于封装Mainfest文件的相关节点信息，而它包含了所以Activity、Service等信息。</li>
<li>ResolveInfo：封装的是包含<intent\>信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含<intent\>的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</intent\></intent\></li>
</ul>
<p>PackageManager常用方法如下：</p>
<ul>
<li>getPackageManager：通过调用这个方法返回一个PackageManager对象。</li>
<li>getApplicationInfo：以ApplicationInfo的形式返回指定包名的ApplicationInfo。</li>
<li>getApplicationIcon：返回指定包名的Icon。</li>
<li>getInstallApplication：以ApplicationInfo的形式返回安装的应用。</li>
<li>getInstalledPackages：以PackageInfo的形式返回安装的应用。</li>
<li>queryIntentActivities：返回指定intent的ResolveInfo对象、Activity集合。</li>
<li>queryIntentServices：返回指定intent的ResolveInfo对象、Service集合。</li>
<li>resolveActivity：返回指定Intent的Activity。</li>
<li>resolveService：返回指定Intent的Service。</li>
</ul>
<p>判断App类型的依据，就是利用ApplicationInfo中的FLAG_SYSTEM来进行判断，代码如下所示：</p>
<pre><code>app.flags &amp; ApplicationInfo.FLAG_SYSTEM
</code></pre><ul>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM != 0</code>则为系统应用；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM &lt;= 0</code>则为第三方应用；</li>
<li>特殊的，当系统应用经过升级后，也将成为第三方应用：<code>flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP != 0</code>；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE != 0</code>则为安装在SDCard上的应用。</li>
</ul>
<h2 id="9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager"><a href="#9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager" class="headerlink" title="9.3 Android Apk应用信息获取之ActivityManager"></a>9.3 Android Apk应用信息获取之ActivityManager</h2><p>ActivityManager可以获得在运行的应用程序信息。其中封装的信息如下：</p>
<ul>
<li>ActivityManager.MemoryInfo：MemoryInfo有几个非常重要的字段，availMem–系统可用内存，totalMem–总内存，threshold–低内存的阈值，即区分是否低内存的临界值，lowMemory–是否处于低内存。</li>
<li>Debug.MemoryInfo：ActivityManager.MemoryInfo用于统计全局的内存信息，而Debug.MemoryInfo用于统计进程下的内存信息。</li>
<li>RunningAppProcessInfo：进程相关的信息，processName–进程名，pid–进程pid，uid–进程uid，pkgList–该进程下的所有包。</li>
<li>RunningServiceInfo：用于封装运行的服务信息，在它里面包含一些服务进程的信息，同时还有一些其他信息。activeSince–第一次被激活的时间、方式，foreground–服务是否在后台执行。</li>
</ul>
<h2 id="9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F"><a href="#9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F" class="headerlink" title="9.4 解析Packages.xml获取系统信息"></a>9.4 解析Packages.xml获取系统信息</h2><p>packages.xml在 data/system/目录下。</p>
<h2 id="9-5_Android_u5B89_u5168_u673A_u5236"><a href="#9-5_Android_u5B89_u5168_u673A_u5236" class="headerlink" title="9.5 Android安全机制"></a>9.5 Android安全机制</h2><p>反编译：</p>
<ul>
<li>apktool(反编译XML) ： <code>java -jar apktool_2.1.0.jar d test.apk</code></li>
<li>apktool(重新打包) ： <code>java -jar apktool_2.1.0.jar b test</code></li>
<li>Dex2jar、jd-gui ：<code>d2j-dex2jar.bat classes.dex</code></li>
</ul>
<p>Android Apk 加密：</p>
<p>打开build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能，proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><h1 id="u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十章：Android性能优化"></a>第十章：Android性能优化</h1><h2 id="10-1__u5E03_u5C40_u4F18_u5316"><a href="#10-1__u5E03_u5C40_u4F18_u5316" class="headerlink" title="10.1 布局优化"></a>10.1 布局优化</h2><ul>
<li><p>Android UI渲染机制</p>
<p>  在Android中，系统通过VSYNC信号出发对UI的渲染、重绘，其间隔时间是16ms。这个16ms其实就是1000ms中显示60帧画面的单位时间（玩游戏的就该知道，大于等于60帧就感觉不到卡顿）。Android系统提供了检测UI渲染时间的工具，打开“开发者选项”，选择“Profile GPU Rendering”（我的手机是“GPU呈现模式分析”），选中“On screen as bars”（我的为“在屏幕上显示为条形图”）。每一条柱状线都包括三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间，中间绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。</p>
</li>
<li><p>避免Overdraw</p>
<p>  过渡绘制会浪费很多CPU、GPU资源，例如系统默认会绘制Activity的背景，而如果再给布局绘制了重叠的背景，那么默认Activity的背景就属于无效的过渡绘制。Android系统在开发者选项中提供了这样一个检测工具–“Enable GPU Overdraw”。借助它可以判断Overdraw的次数。尽量增大蓝色的区域，减少红色的区域。</p>
</li>
<li><p>优化布局层级</p>
<p>  在Android中系统对View的测量、布局和绘制都是通过遍历View树来进行的，如果View树太高，就会影响其速度，Google也建议View树的高度不宜超过10层。</p>
</li>
<li><p>避免嵌套过多无用布局</p>
<ul>
<li>使用<include\>标签重用Layout</include\></li>
<li><p>使用<viewstub\>实现View的延迟加载</viewstub\></p>
<p><viewstub\>是个非常轻量级的组件，不仅不可视而且大小为0。这个布局在初始化时不需要显示，只有在某些情况下才显示出来。下面是实例代码：</viewstub\></p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;TextView
      android:id=&quot;@+id/tv&quot;
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:text=&quot;not often use&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>使用<viewstub\>：</viewstub\></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;ViewStub
      android:id=&quot;@+id/view_stub&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerInParent=&quot;true&quot;
      android:layout=&quot;@layout/test&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>在<code>onCreate(Bundle savedInstanceState)</code>中：</p>
<pre><code>ViewStub viewStub= (ViewStub) findViewById(R.id.view_stub);
//下面两个方法都是用来实现延迟加载的，区别是inflate()方法会返回引用的布局。
viewStub.setVisibility(View.VISIBLE); // 第一种方法

View view=viewStub.inflate(); // 第二种方法
TextView tv= (TextView) view.findViewById(R.id.tv);
</code></pre><p><viewstub\>标签与设置View.GONE这种方式的区别在于<viewstub\>标签只在显示时渲染整个布局，而设置View.GONE这种方式在初始化布局树时就已经添加在布局树上了，所以相比之下<viewstub>更有效率。</viewstub></viewstub\></viewstub\></p>
</li>
</ul>
</li>
<li><p>Hierarchy Viewer</p>
</li>
</ul>
<p>这是个用来测试布局冗余的工具。<a href="http://blog.csdn.net/xyz_lmn/article/details/14222975" target="_blank" rel="external">可点击此处</a></p>
<h2 id="10-2__u5185_u5B58_u4F18_u5316"><a href="#10-2__u5185_u5B58_u4F18_u5316" class="headerlink" title="10.2 内存优化"></a>10.2 内存优化</h2><ul>
<li><p>什么是内存</p>
<ul>
<li>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制。</li>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。</li>
<li>堆：堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器(GC)来管理。</li>
<li>静态存储区域：是指在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量。</li>
<li><p>常量池：就是该类型所用到常量的一个有序集合，包括直接常量（基本类型，String）和对其他类型、字段和方法的符号引用。</p>
<p>在程序中，可以使用如下所示的代码来获得堆的大小，所谓的内存分析，正是分析Heap中的内存状态</p>
<pre><code>ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)；
int heapSize = manager.getLargeMemoryClass();
</code></pre></li>
</ul>
</li>
<li><p>获取Android系统内存信息</p>
<ul>
<li><p>进程状态</p>
<pre><code>adb shell dumpsys procstats
</code></pre></li>
<li><p>内存信息</p>
<pre><code>adb shell dumpsys meminfo
</code></pre></li>
</ul>
</li>
<li><p>内存优化实例</p>
<ul>
<li><p>Bitmap优化</p>
<p>Bitmap是造成内存占用过高甚至是OOM的最大威胁，可以通过以下技巧进行优化</p>
<p>① 使用适当分辨率和大小的图片：例如在图片列表界面可以使用图片的缩略图thumbnails，而在显示详细图片的时候再显示原图；或者在对图像要求不高的地方，尽量降低图片的精度。</p>
<p>② 及时回收内存：一旦使用完Bitmap后，一定要及时使用bitmap.recycle()方法释放内存资源。自Android3.0后，由于Bitmap被放到了堆中，其内存由GC管理，就不需要释放了。</p>
<p>③ 通过内存缓存LruCache和DiskLruCache可以更好地使用Bitmap。</p>
</li>
<li><p>代码优化</p>
<p>任何Java类都将占用大约500字节的内存空间，创建一个类的实例会消耗大约15字节内存。从代码的实现上，也可以对内存进行优化。</p>
<p>① 对常量使用static修饰符。</p>
<p>② 使用静态方法，静态方法会比普通方法提高15%左右的访问速度。</p>
<p>③ 减少不必要的成员变量，这点在Android Lint工具上已经集成检测了。</p>
<p>④ 减少不必要对象，使用基础类型会比使用对象更加节省资源，同时更应该避免频繁创建短作用域的变量。</p>
<p>⑤ 尽量不要使用枚举、少用迭代器。</p>
<p>⑥ 对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收和注册、反注册。</p>
<p>⑦ 避免使用IOC框架，IOC通常使用注解、反射来进行实现，大量使用反射会带来性能的下降。</p>
<p>⑧ 使用RenderScript、OpenGL来进行非常复杂的绘图操作。</p>
<p>⑨ 使用SurfaceView来代替View进行大量、频繁的绘图操作。</p>
<p>⑩ 尽量使用视图缓存，而不是每次都执行inflate()解析视图。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-3_Lint_u5DE5_u5177"><a href="#10-3_Lint_u5DE5_u5177" class="headerlink" title="10.3 Lint工具"></a>10.3 Lint工具</h2><h2 id="10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177"><a href="#10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177" class="headerlink" title="10.4 使用Android Studio的Memory Monitor工具"></a>10.4 使用Android Studio的Memory Monitor工具</h2><h2 id="10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD"><a href="#10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD" class="headerlink" title="10.5 使用TraceView工具优化App性能"></a>10.5 使用TraceView工具优化App性能</h2><h2 id="10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001"><a href="#10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001" class="headerlink" title="10.6 使用MAT工具分析App内存状态"></a>10.6 使用MAT工具分析App内存状态</h2><h2 id="10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001"><a href="#10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001" class="headerlink" title="10.7 使用Dumpsys命令分析系统状态"></a>10.7 使用Dumpsys命令分析系统状态</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现WebView中JS和App之间的交互]]></title>
    <link href="http://yuqirong.me/2016/03/07/%E5%AE%9E%E7%8E%B0WebView%E4%B8%ADJS%E5%92%8CApp%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yuqirong.me/2016/03/07/实现WebView中JS和App之间的交互/</id>
    <published>2016-03-07T11:53:12.000Z</published>
    <updated>2016-08-18T15:09:33.942Z</updated>
    <content type="html"><![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img src="/uploads/20160307/20160307200816.png" alt="这里写图片的描述"></p>
<p>之后在脑海中回想到 WebView 中的JS可以和app产生交互，于是搜索了一下，果然网上有类似的实现效果。看了一下，在这里就做一个简单的笔记了以便之后查看。</p>
<p>在 WebView 中想要JS和app产生交互，就不得不提一个方法，那就是<code>addJavascriptInterface(Object object, String name)</code>：</p>
<ul>
<li>第一个参数：绑定到 JavaScript 的类实例。</li>
<li>第二个参数：用来显示 JavaScript 中的实例的名称。</li>
</ul>
<p>这里只是给出了参数的解释，如果你没看懂，那接下来就告诉你答案。</p>
<p>那就开始吧，在创建新的 project 之前，我们先把要加载的 test.html 写好，放在 assets 目录下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">title</span>&gt;</span>WebView Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">btnShowToast</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		    <span class="built_in">window</span>.testJS.showToast();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">btnGoActivity</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		    <span class="built_in">window</span>.testJS.goActivity();</span><br><span class="line">		&#125;</span><br><span class="line">	    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span>This is a website<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">'btnShowToast();'</span>&gt;</span>show Toast<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">'btnGoActivity();'</span>&gt;</span>go Activity<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的 html 很简单，相信有点基础的同学都能看得懂。要注意的是在JS函数中的 testJS 是要和 WebView 约定好的，这里就取名叫 testJS 吧，在下面会用到。还有<code>showToast()</code>和<code>goActivity()</code>也是约定好的函数名。我们预期的效果是点击 show Toast 按钮会显示Toast，而点击 go Activity 按钮会跳转到另外一个 Activity 上。</p>
<p>下面创建了一个 project ，名叫 WebViewDemo ，工程中 MainActivity 的 layout.xml 就只有一个 WebView 了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"com.yuqirong.webviewdemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">WebView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/mWebView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>MainActivity 的代码很短，就直接贴出来了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView mWebView;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mWebView = (WebView) findViewById(R.id.mWebView);</span><br><span class="line">        <span class="comment">// 设置支持JS</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 增加JS交互的接口</span></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> AndroidJSInterface(<span class="keyword">this</span>), <span class="string">"testJS"</span>);</span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String url = <span class="string">"file:///android_asset/test.html"</span>;</span><br><span class="line">        mWebView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，如果想要和JS交互，那么<code>mWebView.getSettings().setJavaScriptEnabled(true);</code>这句是必不可少的，再看到下面一行代码：<code>mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);</code>，这里注意一下第二个参数，没错，就是在 html 中的 testJS ！</p>
<p>再看回第一个参数，发现 new 了一个 AndroidJSInterface 类，下面就是 AndroidJSInterface 的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidJSInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidJSInterface</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        context.startActivity(<span class="keyword">new</span> Intent(context, SecondActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"hello js"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到上面的<code>showToast()</code>和<code>goActivity()</code>方法名和 html 里面的一定要一样，不然无法触发了。然后在方法的内部实现你想要的逻辑。</p>
<p>经过上面的步骤，就可以实现和JS交互了，一起来看看效果吧：</p>
<p><img src="/uploads/20160307/20160307225743.gif" alt="这里写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160307/WebViewDemo.rar">WebViewDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="WebView" scheme="http://yuqirong.me/tags/WebView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/02/28/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/02/28/《Android群英传》笔记(上)/</id>
    <published>2016-02-28T12:20:04.000Z</published>
    <updated>2016-08-18T15:09:33.864Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3" class="headerlink" title="第三章：Android控件架构与自定义控件详解"></a>第三章：Android控件架构与自定义控件详解</h1><h2 id="3-1_Android_u63A7_u4EF6_u67B6_u6784"><a href="#3-1_Android_u63A7_u4EF6_u67B6_u6784" class="headerlink" title="3.1 Android控件架构"></a>3.1 Android控件架构</h2><p>控件分为两类：View和ViewGroup，通过ViewGroup整个界面形成一个树形结构，并且ViewGroup负责对子View的测量与绘制以及传递交互事件。通常在Activity中使用的findViewById()方法，就是在控件树中以树的深度优先遍历来查找对应元素。在每颗控件树的顶部，都有一个ViewParent对象，这就是整棵树的控制核心，所有的交互管理事件都由它来统一调度和分配。</p>
<p><img src="/uploads/20160228/20160228230641.png" alt="这里写图片描述"></p>
<p>如上图所示，每个Activity都包含一个Window对象，在Android中Window对象通常由PhoneWindow来实现。PhoneWindow对象又将一个DecorView设置为整个应用的根View。DecorView作为了窗口界面的顶层视图，封装了一些窗口操作的通用方法。可以说，DecorView将要显示的具体内容呈现在了PhoneWindow上，这里所有View的监听事件，都通过WindowManagerService来接收，并通过Activity对象来回调onClickListener。DecorView在显示上分为TitleView和ContentView两部分。ContentView是一个ID为content的FrameLayout，activity_main.xml就是设置在这样一个FrameLayout里。可以通过如下代码获得ContentView：</p>
<pre><code>FrameLayout content = (FrameLayout)findViewById(android.R.id.content);
</code></pre><p><img src="/uploads/20160228/20160228232837.png" alt="这里写图片描述"></p>
<p>而在代码中，当程序在onCreate()方法中调用setContentView()方法后，ActivityManagerService会回调onResume()方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p>
<h2 id="3-2_View_u7684_u6D4B_u91CF"><a href="#3-2_View_u7684_u6D4B_u91CF" class="headerlink" title="3.2 View的测量"></a>3.2 View的测量</h2><p>View的测量在onMeasure中进行，系统提供了MeasureSpec类，是一个32位的int值，其高2位为测量模式，低30位为测量的大小。测量模式有以下三种：</p>
<ul>
<li><p>EXACTLY：精确模式，当控件指定精确值（例如android:layout_width=”50dp”）或者指定为match_parent属性时系统使用该模式。</p>
</li>
<li><p>AT_MOST：最大值模式，指定wrap_content时系统使用该属性。控件大小一般随着控件的子空间或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。View类默认只支持EXACTLY，如果想使用wrap_content需自己在onMeasure中实现。</p>
</li>
<li><p>UNSPECIFIED：自定义模式，View想多大就多大，通常在绘制自定义View的时候才使用。</p>
</li>
</ul>
<p>下面是onMeasure的示例代码：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);// 获取宽度模式
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);// 获取宽度值
    int width = 0;
    if (widthMode == MeasureSpec.EXACTLY) {
        width = widthSize;
    } else {
        width = 200;// 自定义的默认wrap_content值
        if (widthMode == MeasureSpec.AT_MOST) {
                width = Math.min(widthSize, width);
        }

    }
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);// 获取高度模式
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);// 获取高度值
    int height = 0;
    if (heightMode == MeasureSpec.EXACTLY) {
        height = heightSize;
    } else {
        height = 200;// 自定义的默认wrap_content值
        if (heightMode == MeasureSpec.AT_MOST) {
            height = Math.min(heightSize, height);
        }
    }
    setMeasuredDimension(width, height);// 最终将测量的值传入该方法完成测量
}
</code></pre><h2 id="3-3_View_u7684_u7ED8_u5236"><a href="#3-3_View_u7684_u7ED8_u5236" class="headerlink" title="3.3 View的绘制"></a>3.3 View的绘制</h2><p>View的绘制是通过onDraw()方法实现的，具体是通过对onDraw()方法中Canvas参数操作执行绘图。在其他地方，则需要自己创建Canvas对象，创建时需传入一个bitmap对象，这个过程我们称之为装载画布。bitmap是用来存储所有绘制在Canvas上的像素信息，当你通过这种方式创建了Canvas对象后，后面调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p>
<h2 id="3-4_ViewGroup_u7684_u6D4B_u91CF"><a href="#3-4_ViewGroup_u7684_u6D4B_u91CF" class="headerlink" title="3.4 ViewGroup的测量"></a>3.4 ViewGroup的测量</h2><p>当ViewGroup的大小为wrap_content时，它就会遍历所有子View，以便获得所有子View的大小，从而来决定自身的大小，而在其他模式下则通过指定值来设置自身的大小。</p>
<p>然后当子View测量完毕以后，ViewGroup会执行它的Layout方法，同样是遍历子View并调用其Layout方法来确定布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout()方法来控制子View显示位置，若需支持wrap_content还需重写onMeasure()方法，这点与View是相同的。</p>
<h2 id="3-5_ViewGroup_u7684_u7ED8_u5236"><a href="#3-5_ViewGroup_u7684_u7ED8_u5236" class="headerlink" title="3.5 ViewGroup的绘制"></a>3.5 ViewGroup的绘制</h2><p>ViewGroup通常情况下不需要绘制，如果不是指定了ViewGroup的背景颜色，那么ViewGroup的onDraw()方法都不会被调用。但是ViewGroup会调用dispatchDraw()方法来绘制其子View，过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
<h2 id="3-6__u81EA_u5B9A_u4E49View"><a href="#3-6__u81EA_u5B9A_u4E49View" class="headerlink" title="3.6 自定义View"></a>3.6 自定义View</h2><p>自定义View时有一些比较重要的回调方法如下：</p>
<ul>
<li>onFinishInflate();//从xml加载组件后回调</li>
<li>onSizeChanged();//组件大小改变时回调</li>
<li>onMeasure();//回调该方法进行测量</li>
<li>onLayout();//回调该方法来确定显示的位置</li>
<li>onTouchEvent();//监听到触摸事件回调</li>
</ul>
<p>通常情况下，有以下三种方法来实现自定义的控件：</p>
<ul>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写View来实现全新的控件</li>
</ul>
<p>PS ： LinearGradient也称作线性渲染，LinearGradient的作用是实现某一区域内颜色的线性渐变效果。构造函数有两个，分别如下：</p>
<p><code>public LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标　；color0表示渐变开始颜色；color1表示渐变结束颜色；参数tile表示平铺方式。</p>
<p>Shader.TileMode有3种参数可供选择，分别为CLAMP、REPEAT和MIRROR：</p>
<ul>
<li><p>CLAMP的作用是如果渲染器超出原始边界范围，则会复制边缘颜色对超出范围的区域进行着色</p>
</li>
<li><p>REPEAT的作用是在横向和纵向上以平铺的形式重复渲染位图</p>
</li>
<li><p>MIRROR的作用是在横向和纵向上以镜像的方式重复渲染位图</p>
</li>
</ul>
<p><code>public LinearGradient (float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标；参数colors表示渐变的颜色数组；参数positions用来定义每个颜色处于的渐变相对位置；参数tile表示平铺方式。通常，参数positions设为null，表示颜色数组按顺序均匀的分布。</p>
<h2 id="3-7__u81EA_u5B9A_u4E49ViewGroup"><a href="#3-7__u81EA_u5B9A_u4E49ViewGroup" class="headerlink" title="3.7 自定义ViewGroup"></a>3.7 自定义ViewGroup</h2><p>自定义ViewGroup通常需要重写onMeasure()方法来对子View进行测量，重写onLayout()方法来确定子View的位置，重写onTouchEvent()方法增加响应事件。</p>
<p><code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int count = getChildCount();
    for (int i = 0; i &lt; count; i++) {
        measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><h2 id="3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790"><a href="#3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790" class="headerlink" title="3.8 事件拦截机制分析"></a>3.8 事件拦截机制分析</h2><p>本章较为浅显的分析了下事件传递的机制。当ViewGroup接收到事件，通过调用dispatchTouchEvent()，由这个方法再调用onInterceptTouchEvent()方法来判断是否要拦截事件，如果返回true则拦截将事件交给自己的onTouchEvent处理，返回false则继续向下传递。当View在接受到事件时，通过调用dispatchTouchEvent()，由此方法再调用onTouchEvent方法，如果返回true则拦截事件自己处理，如果返回false则将事件向上传递回ViewGroup并且调用其onTouchEvent方法继续做判断。</p>
<h1 id="u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第四章：ListView使用技巧"></a>第四章：ListView使用技巧</h1><h2 id="4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7"><a href="#4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7" class="headerlink" title="4.1 ListView常用优化技巧"></a>4.1 ListView常用优化技巧</h2><ul>
<li>使用ViewHolder模式提高效率</li>
<li><p>设置项目间分隔线：</p>
<pre><code>android:divider=&quot;@android:color/darker_gray&quot;
android:dividerHeight=&quot;10dp&quot;
</code></pre><p>   特殊情况下，以下代码可以设置分割线为透明：</p>
<pre><code>android:divider=&quot;@null&quot;
</code></pre></li>
<li><p>隐藏ListView的滚动条：</p>
<pre><code>android:scrollbars=&quot;none&quot;
</code></pre></li>
<li><p>取消ListView的点击效果：</p>
<pre><code>android:listSelector=&quot;#00000000&quot;
</code></pre><p>  也可以用Android自带的透明色来实现这个效果：</p>
<pre><code>android:listSelector=&quot;@android:color/transparent&quot;
</code></pre></li>
<li><p>设置ListView需要显示在第几项：</p>
<pre><code>listView.setSelection(N);
</code></pre><p>  其中N就是需要显示的第N个Item。</p>
<p>  除此之外，还可以使用如下代码来实现平滑移动：</p>
<pre><code>mListView.smoothScrollBy(distance,duration);
mListView.smoothScrollByOffset(offset);
mListView.smoothScrollToPosition(index);
</code></pre></li>
<li><p>动态修改ListView：</p>
<pre><code>mAdapter.notifyDataSetChanged();
</code></pre></li>
<li><p>遍历ListView中的所有Item：</p>
<pre><code>for(int i=0;i&lt;mListView.getChildCount();i++){
    View view = mListView.getChildAt(i);
}
</code></pre></li>
<li><p>处理空ListView：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;ListView
    android:id=&quot;@+id/listView&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;ImageView
        android:id=&quot;@+id/imageView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:src=&quot;@drawable/empty_view&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>  在代码中，我们通过以下方式给ListView设置空数据时要显示的布局，代码如下：</p>
<pre><code>ListView listView = (ListView)findViewById(R.id.listView);
listView.setEmptyView(findViewById(R.id.imageView));
</code></pre></li>
<li><p>ListView滑动监听：一种是通过OnTouchListener来实现监听，另外一种是使用OnScrollListener来实现监听。</p>
<p>  OnScrollListener中有两个回调方法——onScrollStateChanged()和onScroll()</p>
<pre><code> @Override
public void onScrollStateChanged(AbsListView view, int scrollState) {
    switch(scrollState){
        case SCROLL_STATE_FLING:
          // TODO    
        break;
        case SCROLL_STATE_IDLE:
        // TODO 
        break;
        case SCROLL_STATE_TOUCH_SCROLL:
        // TODO 
        break;
    }
}
</code></pre><p>  scrollState有以下三种模式：</p>
<ul>
<li>OnScrollListener.SCROLL_STATE_IDLE ： 滚动停止时；</li>
<li>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL ： 正在滚动时；</li>
<li><p>OnScrollListener.SCROLL_STATE_FLING ： 手指抛动时，即手指用力滑动，在离开后ListView由于惯性继续滑动的状态；</p>
<p>当手指没有做手指抛动的状态时，这个方法只会回调2次，否则会回调3次。</p>
<pre><code>@Override
public void onScroll(AbsListView view, int firstVisibleItem,
        int visibleItemCount, int totalItemCount) {
    // TODO Auto-generated method stub
}
</code></pre></li>
<li><p>firstVisibleItem ： 当前能看见的第一个Item的ID（从0开始）</p>
</li>
<li><p>visibleItemCount ： 当前能看见的Item的总数</p>
</li>
<li><p>totalItemCount ： 整个ListView的Item总数</p>
<p>判断是否滚动到最后一行：</p>
<pre><code>if(firstVisibleItem + visibleItemCount == totalItemCount &amp;&amp; totalItemCount &gt; 0){
    // 滚动到最后一行
} 
</code></pre><p>再比如，可以通过如下代码来判断滚动的方向：</p>
<pre><code>if(firstVisibleItem &gt; lastVisibleItemPosition){
    // 上滑
}else if(firstVisibleItem &lt; lastVisibleItemPosition){
    // 下滑
}
lastVisibleItemPosition = firstVisibleItem;
</code></pre><p>当然，ListView也给我们提供了一些封装的方法来获得当前可视的Item的位置等信息：</p>
<pre><code>// 获取可视区域内最后一个Item的id
mListView.getLastVisiblePosition()；
// 获取可视区域内第一个Item的id
mListView。getFirstVisiblePosition();
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="4-2_ListView_u5E38_u7528_u62D3_u5C55"><a href="#4-2_ListView_u5E38_u7528_u62D3_u5C55" class="headerlink" title="4.2 ListView常用拓展"></a>4.2 ListView常用拓展</h2><ol>
<li><p>具有弹性的ListView：</p>
<pre><code>@Override
protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
    return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
}
</code></pre><p> 其中的maxOverScrollY，默认值为0。所以只要修改它的值，就可以让ListView具有弹性了。</p>
</li>
</ol>
<h1 id="u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790"><a href="#u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790" class="headerlink" title="第五章：Android Scroll分析"></a>第五章：Android Scroll分析</h1><h2 id="5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684"><a href="#5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684" class="headerlink" title="5.1 滑动效果是如何产生的"></a>5.1 滑动效果是如何产生的</h2><p>滑动一个View，本质上来说就是移动一个View。改变其当前所处的位置，它的原理与动画效果的实现非常相似，都是通过不断地改变View的坐标来实现这一效果。所以，要实现View的滑动，就必须监听用户触摸的事件，并根据事件传入的坐标，动态且不断地改变View的坐标，从而实现View跟随用户触摸的滑动而滑动。</p>
<p><strong>Android坐标系</strong></p>
<p>Android的坐标系是以屏幕最左上角为顶点，向右为x轴正方向，向下是y轴正方向。在触控事件中通过<code>getRawX()</code>和<code>getRawY()</code>获取Android坐标系中的坐标。在View中通过<code>getLocationOnScreen(int[] location)</code>获取。</p>
<p><strong>视图坐标系</strong></p>
<p>描述的是子视图在父视图中的位置关系，原点为父视图的左上角，x、y轴方向与Android坐标系一致。触控事件中通过<code>getX()</code>,<code>getY()</code>获取视图坐标系的坐标。</p>
<p><strong>触控事件——MotionEvent</strong></p>
<pre><code>// 单点触摸按下动作
public static final int MotionEvent.ACTION_DOWN = 0;
// 单点触摸离开动作
public static final int MotionEvent.ACTION_UP = 1;
// 触摸点移动动作
public static final int MotionEvent.ACTION_MOVE = 2;
// 触摸动作取消
public static final int MotionEvent.ACTION_CANCEL = 3;
// 触摸动作超出边界
public static final int MotionEvent.ACTION_OUTSIDE = 4;
// 多点触摸按下动作
public static final int MotionEvent.ACTION_POINTER_DOWN = 5;
// 多点离开动作
public static final int MotionEvent.ACTION_POINTER_UP = 6;
</code></pre><p><strong>View提供的获取坐标方法</strong></p>
<ul>
<li>getTop()：获取到的是View自身的顶边到其父布局顶边的距离</li>
<li>getLeft()：获取到的是View自身的左边到其父布局左边的距离</li>
<li>getRight()：获取到的是View自身的右边到其父布局右边的距离</li>
<li>getBottom()：获取到的是View自身的底边到其父布局底边的距离</li>
</ul>
<p><strong>MotionEvent提供的方法</strong></p>
<ul>
<li>getX()：获取点击事件距离控件左边的距离，即视图坐标</li>
<li>getY()：获取点击事件距离控件顶边的距离，即视图坐标</li>
<li>getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标</li>
<li>getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标</li>
</ul>
<h2 id="5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5"><a href="#5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5" class="headerlink" title="5.2 实现滑动的七种方法"></a>5.2 实现滑动的七种方法</h2><ul>
<li><p>layout()方法</p>
<pre><code>private int lastX;
private int lastY;
private int offsetX;
private int offsetY;

@Override
public boolean onTouchEvent(MotionEvent event) {
  int x = (int) event.getRawX();
  int y = (int) event.getRawY();

  switch (event.getAction()) {
  case MotionEvent.ACTION_DOWN:
      lastX = x;
      lastY = y;
      break;
  case MotionEvent.ACTION_MOVE:
      offsetX = x - lastX;
      offsetY = y - lastY;

      layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY);

      lastX = x;
      lastY = y;
      break;
  }
  return true;
}
</code></pre></li>
<li><p>offsetLeftAndRight()与offsetTopAndBottom()</p>
<pre><code>// 同时对left和right进行偏移
offsetLeftAndRight(offsetX);
// 同时对top和bottom进行偏移
offsetTopAndBottom(offsetY);
</code></pre></li>
<li><p>LayoutParams</p>
<pre><code>LinearLayout.MarginLayoutParams layoutParams=(LinearLayout.LayoutParams)getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre><p>  或者</p>
<pre><code>ViewGroup.MarginLayoutParams layoutParams=(MarginLayoutParams) getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre></li>
<li><p>scrollTo()和scrollBy()</p>
<pre><code>//scrollTo和scrollBy移动的是view的内容而不是view本身
//如果在viewgroup中使用就是移动所有子view。
View view=(View) getParent();
//scrollTo和scrollBy参考的坐标系正好与视图坐标系相反，所以offset需为负
view.scrollBy(-offsetX, -offsetY);
</code></pre></li>
<li><p>Scroller</p>
<p>  scrollTo()和scrollBy()都是使View的平移瞬间发生的，这样的效果会让人感觉很突兀，而Scroller可以实现平滑移动的效果，而不是瞬间完成的移动。</p>
<p>  使用Scroller主要有三个步骤：</p>
<ol>
<li><p>初始化Scroller对象，一般在view初始化的时候同时初始化scroller，代码如下：<br><code>mScroller=new Scroller(context);</code></p>
</li>
<li><p>重写view的computeScroll()方法，实现模拟滑动。computeScroll()的模版代码如下：</p>
<pre><code>@Override
public void computeScroll() {
  super.computeScroll();
  // 判断Scroller是否执行完毕
  if (mScroller.computeScrollOffset()) {
      ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
      // 通过重绘来不断调用computeScroll
      invalidate();
  }
}
</code></pre><p> Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动，同时也提供了getCurrX()和getCurrY()方法来获得当前的滑动坐标。computeScroll()方法是不会自动调用的，只能通过invalidate()-&gt;draw()-&gt;computeScroll()来间接调用，实现循环获取scrollX和scrollY的目的，当移动过程结束之后，Scroller.computeScrollOffset方法会返回false，从而中断循环,完成整个平滑移动过程；</p>
</li>
<li><p>startScroll开启模拟过程。调用Scroller.startScroll()方法，将起始位置、偏移量以及移动时间(可选)作为参数传递给startScroll()方法。在获取坐标时，通常可以使用getScrollX()和getScrollY()方法来获取父视图中content所滑动到的点的坐标，不过要注意的是这个值的正负，它与在scrollBy()、scrollTo()中讲解是一样的。另外，在startScroll()之后，还要invalidate()方法来通知View进行重绘，从而来调用computeScroll()的模拟过程。当然，可以给startScroll()方法增加一个duration的参数来设置滑动的持续时长。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>属性动画</p>
</li>
<li><p>ViewDragHelper</p>
<p>  ViewDragHelper基本可以实现各种不同滑动需求，但使用稍微复杂。</p>
<p>  示例代码：</p>
<pre><code>public class DragViewGroup extends FrameLayout {

  private ViewDragHelper mViewDragHelper;
  private View mMenuView, mMainView;
  private int mWidth;

  public DragViewGroup(Context context) {
      super(context);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs) {
      super(context, attrs);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      initView();
  }

  @Override
  protected void onFinishInflate() {
      super.onFinishInflate();
      mMenuView = getChildAt(0);
      mMainView = getChildAt(1);
  }

  @Override
  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
      super.onSizeChanged(w, h, oldw, oldh);
      mWidth = mMenuView.getMeasuredWidth();
  }

  @Override
  public boolean onInterceptTouchEvent(MotionEvent ev) {
      return mViewDragHelper.shouldInterceptTouchEvent(ev);
  }

  @Override
  public boolean onTouchEvent(MotionEvent event) {
      //将触摸事件传递给ViewDragHelper,此操作必不可少
      mViewDragHelper.processTouchEvent(event);
      return true;
  }

  private void initView() {
      mViewDragHelper = ViewDragHelper.create(this, callback);
  }

  private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {

      // 何时开始检测触摸事件
      @Override
      public boolean tryCaptureView(View child, int pointerId) {
          //如果当前触摸的child是mMainView时开始检测
          return mMainView == child;
      }

      // 触摸到View后回调
      @Override
      public void onViewCaptured(View capturedChild, int activePointerId) {
          super.onViewCaptured(capturedChild, activePointerId);
      }

      // 当拖拽状态改变，比如idle，dragging
      @Override
      public void onViewDragStateChanged(int state) {
          super.onViewDragStateChanged(state);
      }

      // 当位置改变的时候调用,常用与滑动时更改scale等
      @Override
      public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
          super.onViewPositionChanged(changedView, left, top, dx, dy);
      }

      // 处理垂直滑动
      @Override
      public int clampViewPositionVertical(View child, int top, int dy) {
          return 0;
      }

      // 处理水平滑动
      @Override
      public int clampViewPositionHorizontal(View child, int left, int dx) {
          return left;
      }

      // 拖动结束后调用
      @Override
      public void onViewReleased(View releasedChild, float xvel, float yvel) {
          super.onViewReleased(releasedChild, xvel, yvel);
          //手指抬起后缓慢移动到指定位置
          if (mMainView.getLeft() &lt; 500) {
              //关闭菜单，相当于Scroller的startScroll方法
              mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          } else {
              //打开菜单
              mViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          }
      }
  };

  @Override
  public void computeScroll() {
      if (mViewDragHelper.continueSettling(true)) {
          ViewCompat.postInvalidateOnAnimation(this);
      }
  }
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用RecyclerView实现仿喵街效果]]></title>
    <link href="http://yuqirong.me/2016/02/26/%E4%BD%BF%E7%94%A8RecyclerView%E5%AE%9E%E7%8E%B0%E4%BB%BF%E5%96%B5%E8%A1%97%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/02/26/使用RecyclerView实现仿喵街效果/</id>
    <published>2016-02-26T11:50:18.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></p>
<p>值得一提的是，这是旧版本的特效，新版本的喵街已经去掉了这种效果。</p>
<p>看完了效果，接下来就是动手的时间了。</p>
<p>我们先来分析一下思路：我们先给RecyclerView添加一个OnScrollListener，然后分别去获得firstVisiblePosition和firstCompletelyVisiblePosition。这里要注意一下，firstVisiblePosition是第一个在屏幕中<strong>可见</strong>的itemView对应的position，而firstCompletelyVisiblePosition是是第一个在屏幕中<strong>完全可见</strong>的itemView对应的position。之后在滚动中去动态地设置itemView的高度。整体的思路就这样了，下面我们直接来看代码。</p>
<p>创建几个自定义的属性，以便后面备用：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ExpandRecyclerView"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- item最大的高度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"max_item_height"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- item普通的高度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"normal_item_height"</span> <span class="attribute">format</span>=<span class="value">"dimension"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>之后我们新建一个类继承自RecyclerView，类名就叫ExpandRecyclerView。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//最大item的高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> maxItemHeight;</span><br><span class="line"><span class="comment">//普通item的高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> normalItemHeight;</span><br><span class="line"><span class="comment">// 默认最大的item高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultMaxItemHeight;</span><br><span class="line"><span class="comment">// 默认普通的item高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultNormalItemHeight;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExpandRecyclerView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExpandRecyclerView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ExpandRecyclerView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyle)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyle);</span><br><span class="line">    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ExpandRecyclerView);</span><br><span class="line">    defaultMaxItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">256</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">    defaultNormalItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">120</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">    maxItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_max_item_height, defaultMaxItemHeight);</span><br><span class="line">    normalItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_normal_item_height, defaultNormalItemHeight);</span><br><span class="line">    a.recycle();</span><br><span class="line"></span><br><span class="line">    setHasFixedSize(<span class="keyword">true</span>);</span><br><span class="line">    setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(context));</span><br><span class="line">    setItemAnimator(<span class="keyword">new</span> DefaultItemAnimator());</span><br><span class="line">    <span class="keyword">this</span>.addOnScrollListener(listener);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造器中我们得到了<code>maxItemHeight</code>和<code>normalItemHeight</code>，之后设置了OnScrollListener。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">OnScrollListener listener = <span class="keyword">new</span> RecyclerView.OnScrollListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onScrolled</span><span class="params">(RecyclerView recyclerView, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onScrolled(recyclerView, dx, dy);</span><br><span class="line">        Log.i(TAG,<span class="string">"dy : "</span> + dy);</span><br><span class="line">        LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();</span><br><span class="line">        <span class="comment">// 在屏幕中第一个可见的position</span></span><br><span class="line">        <span class="keyword">int</span> firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();</span><br><span class="line">        <span class="comment">// 得到第一个可见的ViewHolder</span></span><br><span class="line">        RecyclerView.ViewHolder firstVisibleViewHolder =</span><br><span class="line">                recyclerView.findViewHolderForLayoutPosition(firstVisiblePosition);</span><br><span class="line">        <span class="comment">// 在屏幕中第一个完全可见的position</span></span><br><span class="line">        <span class="keyword">int</span> firstCompletelyVisiblePosition = mLinearLayoutManager.findFirstCompletelyVisibleItemPosition();</span><br><span class="line">        <span class="comment">// 得到第一个完全可见的ViewHolder</span></span><br><span class="line">        RecyclerView.ViewHolder firstCompletelyVisibleViewHolder =</span><br><span class="line">                recyclerView.findViewHolderForLayoutPosition(firstCompletelyVisiblePosition);</span><br><span class="line"></span><br><span class="line">        Log.i(TAG, <span class="string">"firstVisiblePosition : "</span> + firstVisiblePosition + <span class="string">" , firstCompletelyVisiblePosition : "</span> + firstCompletelyVisiblePosition);</span><br><span class="line">        <span class="comment">// 当firstVisibleViewHolder被滑出屏幕时</span></span><br><span class="line">        <span class="keyword">if</span> (firstVisibleViewHolder.itemView.getLayoutParams().height - dy &lt; maxItemHeight</span><br><span class="line">                &amp;&amp; firstVisibleViewHolder.itemView.getLayoutParams().height - dy &gt;= normalItemHeight) &#123;</span><br><span class="line">            <span class="comment">// 高度减小</span></span><br><span class="line">            firstVisibleViewHolder.itemView.getLayoutParams().height -= dy;</span><br><span class="line">            firstVisibleViewHolder.itemView.setLayoutParams(firstVisibleViewHolder.itemView.getLayoutParams());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 当firstCompletelyVisibleViewHolder慢慢滑到屏幕顶部时</span></span><br><span class="line">        <span class="keyword">if</span> (firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &lt;= maxItemHeight</span><br><span class="line">                &amp;&amp; firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &gt;= normalItemHeight) &#123;</span><br><span class="line">            <span class="comment">// 高度增加</span></span><br><span class="line">            firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height += dy;</span><br><span class="line">            firstCompletelyVisibleViewHolder.itemView.setLayoutParams(firstCompletelyVisibleViewHolder.itemView.getLayoutParams());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>在<code>onScrolled(RecyclerView recyclerView, int dx, int dy)</code>里大部分的代码都加上注释了，就是根据<code>dy</code>去动态地改变了<code>firstVisibleViewHolder</code>和<code>firstCompletelyVisibleViewHolder</code>的高度。</p>
<p>上面的搞定了之后，别忘了要在Adapter里去初始化设置Item的高度。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置适配器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> adapter</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAdapter</span><span class="params">(Adapter adapter)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.setAdapter(adapter);</span><br><span class="line">    <span class="keyword">if</span> (adapter <span class="keyword">instanceof</span> ExpandRecyclerViewAdapter) &#123;</span><br><span class="line">        ExpandRecyclerViewAdapter mAdapter = (ExpandRecyclerViewAdapter) adapter;</span><br><span class="line">        <span class="comment">//设置最大的item高度</span></span><br><span class="line">        mAdapter.setMaxItemHeight(maxItemHeight);</span><br><span class="line">        <span class="comment">//设置普通的item高度</span></span><br><span class="line">        mAdapter.setNormalItemHeight(normalItemHeight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>ExpandRecyclerViewAdapter的代码，重写<code>onBindViewHolder(RecyclerView.ViewHolder holder, int position)</code>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(position == <span class="number">0</span>)&#123;</span><br><span class="line">            holder.itemView.setLayoutParams(<span class="keyword">new</span> RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (<span class="keyword">int</span>) maxItemHeight));</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            holder.itemView.setLayoutParams(<span class="keyword">new</span> RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (<span class="keyword">int</span>) normalItemHeight));</span><br><span class="line">        &#125;</span><br><span class="line">        bindCustomViewHolder(holder, position);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">bindCustomViewHolder</span><span class="params">(RecyclerView.ViewHolder holder, <span class="keyword">int</span> position)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p>好了，整体的代码就这些了，下面贴出运行效果：</p>
<p><img src="/uploads/20160226/20160226210235.gif" alt="这里写图片描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160226/ExpandRecyclerView.rar">ExpandRecyclerView.rar</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.jianshu.com/p/a2c3c21e3b99" target="_blank" rel="external">android版高仿喵街主页滑动效果</a></p>
<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><ul>
<li><a href="https://github.com/dongjunkun/miaojiedemo" target="_blank" rel="external">miaojiedemo</a> created by <a href="https://github.com/dongjunkun" target="_blank" rel="external">dongjunkun</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[九大基本排序算法]]></title>
    <link href="http://yuqirong.me/2016/02/18/%E4%B9%9D%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yuqirong.me/2016/02/18/九大基本排序算法/</id>
    <published>2016-02-18T13:56:06.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O(N),最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] bubbleSort(int[] A, int n) {
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (A[j] &gt; A[j + 1]) {
                temp = A[j + 1];
                A[j + 1] = A[j];
                A[j] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u9009_u62E9_u6392_u5E8F"><a href="#u9009_u62E9_u6392_u5E8F" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序时间复杂度 O(N^2)，最坏的情况O(N^2);空间复杂度O(1)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] selectionSort(int[] A, int n) {
    int minPos = 0;
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (A[j] &lt; A[minPos]) {
                minPos = j;
            }
        }
        temp = A[minPos];
        A[minPos] = A[i];
        A[i] = temp;
        minPos = i + 1;
    }
    return A;
}
</code></pre><h1 id="u63D2_u5165_u6392_u5E8F"><a href="#u63D2_u5165_u6392_u5E8F" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的平均复杂度是O(N^2)，最好的情况O(N)，最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] insertionSort(int[] A, int n) {
    int temp;
    for (int i = 2; i &lt; n; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (A[i] &lt; A[j]) {
                temp = A[j];
                A[j] = A[i];
                A[i] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u5F52_u5E76_u6392_u5E8F"><a href="#u5F52_u5E76_u6392_u5E8F" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序时间复杂度O(N*logN),最好的情况O(N*logN)，最坏的情况O(N*logN)；空间复杂度O(N)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] mergeSort(int[] A, int n) {
    if (n &gt; 1) {
        int k = n / 2;
        int[] temp1 = new int[k];
        int[] temp2 = new int[n - k];

        for (int i = 0; i &lt; k; i++) {
            temp1[i] = A[i];
        }
        for (int i = k; i &lt; n; i++) {
            temp2[i - k] = A[i];
        }
        temp1 = mergeSort(temp1, k);
        temp2 = mergeSort(temp2, n - k);

        int i = 0;
        int j = 0;
        int x = 0;
        int[] temp = new int[n];

        while (i &lt; k &amp;&amp; j &lt; n - k) {
            if (temp1[i] &lt;= temp2[j]) {
                temp[x] = temp1[i];
                x++;
                i++;
            } else {
                temp[x] = temp2[j];
                x++;
                j++;
            }
        }

        while (i &lt; k) {
            temp[x] = temp1[i];
            x++;
            i++;
        }

        while (j &lt; n - k) {
            temp[x] = temp2[j];
            x++;
            j++;
        }
        return temp;
    }
    return A;
}
</code></pre><h1 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的平均复杂度是O(N*logN)，最好的情况O(N*logN)，最坏的情况O(N^2);空间复杂度O(logN)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] quickSort(int[] A, int n) {
    qSort(A, 0, n - 1);
    return A;
}

/**
 * 
 * @param A
 *            数组
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void qSort(int[] A, int start, int end) {
    if (start &lt; end) {
        Random random = new Random();
        // 产生一个随机数
        int nextInt = random.nextInt(end - start + 1) + start;
        // 把随机位和数组最后一位交换
        int temp = A[end];
        A[end] = A[nextInt];
        A[nextInt] = temp;
        // 比A[nextInt]小的数的个数
        int lt = 0;

        for (int i = start; i &lt; end; i++) {
            if (A[i] &lt;= A[end]) {
                int temp1 = A[lt + start];
                A[lt + start] = A[i];
                A[i] = temp1;
                lt++;
            }
        }
        // 把数组最后一位和A[start + lt]交换
        int temp2 = A[start + lt];
        A[lt + start] = A[end];
        A[end] = temp2;
        // 递归
        qSort(A, start, lt + start - 1);
        qSort(A, lt + start + 1, end);
    }
}
</code></pre><h1 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h1><p>时间复杂度 O(N*logN),最坏O(N*logN);不稳定算法</p>
<pre><code>/**
 * 从堆顶中取值，再重新建堆
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] heapSort(int[] A, int n) {
    while (n &gt; 0) {
        sift(A, n);
        int temp = A[n - 1];
        A[n - 1] = A[0];
        A[0] = temp;
        n--;
        sift(A, n);
    }
    return A;
}

/**
 * 建堆
 * 
 * @param A
 * @param n
 */
public static void sift(int[] A, int n) {
    // 最后一个非终端节点
    int temp = n / 2;

    while (temp &gt; 0) {
        int tt = 2 * temp - 1;
        if (2 * temp &lt;= n - 1) {
            if (A[2 * temp] &lt; A[2 * temp - 1]) {
                tt = 2 * temp - 1;
            } else {
                tt = 2 * temp;
            }
        }
        // 如果子节点大于父节点
        if (A[temp - 1] &lt; A[tt]) {
            int t = A[temp - 1];
            A[temp - 1] = A[tt];
            A[tt] = t;
        }

        // 保证下面的堆为大顶堆
        for (int i = (tt + 1); i &lt;= n; i = 2 * i) {
            int k = 2 * i - 1;
            if (k &lt; n) {
                if (i * 2 + 1 &lt;= n) {
                    if (A[2 * i] &gt; A[2 * i - 1]) {
                        k = 2 * i;
                    }
                }
                if (A[i - 1] &lt; A[k]) {
                    int t = A[i - 1];
                    A[i - 1] = A[k];
                    A[k] = t;
                }
            }
        }
        // 节点自减
        temp--;
    }
}
</code></pre><h1 id="u5E0C_u5C14_u6392_u5E8F"><a href="#u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的平均复杂度是O(N*logN)~O(N^2)，最好的情况O(N^1.3)，最坏的情况O(N^2)；空间复杂度O(1);不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] shellSort(int[] A, int n) {
    Random random = new Random();
    // 步长
    int step = random.nextInt(n);
    sSort(A,step);
    return A;
}

/**
 * 
 * @param A
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void sSort(int[] A, int step) {
    // 当步长大于0时循环
    while (step &gt; 0) {
        for (int i = step; i &lt; A.length; i++) {
            int k = i;
            int temp = k - step;
            while (temp &gt;= 0) {
                if (A[k] &lt; A[temp]) {
                    int temp2 = A[k];
                    A[k] = A[temp];
                    A[temp] = temp2;
                    k = temp;
                }
                temp -= step;
            }
        }
        // 步长自减
        step--;
    }
}
</code></pre><h1 id="u8BA1_u6570_u6392_u5E8F"><a href="#u8BA1_u6570_u6392_u5E8F" class="headerlink" title="计数排序"></a>计数排序</h1><p>时间复杂度 O(N)；</p>
<pre><code>/**
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] countingSort(int[] A, int n) {
    int temp = A[0];
    for (int i = 1;i&lt;n ;i++) {
        if(A[i]&gt;temp){
            temp = A[i];
        }
    }

    int[] count = new int[temp+1];

    for (int i = 0; i &lt; n; i++) {
        count[A[i]]++;
    }
    int[] result = new int[n];
    int length = 0;
    for (int i = 0; i &lt; count.length; i++) {
        while(count[i]&gt;0){
            result[length] = i;
            count[i]--;
            length++;
        }
    }
    return result;
}
</code></pre><h1 id="u57FA_u6570_u6392_u5E8F"><a href="#u57FA_u6570_u6392_u5E8F" class="headerlink" title="基数排序"></a>基数排序</h1><p>时间复杂度 O (nlog(r)m)，其中r为所采取的基数，而m为堆数;空间复杂度O(N)；稳定算法</p>
<pre><code>public static int[] radixSort(int[] A, int n) {

    int index = 0;
    for (int i = 1; i &lt; n; i++) {
        if (A[i] &gt; A[index]) {
            index = i;
        }
    }

    int temp = A[index];
    int count = 0;
    while (temp / 10 &gt; 0) {
        count++;
        temp /= 10;
    }
    count++;

    int[][] bucket = new int[10][n + 1];

    int temp1 = count;
    while (count &gt; 0) {

        for (int i = 0; i &lt; bucket.length; i++) {
            bucket[i][0] = 0;
        }

        for (int i = 0; i &lt; n; i++) {
            int num;
            if (temp1 - count == 0) {
                num = A[i] % 10;
            } else {
                int tt = (int) Math.pow(10, temp1 - count);
                num = (int) A[i] / tt % 10;
            }
            int length = bucket[num][0];
            bucket[num][length + 1] = A[i];
            length++;
            bucket[num][0] = length;
        }
        int length = 0;
        for (int i = 0; i &lt; 10; i++) {
            for (int j = 0; j &lt; bucket[i][0]; j++) {
                A[length] = bucket[i][j + 1];
                length++;
            }
        }
        count--;
    }
    return A;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O]]>
    </summary>
    
      <category term="算法" scheme="http://yuqirong.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://yuqirong.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
