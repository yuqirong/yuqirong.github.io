<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-09-10T04:23:11.372Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[对于Android日夜间模式实现的探讨]]></title>
    <link href="http://yuqirong.me/2016/09/08/%E5%AF%B9%E4%BA%8EAndroid%E6%97%A5%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
    <id>http://yuqirong.me/2016/09/08/对于Android日夜间模式实现的探讨/</id>
    <published>2016-09-08T10:32:11.000Z</published>
    <updated>2016-09-10T04:23:11.372Z</updated>
    <content type="html"><![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有相关的模式切换。实现日间/夜间模式切换的方案也有许多种，趁着今天有空来讲一下日间/夜间模式切换的几种实现方案，也可以做一个横向的对比来看看哪种方案最好。</p>
<p>在本篇文章中给出了三种实现日间/夜间模式切换的方案：</p>
<ol>
<li>使用 setTheme 的方法让 Activity 重新设置主题；</li>
<li>设置 Android Support Library 中的 UiMode 来支持日间/夜间模式的切换；</li>
<li>通过资源 id 映射，回调自定义 ThemeChangeListener 接口来处理日间/夜间模式的切换。</li>
</ol>
<p>三种方案综合起来可能导致文章的篇幅过长，请耐心阅读。</p>
<h1 id="0x0002"><a href="#0x0002" class="headerlink" title="0x0002"></a>0x0002</h1><h2 id="u4F7F_u7528_setTheme__u65B9_u6CD5"><a href="#u4F7F_u7528_setTheme__u65B9_u6CD5" class="headerlink" title="使用 setTheme 方法"></a>使用 setTheme 方法</h2><p>我们先来看看使用 setTheme 方法来实现日间/夜间模式切换的方案。这种方案的思路很简单，就是在用户选择夜间模式时，Activity 设置成夜间模式的主题，之后再让 Activity 调用 recreate() 方法重新创建一遍就行了。</p>
<p>那就动手吧，在 colors.xml 中定义两组颜色，分别表示日间和夜间的主题色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后在 styles.xml 中定义两组主题，也就是日间主题和夜间主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/black&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"NightAppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"><span class="at_rule"></span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimary"</span>&gt;@color/nightColorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/nightColorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在主题中的 <code>mainBackground</code> 属性是我们自定义的属性，用来表示背景色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"mainBackground"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是看一下布局 activity_main.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"?attr/mainBackground"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"com.yuqirong.themedemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"切换日/夜间模式"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"通过setTheme()的方法"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;RelativeLayout&gt;</code> 的 <code>android:background</code> 属性中，我们使用 <code>&quot;?attr/mainBackground&quot;</code> 来表示，这样就代表着 <code>RelativeLayout</code> 的背景色会去引用在主题中事先定义好的 <code>mainBackground</code> 属性的值。这样就实现了日间/夜间模式切换的换色了。</p>
<p>最后就是 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theme = R.style.AppTheme;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		<span class="comment">// 判断是否有主题存储</span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">            theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">            setTheme(theme);</span><br><span class="line">        &#125;</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                theme = (theme == R.style.AppTheme) ? R.style.NightAppTheme : R.style.AppTheme;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putInt(<span class="string">"theme"</span>, theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中有几点要注意一下：</p>
<ol>
<li><p>调用 <code>recreate()</code> 方法后 Activity 的生命周期会调用 <code>onSaveInstanceState(Bundle outState)</code> 来备份相关的数据，之后也会调用 <code>onRestoreInstanceState(Bundle savedInstanceState)</code> 来还原相关的数据，因此我们把 <code>theme</code> 的值保存进去，以便 Activity 重新创建后使用。</p>
</li>
<li><p>我们在 <code>onCreate(Bundle savedInstanceState)</code> 方法中还原得到了 <code>theme</code> 值后，<code>setTheme()</code> 方法一定要在 <code>setContentView()</code> 方法之前调用，否则的话就看不到效果了。</p>
</li>
<li><p><code>recreate()</code> 方法是在 API 11 中添加进来的，所以在 Android 2.X 中使用会抛异常。</p>
</li>
</ol>
<p>贴完上面的代码之后，我们来看一下该方案实现的效果图：</p>
<p><img src="/uploads/20160908/20160909103512.gif" alt="setTheme()效果图gif"></p>
<h2 id="u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5"><a href="#u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5" class="headerlink" title="使用 Android Support Library 中的 UiMode 方法"></a>使用 Android Support Library 中的 UiMode 方法</h2><p>使用 UiMode 的方法也很简单，我们需要把 colors.xml 定义为日间/夜间两种。之后根据不同的模式会去选择不同的 colors.xml 。在 Activity 调用 recreate() 之后，就实现了切换日/夜间模式的功能。</p>
<p>说了这么多，直接上代码。下面是 values/colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 values/colors.xml 之外，我们还要创建一个 values-night/colors.xml 文件，用来设置夜间模式的颜色，其中 <code>&lt;color&gt;</code> 的 name 必须要和 values/colors.xml 中的相对应：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 styles.xml 中去引用我们在 colors.xml 中定义好的颜色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@color/textColor&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/backgroundColor&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>activity_main.xml 布局的内容和上面 setTheme() 方法中的相差无几，这里就不贴出来了。之后的事情就变得很简单了，在 MyApplication 中先选择一个默认的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 默认设置为日间模式</span></span><br><span class="line">        AppCompatDelegate.setDefaultNightMode(</span><br><span class="line">                AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，这里的 Mode 有四种类型可以选择：</p>
<ul>
<li>MODE_NIGHT_NO： 使用亮色(light)主题，不使用夜间模式；</li>
<li>MODE_NIGHT_YES：使用暗色(dark)主题，使用夜间模式；</li>
<li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题；</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO</li>
</ul>
<p>当用户点击按钮切换日/夜间时，重新去设置相应的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;</span><br><span class="line">                getDelegate().setLocalNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO</span><br><span class="line">                        ? AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">                <span class="comment">// 同样需要调用recreate方法使之生效</span></span><br><span class="line">                recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下 UiMode 方案实现的效果图：</p>
<p><img src="/uploads/20160908/20160910011353.gif" alt="UiMode的效果图gif"></p>
<p>就前两种方法而言，配置比较简单，最后的实现效果也都基本上是一样的。但是缺点就是需要调用 <code>recreate()</code> 使之生效。而让 Activity 重新创建就必须涉及到一些状态的保存。这就增加了一些难度。所以，我们一起来看看第三种解决方法。</p>
<h2 id="u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3"><a href="#u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3" class="headerlink" title="通过资源 id 映射，回调接口"></a>通过资源 id 映射，回调接口</h2><p>第三种方法的思路就是根据设置的主题去动态地获取资源 id 的映射，然后使用回调接口的方式让 UI 去设置相关的属性值。我们在这里先规定一下：夜间模式的资源在命名上都要加上后缀 “_night” ，比如日间模式的背景色命名为 color_background ，那么相对应的夜间模式的背景资源就要命名为 color_background_night 。好了，下面就是我们的 Demo 所需要用到的 colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark_night"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent_night"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor_night"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到每一项 color 都会有对应的 “_night” 与之匹配。</p>
<p>看到这里，肯定有人会问，为什么要设置对应的 “_night” ？到底是通过什么方式来设置日/夜间模式的呢？下面就由 ThemeManager 来为你解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThemeMode mThemeMode = ThemeMode.DAY;</span><br><span class="line">    <span class="comment">// 主题模式监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;OnThemeChangeListener&gt; mThemeChangeListenerList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间资源的缓存，key : 资源类型, 值&lt;key:资源名称, value:int值&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; sCachedNightResrouces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间模式资源的后缀，比如日件模式资源名为：R.color.activity_bg, 那么夜间模式就为 ：R.color.activity_bg_night</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_SUFFIX = <span class="string">"_night"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式，分为日间模式和夜间模式</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ThemeMode &#123;</span><br><span class="line">        DAY, NIGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 设置主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> themeMode</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThemeMode</span><span class="params">(ThemeMode themeMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeMode != themeMode) &#123;</span><br><span class="line">            mThemeMode = themeMode;</span><br><span class="line">            <span class="keyword">if</span> (mThemeChangeListenerList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (OnThemeChangeListener listener : mThemeChangeListenerList) &#123;</span><br><span class="line">                    listener.onThemeChanged();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的日间模式的resId得到相应主题的resId，注意：必须是日间模式的resId</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> dayResId 日间模式的resId</span><br><span class="line">     * <span class="doctag">@return</span> 相应主题的resId，若为日间模式，则得到dayResId；反之夜间模式得到nightResId</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThemeRes</span><span class="params">(Context context, <span class="keyword">int</span> dayResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getThemeMode() == ThemeMode.DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> dayResId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源名</span></span><br><span class="line">        String entryName = context.getResources().getResourceEntryName(dayResId);</span><br><span class="line">        <span class="comment">// 资源类型</span></span><br><span class="line">        String typeName = context.getResources().getResourceTypeName(dayResId);</span><br><span class="line">        HashMap&lt;String, Integer&gt; cachedRes = sCachedNightResrouces.get(typeName);</span><br><span class="line">        <span class="comment">// 先从缓存中去取，如果有直接返回该id</span></span><br><span class="line">        <span class="keyword">if</span> (cachedRes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedRes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer resId = cachedRes.get(entryName + RESOURCE_SUFFIX);</span><br><span class="line">        <span class="keyword">if</span> (resId != <span class="keyword">null</span> &amp;&amp; resId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果缓存中没有再根据资源id去动态获取</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过资源名，资源类型，包名得到资源int值</span></span><br><span class="line">                <span class="keyword">int</span> nightResId = context.getResources().getIdentifier(entryName + RESOURCE_SUFFIX, typeName, context.getPackageName());</span><br><span class="line">                <span class="comment">// 放入缓存中</span></span><br><span class="line">                cachedRes.put(entryName + RESOURCE_SUFFIX, nightResId);</span><br><span class="line">                sCachedNightResrouces.put(typeName, cachedRes);</span><br><span class="line">                <span class="keyword">return</span> nightResId;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Resources.NotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 反注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unregisterThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 得到主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThemeMode <span class="title">getThemeMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mThemeMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式切换监听器</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 主题切换时回调</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 ThemeManager 的代码基本上都有注释，想要看懂并不困难。其中最核心的就是 <code>getCurrentThemeRes</code> 方法了。在这里解释一下 <code>getCurrentThemeRes</code> 的逻辑。参数中的 dayResId 是日间模式的资源id，如果当前主题是日间模式的话，就直接返回 dayResId 。反之当前主题为夜间模式的话，先根据 dayResId 得到资源名称和资源类型。比如现在有一个资源为 R.color.colorPrimary ，那么资源名称就是 colorPrimary ，资源类型就是 color 。然后根据资源类型和资源名称去获取缓存。如果没有缓存，那么就要动态获取资源了。这里使用方法的是</p>
<pre><code>context.getResources().getIdentifier(String name, String defType, String defPackage)
</code></pre><ul>
<li><code>name</code> 参数就是资源名称，不过要注意的是这里的资源名称还要加上后缀 “_night” ，也就是上面在 colors.xml 中定义的名称；</li>
<li><code>defType</code> 参数就是资源的类型了。比如 color，drawable等；</li>
<li><code>defPackage</code> 就是资源文件的包名，也就是当前 APP 的包名。</li>
</ul>
<p>有了上面的这个方法，就可以通过 R.color.colorPrimary 资源找到对应的 R.color.colorPrimary_night 资源了。最后还要把找到的夜间模式资源加入到缓存中。这样的话以后就直接去缓存中读取，而不用再次去动态查找资源 id 了。</p>
<p>ThemeManager 中剩下的代码应该都是比较简单的，相信大家都可以看得懂了。</p>
<p>现在我们来看看 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ThemeManager</span>.<span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line">    <span class="keyword">private</span> Button btn_theme;</span><br><span class="line">    <span class="keyword">private</span> RelativeLayout relativeLayout;</span><br><span class="line">    <span class="keyword">private</span> ActionBar supportActionBar;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ThemeManager.registerThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        supportActionBar = getSupportActionBar();</span><br><span class="line">        btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        relativeLayout = (RelativeLayout) findViewById(R.id.relativeLayout);</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ThemeManager.setThemeMode(ThemeManager.getThemeMode() == ThemeManager.ThemeMode.DAY</span><br><span class="line">                        ? ThemeManager.ThemeMode.NIGHT : ThemeManager.ThemeMode.DAY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        btn_theme.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        relativeLayout.setBackgroundColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.backgroundColor)));</span><br><span class="line">        <span class="comment">// 设置标题栏颜色</span></span><br><span class="line">        <span class="keyword">if</span>(supportActionBar != <span class="keyword">null</span>)&#123;</span><br><span class="line">            supportActionBar.setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置状态栏颜色</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            Window window = getWindow();</span><br><span class="line">            window.setStatusBarColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initTheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ThemeManager.unregisterThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中实现了 OnThemeChangeListener 接口，这样就可以在主题改变的时候执行回调方法。然后在 <code>initTheme()</code> 中去重新设置 UI 的相关颜色属性值。还有别忘了要在 <code>onDestroy()</code> 中移除 ThemeChangeListener 。</p>
<p>最后就来看看第三种方法的效果吧：</p>
<p><img src="/uploads/20160908/20160910114556.gif" alt="动态获取资源id的效果图gif"></p>
<p>也许有人会说和前两种方法的效果没什么差异啊，但是仔细看就会发现前面两种方法在切换模式的瞬间会有短暂黑屏现象存在，而第三种方法没有。这是因为前两种方法都要调用 <code>recreate()</code> 。而第三种方法不需要 Activity 重新创建，使用回调的方法来实现。</p>
<h1 id="0x0003"><a href="#0x0003" class="headerlink" title="0x0003"></a>0x0003</h1><p>到了这里，按照套路应该是要总结的时候了。那么就根据上面给的三种方法来一个简单的对比吧：</p>
<ol>
<li><p>setTheme 方法：可以配置多套主题，比较容易上手。除了日/夜间模式之外，还可以有其他五颜六色的主题。但是需要调用 recreate() ，切换瞬间会有黑屏闪现的现象；</p>
</li>
<li><p>UiMode 方法：优点就是 Android Support Library 中已经支持，简单规范。但是也需要调用 recreate() ，存在黑屏闪现的现象；</p>
</li>
<li><p>动态获取资源 id ，回调接口：该方法使用起来比前两个方法复杂，另外在回调的方法中需要设置每一项 UI 相关的属性值。但是不需要调用 recreate() ，没有黑屏闪现的现象。</p>
</li>
</ol>
<p>三种方法整体的对比就如上所示了。当然除了上面的三种方法实现日/夜间模式切换之外，还有比如动态换肤等也都可以实现。方法有很多种，重要的是要根据自身情况选择合适的方法去实现。在下面我会给出其他几种实现日/夜间模式切换方法的链接，可以参考一下。</p>
<p>好了，到了说再见的时候了。</p>
<p>Goodbye !</p>
<p><a href="/uploads/20160908/ThemeDemo_setTheme.rar">setTheme方法的Demo下载</a></p>
<p><a href="/uploads/20160908/ThemeDemo_UiMode.rar">UiMode方法的Demo下载</a></p>
<p><a href="/uploads/20160908/ThemeDemo_thememanager.rar">动态获取资源id方法的Demo下载</a></p>
<h1 id="0x0004"><a href="#0x0004" class="headerlink" title="0x0004"></a>0x0004</h1><p><a href="https://segmentfault.com/a/1190000005736047?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">android 实现【夜晚模式】的另外一种思路</a></p>
<p><a href="http://www.diycode.cc/topics/269" target="_blank" rel="external">知乎和简书的夜间模式实现套路</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/08/06/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/08/06/《Android开发艺术探索》笔记(下)/</id>
    <published>2016-08-05T16:12:02.000Z</published>
    <updated>2016-09-06T10:27:25.523Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager" class="headerlink" title="第八章：理解Window和WindowManager"></a>第八章：理解Window和WindowManager</h1><h2 id="8-1_Window_u548CWindowManager"><a href="#8-1_Window_u548CWindowManager" class="headerlink" title="8.1 Window和WindowManager"></a>8.1 Window和WindowManager</h2><p>Window是抽象类，具体实现是PhoneWindow，通过WindowManager就可以创建Window。WindowManager是外界访问Window的入口，但是Window的具体实现是在WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。所有的视图例如Activity、Dialog、Toast都是附加在Window上的。因此，Window是实际上View的直接管理者。</p>
<p>WindowManager.LayoutParams中的flags参数解析：</p>
<ul>
<li>FLAG_NOT_FOCUSABLE：表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</li>
<li>FLAG_NOT_TOUCH_MODAL：在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</li>
<li>FLAG_SHOW_WHEN_LOCKED：开启此模式可以让Window显示在锁屏的界面上。</li>
</ul>
<p>type参数表示window的类型，window共有三种类型：应用window，子window和系统window。应用window对应着一个Activity，子window不能独立存在，需要附属在特定的父window之上，比如Dialog就是子window。系统window是需要声明权限才能创建的window，比如Toast和系统状态栏这些都是系统window，需要声明的权限是<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code>。</p>
<p>window是分层的，每个window都对应着z-ordered，层级大的会覆盖在层级小的上面，应用window的层级范围是1~99，子window的层级范围是1000~1999，系统window的层级范围是2000~2999。</p>
<p>WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="8-2_Window_u7684_u5185_u90E8_u673A_u5236"><a href="#8-2_Window_u7684_u5185_u90E8_u673A_u5236" class="headerlink" title="8.2 Window的内部机制"></a>8.2 Window的内部机制</h2><p>Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
<p>Window的添加、删除和更新过程都是IPC过程。WindowManager的实现类(即：WindowManagerImpl)对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots，其他的还有mParams和mDyingViews等。</p>
<p><strong>Window的添加过程</strong>：</p>
<ol>
<li>WindowManagerGlobal中的addView；</li>
<li>检查参数是否合法，如果子Window还需要调节布局参数；</li>
<li>创建ViewRootImpl并将View添加到列表中；</li>
<li>通过ViewRootImpl的setView来更新界面并完成Window的添加过程。在setView内部会调用requestLayout来完成异步刷新请求。在requestLayout中的scheduleTraversals是View绘制的入口，最终通过WindowSession来完成Window的添加过程，注意其实这里是个IPC过程，最终会通过WindowManagerService的addWindow方法来实现Window的添加。 </li>
</ol>
<p><strong>Window的删除过程</strong>：</p>
<ol>
<li>WinodwManagerGlobal中的removeView；</li>
<li>findViewLocked来查找待删除待View的索引，再调用removeViewLocked来做进一步删除；</li>
<li>removeViewLocked通过ViewRootImpl的die方法来完成删除操作，包括同步和异步两种方式，同步方式可能会导致意外的错误，不推荐，一般使用异步的方式，其实就是通过handler发送了一个删除请求，将View添加到mDyingViews中；</li>
<li>die方法本质调用了doDie方法，真正删除View的逻辑在该方法的dispatchDetachedFromWindow方法中，主要做了四件事：垃圾回收，通过Session的remove方法删除Window，调用View的dispatchDetachedFromWindow方法同时会回调View的onDetachedFromWindow以及onDetachedFromWindowInternal，调用WindowManagerGlobal的doRemoveView刷新数据。 </li>
</ol>
<p><strong>Window的更新过程</strong>：</p>
<ol>
<li>WindowManagerGlobal的updateViewLayout；</li>
<li>更新View的LayoutParams；</li>
<li>更新ViewImple的LayoutParams，实现对View的重新测量，布局，重绘；</li>
<li>通过WindowSession更新Window的视图，WindowManagerService.relayoutWindow()。</li>
</ol>
<h2 id="8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B"><a href="#8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B" class="headerlink" title="8.3 Window的创建过程"></a>8.3 Window的创建过程</h2><p><strong>Activity的window创建过程</strong>：</p>
<ol>
<li>Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</li>
<li>Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</li>
<li>Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</li>
<li>Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</li>
<li>还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewManager vm = getWindowManager();</span><br><span class="line">vm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">mWindowAdded = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Dialog的Window创建过程</strong>：</p>
<p>过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。解决的方案就是通过<code>dialog.getWindow.setType</code>方法设置成系统级别的type，记得在manifest中设置权限。</p>
<p><strong>Toast的Window创建过程</strong>：</p>
<ol>
<li>Toast内部有两类IPC：Toast访问NotificationManagerService；NotificationManagerService（下文简称NMS）访问Toast的TN接口；</li>
<li>Toast属于系统Window，内部视图mNextView一种为系统默认样式，另一种通过setView方法来指定一个自定义View。</li>
<li>TN是一个Binder类，NMS处理Toast的显示隐藏请求时会跨进程回调TN中的方法，所以TN运行在Binder线程池中，所以需要handler切换到当前发送Toast请求的线程中，也就是说没有Looper的线程是无法弹出Toast的。</li>
<li>Toast的show方法调用了NMS的enqueueToast方法，该方法先将Toast请求封装成ToastRecord并丢入mToastQueue队列中（非系统应用最多塞50个）。</li>
<li>NMS通过showNextToastLocked方法来显示当前View，Toast显示由ToastRecord的callback方法中的show方法完成，callback其实就是TN对象的远程Binder，所以最终调用的是TN中的方法，并运行在发起Toast请求应用的Binder线程池中。</li>
<li>显示以后，NMS通过scheduleTimeoutLocked方法发送延时消息，延时后NMS通过cancelToastLocked方法来隐藏Toast并从队列中移除，隐藏依然通过ToastRecord的callback中的hide方法实现。</li>
<li>callback回调TN的show和hide方法后，会通过handler发送两个Runnable，里面的handleShow和handleHide方法是真正完成显示和隐藏Toast的地方。handleShow方法中将Toast的视图添加到Window中，handleHide方法将Toast视图从Window中移除。</li>
</ol>
<h1 id="u7B2C10_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236"><a href="#u7B2C10_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236" class="headerlink" title="第10章 Android的消息机制"></a>第10章 Android的消息机制</h1><h2 id="10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0"><a href="#10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0" class="headerlink" title="10.1 Android消息机制概述"></a>10.1 Android消息机制概述</h2><p>Android的消息机制主要是指Handler的运行机制，其底层需要MessageQueue和Looper的支撑。MessageQueue是以单链表的数据结构存储消息列表但是以队列的形式对外提供插入和删除消息操作的消息队列。MessageQueue只是消息的存储单元，而Looper则是以无限循环的形式去查找是否有新消息，如果有的话就去处理消息，否则就一直等待着。</p>
<p>Handler的主要作用是将一个任务切换到某个指定的线程中去执行。</p>
<ul>
<li>为什么要提供这个功能呢？</li>
</ul>
<p>Android规定UI操作只能在主线程中进行，ViewRootImpl的checkThread方法会验证当前线程是否可以进行UI操作。</p>
<ul>
<li>为什么不允许子线程访问UI呢？</li>
</ul>
<p>这是因为UI组件不是线程安全的，如果在多线程中并发访问可能会导致UI组件处于不可预期的状态。另外，如果对UI组件的访问进行加锁机制的话又会降低UI访问的效率，所以还是采用单线程模型来处理UI事件。</p>
<p>Handler的创建会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程中不存在Looper的话就会报错。Handler可以用post方法将一个Runnable投递到消息队列中，也可以用send方法发送一个消息投递到消息队列中，其实post最终还是调用了send方法。</p>
<h2 id="10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790"><a href="#10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790" class="headerlink" title="10.2 Android的消息机制分析"></a>10.2 Android的消息机制分析</h2><p>(1).ThreadLocal的工作原理</p>
<ol>
<li>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用ThreadLocal。 对于Handler来说，它需要获取当前线程的Looper，而Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以实现Looper在线程中的存取了。</li>
<li>ThreadLocal的原理：不同线程访问同一个ThreadLocal的get方法时，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同线程中维护一套数据的副本并且彼此互不干扰。</li>
<li><p>ThreadLocal是一个泛型类public class ThreadLocal<t>，下面是它的set方法</t></p>
<pre><code>public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}
</code></pre><p> Values是Thread类内部专门用来存储线程的ThreadLocal数据的，它内部有一个数组private Object[] table，ThreadLocal的值就存在这个table数组中。如果values的值为null，那么就需要对其进行初始化然后再将ThreadLocal的值进行存储。<br> ThreadLocal数据的存储规则：ThreadLocal的值在table数组中的存储位置总是ThreadLocal的索引+1的位置。</p>
</li>
</ol>
<p>(2).MessageQueue的工作原理</p>
<ol>
<li>MessageQueue其实是通过单链表来维护消息列表的，它包含两个主要操作enqueueMessage和next，前者是插入消息，后者是取出一条消息并移除。</li>
<li>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将它从链表中移除。</li>
</ol>
<p>(3).Looper的工作原理</p>
<ol>
<li><p>为一个线程创建Looper的方法，代码如下所示</p>
<pre><code>new Thread(&quot;test&quot;){
    @Override
    public void run() {
        Looper.prepare();//创建looper
        Handler handler = new Handler();//可以创建handler了
        Looper.loop();//开始looper循环
    }
}.start();
</code></pre></li>
<li><p>Looper的prepareMainLooper方法主要是给主线程也就是ActivityThread创建Looper使用的，本质也是调用了prepare方法。</p>
</li>
<li>Looper的quit和quitSafely方法的区别是：前者会直接退出Looper，后者只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出之后，通过Handler发送的消息就会失败，这个时候Handler的send方法会返回false。<br>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</li>
<li>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null。也就是说，Looper必须退出，否则loop方法就会无限循环下去。Looper的loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞着在那里，这也导致了loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg)，其中的msg.target就是发送这条消息的Handler对象。</li>
</ol>
<p>(4).Handler的工作原理</p>
<ol>
<li>Handler就是处理消息的发送和接收之后的处理；</li>
<li><p>Handler处理消息的过程</p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);//当message是runnable的情况，也就是Handler的post方法传递的参数，这种情况下直接执行runnable的run方法
    } else {
        if (mCallback != null) {//如果创建Handler的时候是给Handler设置了Callback接口的实现，那么此时调用该实现的handleMessage方法
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);//如果是派生Handler的子类，就要重写handleMessage方法，那么此时就是调用子类实现的handleMessage方法
    }
}

private static void handleCallback(Message message) {
        message.callback.run();
}

/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
}
</code></pre></li>
<li><p>Handler还有一个特殊的构造方法，它可以通过特定的Looper来创建Handler。</p>
<pre><code>public Handler(Looper looper){
  this(looper, null, false);
}
</code></pre></li>
</ol>
<h2 id="10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF"><a href="#10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF" class="headerlink" title="10.3 主线程的消息循环"></a>10.3 主线程的消息循环</h2><p>Android的主线程就是ActivityThread，主线程的入口方法就是main，其中调用了Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()方法来开启主线程的消息循环。主线程内有一个Handler，即ActivityThread.H，它定义了一组消息类型，主要包含了四大组件的启动和停止等过程，例如LAUNCH_ACTIVITY等。</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方法完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
<h1 id="u7B2C11_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60"><a href="#u7B2C11_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60" class="headerlink" title="第11章 Android的线程和线程池"></a>第11章 Android的线程和线程池</h1><h2 id="11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B"><a href="#11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B" class="headerlink" title="11.1 主线程和子线程"></a>11.1 主线程和子线程</h2><ol>
<li>在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</li>
<li>在Android中除了Thread，还有HandlerThread、AsyncTask以及IntentService等也都扮演着线程的角色，只是它们具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</li>
<li>从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</li>
<li>AsyncTask是一个抽象泛型类，它提供了Params、Progress、Result三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为Void。下面是它的四个核心方法，其中doInBackground不是在主线程执行的。<br>onPreExecute、doInBackground、onProgressUpdate、onPostResult</li>
</ol>
<h2 id="11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001"><a href="#11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001" class="headerlink" title="11.2 Android中的线程形态"></a>11.2 Android中的线程形态</h2><ol>
<li><p>AsyncTask的使用过程中的条件限制：</p>
<p> (1).AsyncTask的类必须在主线程中加载，这个过程在Android 4.1及以上版本中已经被系统自动完成。</p>
<p> (2).AsyncTask对象必须在主线程中创建，execute方法必须在UI线程中调用。</p>
<p> (3).一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。</p>
<p> (4).在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android 3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android 3.0新添加的方法，并不能在低版本上使用。</p>
</li>
<li><p>AsyncTask的原理：</p>
<p> (1).AsyncTask中有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池；后者用于真正执行任务。AsyncTask中还有一个Handler，即InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</p>
<p> (2).AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable；接着将FutureTask交给SerialExecutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。</p>
</li>
<li><p>HandlerThread就是一种可以使用Handler的Thread，它的实现就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了，外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的quit或者quitSafely方法来终止线程的执行。HandlerThread的最主要的应用场景就是用在IntentService中。</p>
</li>
<li><p>IntentService是一个继承自Service的抽象类，要使用它就要创建它的子类。IntentService适合执行一些高优先级的后台任务，这样不容易被系统杀死。IntentService的onCreate方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的handleMessage方法中会调用IntentService的抽象方法onHandleIntent，所以IntentService的子类都要是实现这个方法。</p>
</li>
</ol>
<h2 id="11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60"><a href="#11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60" class="headerlink" title="11.3 Android中的线程池"></a>11.3 Android中的线程池</h2><p><strong>使用线程池的好处</strong>：</p>
<ol>
<li>重用线程，避免线程的创建和销毁带来的性能开销；</li>
<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<p>Executor只是一个接口，真正的线程池是ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，Android的线程池都是通过Executors提供的工厂方法得到的。</p>
<p><strong>ThreadPoolExecutor的构造参数</strong>：</p>
<ol>
<li>corePoolSize：核心线程数，默认情况下，核心线程会在线程中一直存活；</li>
<li>maximumPoolSize：最大线程数，当活动线程数达到这个数值后，后续的任务将会被阻塞；</li>
<li>keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收；</li>
<li>unit：用于指定keepAliveTime参数的时间单位，有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等；</li>
<li>workQueue：任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中；</li>
<li>threadFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，它只有一个方法Thread newThread(Runnable r)；</li>
<li>RejectedExecutionHandler：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的rejectedExecution方法来通知调用者，默认情况下，rejectedExecution会直接抛出一个rejectedExecutionException。</li>
</ol>
<p><strong>ThreadPoolExecutor执行任务的规则</strong>：</p>
<ol>
<li>如果线程池中的线程数未达到核心线程的数量，那么会直接启动一个核心线程来执行任务；</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在步骤2中无法将任务插入到的任务队列中，可能是任务队列已满，这个时候如果线程数量没有达到规定的最大值，那么会立刻启动非核心线程来执行这个任务；</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<p><strong>AsyncTask的THREAD_POOL_EXECUTOR线程池的配置</strong>：</p>
<ol>
<li>corePoolSize=CPU核心数+1；</li>
<li>maximumPoolSize=2倍的CPU核心数+1；</li>
<li>核心线程无超时机制，非核心线程在闲置时间的超时时间为1s；</li>
<li>任务队列的容量为128。</li>
</ol>
<p><strong>Android中常见的4类具有不同功能特性的线程池</strong>：</p>
<ol>
<li>FixedThreadPool：线程数量固定的线程池，它只有核心线程；</li>
<li>CachedThreadPool：线程数量不固定的线程池，它只有非核心线程；</li>
<li>ScheduledThreadPool：核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务；</li>
<li>SingleThreadPool：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。</li>
</ol>
<h1 id="u7B2C12_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache"><a href="#u7B2C12_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache" class="headerlink" title="第12章 Bitmap的加载和Cache"></a>第12章 Bitmap的加载和Cache</h1><h2 id="12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D"><a href="#12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D" class="headerlink" title="12.1 Bitmap的高速加载"></a>12.1 Bitmap的高速加载</h2><ol>
<li><p>Bitmap是如何加载的？</p>
<p> BitmapFactory类提供了四类方法：decodeFile、decodeResource、decodeStream和decodeByteArray从不同来源加载出一个Bitmap对象，最终的实现是在底层实现的。</p>
</li>
<li><p>如何高效加载Bitmap？</p>
<p> 采用BitmapFactory.Options按照一定的采样率来加载所需尺寸的图片，因为imageview所需的图片大小往往小于图片的原始尺寸。</p>
</li>
<li><p>BitmapFactory.Options的inSampleSize参数，即采样率<br>官方文档指出采样率的取值应该是2的指数，例如k，那么采样后的图片宽高均为原图片大小的 1/k。<br>如何获取采样率？</p>
<p> 下面是常用的获取采样率的代码片段：</p>
<pre><code>public Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {
    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}

public int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    if (reqWidth == 0 || reqHeight == 0) {
        return 1;
    }

    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    Log.d(TAG, &quot;origin, w= &quot; + width + &quot; h=&quot; + height);
    int inSampleSize = 1;

    if (height &gt; reqHeight || width &gt; reqWidth) {
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and
        // keeps both height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) {
            inSampleSize *= 2;
        }
    }

    Log.d(TAG, &quot;sampleSize:&quot; + inSampleSize);
    return inSampleSize;
}
</code></pre><p> 将inJustDecodeBounds设置为true的时候，BitmapFactory只会解析图片的原始宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。需要注意的是，这个时候BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，这都会导致BitmapFactory获取到不同的结果。</p>
</li>
</ol>
<h2 id="12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565"><a href="#12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565" class="headerlink" title="12.2 Android中的缓存策略"></a>12.2 Android中的缓存策略</h2><ol>
<li>最常用的缓存算法是LRU，核心是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，系统中采用LRU算法的缓存有两种：LruCache(内存缓存)和DiskLruCache(磁盘缓存)。</li>
<li>LruCache是Android 3.1才有的，通过support-v4兼容包可以兼容到早期的Android版本。LruCache类是一个线程安全的泛型类，它内部采用一个LinkedHashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</li>
<li>DiskLruCache磁盘缓存，它不属于Android sdk的一部分，<a href="/uploads/20160826/DiskLruCache.java">它的源码可以在这里下载</a><br>DiskLruCache的创建、缓存查找和缓存添加操作</li>
<li>ImageLoader的实现 具体内容看源码，<a href="/uploads/20160826/ImageLoader.java">点击下载</a><br>功能：图片的同步/异步加载，图片压缩，内存缓存，磁盘缓存，网络拉取</li>
</ol>
<h2 id="12-3_ImageLoader_u7684_u4F7F_u7528"><a href="#12-3_ImageLoader_u7684_u4F7F_u7528" class="headerlink" title="12.3 ImageLoader的使用"></a>12.3 ImageLoader的使用</h2><p>避免发生列表item错位的解决方法：给显示图片的imageview添加tag属性，值为要加载的图片的目标url，显示的时候判断一下url是否匹配。<br>优化列表的卡顿现象</p>
<ol>
<li>不要在getView中执行耗时操作，不要在getView中直接加载图片，否则肯定会导致卡顿；</li>
<li>控制异步任务的执行频率：在列表滑动的时候停止加载图片，等列表停下来以后再加载图片；</li>
<li>使用硬件加速来解决莫名的卡顿问题，给Activity添加配置<code>android:hardwareAccelerated=&quot;true&quot;</code>。</li>
</ol>
<h1 id="u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F"><a href="#u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F" class="headerlink" title="第十三章：综合技术"></a>第十三章：综合技术</h1><h2 id="13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F"><a href="#13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F" class="headerlink" title="13.1 使用CrashHandler来获取应用的Crash信息"></a>13.1 使用CrashHandler来获取应用的Crash信息</h2><p>应用发生Crash在所难免，但是如何采集crash信息以供后续开发处理这类问题呢？利用Thread类的setDefaultUncaughtExceptionHandler方法！defaultUncaughtHandler是Thread类的静态成员变量，所以如果我们将自定义的UncaughtExceptionHandler设置给Thread的话，那么当前进程内的所有线程都能使用这个UncaughtExceptionHandler来处理异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler handler)</span> </span>&#123;</span><br><span class="line">    Thread.defaultUncaughtHandler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实现了一个简易版本的UncaughtExceptionHandler类的子类<a href="/uploads/20160826/CrashHandler.java">CrashHandler，点击下载</a>。</p>
<p>CrashHandler的使用方式就是在Application的onCreate方法中设置一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里为应用设置异常处理程序，然后我们的程序才能捕获未处理的异常</span></span><br><span class="line">CrashHandler crashHandler = CrashHandler.getInstance();</span><br><span class="line">crashHandler.init(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h2 id="13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C"><a href="#13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C" class="headerlink" title="13.2 使用multidex来解决方法数越界"></a>13.2 使用multidex来解决方法数越界</h2><p>在Android中单个dex文件所能够包含的最大方法数是65536，这包含Android Framework、依赖的jar以及应用本身的代码中的所有方法。如果方法数超过了最大值，那么编译会报错<code>DexIndexOverflowException: method ID not in [0, 0xffff]:65536</code>。</p>
<p>有时方法数没有超过最大值，但是安装在低版本手机上时应用异常终止了，报错：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E/<span class="string">dalvikvm :</span> Optimization failed</span><br><span class="line">E<span class="regexp">/installed : dexopt failed on '/</span>data<span class="regexp">/dalvik-cache/</span>data<span class="annotation">@app</span><span class="annotation">@com</span>.ryg.multidextest-<span class="number">2.</span>apk<span class="annotation">@classes</span>.dex<span class="string">' res=65280</span></span><br></pre></td></tr></table></figure>
<p>这是因为应用在安装的时候，系统会通过dexopt程序来优化dex文件，在优化的过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法的信息，这个缓冲区就是LinearAlloc。LinearAlloc缓冲区在新版本的Android系统中大小是8MB或者16MB，但是在Android 2.2和2.3中却只有5MB，当待安装的应用的方法数比较多的时候，尽管它还没有达到最大方法数，但是它的存储空间仍然有可能超过5MB，这种情况下dexopt就会报错导致安装失败。</p>
<p>如何解决方法数越界的问题呢？ Google在2014年提出了简单方便的multidex的解决方案。<br>在Android 5.0之前使用multidex需要引入android-support-multidex.jar包，从Android 5.0开始，系统默认支持了multidex，它可以从apk中加载多个dex。这里Multidex方案主要针对AndroidStudio和Gradle编译环境。</p>
<p>使用Multidex的步骤：</p>
<ol>
<li><p>在build.gradle文件中添加multiDexEnabled true</p>
<pre><code>android {
    ...

    defaultConfig {
        ...

        multiDexEnabled true // [添加的配置] enable multidex support
    }
    ...
}
</code></pre></li>
<li><p>添加对multidex的依赖</p>
<pre><code>compile &apos;com.android.support:multidex:1.0.0&apos;
</code></pre></li>
<li><p>在代码中添加对multidex的支持，这里有三种方案：</p>
<p> ① 在AndroidManifest文件中指定Application为MultiDexApplication；</p>
<pre><code>&lt;application android:name=&quot;android.support.multidex.MultiDexApplication&quot;
...
&lt;/application&gt;
</code></pre><p> ② 让应用的Application继承自MultiDexApplication；</p>
<p> ③ 重写Application的attachBaseContext方法，这个方法要先于onCreate方法执行；</p>
<pre><code>public class TestApplication extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
</code></pre></li>
</ol>
<p>采用上面的配置之后，如果应用的方法数没有越界，那么Gradle并不会生成多个dex文件；如果方法数越界后，Gradle就会在apk中打包2个或者多个dex文件，具体会打包多少个dex文件要看当前项目的代码规模。在有些情况下，可能需要指定主dex文件中所要包含的类，这个可以通过–main-dex-list选项来实现这个功能。</p>
<p>build.gradle：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"afterEvaluate"</span></span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">'dex'</span>)</span><br><span class="line">    &#125;.<span class="keyword">each</span> &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">def</span> listFile = <span class="keyword">project</span>.rootDir.absolutePath + <span class="string">'/app/maindexlist.txt'</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"root dir:"</span> + <span class="keyword">project</span>.rootDir.absolutePath</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"dex task found: "</span> + dx.name</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        dx.additionalParameters += <span class="string">'--multi-dex'</span></span><br><span class="line">        dx.additionalParameters += <span class="string">'--main-dex-list='</span> + listFile</span><br><span class="line">        dx.additionalParameters += <span class="string">'--minimal-main-dex'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>maindexlist.txt：</p>
<pre><code>com/ryg/multidextest/TestApplication.class
com/ryg/multidextest/MainActivity.class

// multidex
android/support/multidex/MultiDex.class
android/support/multidex/MultiDexApplication.class
android/support/multidex/MultiDexExtractor.class
android/support/multidex/MultiDexExtractor$1.class
android/support/multidex/MultiDex$V4.class
android/support/multidex/MultiDex$V14.class
android/support/multidex/MultiDex$V19.class
android/support/multidex/ZipUtil.class
android/support/multidex/ZipUtil$CentralDirectory.class
</code></pre><p>–multi-dex表明当方法数越界时生成多个dex文件，–main-dex-list指定了要在主dex中打包的类的列表，–minimal-main-dex表明只有–main-dex-list所指定的类才能打包到主dex中。multidex的jar包中的9个类必须要打包到主dex中，其次不能在Application中成员以及代码块中访问其他dex中的类，否个程序会因为无法加载对应的类而中止执行。</p>
<p>Multidex方案可能带来的问题：</p>
<ol>
<li>应用启动速度会降低，因为应用启动的时候会加载额外的dex文件，甚至可能出现ANR现象。所以要避免生成较大的dex文件；</li>
<li>需要做大量的兼容性测试，因为Dalvik LinearAlloc的bug，可能导致使用multidex的应用无法在Android 4.0以前的手机上运行。同时由于Dalvik linearAlloc的bug，有可能会出现应用在运行中由于采用了multidex方案从而产生大量的内存消耗的情况，这会导致奔溃。</li>
</ol>
<p>在实际项目中，1.中的现象是客观存在的，但是2.中的现象目前极少遇到。</p>
<h2 id="13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F"><a href="#13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F" class="headerlink" title="13.3 Android的动态加载技术"></a>13.3 Android的动态加载技术</h2><p>动态加载技术又称插件化技术，将应用插件化可以减轻应用的内存和CPU占用，还可以在不发布新版本的情况下更新某些模块。不同的插件化方案各有特色，但是都需要解决三个基础性问题：资源访问，Activity生命周期管理和插件ClassLoader的管理。</p>
<p>宿主和插件：宿主是指普通的apk，插件是经过处理的dex或者apk。在主流的插件化框架中多采用特殊处理的apk作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。</p>
<p>三个基础性问题的解决方案：</p>
<ol>
<li>资源访问：宿主程序调起未安装的插件apk，插件中凡是R开头的资源都不能访问了，因为宿主程序中并没有插件的资源，通过R来访问插件的资源是行不通的。<br>Activity的资源访问是通过ContextImpl来完成的，它有两个方法getAssets()和getResources()方法是用来加载资源的。<br>具体实现方式是通过反射，调用AssetManager的addAssetPath方法添加插件的路径，然后将插件apk中的资源加载到Resources对象中即可。</li>
<li>Activity生命周期管理：有两种常见的方式，反射方式和接口方式。反射方式就是通过反射去获取Activity的各个生命周期方法，然后在代理Activity中去调用插件Activity对应的生命周期方法即可。<br>反射方式代码繁琐，性能开销大。接口方式将Activity的生命周期方法提取出来作为一个接口，然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理。</li>
<li>插件ClassLoader的管理：为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引起的类型转换错误。</li>
</ol>
<p>其他详细信息看作者插件化框架 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">singwhatiwanna/dynamic-load-apk</a></p>
<h2 id="13-4__u53CD_u7F16_u8BD1_u521D_u6B65"><a href="#13-4__u53CD_u7F16_u8BD1_u521D_u6B65" class="headerlink" title="13.4 反编译初步"></a>13.4 反编译初步</h2><p>反编译可查看<a href="/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/">Android安全机制之反编译</a></p>
<p>二次打包：</p>
<pre><code>apktool.bat b [解包后文件所在的位置] [二次打包之后的文件名]
</code></pre><p>签名：</p>
<pre><code>java -jar signapk.jar testkey.x509.pem testkey.pk8 [未签名apk] [已签名apk]
</code></pre><h1 id="u7B2C15_u7AE0_Android_u6027_u80FD_u4F18_u5316"><a href="#u7B2C15_u7AE0_Android_u6027_u80FD_u4F18_u5316" class="headerlink" title="第15章 Android性能优化"></a>第15章 Android性能优化</h1><p>2015年Google关于Android性能优化典范的专题视频：</p>
<p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Youtube视频地址</a></p>
<h2 id="15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5"><a href="#15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5" class="headerlink" title="15.1 Android的性能优化方法"></a>15.1 Android的性能优化方法</h2><ol>
<li><p>布局优化</p>
<p> (1).删除布局中无用的组件和层级，有选择地使用性能较低的ViewGroup；</p>
<p> (2).使用<include>、<merge>、<viewstub>等标签：<include>标签主要用于布局重用，<merge>标签一般和<include>配合使用，它可以减少布局中的层级；<viewstub>标签则提供了按需加载的功能，当需要的时候才会将ViewStub中的布局加载到内存，提供了程序的初始化效率。</viewstub></include></merge></include></viewstub></merge></include></p>
<p> (3).<include>标签只支持android:layout_开头的属性，android:id属性例外。</include></p>
<p> (4).ViewStub继承自View，它非常轻量级且宽高都为0，它本身不参与任何的布局和绘制过程。实际开发中，很多布局文件在正常情况下不会显示，例如网络异常时的界面，这个时候就没有必要在整个界面初始化的时候加载进行，通过ViewStub可以做到在需要的时候再加载。<br> 如下面示例，android:id是ViewStub的id，而android:inflatedId是布局的根元素的id。</p>
<pre><code>&lt;ViewStub android:id=&quot;@+id/xxx&quot;
  android:inflatedId=&quot;@+id/yyy&quot;
  android:layout=&quot;@layout/zzz&quot;
  ...
&lt;/ViewStub&gt;
</code></pre></li>
<li><p>绘制优化</p>
<p> (1).在onDraw中不要创建新的布局对象，因为onDraw会被频繁调用；<br> (2).onDraw方法中不要指定耗时任务，也不能执行成千上万次的循环操作。</p>
</li>
<li><p>内存泄露优化</p>
<p> 可能导致内存泄露的场景很多，例如静态变量、单例模式、属性动画、AsyncTask、Handler等等</p>
</li>
<li><p>响应速度优化和ANR日志分析</p>
<p> (1).ANR出现的情况：Activity如果5s内没有响应屏幕触摸事件或者键盘输入事件就会ANR，而BroadcastReceiver如果10s内没有执行完操作也会出现ANR。</p>
<p> (2).当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位ANR的原因。</p>
</li>
<li><p>ListView和Bitmap优化</p>
<p> (1).ListView优化：采用ViewHolder并避免在getView方法中执行耗时操作；根据列表的滑动状态来绘制任务的执行频率；可以尝试开启硬件加速来使ListView的滑动更加流畅。</p>
<p> (2).Bitmap优化：根据需要对图片进行采样，详情请看第12章 Bitmap的加载和Cache。</p>
</li>
<li><p>线程优化</p>
<p> 采用线程池，详情请看第11章 Android的线程和线程池。</p>
</li>
<li><p>一些性能优化建议</p>
<p> (1).不要过多使用枚举，枚举占用的内存空间要比整型大；</p>
<p> (2).常量请使用static final来修饰；</p>
<p> (3).使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能；</p>
<p> (4).适当使用软引用和弱引用；</p>
<p> (5).采用内存缓存和磁盘缓存；</p>
<p> (6).尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</p>
</li>
</ol>
<h2 id="15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177"><a href="#15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177" class="headerlink" title="15.2 内存泄露分析之MAT工具"></a>15.2 内存泄露分析之MAT工具</h2><p>MAT是功能强大的内存分析工具，主要有Histograms和Dominator Tree等功能。</p>
<p>详细的可以查看 <a href="http://gold.xitu.io/entry/563b341e60b20bd506b55592" target="_blank" rel="external">内存泄露从入门到精通三部曲</a>。</p>
<h2 id="15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027"><a href="#15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027" class="headerlink" title="15.3 提高程序的可维护性"></a>15.3 提高程序的可维护性</h2><ol>
<li>命名规范。比如私有成员变量以m开头，静态成员变量以s开头，常量全部以大写字母表示；</li>
<li>代码的排版上需要留出合理的空白来区分不同的代码块；</li>
<li>仅为非常关键的代码添加注释，其他地方不用注释。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步步深入解析AIDL]]></title>
    <link href="http://yuqirong.me/2016/07/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90AIDL/"/>
    <id>http://yuqirong.me/2016/07/28/一步步深入解析AIDL/</id>
    <published>2016-07-28T14:55:37.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需要在两个进程之间进行一些数据的交换。而在深入学习 Android 的过程中难免会遇到 IPC 的相关问题，比如常见的有在自己的应用程序中读取手机联系人的信息，这就涉及到 IPC 了。因为自己的应用程序是一个进程，通讯录也是一个进程，只不过获取通讯录的数据信息是通过 Content Provider 的方式来实现的。</p>
<p>对于初学者来说，在一开始接触 IPC 时可能会摸不着头脑，因为网上很多博客在讲 Android IPC 时通常都是长篇大论，没有从例子着手。基于以上种种原因以及希望对 AIDL 有一个更深入的理解，本篇博文就诞生了。在 Android 系统中，IPC 的方式有很多种，比如有 Messenger 、AIDL 和 ContentProvider 等。我们今天就来讲讲其中的 AIDL ，AIDL 也是比较常见和经常使用的一种 IPC 方式。希望读者在看完本篇之后对于 AIDL 有一个比较深入的理解。</p>
<h1 id="u4EC0_u4E48_u662F_AIDL"><a href="#u4EC0_u4E48_u662F_AIDL" class="headerlink" title="什么是 AIDL"></a>什么是 AIDL</h1><p>首先我们对于新的事物都会有一个疑问，那就是什么是 AIDL？</p>
<p>AIDL 的全称是 Android Interface Definition Language(即 Android 接口定义语言)。通常对于 AIDL 的使用有三步流程：</p>
<ol>
<li>定义 AIDL 接口；</li>
<li>在 Service 中创建对应的 Stub 对象；</li>
<li>将该服务暴露给其他进程调用；</li>
</ol>
<p>讲完了流程，我们就又有一个疑问了，Android系统中实现 IPC 有这么多方式，到底应该在什么情况下使用 AIDL 呢？</p>
<p>Android 官方文档给出的答案是：</p>
<p>Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.</p>
<p>使用AIDL只有在你允许来自不同应用的客户端跨进程通信访问你的Service，并且想要在你的Service种处理多线程的时候才是必要的。 简单地来说，就是多个客户端，多个线程并发的情况下要使用 AIDL 。官方文档还指出，如果你的 IPC 不需要适用于多个客户端的，那就使用 Binder ；如果你的想要 IPC ，但是不需要多线程，那就选择 Messenger 。</p>
<p>相信大家到这里对于 AIDL 有一个初步的概念了，那么下面我们就来举个例子讲解一下 AIDL 。</p>
<h1 id="AIDL_u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#AIDL_u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="AIDL的使用方法"></a>AIDL的使用方法</h1><p>我们来模拟一下需要进行 IPC 的情况，现在有客户端和服务端，客户端通过 AIDL 来和服务端进行 IPC 。我们假定现在客户端需要传一个 Person 类的对象给服务端，之后服务端回传给客户端一个 Person 类的集合。</p>
<p>先来看看服务端的相关代码，以下 Person.aidl 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>
<p>注意在 IPC 机制中传递的自定义对象需要序列化，所以要实现 Parcelable 接口。在 AIDL 文件中使用 <code>parcelable</code> 关键字声明。有了 Person.aidl 之后，我们就要创建 AIDL 接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="keyword">import</span> com.yuqirong.aidldemo.Person;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(in Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 IMyAidlInterface.aidl 里，主要声明一个用于添加 Person 对象的抽象方法。另外，需要注意以下几点：</p>
<ol>
<li>Person 类需要手动去 import ，在 AIDL 文件中不能自动导包；</li>
<li>在 <code>addPerson</code> 方法里需要声明参数是 in 的，用来表示该参数是传入的。除了 in 之外，还有 out 和 inout ；</li>
</ol>
<p>下面我们要创建一个 Service 用于和客户端进行 IPC 。这里还要把该 Service 运行在一个新的进程里。我们只要在 AndroidManifest.xml 中声明 <code>android:process=&quot;:remote&quot;</code> 就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Nullable</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"bind success"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="comment">// 需要同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (persons)&#123;</span><br><span class="line">                persons.add(person);</span><br><span class="line">                <span class="keyword">return</span> persons;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们可以看到在 <code>onBind(Intent intent)</code> 方法中返回了 mBinder ，而客户端正是通过这个 mBinder 来和服务端进行 IPC 的。mBinder 是 IMyAidlInterface.Stub 匿名类的对象，IMyAidlInterface.Stub 其实是一个抽象类，继承自 Binder ，实现 <code>addPerson</code> 方法。这里要注意以下，在 <code>addPerson</code> 的方法中需要将 persons 同步，这是因为在服务端 AIDL 是运行在 Binder 线程池中的，有可能会有多个客户端同时连接，这时候就需要同步以防止数据出错。</p>
<p>服务端的代码差不多就这些，下面我们来看看客户端的，客户端也是需要 AIDL 文件的，可以从服务端中复制过来。需要注意的是包名和 AIDL 文件都要和服务端保持一致，否则在客户端反序列化的时候会出错。以下只截取了客户端部分关键代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端用来和服务端IPC的接口</span></span><br><span class="line"><span class="keyword">private</span> IMyAidlInterface aidlInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务端的服务，并进行绑定</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yuqirong.aidldemo"</span>, <span class="string">"com.yuqirong.aidldemo.MyService"</span>));</span><br><span class="line">bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里得到了和服务端进行通信的接口</span></span><br><span class="line">        aidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        aidlInterface = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端通过 Intent 启动并绑定服务端的 Service ，在 <code>onServiceConnected</code> 中通过 binder 对象得到了 aidlInterface 。之后客户端就可以使用 aidlInterface 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Person&gt; list = aidlInterface.addPerson(<span class="keyword">new</span> Person(<span class="string">"yuqirong"</span>, <span class="number">21</span>, <span class="string">"13567891023"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>我们注意到，在客户端调用 AIDL 接口方法时是新创建了一个子线程去执行的，这是因为在服务端在处理 AIDL 时有可能是很耗时的。如果在主线程中去执行，那么就有可能出现 ANR 的问题。所以为了避免 ANR ，在客户端调用 AIDL 的代码最好在子线程去执行。</p>
<p>整套 AIDL 的流程基本上就是这样的。通过这个简单的例子，相信对于 AIDL 有了一个初步的了解。下面我们就要去揭开 AIDL 是如何实现 IPC 的神秘面纱。</p>
<h1 id="u89E3_u6790AIDL"><a href="#u89E3_u6790AIDL" class="headerlink" title="解析AIDL"></a>解析AIDL</h1><p>现在我们终于要来看看 AIDL 是如何工作的？我们可以在工程中的 gen 目录下找到对应 AIDL 编译后的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.yuqirong.aidldemo.IMyAidlInterface"</span>;</span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.yuqirong.aidldemo.IMyAidlInterface interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.yuqirong.aidldemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.yuqirong.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.yuqirong.aidldemo.IMyAidlInterface)iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.yuqirong.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addPerson:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.yuqirong.aidldemo.Person _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.yuqirong.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result = <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">            Proxy(android.os.IBinder remote)</span><br><span class="line">            &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">            &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((person!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.yuqirong.aidldemo.Person.CREATOR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到编译后的 IMyAidlInterface.aidl 变成了一个接口，继承自 IInterface 。在 IMyAidlInterface 接口中我们发现主要分成两部分结构：抽象类 Stub 和原来 aidl 中声明的 <code>addPerson</code> 方法。</p>
<p>重点在于 Stub 类，下面我们来分析一下。从 Stub 类中我们可以看到是继承自 Binder 并且实现了 IMyAidlInterface 接口。 Stub 类的基本结构如下：</p>
<ul>
<li><code>asInterface(android.os.IBinder obj)</code> 方法；</li>
<li><code>asBinder()</code> 方法；</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法；</li>
<li>静态类 <code>Proxy</code>，主要方法是 <code>addPerson(com.yuqirong.aidldemo.Person person)</code> ；</li>
<li>静态常量 <code>TRANSACTION_addPerson</code> ；</li>
</ul>
<p><strong>asInterface(android.os.IBinder obj)</strong></p>
<p>我们先从 <code>asInterface(android.os.IBinder obj)</code> 方法入手，在上面的代码中可以看到，主要的作用就是根据传入的Binder对象转换成客户端需要的 IMyAidlInterface 接口。如果服务端和客户端处于同一个进程，那么该方法得到的就是服务端 Stub 对象本身，也就是上面 AIDL 例子 MyService 中的 mBinder 对象；否则返回的是系统封装后的 Stub.Proxy ，也就是一个代理类，在这个代理中实现跨进程通信。</p>
<p><strong>asBinder()</strong></p>
<p>该方法就是返回当前的 Binder 对象。</p>
<p><strong>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</strong></p>
<p>在 <code>onTransact</code> 方法中，根据传入的 code 值会去执行服务端相对应的方法。其中静态变量 <code>TRANSACTION_addPerson</code> 就是其中的 code 值之一(在 AIDL 文件中声明的方法有多少个就有多少个对应的 code )。其中 data 就是服务端方法中所需要的参数，执行完后，最后把方法的返回结果放入 reply 中传递给客户端。若该方法返回 false ，那么客户端请求失败。</p>
<p><strong>Proxy中的addPerson(com.yuqirong.aidldemo.Person person)</strong></p>
<p>Proxy 类是实现了 IMyAidlInterface 接口，把其中的 <code>addPerson</code> 方法进行了重写。在方法中一开始创建了两个 Parcel 对象，其中一个用来把方法的参数装入，然后调用 <code>transact</code> 方法执行服务端的代码，执行完后把返回的结果装入另外一个 Parcel 对象中返回。</p>
<p>看完上面方法的介绍，我们回过头来看看 AIDL 例子中实现的流程。在客户端中通过 Intent 去绑定一个服务端的 Service 。在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 方法中通过返回的 service 可以得到对应的 AIDL 接口的实例。这是调用了 <code>asInterface(android.os.IBinder obj)</code> 方法来完成的。</p>
<p>客户端在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 中得到的 service 正是服务端中的 mBinder 。当客户端调用 AIDL 接口时，AIDL 通过 Proxy 类中的 <code>addPerson</code> 来调用 <code>transact</code> 方法，<code>transact</code> 方法又会去调用服务端的 <code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法。 <code>onTransact</code> 方法是运行在服务端的 Binder 线程池中的。在 <code>onTransact</code> 中根据 code 执行相关 AIDL 接口的方法，方法的参数从 data 中获取。执行完毕之后把结果装入 reply 中返回给客户端。 AIDL 的流程基本上就是这样子了。</p>
<p>到了这里，大家就会发现 AIDL 底层的实现就是依靠 Binder 来完成的。为了方便大家的理解，这里给出一张 AIDL 机制的原理图( PS :该图来自于《Android开发艺术探索》，感谢任主席)：</p>
<p><img src="/uploads/20160728/20160728201234.png" alt="AIDL机制原理图"></p>
<h1 id="u7ED3_u5C3E"><a href="#u7ED3_u5C3E" class="headerlink" title="结尾"></a>结尾</h1><p>写到这里本篇博文就临近末尾了。 AIDL 在 Android IPC 机制中算得上是很重要的一部分，AIDL 主要是通过 Binder 来实现进程通信的。其实另一种 IPC 的方式 Messenger 底层也是通过 AIDL 来实现的。所以 AIDL 的重要性就不言而喻了。如果有兴趣的同学可以在理解 AIDL 的基础上去看看 Messenger 的源码。当然在上面的 AIDL 例子中的代码是很简单的，没有涉及到死亡代理、权限验证等功能，童鞋们可以自己去把这些相关的去学习下。</p>
<p>好了，最后附上 AIDL 例子的源码：</p>
<p><a href="/uploads/20160728/AIDLDemo.rar">AIDLDemo.rar</a></p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="/2016/03/31/《Android开发艺术探索》笔记(上)/">《Android开发艺术探索》笔记(上) —— 第二章：IPC机制</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="IPC" scheme="http://yuqirong.me/tags/IPC/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现炫酷的滑动返回效果]]></title>
    <link href="http://yuqirong.me/2016/07/07/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/07/07/简单实现炫酷的滑动返回效果/</id>
    <published>2016-07-06T16:25:04.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功能，那就是滑动返回。比如知乎、百度贴吧等，用户在使用这一类的 app 都可以滑动返回上一个页面。不得不说这个设计很赞，是不是心动了呢？那就继续往下看吧！</p>
<p>在GitHub上有实现该效果的开源库 <a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a> ，可以看到该库发展得已经非常成熟了。仔细看源码你会惊奇地发现其中的奥秘，没错，正是借助了 ViewDragHelper 来实现滑动返回的效果。ViewDragHelper 我想不必多说了，在我的博客中有很多的效果都是通过它来实现的。那么，下面我们就使用 ViewDragHelper 来实现这个效果吧。</p>
<h1 id="u81EA_u5B9A_u4E49_u5C5E_u6027"><a href="#u81EA_u5B9A_u4E49_u5C5E_u6027" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>首先，我们应该先定义几个自定义属性，比如说支持用户从左边或者右边滑动返回，丰富用户的选择性。所以现在 attrs.xml 中定义如下属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SwipeBackLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"swipe_mode"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的 xml 中可知，定义了一个枚举属性，左边为0，右边为1。</p>
<p>然后主角 SwipeBackLayout 就要登场了。</p>
<pre><code>public class SwipeBackLayout extends FrameLayout {

    private ViewDragHelper mViewDragHelper;
    // 主界面
    private View mainView;
    // 主界面的宽度
    private int mainViewWidth;
    // 模式，默认是左滑
    private int mode = MODE_LEFT;
    // 监听器
    private SwipeBackListener listener;
    // 是否支持边缘滑动返回, 默认是支持
    private boolean isEdge = true;

    private int mEdge;
    // 阴影Drawable
    private Drawable shadowDrawable;
    // 阴影Drawable固有宽度
    private int shadowDrawbleWidth;
    // 已经滑动的百分比
    private float movePercent;
    // 滑动的总长度
    private int totalWidth;
    // 默认的遮罩透明度
    private static final int DEFAULT_SCRIM_COLOR = 0x99000000;
    // 遮罩颜色
    private int scrimColor = DEFAULT_SCRIM_COLOR;
    // 透明度
    private static final int ALPHA = 255;

    private Paint mPaint;
    /**
     * 滑动的模式，左滑
     */
    public static final int MODE_LEFT = 0;
    /**
     * 滑动的模式，右滑
     */
    public static final int MODE_RIGHT = 1;
    // 最小滑动速度
    private static final int MINIMUM_FLING_VELOCITY = 400;

    private static final String TAG = &quot;SwipeBackLayout&quot;;

    public SwipeBackLayout(Context context) {
        this(context, null);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeBackLayout);
        // 得到滑动模式，默认左滑
        mode = a.getInt(R.styleable.SwipeBackLayout_swipe_mode, MODE_LEFT);
        a.recycle();
        initView();
    }

    ...

}
</code></pre><h1 id="initView"><a href="#initView" class="headerlink" title="initView"></a>initView</h1><p>在构造器主要做的就是得到滑动模式，默认是左边滑动。之后调用 <code>initView()</code> 。那么我们来看看 <code>initView()</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阴影Drawable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShadowView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right, getContext().getTheme());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shadowDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shadowDrawbleWidth = shadowDrawable.getIntrinsicWidth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> density = getResources().getDisplayMetrics().density;</span><br><span class="line">	<span class="comment">// 最小滑动速度</span></span><br><span class="line">    <span class="keyword">float</span> minVel = density * MINIMUM_FLING_VELOCITY;</span><br><span class="line">    initShadowView();</span><br><span class="line">    mViewDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="keyword">new</span> ViewDragHelper.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mainView == child; <span class="comment">// 只有是主界面时才可以被滑动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据模式区分</span></span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:  <span class="comment">// 左边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:  <span class="comment">// 右边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    movePercent = left * <span class="number">1f</span> / totalWidth;  <span class="comment">// 滑动的进度</span></span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    movePercent = Math.abs(left) * <span class="number">1f</span> / totalWidth;</span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == MODE_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(totalWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -totalWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &gt; -mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;  <span class="comment">// 如果当前已经滑动超过子View宽度的一半，并且速度符合预期设置</span></span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);  <span class="comment">// 把当前界面finish</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &gt; mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();  <span class="comment">// 当前界面回到原位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &lt; mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &lt; -mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置最小滑动速度</span></span><br><span class="line">    mViewDragHelper.setMinVelocity(minVel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// 子View只能有一个</span></span><br><span class="line">        <span class="comment">// 获取子view</span></span><br><span class="line">        mainView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the child of swipebacklayout can not be empty and must be the one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 得到主界面的宽度</span></span><br><span class="line">    mainViewWidth = w;</span><br><span class="line">    <span class="comment">//总长度，包含了mainView的宽度以及阴影图片的宽度</span></span><br><span class="line">    totalWidth = mainViewWidth + shadowDrawbleWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initView()</code> 中，设置了 mViewDragHelper 的最小滑动速度，并且设置了 mViewDragHelper 回调的接口。回调接口中的方法都有注释，相信大家应该都能看懂。另外在 <code>initView()</code> 中初始化了阴影图片，以备下面中使用。</p>
<h1 id="drawChild"><a href="#drawChild" class="headerlink" title="drawChild"></a>drawChild</h1><p>想要阴影在滑动中绘制出来，我们必须重写 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法，并且在 <code>onTouchEvent(MotionEvent event)</code> 里 <code>invalidate()</code> ,保证用户滑动过程中调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">""</span> + (mViewDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE));</span><br><span class="line">    <span class="keyword">if</span> (child == mainView &amp;&amp; mViewDragHelper.getViewDragState() != ViewDragHelper.STATE_IDLE) &#123;</span><br><span class="line">        <span class="comment">// 绘制阴影</span></span><br><span class="line">        drawShadowDrawable(canvas, child);</span><br><span class="line">        <span class="comment">// 绘制遮罩层</span></span><br><span class="line">        drawScrimColor(canvas, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="comment">// 重绘，保证在滑动的时候可以绘制阴影</span></span><br><span class="line">    invalidate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中调用 <code>drawShadowDrawable(Canvas canvas, View child)</code> 来绘制阴影以及 <code>drawScrimColor(Canvas canvas, View child)</code> 来绘制遮罩层。下面分别是两个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制阴影</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadowDrawable</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    Rect drawableRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">// 得到mainView的矩形</span></span><br><span class="line">    child.getHitRect(drawableRect);</span><br><span class="line">    <span class="comment">// 设置shadowDrawable绘制的矩形</span></span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.left - shadowDrawbleWidth, drawableRect.top, drawableRect.left, drawableRect.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.right, drawableRect.top, drawableRect.right + shadowDrawbleWidth, drawableRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置shadowDrawable的透明度,最低为0.3</span></span><br><span class="line">    shadowDrawable.setAlpha((<span class="keyword">int</span>) ((<span class="number">1</span> - movePercent &gt; <span class="number">0.3</span> ? <span class="number">1</span> - movePercent : <span class="number">0.3</span>) * ALPHA));</span><br><span class="line">    <span class="comment">// 将shadowDrawable绘制在canvas上</span></span><br><span class="line">    shadowDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制遮罩层</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawScrimColor</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据滑动进度动态设置透明度</span></span><br><span class="line">    <span class="keyword">int</span> baseAlpha = (scrimColor &amp; <span class="number">0xFF000000</span>) &gt;&gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (baseAlpha * (<span class="number">1</span> - movePercent));</span><br><span class="line">    <span class="keyword">int</span> color = alpha &lt;&lt; <span class="number">24</span> | (scrimColor &amp; <span class="number">0xffffff</span>);</span><br><span class="line">    <span class="comment">// 设置绘制矩形区域</span></span><br><span class="line">    Rect rect;</span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, child.getLeft(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(child.getRight(), <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(color);</span><br><span class="line">    canvas.drawRect(rect, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mainView 、阴影、遮罩层的关系示意图如下：</p>
<p><img src="/uploads/20160707/20160707211516.png" alt="relatives_pic"></p>
<h1 id="onViewReleased"><a href="#onViewReleased" class="headerlink" title="onViewReleased"></a>onViewReleased</h1><p>看完了上面的两个方法的代码，最后就是当用户手指抬起时判断逻辑的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动返回，结束该View</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToFinish</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, finalLeft, finalTop)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onSwipeBackFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动回归到原位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToRestore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SwipeBackListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 该方法会在滑动返回完成的时候回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipeBackFinish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置滑动返回监听器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> listener</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwipeBackListener</span><span class="params">(SwipeBackListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的代码还是比较简单的，主要使用了 <code>smoothSlideViewTo(View view, int left, int top)</code> 的方法来滑动到指定位置。若是结束当前界面的话，回调监听器的接口。</p>
<p>啰嗦了这么多，我们来看看运行时的效果图吧：</p>
<p><img src="/uploads/20160707/20160707212521.gif" alt="SwipeBackDemo Screenshot"></p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>好了，SwipeBackLayout 大致的逻辑就是上面这样子的。整体来说还是比较通俗易懂的，而且对 ViewDragHelper 熟悉的人会发现，使用 ViewDragHelper 自定义一些 ViewGroup 的套路都是大同小异的。以后想要自定义一些 ViewGroup 都是得心应手了。</p>
<p>如果对此有疑问的话可以在下面留言。</p>
<p>最后，国际惯例，附上 SwipeBackLayout Demo 的源码：</p>
<p><a href="/uploads/20160707/SwipeBackDemo.rar">SwipeBackDemo.rar</a></p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CursorAdapter中的filter机制]]></title>
    <link href="http://yuqirong.me/2016/07/03/%E8%AF%A6%E8%A7%A3CursorAdapter%E4%B8%AD%E7%9A%84filter%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2016/07/03/详解CursorAdapter中的filter机制/</id>
    <published>2016-07-03T12:35:51.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天为什么讲 CursorAdapter 的原因，是因为之前在工作的时候有遇到 CursorAdapter 中 filter 的相关问题，于是就想把 CursorAdapter 中的 filter 机制流程好好梳理一下。出于这样的目的，本篇博文就诞生了。</p>
<p>在阅读本文之前，最好已经有写过 CursorAdapter 中 filter 相关代码的经历，这样可以帮助你更好地理解其中的原理。如果你准备好了，那么接下来就一起来看看吧。</p>
<h1 id="CursorAdapter__u7C7B"><a href="#CursorAdapter__u7C7B" class="headerlink" title="CursorAdapter 类"></a>CursorAdapter 类</h1><p>首先我们来看一下 CursorAdapter 的继承以及实现关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CursorAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">Filterable</span>, <span class="title">CursorFilter</span>.<span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CursorAdapter 继承自 BaseAdapter ，相信大家都可以理解。之后又实现了 Filterable 和 CursorFilter.CursorFilterClient 接口。</p>
<p>Filterable 的接口很简单，只有一个 <code>getFilter()</code> 方法，用来返回 filter 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Returns a filter that can be used to constrain data with a filtering</span><br><span class="line">     * pattern.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is usually implemented by &#123;<span class="doctag">@link</span> android.widget.Adapter&#125;</span><br><span class="line">     * classes.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> a filter used to constrain data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Filter <span class="title">getFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 CursorFilter.CursorFilterClient 的接口是定义在 CursorFilter 类里面的。而 CursorFilter 类是默认修饰符，也就是说我们在外部无法访问到它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line">    <span class="function">CharSequence <span class="title">convertToString</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 CursorFilterClient 接口中的抽象方法。根据方法名我们大概都能猜出该方法需要做的事情。 <code>convertToString(Cursor cursor)</code> 方法主要的功能就是根据传入的 cursor 参数返回某个字段；<code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法的意思就是根据传入的 constraint 字符序列去搜索得到 cursor；而 <code>getCursor()</code>就是返回 cursor；<code>changeCursor(Cursor cursor)</code> 就是根据传入的新的 cursor 去替换旧的 cursor 。</p>
<h1 id="filter__u7684_u7528_u6CD5"><a href="#filter__u7684_u7528_u6CD5" class="headerlink" title="filter 的用法"></a>filter 的用法</h1><p>好了，我们来想想平时我们是怎么样使用 CursorAdapter 中的 filter ？</p>
<p>第一步，我们会使用自定义的 adapter 继承自 CursorAdapter ，并且实现 FilterQueryProvider 和 FilterListener 接口。最后别忘了调用 <code>setFilterQueryProvider(FilterQueryProvider filterQueryProvider)</code> 方法。</p>
<p>然后，第二步我们会使用CursorAdapter的 <code>getFilter()</code> 方法来得到 filter 。对，没错，就是实现 Filterable 接口的那个 <code>getFilter</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">getFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCursorFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCursorFilter = <span class="keyword">new</span> CursorFilter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCursorFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CursorAdapter 的源码中，判断了 mCursorFilter 是否为空。若为空，则创建一个新的 CursorFilter 对象。否则直接返回 mCursorFilter 。在这里要说明一下 CursorFilter 是 Filter 的子类。</p>
<p>而在 CursorFilter 的构造器中，主要是设置了 client (CursorAdapter 实现了 CursorFilterClient 接口)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CursorFilter(CursorFilterClient client) &#123;</span><br><span class="line">    mClient = client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二步得到了 filter 之后，第三步就可以使用 <code>filter.filter(CharSequence constraint)</code> 或者 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法了。constraint 参数就是要过滤的关键词；而 FilterListener 是一个 Filter 类的内部接口，会在过滤完成之后回调其中的 <code>onFilterComplete(int count)</code> 方法。</p>
<h1 id="filter__u7684_u539F_u7406"><a href="#filter__u7684_u539F_u7406" class="headerlink" title="filter 的原理"></a>filter 的原理</h1><p>大致使用 filter 的步骤就是像上面这样的了。下面我们就来揭开这其中神秘的面纱吧！</p>
<p>我们的入手点就是 Filter 的 filter 方法了。其中的 <code>filter.filter(CharSequence constraint)</code> 方法内部会调用 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法。所以我们只需要看下<code>filter.filter(CharSequence constraint, FilterListener listener)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Starts an asynchronous filtering operation. Calling this method</span><br><span class="line"> * cancels all previous non-executed filtering requests and posts a new</span><br><span class="line"> * filtering request that will be executed later.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Upon completion, the listener is notified.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint used to filter the data</span><br><span class="line"> * <span class="doctag">@param</span> listener a listener notified upon completion of the operation</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #filter(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #performFiltering(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #publishResults(CharSequence, android.widget.Filter.FilterResults)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(CharSequence constraint, FilterListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HandlerThread thread = <span class="keyword">new</span> HandlerThread(</span><br><span class="line">                    THREAD_NAME, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            thread.start();</span><br><span class="line">            mThreadHandler = <span class="keyword">new</span> RequestHandler(thread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = (mDelayer == <span class="keyword">null</span>) ? <span class="number">0</span> : mDelayer.getPostingDelay(constraint);</span><br><span class="line">        </span><br><span class="line">        Message message = mThreadHandler.obtainMessage(FILTER_TOKEN);</span><br><span class="line"></span><br><span class="line">        RequestArguments args = <span class="keyword">new</span> RequestArguments();</span><br><span class="line">        <span class="comment">// make sure we use an immutable copy of the constraint, so that</span></span><br><span class="line">        <span class="comment">// it doesn't change while the filter operation is in progress</span></span><br><span class="line">        args.constraint = constraint != <span class="keyword">null</span> ? constraint.toString() : <span class="keyword">null</span>;</span><br><span class="line">        args.listener = listener;</span><br><span class="line">        message.obj = args;</span><br><span class="line"></span><br><span class="line">        mThreadHandler.removeMessages(FILTER_TOKEN);</span><br><span class="line">        mThreadHandler.removeMessages(FINISH_TOKEN);</span><br><span class="line">        mThreadHandler.sendMessageDelayed(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中我们可以看到，主要做的就是在一开始创建一个 HandlerThread 线程，并且创建了一个 RequestHandler 的对象 mThreadHandler 。之后创建了一个 RequestArguments 的对象 args，然后把 constraint 和 listener 传到 args 中去，而 RequestArguments 类还有一个成员变量就是 results ，主要用于存储 filter 过滤之后的结果，这会在下面的代码中用到。然后用 mThreadHandler 将该消息发送出去。</p>
<p>那么我们接下来就要来看看 RequestHandler 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Worker thread handler. When a new filtering request is posted from</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.Filter#filter(CharSequence, android.widget.Filter.FilterListener)&#125;,</span><br><span class="line"> * it is sent to this handler.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Handles filtering requests by calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#performFiltering&#125; and then sending a message</span><br><span class="line">     * with the results to the results handler.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering request</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> what = msg.what;</span><br><span class="line">        Message message;</span><br><span class="line">        <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> FILTER_TOKEN:</span><br><span class="line">                RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args.results = performFiltering(args.constraint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">                    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    message = mResultHandler.obtainMessage(what);</span><br><span class="line">                    message.obj = args;</span><br><span class="line">                    message.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Message finishMessage = mThreadHandler.obtainMessage(FINISH_TOKEN);</span><br><span class="line">                        mThreadHandler.sendMessageDelayed(finishMessage, <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINISH_TOKEN:</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mThreadHandler.getLooper().quit();</span><br><span class="line">                        mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 case FILTER_TOKEN 中我们可以看到，会先去调用 <code>performFiltering(CharSequence constraint)</code> 方法。而该方法在 Filter 类中是抽象方法，需要在子类中去实现。那么我们就来看看 CursorFilter 的 <code>performFiltering(CharSequence constraint)</code> 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FilterResults <span class="title">performFiltering</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = mClient.runQueryOnBackgroundThread(constraint);</span><br><span class="line"></span><br><span class="line">    FilterResults results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        results.count = cursor.getCount();</span><br><span class="line">        results.values = cursor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        results.count = <span class="number">0</span>;</span><br><span class="line">        results.values = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performFiltering(CharSequence constraint)</code> 方法中又会去调用  mClient 的 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，而 mClient 就是之前的 CursorAdapter ，所以我们又要跳到 CursorAdapter 类去看相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Runs a query with the specified constraint. This query is requested</span><br><span class="line"> * by the filter attached to this adapter.</span><br><span class="line"> *</span><br><span class="line"> * The query is provided by a</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.FilterQueryProvider&#125;.</span><br><span class="line"> * If no provider is specified, the current cursor is not filtered and returned.</span><br><span class="line"> *</span><br><span class="line"> * After this method returns the resulting cursor is passed to &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;</span><br><span class="line"> * and the previous cursor is closed.</span><br><span class="line"> *</span><br><span class="line"> * This method is always executed on a background thread, not on the</span><br><span class="line"> * application's main thread (or UI thread.)</span><br><span class="line"> * </span><br><span class="line"> * Contract: when constraint is null or empty, the original results,</span><br><span class="line"> * prior to any filtering, must be returned.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint with which the query must be filtered</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> a Cursor representing the results of the new query</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #getFilter()</span><br><span class="line"> * <span class="doctag">@see</span> #getFilterQueryProvider()</span><br><span class="line"> * <span class="doctag">@see</span> #setFilterQueryProvider(android.widget.FilterQueryProvider)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilterQueryProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFilterQueryProvider.runQuery(constraint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到会去调用 mFilterQueryProvider 的 <code>runQuery(CharSequence constraint)</code> 方法。 FilterQueryProvider 其实就是一个接口而已，当我们需要使用 filter 时就要实现该接口。在上面的 filter 用法中已经提到过了。其中的 <code>runQuery(CharSequence constraint)</code> 方法就是需要我们自己去实现的。当然，这里还有另外一种方法，就是不用实现 FilterQueryProvider 接口。而是在子类中去重写 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，也是达到了一样的效果。</p>
<p>假定我们已经在 <code>runQuery(CharSequence constraint)</code> 实现了相关的操作，并且返回了查询出来的 cursor 。那样我们又要跳回到 RequestHandler 的源码中了(这里只截取部分代码，完整代码请查看上面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    args.results = performFiltering(args.constraint);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    message = mResultHandler.obtainMessage(what);</span><br><span class="line">    message.obj = args;</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里把返回的 cursor 传给了 args.results 。并且又使用了 mResultHandler 发送了消息。这样我们又要来看一下 ResultHandler 的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Handles the results of a filtering operation. The results are</span><br><span class="line"> * handled in the UI thread.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultsHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Messages received from the request handler are processed in the</span><br><span class="line">     * UI thread. The processing involves calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#publishResults(CharSequence,</span><br><span class="line">     * android.widget.Filter.FilterResults)&#125;</span><br><span class="line">     * to post the results back in the UI and then notifying the listener,</span><br><span class="line">     * if any.&lt;/p&gt; </span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering results</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line"></span><br><span class="line">        publishResults(args.constraint, args.results);</span><br><span class="line">        <span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">            args.listener.onFilterComplete(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>handleMessage(Message msg)</code> 中，调用了 <code>publishResults(CharSequence constraint, FilterResults results)</code> 方法。在 Filter 类中 <code>publishResults(CharSequence constraint, FilterResults results)</code> 又是抽象的，所以还得去 CursorFilter 类中查看相关的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishResults</span><span class="params">(CharSequence constraint, FilterResults results)</span> </span>&#123;</span><br><span class="line">    Cursor oldCursor = mClient.getCursor();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (results.values != <span class="keyword">null</span> &amp;&amp; results.values != oldCursor) &#123;</span><br><span class="line">        mClient.changeCursor((Cursor) results.values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码里表示了会去调用 CursorAdapter 的 <code>changeCursor(Cursor cursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Change the underlying cursor to a new cursor. If there is an existing cursor it will be</span><br><span class="line"> * closed.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cursor The new cursor to be used</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span> </span>&#123;</span><br><span class="line">    Cursor old = swapCursor(cursor);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        old.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>changeCursor(Cursor cursor)</code> 中，又调用了 <code>swapCursor(Cursor newCursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Swap in a new Cursor, returning the old Cursor.  Unlike</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;, the returned old Cursor is &lt;em&gt;not&lt;/em&gt;</span><br><span class="line"> * closed.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> newCursor The new cursor to be used.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the previously set Cursor, or null if there wasa not one.</span><br><span class="line"> * If the given new Cursor is the same instance is the previously set</span><br><span class="line"> * Cursor, null is also returned.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">swapCursor</span><span class="params">(Cursor newCursor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newCursor == mCursor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor oldCursor = mCursor;</span><br><span class="line">    <span class="keyword">if</span> (oldCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) oldCursor.unregisterContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) oldCursor.unregisterDataSetObserver(mDataSetObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    mCursor = newCursor;</span><br><span class="line">    <span class="keyword">if</span> (newCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) newCursor.registerContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) newCursor.registerDataSetObserver(mDataSetObserver);</span><br><span class="line">        mRowIDColumn = newCursor.getColumnIndexOrThrow(<span class="string">"_id"</span>);</span><br><span class="line">        mDataValid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the new cursor</span></span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRowIDColumn = -<span class="number">1</span>;</span><br><span class="line">        mDataValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the lack of a data set</span></span><br><span class="line">        notifyDataSetInvalidated();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>swapCursor(Cursor newCursor)</code> 中主要的工作就是把 oldCursor 替换成 newCursor ，并且调用了 <code>notifyDataSetChanged();</code> 来更新 ListView 。从上面的源码中还可以看到， <code>swapCursor(Cursor newCursor)</code> 方法中返回的 oldCursor 是没有关闭的。</p>
<p>完成了替换 Cursor 的工作后，我们还要回过头来看看 ResultsHandler 剩余部分的代码(只截取了部分代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">    args.listener.onFilterComplete(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在最后回调了 FilterListener 的 <code>onFilterComplete(int count)</code> 方法。其中的 count 参数是查询出来结果的总数。</p>
<p>至此，一个完整的 filter 流程终于走完了。这其中虽然看似很绕，其实原理还是比较简单的。</p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>看完上面分析，相信大家对 CursorAdapter 的 filter 机制已经有了一个大致的了解了吧。主要原理基本上还是 Handler 异步消息机制以及各个接口回调等。从中可以发现其实源码并不难，只要有耐心慢慢分析，一定会有所突破的。如果对这整个流程有问题的童鞋可以在下面留言。</p>
<p>那么，今天就到这了。Goodbye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Pro Git》笔记]]></title>
    <link href="http://yuqirong.me/2016/06/18/%E3%80%8APro%20Git%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/06/18/《Pro Git》笔记/</id>
    <published>2016-06-17T16:29:14.000Z</published>
    <updated>2016-08-18T15:09:33.879Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E"><a href="#1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E" class="headerlink" title="1.5 初次运行 Git 前的配置"></a>1.5 初次运行 Git 前的配置</h2><ul>
<li><p>Git 配置用户名：</p>
<p>  git config –global user.name “yuqirong”</p>
</li>
<li><p>Git 配置电子邮箱：</p>
<p>  git config –global user.email “yuqirong@myhexin.com”</p>
</li>
<li><p>查看 Git 配置情况：</p>
<p>  git config –list</p>
</li>
<li><p>设置默认使用的文本编辑器：</p>
<p>  git config –global core.editor emacs</p>
</li>
<li><p>设置默认使用的差异分析工具</p>
<p>  git config –global merge.tool vimdiff</p>
</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_Git__u57FA_u7840"><a href="#u7B2C_u4E8C_u7AE0_Git__u57FA_u7840" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h1><h2 id="2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93"><a href="#2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93" class="headerlink" title="2.1 取得项目的 Git 仓库"></a>2.1 取得项目的 Git 仓库</h2><ul>
<li><p>对某个项目进行 Git 管理：</p>
<p>  git init</p>
</li>
<li><p>对某个仓库进行克隆：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“</p>
</li>
<li><p>或者对克隆下来的仓库进行改名：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“ yuqirong</p>
</li>
<li><p>Git 添加某个文件：</p>
<p>  git add src/com/yuqirong/Test/a.java</p>
</li>
</ul>
<h2 id="2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93"><a href="#2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h2><ul>
<li><p>检查当前文件状态：</p>
<p>  git status</p>
</li>
<li><p>查看已暂存的更新：</p>
<p>  git diff –cached</p>
</li>
<li><p>查看未暂存的更新：</p>
<p>  git diff</p>
</li>
<li><p>提交更新：</p>
<p>  git commit<br>  或<br>  git commit -m “add new file”</p>
</li>
<li><p>跳过使用暂存区域的提交更新：</p>
<p>  git commit -a -m “add new file”</p>
</li>
<li><p>移除文件：</p>
<p>  git rm abc.txt</p>
</li>
<li><p>强制移除文件：</p>
<p>  git rm -f abc.txt</p>
</li>
<li><p>文件保存在当前目录中但从跟踪清单中移除：</p>
<p>  git rm –cached abc.txt</p>
</li>
<li><p>移动文件：</p>
<p>  git mv file_from file_to</p>
</li>
</ul>
<h2 id="2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="2.3 查看提交历史"></a>2.3 查看提交历史</h2><ul>
<li><p>查看提交历史：</p>
<p>  git log</p>
</li>
<li><p>查看提交历史中每次提交的内容差异：</p>
<p>  git log -patch</p>
</li>
<li><p>查看提交历史但仅显示简要的增改行数统计：</p>
<p>  git log –stat</p>
</li>
<li><p>查看提交历史并限制输出长度：</p>
<p>  git log -2<br>  或<br>  git log –since=2.weeks</p>
</li>
</ul>
<h2 id="2-4__u64A4_u6D88_u64CD_u4F5C"><a href="#2-4__u64A4_u6D88_u64CD_u4F5C" class="headerlink" title="2.4 撤消操作"></a>2.4 撤消操作</h2><ul>
<li><p>修改最后一次提交：</p>
<p>  git commit –amend</p>
</li>
<li><p>取消已经暂存的文件：</p>
<p>  git reset HEAD abc.txt</p>
</li>
<li><p>取消对文件的修改：</p>
<p>  git checkout – abc.txt (ps:该命令对已经add的文件无效)</p>
</li>
</ul>
<h2 id="2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528"><a href="#2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528" class="headerlink" title="2.5 远程仓库的使用"></a>2.5 远程仓库的使用</h2><ul>
<li><p>查看当前的远程库：</p>
<p>  git remote</p>
</li>
<li><p>查看当前远程库对应的克隆地址：</p>
<p>  git remote -v</p>
</li>
<li><p>添加远程仓库：</p>
<p>  git remote add [short-name] [url]</p>
</li>
<li><p>从远程仓库抓取数据：</p>
<p>  git fetch [remote-name] (fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。)</p>
</li>
<li><p>从远程仓库抓取数据，自动合并到本地仓库中：</p>
<p>  git pull [remote-name]</p>
</li>
<li><p>推送数据到远程仓库中：</p>
<p>  git push [remote-name] [branch-name]</p>
</li>
<li><p>查看远程仓库信息:</p>
<p>  git remote show [remote-name]</p>
</li>
<li><p>远程仓库的重命名:</p>
<p>  git remote rename [old-name] [new-name]</p>
</li>
<li><p>远程仓库的删除:</p>
<p>  git remote rm [remote-name]</p>
</li>
</ul>
<h2 id="2-6__u6253_u6807_u7B7E"><a href="#2-6__u6253_u6807_u7B7E" class="headerlink" title="2.6 打标签"></a>2.6 打标签</h2><ul>
<li><p>列出现有的标签：</p>
<p>  git tag</p>
</li>
<li><p>新建标签：</p>
<p>  git tag -a v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>查看相应标签的版本信息：</p>
<p>  git show v1.0</p>
</li>
<li><p>签署标签：</p>
<p>  git tag -s v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>轻量级标签：</p>
<p>  git tag v1.0</p>
</li>
<li><p>验证标签：</p>
<p>  git tag -v [tag-name]</p>
</li>
<li><p>分享标签:</p>
<p>  git push origin v1.0</p>
</li>
<li><p>推送所有的标签：</p>
<p>  git push origin –tags</p>
</li>
</ul>
<h2 id="2-7__u6280_u5DE7_u548C_u7A8D_u95E8"><a href="#2-7__u6280_u5DE7_u548C_u7A8D_u95E8" class="headerlink" title="2.7 技巧和窍门"></a>2.7 技巧和窍门</h2><ul>
<li><p>设置 Git 命令别名：</p>
<p>  git config –global alias.co checkout</p>
</li>
</ul>
<h1 id="u7B2C_u4E09_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E09_u7AE0__u8D77_u6B65" class="headerlink" title="第三章 起步"></a>第三章 起步</h1><h2 id="3-1__u4F55_u8C13_u5206_u652F"><a href="#3-1__u4F55_u8C13_u5206_u652F" class="headerlink" title="3.1 何谓分支"></a>3.1 何谓分支</h2><ul>
<li><p>创建一个新的分支：</p>
<p>  git branch [branch-name]</p>
</li>
<li><p>克隆一个远程服务器上的分支：</p>
<p>  git clone -b [branch-name] [remote-url]</p>
</li>
<li><p>切换分支：</p>
<p>  git checkout [branch-name]</p>
</li>
</ul>
<h2 id="3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76"><a href="#3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76" class="headerlink" title="3.2 基本的分支与合并"></a>3.2 基本的分支与合并</h2><ul>
<li><p>新建一个分支并切换到该分支上：</p>
<p>  git checkout -b [branch-name]</p>
</li>
<li><p>合并分支：</p>
<p>  git merge [branch-name]</p>
</li>
<li><p>删除分支：</p>
<p>  git branch -d [branch-name]</p>
</li>
<li><p>调用可视化的合并工具来解决冲突：</p>
<p>  git mergetool</p>
</li>
</ul>
<h2 id="3-3__u5206_u652F_u7BA1_u7406"><a href="#3-3__u5206_u652F_u7BA1_u7406" class="headerlink" title="3.3 分支管理"></a>3.3 分支管理</h2><ul>
<li><p>列出所有分支：</p>
<p>  git branch</p>
</li>
<li><p>查看分支最后一次 commit 信息：</p>
<p>  git branch -v</p>
</li>
<li><p>查看哪些分支已经被并入：</p>
<p>  git branch –merged</p>
</li>
<li><p>查看哪些分支没有被并入：</p>
<p>  git branch –no-merged</p>
</li>
</ul>
<h2 id="3-5__u8FDC_u7A0B_u5206_u652F"><a href="#3-5__u8FDC_u7A0B_u5206_u652F" class="headerlink" title="3.5 远程分支"></a>3.5 远程分支</h2><ul>
<li><p>跟踪分支</p>
<p>  git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</p>
</li>
<li><p>删除远程分支：</p>
<p>  git push [remote-name] :[remote-branch-name]</p>
</li>
</ul>
<h2 id="3-6__u884D_u5408"><a href="#3-6__u884D_u5408" class="headerlink" title="3.6 衍合"></a>3.6 衍合</h2><ul>
<li><p>衍合分支：</p>
<p>  git rebase [branch-name]</p>
</li>
</ul>
<h1 id="u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git"><a href="#u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git" class="headerlink" title="第4章 服务器上的 Git"></a>第4章 服务器上的 Git </h1><h1 id="u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git"><a href="#u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git" class="headerlink" title="第5章 分布式 Git"></a>第5章 分布式 Git</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1]]>
    </summary>
    
      <category term="Git" scheme="http://yuqirong.me/tags/Git/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android 6.0的运行时权限处理]]></title>
    <link href="http://yuqirong.me/2016/06/08/%E5%85%B3%E4%BA%8EAndroid%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2016/06/08/关于Android M的运行权限处理/</id>
    <published>2016-06-08T14:12:20.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问题的原因大家都知道，是 Android 6.0 新引入了在运行时权限申请(Runtime Permissions)的功能。那么这所谓的运行时申请权限究竟是怎么一回事呢，一起来看看吧！</p>
<p>在 Android 6.0 中，app 如果想要获得某些权限，会在应用中弹出一个对话框，让用户确认是否授予该权限。具体的截图如下：</p>
<p><img src="/uploads/20160608/20160608161439.png" alt="Runtime Permissions screenshot"></p>
<p>这要做的好处就是运行一个 app 时可以拒绝其中的某些权限，防止 app 触及到你的隐私(比如说通讯录、短信之类的)。而在 Android 6.0 之前，若同意安装 app ，就意味着该 app 可以获取权限列表中的所有权限。(注：这里所指的都是原生 Android 系统，比如 MIUI 之类的第三方 ROM 很早就具备了这种功能。)</p>
<p>接下来就来看看相关的 API 吧，首先我们来看看 <code>Context.checkSelfPermission(String permission)</code> 方法，该方法主要用于检测该 app 是否已经被赋予了某权限，传入的参数有。如果已被赋予，则返回 <code>PERMISSION_GRANTED</code> ，否则返回 <code>PERMISSION_DENIED</code> 。</p>
<p>若返回了 <code>PERMISSION_DENIED</code> ，那么我们就要去申请该权限了。这时就要用到  <code>Activity.requestPermissions(String[] permissions, int requestCode)</code> 这个方法了。顾名思义，该方法的作用就是申请某些权限了。第一个参数就是要申请的权限，可以看到参数形式是一个数组，也就是说可以一次申请多个权限。而第二个参数就是申请权限的代号，主要用于在之后的回调中选择。</p>
<p>当用户在权限申请的对话框中作出选择后，就会回调 <code>onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)</code> 方法。第一个参数就是上面的权限代号；第二个参数是申请的权限数组；第三个参数就是权限申请的结果。</p>
<p>结合上面的几个方法，可以写出如下所示的权限申请代码模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_CONTACTS_REQUEST_CODE = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果权限没有被授予</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.READ_CONTACTS) !=</span><br><span class="line">        PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 申请权限</span></span><br><span class="line">    ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;, READ_CONTACTS_REQUEST_CODE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 权限已经被授予</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> READ_CONTACTS_REQUEST_CODE:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// TODO 用户已经授予了权限</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// TODO 用户拒绝授予权限</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，还有一个方法需要注意下，那就是 <code>shouldShowRequestPermissionRationale (Activity activity, String permission)</code> 方法。这个方法的作用就是当用户拒绝了某个权限之后，下一次就会显示出需要该权限的说明。</p>
<p>关于运行时申请权限基本就这样了，值得提醒的是，并不是所有的权限都需要运行时申请，只有“危险”的权限才通过运行时来申请。比如说读取联系人、获取位置信息、读写SD卡等等都为“危险权限”，而比如振动、联网、蓝牙等就是普通权限了，就不需要运行时申请了。</p>
<p>说完了运行时申请权限后，另外还有一点需要注意的是，在 Android 6.0 显示悬浮窗也有一个“坑”。如果调用平常的显示悬浮窗的方法，会抛出 “permission denied for this window type” 异常。解决的方案就是在显示悬浮窗之前，需要调用一下 <code>Settings.canDrawOverlays(context)</code> 这个方法。若该方法返回 true ，则说明用户同意创建悬浮窗；否则可以跳转到相关的设置页面。具体的代码模版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Settings.canDrawOverlays(context)) &#123;</span><br><span class="line">        <span class="comment">// 显示悬浮窗</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 跳转到相关的设置页面</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 版本低于Android 6.0，直接显示悬浮窗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，就到这里吧。</p>
<p>GoodBye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易实现Android九宫格解锁]]></title>
    <link href="http://yuqirong.me/2016/05/10/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Android%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/"/>
    <id>http://yuqirong.me/2016/05/10/简易实现Android九宫格解锁/</id>
    <published>2016-05-10T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等。因为九宫格可以保护用户的隐私，所以它的应用面很广泛。那么今天我们就来自定义一个属于自己的九宫格吧！</p>
<p>首先我们来分析一下实现九宫格解锁的思路：当用户的手指触摸到某一个点时，先判断该点是否在九宫格的某一格范围之内，若在范围内，则该格变成选中的状态；之后用户手指滑动的时候，以该格的圆心为中心，用户手指为终点，两点连线。最后当用户手指抬起时，判断划过的九宫格密码是否和原先的密码匹配。</p>
<p>大致的思路流程就是上面这样的了，下面我们可以来实践一下。</p>
<h1 id="Point__u7C7B"><a href="#Point__u7C7B" class="headerlink" title="Point 类"></a>Point 类</h1><p>我们先来创建一个 <code>Point</code> 类，用来表示九宫格锁的九个格子。除了坐标 <code>x</code> ，<code>y</code> 之外，还有三种模式：正常模式、按下模式和错误模式。根据模式不同该格子的颜色会有所不同，这会在下面中说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> y;</span><br><span class="line">    <span class="comment">// 正常模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按下模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRESSED_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 错误模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = NORMAL_MODE;</span><br><span class="line">    <span class="comment">// 表示该格的密码，比如“1”、“2”等</span></span><br><span class="line">    <span class="keyword">private</span> String mark;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMark</span><span class="params">(String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RotateDegrees_u7C7B"><a href="#RotateDegrees_u7C7B" class="headerlink" title="RotateDegrees类"></a>RotateDegrees类</h1><p>有了上面的 <code>Point</code> 类之后，我们还要创建一个 <code>RotateDegrees</code> 类，主要作用是计算两个 <code>Point</code> 坐标之间的角度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RotateDegrees &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的point计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> degrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> aX = a.getX();</span><br><span class="line">        <span class="keyword">float</span> aY = a.getY();</span><br><span class="line">        <span class="keyword">float</span> bX = b.getX();</span><br><span class="line">        <span class="keyword">float</span> bY = b.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aX == bX) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aY &lt; bY) &#123;</span><br><span class="line">                degrees = <span class="number">90</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">270</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bY == aY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &lt; bX) &#123;</span><br><span class="line">                degrees = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &gt; bX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第三象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> + (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第四象限</span></span><br><span class="line">                    degrees = <span class="number">360</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一象限</span></span><br><span class="line">                    degrees = (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据point和(x,y)计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param bX</span><br><span class="line">     * @param bY</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, <span class="keyword">float</span> bX, <span class="keyword">float</span> bY)</span> </span>&#123;</span><br><span class="line">        Point b = <span class="keyword">new</span> Point(bX, bY, null);</span><br><span class="line">        <span class="keyword">return</span> getDegrees(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ScreenLockView__u7C7B"><a href="#ScreenLockView__u7C7B" class="headerlink" title="ScreenLockView 类"></a>ScreenLockView 类</h1><p>然后我们要先准备好关于九宫格的几张图片，比如在九宫格的格子中，<code>NORMAL_MODE</code> 模式下是蓝色的，被手指按住时九宫格的格子是绿色的，也就是对应着上面 Point 类的中 <code>PRESSED_MODE</code> 模式，还有 <code>ERROR_MODE</code> 模式下是红色的。另外还有圆点之间的连线，也是根据模式不同颜色也会不同。在这里我就不把图片贴出来了，想要的童鞋可以下载源码从中获取。</p>
<p>有了图片资源之后，我们要做的就是先在构造器中加载图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ScreenLockView"</span>;</span><br><span class="line">    <span class="comment">// 错误格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap errorBitmap;</span><br><span class="line">    <span class="comment">// 正常格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap normalBitmap;</span><br><span class="line">    <span class="comment">// 手指按下时格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap pressedBitmap;</span><br><span class="line">    <span class="comment">// 错误时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap lineErrorBitmap;</span><br><span class="line">    <span class="comment">// 手指按住时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap linePressedBitmap;</span><br><span class="line">    <span class="comment">// 偏移量，使九宫格在屏幕中央</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// 九宫格的九个格子是否已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init;</span><br><span class="line">    <span class="comment">// 格子的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="comment">// 九个格子</span></span><br><span class="line">    <span class="keyword">private</span> Point[][] points = <span class="keyword">new</span> Point[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveY = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手指在移动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isMove;</span><br><span class="line">    <span class="comment">// 是否可以触摸，当用户抬起手指，划出九宫格的密码不正确时为不可触摸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用来存储记录被按下的点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; pressedPoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 屏幕解锁监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnScreenLockListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        errorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_error);</span><br><span class="line">        normalBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_normal);</span><br><span class="line">        pressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_pressed);</span><br><span class="line">        lineErrorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_error);</span><br><span class="line">        linePressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_pressed);</span><br><span class="line">        radius = normalBitmap.getWidth() / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中我们主要就是把图片加载完成，并且得到了格子的半径，即图片宽度的一半。</p>
<p>之后我们来看看 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSize &gt; heightSize) &#123;</span><br><span class="line">        offset = (widthSize - heightSize) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        offset = (heightSize - widthSize) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法中，主要得到对应的偏移量，以便在下面的 <code>onDraw(Canvas canvas)</code> 把九宫格绘制在屏幕中央。</p>
<p>下面就是 <code>onDraw(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        width = getWidth();</span><br><span class="line">        height = getHeight();</span><br><span class="line">        initPoint();</span><br><span class="line">        init = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画九宫格的格子</span></span><br><span class="line">    drawPoint(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moveX != -<span class="number">1</span> &amp;&amp; moveY != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 画直线</span></span><br><span class="line">        drawLine(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断了是否为第一次调用 <code>onDraw(Canvas canvas)</code> 方法，若为第一次则对 points 进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"0"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">4</span>, <span class="string">"1"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"3"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">2</span>, <span class="string">"4"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">2</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"6"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"7"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initPoint()</code> 方法中主要创建了九个格子，并设置了相应的位置和密码。初始化完成之后把 init 置为 false ,下次不会再调用。</p>
<p>回过头再看看 <code>onDraw(Canvas canvas)</code> 中其他的逻辑，接下来调用了 <code>drawPoint(canvas)</code> 来绘制格子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画九宫格的格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> state = points[i][j].getState();</span><br><span class="line">            <span class="keyword">if</span> (state == Point.NORMAL_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(normalBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == Point.PRESSED_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(pressedBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.drawBitmap(errorBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绘制格子还是很简单的，主要分为了三种：普通模式下的格子、按下模式下的格子以及错误模式下的格子。</p>
<h1 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h1><p>在绘制好了格子之后，我们先不看最后的 <code>drawLine(canvas)</code> 方法，因为绘制直线是和用户手指的触摸事件息息相关的，所以我们先把目光转向 <code>onTouchEvent(MotionEvent event)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 判断用户触摸的点是否在九宫格的任意一个格子之内</span></span><br><span class="line">                point = isPoint(x, y);</span><br><span class="line">                <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    point.setState(Point.PRESSED_MODE);  <span class="comment">// 切换为按下模式</span></span><br><span class="line">                    pressedPoint.add(point);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (pressedPoint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    point = isPoint(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!crossPoint(point)) &#123;</span><br><span class="line">                            point.setState(Point.PRESSED_MODE);</span><br><span class="line">                            pressedPoint.add(point);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveX = x;</span><br><span class="line">                    moveY = y;</span><br><span class="line">                    isMove = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                isMove = <span class="keyword">false</span>;</span><br><span class="line">                String tempPwd = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                    tempPwd += p.getMark();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.getStringPassword(tempPwd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tempPwd.equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                        p.setState(Point.ERROR_MODE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    isTouch = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.postDelayed(runnable, <span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScreenLockListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStringPassword</span><span class="params">(String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPassword</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScreenLockListener</span><span class="params">(OnScreenLockListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MotionEvent.ACTION_DOWN</code> 中，先在 <code>isPoint(float x, float y)</code> 方法内判断了用户触摸事件的坐标点是否在九宫格的任意一格之内。如果是，则需要把该九宫格的格子添加到 <code>pressedPoint</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该触摸点是否为格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">isPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            point = points[i][j];</span><br><span class="line">            <span class="keyword">if</span> (isContain(point, x, y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该点(x，y)是否被包含</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Point point, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该点的(x,y)与格子圆心的距离若小于半径就是被包含了</span></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x - point.getX(), <span class="number">2f</span>) + Math.pow(y - point.getY(), <span class="number">2f</span>)) &lt;= radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是要看 <code>MotionEvent.ACTION_MOVE</code> 的逻辑了。一开始判断了用户触摸的点是否为九宫格的某个格子。但是比 <code>MotionEvent.ACTION_DOWN</code> 还多了一个步骤：若用户触摸了某个格子，还要判断该格子是否已经被包含在 <code>pressedPoint</code> 里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否该格子已经被包含在pressedPoint里面了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">crossPoint</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pressedPoint.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看 <code>MotionEvent.ACTION_UP</code> ，把 <code>pressedPoint</code> 里保存的格子遍历后得到用户划出的密码，再和预先设置的密码比较，若相同则回调 <code>OnScreenLockListener</code> 监听器；不相同则把 <code>pressedPoint</code> 中的所有格子的模式设置为错误模式，并在 <code>runnable</code> 中调用 <code>reset()</code> 清空 <code>pressedPoint</code> ，重绘视图，再回调监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isTouch = <span class="keyword">true</span>;</span><br><span class="line">        reset();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            points[i][j].setState(Point.NORMAL_MODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pressedPoint.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们回过头来看看之前在 <code>onDraw(Canvas canvas)</code> 里面的 <code>drawLine(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画直线</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pressedPoint中的所有格子依次遍历，互相连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pressedPoint.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 得到当前格子</span></span><br><span class="line">        Point point = pressedPoint.get(i);</span><br><span class="line">        <span class="comment">// 得到下一个格子</span></span><br><span class="line">        Point nextPoint = pressedPoint.get(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 旋转画布</span></span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        <span class="comment">// 根据距离设置拉伸的长度</span></span><br><span class="line">        matrix.setScale(getDistance(point, nextPoint) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 进行平移</span></span><br><span class="line">        matrix.postTranslate(point.getX(), point.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point.getState() == Point.PRESSED_MODE) &#123;</span><br><span class="line">            canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.drawBitmap(lineErrorBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把画布旋转回来</span></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是手指在移动的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">        Point lastPoint = pressedPoint.get(pressedPoint.size() - <span class="number">1</span>);</span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        Log.i(TAG, <span class="string">"the distance : "</span> + getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth());</span><br><span class="line">        matrix.setScale(getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        matrix.postTranslate(lastPoint.getX(), lastPoint.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line">        canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据point和坐标点计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, <span class="keyword">float</span> moveX, <span class="keyword">float</span> moveY)</span> </span>&#123;</span><br><span class="line">    Point b = <span class="keyword">new</span> Point(moveX,moveY,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> getDistance(point,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个point计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, Point nextPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) Math.sqrt(Math.pow(nextPoint.getX() - point.getX(), <span class="number">2f</span>) + Math.pow(nextPoint.getY() - point.getY(), <span class="number">2f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawLine(Canvas canvas)</code> 整体的逻辑并不复杂，首先将 <code>pressedPoint</code> 中的所有格子依次遍历，将它们连线。之后若是用户的手指还有滑动的话，把最后一个格子和用户手指触摸的点连线。</p>
<h1 id="u6587_u672B"><a href="#u6587_u672B" class="headerlink" title="文末"></a>文末</h1><p><code>ScreenLockView</code> 中的代码差不多就是这些了，既然讲解完了那就一起来看看效果吧：</p>
<p><img src="/uploads/20160510/20160510151253.gif" alt="ScreenShot"></p>
<p>效果还算不错吧，当然你也可以自己设置喜欢的九宫格图片，只要替换一下就可以了。如果对本篇文章有问题，可以留言。</p>
<p>老规矩，附上源码下载链接：</p>
<p><a href="/uploads/20160510/ScreenLockView.rar">ScreenLockView.rar</a></p>
<p>Goodbye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现ViewPager指示器]]></title>
    <link href="http://yuqirong.me/2016/04/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8/"/>
    <id>http://yuqirong.me/2016/04/27/自定义实现ViewPager指示器/</id>
    <published>2016-04-27T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="external">ViewPagerIndicator</a> ，到现在 Material Design 中的 TabLayout 。GitHub 上还有其他形形色色的指示器。那么肯定有人会问：既然有了这么多的指示器可以用，那为什么还要自己自定义呢？其实，我们学习了自定义指示器之后，可以知道 ViewPager 指示器的原理，还可以提高我们代码的水平哦！那还等什么，一起来学习吧。</p>
<p>首先放上一张效果图，亮亮眼：</p>
<p><img src="/uploads/20160427/20160427152924.gif" alt="这里写图片描述"></p>
<p>接下来我们来大致地分析一下思路： ViewPager 指示器我们可以看作是一个横向的 LinearLayout ，相对应的 Tab 可以直接使用 TextView 来实现。而 LinearLayout 中有许多个 TextView ，当我们点击其中的 TextView 时， ViewPager 就切换到对应的 item 上。而当我们手动滑动 ViewPager 时，根据 OnPageChangeListener 来动态地改变指示器。好了，基本上思路就是这样了，下面就来看看代码了。</p>
<p>自定义的属性 attrs.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ViewPagerIndicator"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab可见的数量 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"visible_tab_num"</span> <span class="attribute">format</span>=<span class="value">"integer"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab未选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"unselected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab中字体的大小 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时横线的高度 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"indicator_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义的属性基本上就以上几种，如果自己有其他的需求，可以另外添加。</p>
<p>之后我们就创建一个类，名字就叫 ViewPagerIndicator 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPagerIndicator</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab可见数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visibleTabNum;</span><br><span class="line">    <span class="comment">// 选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectedColor;</span><br><span class="line">    <span class="comment">// 未选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unselectedColor;</span><br><span class="line">    <span class="comment">// 屏幕宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> screenWidth;</span><br><span class="line">    <span class="comment">// tab的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tabWidth;</span><br><span class="line">    <span class="comment">// 横线的偏移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> offset;</span><br><span class="line">    <span class="comment">// 画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">// 横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> indicatorHeight;</span><br><span class="line">    <span class="comment">// 默认横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultIndicatorHeight;</span><br><span class="line">    <span class="comment">// viewpager当前页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentItem;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> textSize;</span><br><span class="line">    <span class="comment">// 默认字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultTextSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager mViewPager;</span><br><span class="line">    <span class="comment">// 滑动的最小距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> touchSlop;</span><br><span class="line">    <span class="comment">// 上次触摸的x轴坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewPagerIndicator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="comment">// 设置横向</span></span><br><span class="line">        setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewPagerIndicator);</span><br><span class="line">        selectedColor = a.getColor(R.styleable.ViewPagerIndicator_selected_color, Color.BLUE);</span><br><span class="line">        unselectedColor = a.getColor(R.styleable.ViewPagerIndicator_unselected_color, Color.WHITE);</span><br><span class="line">        visibleTabNum = a.getInt(R.styleable.ViewPagerIndicator_visible_tab_num, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认字体大小</span></span><br><span class="line">        defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="number">10</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        textSize = a.getDimension(R.styleable.ViewPagerIndicator_text_size, defaultTextSize);</span><br><span class="line">        <span class="comment">// 默认下划横线高度</span></span><br><span class="line">        defaultIndicatorHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">4</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        indicatorHeight = a.getDimension(R.styleable.ViewPagerIndicator_indicator_height, defaultIndicatorHeight);</span><br><span class="line">        a.recycle();</span><br><span class="line">        screenWidth = context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">        tabWidth = screenWidth / visibleTabNum;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(selectedColor);</span><br><span class="line">        mPaint.setStrokeWidth(indicatorHeight);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">// 得到touchSlop</span></span><br><span class="line">        touchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要是初始化了自定义属性，还有得到了 tabWidth 以便后面使用。</p>
<p>当然，如果用户旋转了屏幕，那么 tabWidth 是会改变的。所以我们应该在 <code>onSizeChanged</code> 里重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 当大小改变时，得到一个tab的宽度</span></span><br><span class="line">    tabWidth = w / visibleTabNum;</span><br><span class="line">    height = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论是横屏还是竖屏，在屏幕上可见的 Tab 数量永远是固定的(即 visibleTabNum 的值)。之后，我们先来“画”出 Tab 被选中时底下的那条横线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">// 绘制横线</span></span><br><span class="line">        canvas.drawLine(offset, height - indicatorHeight, offset + tabWidth, height - indicatorHeight, mPaint);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置offset</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOffset</span><span class="params">(<span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mViewPager 的赋值是在<code>setViewPager(ViewPager viewPager)</code>方法中完成的，这个方法放在下面去讲。而其中的 offset 是偏移量。当用户滑动切换 ViewPager 时，Tab 底下的横线应该也要做相应的位移，而这就是由 offset 来完成的。调用 <code>setOffset(float offset)</code> 方法，可以引起视图重绘。另外横线的高度 indicatorHeight 可以由用户自定义的，这里的代码还是比较简单的，相信大家都可以看懂的。</p>
<p>到这就来讲讲 setViewPager 方法了。当我们想要把 ViewPager 和 ViewPagerIndicator 关联起来时，可以给外部设置一个 <code>setViewPager(ViewPager viewPager)</code> 方法，那下面就是该方法的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置ViewPager， 请确保在设置了adapter之后调用该方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> viewPager</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewPager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mViewPager = viewPager;</span><br><span class="line">    <span class="comment">// 得到适配器</span></span><br><span class="line">    PagerAdapter adapter = viewPager.getAdapter();</span><br><span class="line">    <span class="comment">// adapter不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the adapter of viewpager must be not null.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先移除所有的子view</span></span><br><span class="line">    <span class="keyword">this</span>.removeAllViews();</span><br><span class="line">    <span class="comment">// 添加Textview</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapter.getCount(); i++) &#123;</span><br><span class="line">        createTextView(adapter.getPageTitle(i).toString(), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurrentItem = viewPager.getCurrentItem();</span><br><span class="line">    ((TextView) getChildAt(mCurrentItem)).setTextColor(selectedColor);</span><br><span class="line">    viewPager.addOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置了横线的偏移，并引起重绘</span></span><br><span class="line">            setOffset((position + positionOffset) * tabWidth);</span><br><span class="line">            <span class="comment">// tab也要进行相应的移动，若当前的tab是倒数第二个，则不移动。</span></span><br><span class="line">            <span class="keyword">if</span> (position + positionOffset + <span class="number">1</span> &gt; visibleTabNum - <span class="number">1</span> &amp;&amp; position + positionOffset + <span class="number">1</span> &lt;= getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">                scrollTo((<span class="keyword">int</span>) ((position + positionOffset - visibleTabNum + <span class="number">2</span>) * tabWidth), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 字体颜色改变</span></span><br><span class="line">            ((TextView) getChildAt(mCurrentItem)).setTextColor(unselectedColor);</span><br><span class="line">            ((TextView) getChildAt(position)).setTextColor(selectedColor);</span><br><span class="line">            mCurrentItem = position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法内部可以看出，我们要得到 ViewPager 的 adapter 。如果 adapter 为空则抛出异常。之后根据 adapter 的 count 数量去创建相对应的 TextView 作为 Tab 。下面为 <code>createTextView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加textview到ViewPagerIndicator中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTextView</span><span class="params">(String title, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">    LinearLayout.LayoutParams params = <span class="keyword">new</span> LayoutParams(tabWidth, LayoutParams.MATCH_PARENT);</span><br><span class="line">    tv.setLayoutParams(params);</span><br><span class="line">    tv.setText(title);</span><br><span class="line">    tv.setGravity(Gravity.CENTER);</span><br><span class="line">    tv.setTextColor(unselectedColor);</span><br><span class="line">    tv.setTag(i);</span><br><span class="line">    tv.setTextSize(textSize);</span><br><span class="line">    tv.setOnClickListener(tvClickListener);</span><br><span class="line">    <span class="keyword">this</span>.addView(tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// textview的点击监听器</span></span><br><span class="line">OnClickListener tvClickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewPager.setCurrentItem(i, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>createTextView</code> 方法中，使用了addView 来动态地添加 Tab 。这里有一处比较巧妙的地方：我们把当前 TextView 的索引 i 存储到了 Tag 中。而当用户点击 Tab 时，在监听器中我们取出那个 Tag 值，这样就知道了用户点击的是哪个 Tab 了，并且让 ViewPager 切换到那个页面下。</p>
<p>好了，我们再回过头继续看之前的 <code>setViewPager(ViewPager viewPager)</code> 方法，我们看到给 viewPager 设置了 OnPageChangeListener 。在 OnPageChangeListener 的 onPageScrolled 方法中，根据当前的 position 和 positionOffset 就可以完成选中时那条横线的移动。并且为了选中的 Tab 出现在屏幕中，ViewPagerIndicator 也要用 scrollTo 方法来做相应地移动。而在 onPageSelected 方法中，我们把选中的 Tab 中的字体颜色更改为已选中的颜色，之前选中的改成未选中颜色。</p>
<p>到这里，整体完成得差不多了。但是如果我们想让 ViewPagerIndicator 可以滑动的话，还要重写 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent event)</code> 两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = ev.getX();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = ev.getX() - lastX;</span><br><span class="line">            <span class="comment">// 当移动大于touchSlop时，拦截该触摸事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(offsetX) &gt;= touchSlop) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"onInterceptTouchEvent result = "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = x - lastX;</span><br><span class="line">            <span class="comment">// 滑动相应的距离</span></span><br><span class="line">            scrollBy(-(<span class="keyword">int</span>) offsetX, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 最左边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &gt; tabWidth * (getChildCount() - visibleTabNum)) &#123;</span><br><span class="line">                scrollTo(tabWidth * (getChildCount() - visibleTabNum), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onInterceptTouchEvent(MotionEvent ev)</code> 中，若滑动的距离超过 touchSlop ，则拦截该触摸事件自己处理，否则传递给子View。而在 <code>onTouchEvent(MotionEvent event)</code> 中，使用了 scrollBy 来处理滑动，并且设置了边界值的检查。</p>
<p>在这里，整体代码讲解完成了。其实 ViewPagerIndicator 本质就是使用了 OnPageChangeListener 以及当用户点击时切换 ViewPager 到指定页面，并没有太难的地方。以后我们自己也可以实现各种炫酷的 ViewPagerIndicator 了！</p>
<p>下面提供源码的下载链接：</p>
<p><a href="/uploads/20160427/ViewPagerIndicator.rar">ViewPagerIndicator.rar</a></p>
<p>have a nice day !~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blan]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造带有视差效果的ListView]]></title>
    <link href="http://yuqirong.me/2016/04/19/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%B8%A6%E6%9C%89%E8%A7%86%E5%B7%AE%E6%95%88%E6%9E%9C%E7%9A%84ListView/"/>
    <id>http://yuqirong.me/2016/04/19/快速打造带有视差效果的ListView/</id>
    <published>2016-04-19T05:35:32.000Z</published>
    <updated>2016-08-18T15:09:33.989Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/20160419141952.gif" alt="这里写图片描述"></p>
<p>我们可以看到 ListView 的 HeaderView 会跟随 ListView 的滑动而变大，HeaderView里的图片会有缩放效果。这些可以使用属性动画来实现。接下来我们就来动手吧！</p>
<p>首先自定义几个属性，在之后可以用到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ZoomListView"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView的高度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- headerView的最大高度 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView里面的图片最大的伸缩量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_scale"</span> <span class="attribute">format</span>=<span class="value">"float"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后创建 ZoomListView 类，继承自 ListView ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最大的伸缩量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> defaultHeaderMaxScale = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="comment">// 头部最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxHeight;</span><br><span class="line">    <span class="comment">// 头部初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerHeight;</span><br><span class="line">    <span class="comment">// 头部默认初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderHeight;</span><br><span class="line">    <span class="comment">// 头部默认最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderMaxHeight;</span><br><span class="line">    <span class="keyword">private</span> ImageView headerView;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup.LayoutParams layoutParams;</span><br><span class="line">    <span class="keyword">private</span> LinearLayout linearLayout;</span><br><span class="line">    <span class="comment">// 最大的缩放值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxScale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        defaultHeaderHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">160</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        defaultHeaderMaxHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">240</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ZoomListView);</span><br><span class="line">        headerHeight = a.getDimension(R.styleable.ZoomListView_header_height, defaultHeaderHeight);</span><br><span class="line">        headerMaxHeight = a.getDimension(R.styleable.ZoomListView_header_max_height, defaultHeaderMaxHeight);</span><br><span class="line">        headerMaxScale = a.getFloat(R.styleable.ZoomListView_header_max_scale, defaultHeaderMaxScale);</span><br><span class="line">        a.recycle();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里都是按部就班式的，设置好自定义属性的初始值，之后调用 <code>initView()</code> ，那就来看看 <code>initView()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    headerView = <span class="keyword">new</span> ImageView(getContext());</span><br><span class="line">    headerView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">    linearLayout = <span class="keyword">new</span> LinearLayout(getContext());</span><br><span class="line">    linearLayout.addView(headerView);</span><br><span class="line">    layoutParams = headerView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">        layoutParams = <span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (<span class="keyword">int</span>) headerHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutParams.width = ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        layoutParams.height = (<span class="keyword">int</span>) headerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    headerView.setLayoutParams(layoutParams);</span><br><span class="line">    addHeaderView(linearLayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    headerView.setImageResource(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在 <code>initView()</code> 里我们创建了 headerView ，并添加到了ListView的头部。而 <code>setDrawableId(int id)</code> 就是给 headerView 设置相关图片的。</p>
<p>下面就是视差效果的主要实现代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">overScrollBy</span><span class="params">(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY, <span class="keyword">int</span> scrollX, <span class="keyword">int</span> scrollY, <span class="keyword">int</span> scrollRangeX, <span class="keyword">int</span> scrollRangeY, <span class="keyword">int</span> maxOverScrollX, <span class="keyword">int</span> maxOverScrollY, <span class="keyword">boolean</span> isTouchEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span> &amp;&amp; isTouchEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headerView.getHeight() &lt; headerMaxHeight) &#123;</span><br><span class="line">            <span class="keyword">int</span> newHeight = headerView.getHeight()</span><br><span class="line">                    + Math.abs(deltaY / <span class="number">3</span>);</span><br><span class="line">            headerView.getLayoutParams().height = newHeight;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">            <span class="keyword">float</span> temp = <span class="number">1</span> + (headerMaxScale - <span class="number">1f</span>) * (headerView.getHeight() - headerHeight) / (headerMaxHeight - headerHeight);</span><br><span class="line">            headerView.animate().scaleX(temp)</span><br><span class="line">                    .scaleY(temp).setDuration(<span class="number">0</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 <code>overScrollBy()</code> 方法，当 deltaY 小于0时(即 ListView 已经到顶端，但是用户手势还是向下拉)，去动态地设置 headerView 的高度以及 headerView 的 scale 值。这样就可以产生 headerView 变高以及图片放大的效果了。</p>
<p>接下来要考虑的问题就是当用户松开手指时，要恢复回原来的样子。所以我们应该在 <code>onTouchEvent(MotionEvent ev)</code> 里去实现相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                startAnim();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行动画</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(headerView.getHeight(), headerHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.getLayoutParams().height = (<span class="keyword">int</span>) fraction;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line"></span><br><span class="line">    ValueAnimator animator2 = ValueAnimator.ofFloat(headerView.getScaleX(), <span class="number">1f</span>);</span><br><span class="line">    animator2.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.setScaleX(fraction);</span><br><span class="line">            headerView.setScaleY(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator2.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator2.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">    animator.start();</span><br><span class="line">    animator2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码简单点来说，就是在 ACTION_UP 时，去开始两个属性动画，一个属性动画是将 headerView 的高度恢复成原来的值，另一个属性动画就是把 headerView 的 scale 重新恢复为1f。相信大家都可以看懂的。</p>
<p>ZoomListView 整体的代码就这些了，很简短。下面附上下载的链接：</p>
<p><a href="/uploads/20160419/ZoomListView.rar">ZoomListView.rar</a></p>
<p>good luck ! ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你实现仿美团的下拉刷新]]></title>
    <link href="http://yuqirong.me/2016/04/18/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BB%BF%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://yuqirong.me/2016/04/18/带你实现仿美团的下拉刷新/</id>
    <published>2016-04-18T07:34:03.000Z</published>
    <updated>2016-08-18T15:09:33.973Z</updated>
    <content type="html"><![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="这里写图片描述"></p>
<p>我们可以大致地分析一下：首先根据下拉改变的 paddingTop 来动态地缩放“绿色椭圆物”,然后当 headerView 的 paddingTop 大于0时，播放美团小人出现的帧动画，最后就是手指松开时播放刷新中的帧动画了。</p>
<p>基本上思路就是上面分析的那样了，那么我们下面一步就是要获取帧动画的素材了。我们先下载好美团的 apk ，解压后在 res/drawable-xhdpi-v4 里，我们可以得到相关的图片了。如果嫌麻烦，文末有本 Demo 的下载链接，里面就有素材图片。</p>
<p>有了图片后我们先写个帧动画的 drawable.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animation-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_01"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_02"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_03"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_04"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_05"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一共有两个 drawable.xml ，另外一个和这个类似，就不贴出来了。</p>
<p>现在开始编写代码了，创建一个 MeiTuanListView ，继承自 ListView :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiTuanListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通状态模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE_MODE = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PULL_DOWN_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可松开刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RELEASE_REFRESH_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 刷新中模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REFRESHING_MODE = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mode = NONE_MODE;</span><br><span class="line">	<span class="comment">// 阻值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RATIO = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新头部</span></span><br><span class="line">    <span class="keyword">private</span> View headerRefreshView;</span><br><span class="line">    <span class="comment">// 头部高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refreshViewHeight;</span><br><span class="line">    <span class="comment">// 手指按下的Y值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> downY;</span><br><span class="line">    <span class="comment">// 刷新监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnRefreshListener listener;</span><br><span class="line">    <span class="comment">// “绿色椭圆物”的自定义View</span></span><br><span class="line">    <span class="keyword">private</span> MeiTuanOvalView mtOvalView;</span><br><span class="line">    <span class="comment">// 帧动画的ImageView</span></span><br><span class="line">    <span class="keyword">private</span> ImageView aniImageView;</span><br><span class="line">    <span class="comment">// 动画是否已经开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStart;</span><br><span class="line">    <span class="comment">// 只有在listview顶端时下拉才可以刷新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canRefresh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MeiTuanListView"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setOverScrollMode(View.OVER_SCROLL_NEVER);</span><br><span class="line">        headerRefreshView = LayoutInflater.from(getContext()).inflate(R.layout.layout_header, <span class="keyword">null</span>);</span><br><span class="line">        mtOvalView = (MeiTuanOvalView) headerRefreshView.findViewById(R.id.mtFirstView);</span><br><span class="line">        aniImageView = (ImageView) headerRefreshView.findViewById(R.id.iv);</span><br><span class="line">        <span class="comment">// 去测量</span></span><br><span class="line">        headerRefreshView.measure(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        refreshViewHeight = headerRefreshView.getMeasuredHeight();</span><br><span class="line">        headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        addHeaderView(headerRefreshView, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initView()</code>中，初始化了下拉刷新的头部，并且设置了 setPadding (关于 ListView 下拉刷新的原理大家应该都懂吧？！)。</p>
<p>layout_header.xml 的布局如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:gravity</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">com.yuqirong.meituanlistview.view.MeiTuanOvalView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/mtFirstView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_anim"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:visibility</span>=<span class="value">"gone"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MeiTuanOvalView 这个是关于“绿色椭圆物”的自定义View，会根据 <code>headerView.getPaddingTop()</code> 的值自动缩放，这里就不讲解了，源码还是比较简单的，相关代码可以下载 Demo 查看。而 <code>iv_anim</code> 主要是用来播放帧动画的 ImageView 。</p>
<p>下拉刷新的主要代码都在 <code>onTouchEvent(MotionEvent ev)</code> 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 在listview顶端时才可下拉刷新</span></span><br><span class="line">            <span class="keyword">if</span> (getFirstVisiblePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"canRefresh : "</span> + canRefresh);</span><br><span class="line">				<span class="comment">// 记录手指按下的Y坐标</span></span><br><span class="line">                downY = ev.getY();</span><br><span class="line">                canRefresh = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">float</span> moveY = ev.getY();</span><br><span class="line">                <span class="keyword">float</span> offsetY = moveY - downY;</span><br><span class="line">				<span class="comment">// 动态改变paddingTop值</span></span><br><span class="line">                headerRefreshView.setPadding(<span class="number">0</span>, (<span class="keyword">int</span>) (headerRefreshView.getPaddingTop() + offsetY / RATIO), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = PULL_DOWN_MODE;</span><br><span class="line">                    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">                    aniImageView.setVisibility(GONE);</span><br><span class="line">                    mtOvalView.setScale((refreshViewHeight + headerRefreshView.getPaddingTop()) * <span class="number">1f</span> / refreshViewHeight);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = RELEASE_REFRESH_MODE;</span><br><span class="line">                    <span class="keyword">if</span> (!isStart) &#123;</span><br><span class="line">                        mtOvalView.setVisibility(GONE);</span><br><span class="line">                        aniImageView.setVisibility(VISIBLE);</span><br><span class="line">                        aniImageView.setImageResource(R.drawable.pull_end_imag_frame);</span><br><span class="line">                        AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                        <span class="comment">// 只执行一次动画</span></span><br><span class="line">                        animationDrawable.setOneShot(<span class="keyword">true</span>);</span><br><span class="line">                        animationDrawable.start();</span><br><span class="line">                        isStart = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                downY = moveY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = REFRESHING_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    aniImageView.setImageResource(R.drawable.refreshing_image_frame);</span><br><span class="line">                    AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                    animationDrawable.start();</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.refreshing();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = NONE_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    mtOvalView.setScale(<span class="number">0f</span>);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的代码逻辑还是比较简单的：</p>
<ul>
<li>ACTION_DOWN ：首先判断了当 ListView 在顶端时才可以下拉刷新，并且记录了手指按下的Y坐标；</li>
<li>ACTION_MOVE ：根据滑动的 offsetY 来动态地设置 headerView 的 paddingTop 。我们可以看到在 <code>if (headerRefreshView.getPaddingTop() &lt;= 0)</code> 里面根据 paddingTop 的值来动态地设置 <code>mtOvalView</code> 的 scale ，并且在 <code>setScale()</code> 方法里面会调用 <code>invalidate()</code> ，从而让 <code>mtOvalView</code> 去重绘。不然 <code>headerRefreshView.getPaddingTop()</code> 大于0时就播放了美团小人出场的动画。</li>
<li>ACTION_UP ：当手指松开的时候，还是判断了 <code>headerRefreshView.getPaddingTop()</code> 的值。若大于0则把 headerView 全部显示出来，播放刷新中的动画，并且回调了刷新监听器的接口；小于0则把 headerView 重新隐藏起来。并重置相关的值。</li>
</ul>
<p>要注意的一点是，在 <code>onTouchEvent(MotionEvent ev)</code> 里要返回 <code>super.onTouchEvent(ev)</code> 。不能是直接返回 <code>true</code> 。因为在 <code>super.onTouchEvent(ev)</code> 里处理了 ListView 滑动的相关逻辑。</p>
<p>当获取到最新数据后，可以调用<code>notifyRefreshFinished()</code>方法完成下拉刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnRefreshListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnRefreshListener</span><span class="params">(OnRefreshListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新完成后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyRefreshFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mode = NONE_MODE;</span><br><span class="line">    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    aniImageView.setVisibility(GONE);</span><br><span class="line">    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">    isStart = <span class="keyword">false</span>;</span><br><span class="line">    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是附上效果图了：</p>
<p><img src="/uploads/20160418/20160418165251.gif" alt="这里写图片描述"></p>
<p>到这里整体就讲解得差不多了，至于 MeiTuanListView 的使用示例以及 MeiTuanOvalView 的源码可以在 Demo 里查看。</p>
<p>Demo下载链接：</p>
<p><a href="/uploads/20160418/MeiTuanListView.rar">MeiTuanListView.rar</a></p>
<p>good bye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FloatingActionButton在滚动时显示或隐藏]]></title>
    <link href="http://yuqirong.me/2016/04/10/FloatingActionButton%E5%9C%A8%E6%BB%9A%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F/"/>
    <id>http://yuqirong.me/2016/04/10/FloatingActionButton在滚动时显示或隐藏/</id>
    <published>2016-04-10T11:51:22.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>其实关于FAB的显示和隐藏，Google官方就提供了其中一种方案：<code>fab.hidden()</code>和<code>fab.show()</code>。但是自带的是FAB缩放的效果。并不是上下移动的效果。</p>
<p>那么我们就来看看如何实现FAB上下移动的效果吧！</p>
<p>首先在你想要滑动的View(比如说RecyclerView等)的布局上加上：</p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>然后再附上FAB的xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">   <span class="attribute">android:id</span>=<span class="value">"@+id/fab"</span></span><br><span class="line">   <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_gravity</span>=<span class="value">"bottom|end"</span></span><br><span class="line">   <span class="attribute">android:layout_margin</span>=<span class="value">"@dimen/fab_margin"</span></span><br><span class="line">   <span class="attribute">app:layout_behavior</span>=<span class="value">"com.yuqirong.rxnews.ui.view.ScrollAwareFABBehavior"</span></span><br><span class="line">   <span class="attribute">android:src</span>=<span class="value">"@android:drawable/ic_dialog_email"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意其中的layout_behavior，是我们自己实现的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollAwareFABBehavior</span> <span class="keyword">extends</span> <span class="title">FloatingActionButton</span>.<span class="title">Behavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator INTERPOLATOR = <span class="keyword">new</span> FastOutSlowInInterpolator();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScrollAwareFABBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                                       <span class="keyword">final</span> View directTargetChild, <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ensure we react to vertical scrolling</span></span><br><span class="line">        <span class="keyword">return</span> nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">                || <span class="keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                               <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> dxConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyConsumed,</span><br><span class="line">                               <span class="keyword">final</span> <span class="keyword">int</span> dxUnconsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line">        <span class="keyword">if</span> (dyConsumed &gt; <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled down and the FAB is currently visible -&gt; hide the FAB</span></span><br><span class="line">            animateOut(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyConsumed &lt; <span class="number">0</span> &amp;&amp; child.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled up and the FAB is currently not visible -&gt; show the FAB</span></span><br><span class="line">            animateIn(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateOut</span><span class="params">(<span class="keyword">final</span> FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer()</span><br><span class="line">                    .setListener(<span class="keyword">new</span> ViewPropertyAnimatorListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                            view.setVisibility(View.GONE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateIn</span><span class="params">(FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        button.setVisibility(View.VISIBLE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(<span class="number">0</span>)</span><br><span class="line">                    .setInterpolator(INTERPOLATOR).withLayer().setListener(<span class="keyword">null</span>)</span><br><span class="line">                    .start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMarginBottom</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> marginBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = v.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> ViewGroup.MarginLayoutParams) &#123;</span><br><span class="line">            marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> marginBottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看<code>onNestedScroll()</code>这个方法，在方法里主要判断了一下是向上滑还是向下滑。再分别去调用<code>animateOut()</code>和<code>animateIn()</code>。那我们就来看看<code>animateOut()</code>。(<code>animateIn()</code>和<code>animateOut()</code>的原理一样的，我们只看<code>animateOut()</code>吧)</p>
<p>在<code>animateOut()</code>根据SDK的版本判断，若大于或等于14使用属性动画；不然就是使用了自带的<code>hide()</code>方法。代码还是比较简单的，相信大家都能看得懂。当然如下想在SDK 14以下使用上下移动的效果，那就要用NineOldAndroids这个库了。</p>
<p>效果就是如下所示了：</p>
<p><img src="/uploads/20160413/20160413202356.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这了。bye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入解析Scroller滚动原理]]></title>
    <link href="http://yuqirong.me/2016/04/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Scroller%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2016/04/05/深入解析Scroller滚动原理/</id>
    <published>2016-04-05T12:21:10.000Z</published>
    <updated>2016-08-18T15:09:34.051Z</updated>
    <content type="html"><![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括为“三部曲”：</p>
<ol>
<li><p>创建一个Scroller对象，一般在View的构造器中创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    mScroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写View的computeScroll()方法，下面的代码基本是不会变化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用startScroll()方法，startX和startY为开始滚动的坐标点，dx和dy为对应的偏移量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mScroller.startScroll (<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy);</span><br><span class="line">invalidate();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的三步就是Scroller的基本用法了。那接下来的任务就是解析Scroller的滚动原理了。</p>
<p>而在这之前，我们还有一件事要办，那就是搞清楚scrollTo()和scrollBy()的原理。scrollTo()和scrollBy()的区别我这里就不重复叙述了，不懂的可以自行google或百度。下面贴出scrollTo()的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置好mScrollX和mScrollY之后，调用了<code>onScrollChanged(mScrollX, mScrollY, oldX, oldY);</code>，View就会被重新绘制。这样就达到了滑动的效果。</p>
<p>下面我们再来看看scrollBy()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样简短的代码相信大家都懂了，原来scrollBy()内部是调用了scrollTo()的。但是scrollTo()/scrollBy()的滚动都是瞬间完成的，怎么样才能实现平滑滚动呢。</p>
<p>不知道大家有没有这样一种想法：如果我们把要滚动的偏移量分成若干份小的偏移量，当然这份量要大。然后用scrollTo()/scrollBy()每次都滚动小份的偏移量。在一定的时间内，不就成了平滑滚动了吗？没错，Scroller正是借助这一原理来实现平滑滚动的。下面我们就来看看源码吧！</p>
<p>根据“三部曲”中第一部，先来看看Scroller的构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context, Interpolator interpolator, <span class="keyword">boolean</span> flywheel)</span> </span>&#123;</span><br><span class="line">    mFinished = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (interpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> ViscousFluidInterpolator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = interpolator;</span><br><span class="line">    &#125;</span><br><span class="line">    mPpi = context.getResources().getDisplayMetrics().density * <span class="number">160.0f</span>;</span><br><span class="line">    mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());</span><br><span class="line">    mFlywheel = flywheel;</span><br><span class="line"></span><br><span class="line">    mPhysicalCoeff = computeDeceleration(<span class="number">0.84f</span>); <span class="comment">// look and feel tuning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造器中做的主要就是指定了插补器，如果没有指定插补器，那么就用默认的ViscousFluidInterpolator。</p>
<p>我们再来看看Scroller的startScroll()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mMode = SCROLL_MODE;</span><br><span class="line">    mFinished = <span class="keyword">false</span>;</span><br><span class="line">    mDuration = duration;</span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">    mStartX = startX;</span><br><span class="line">    mStartY = startY;</span><br><span class="line">    mFinalX = startX + dx;</span><br><span class="line">    mFinalY = startY + dy;</span><br><span class="line">    mDeltaX = dx;</span><br><span class="line">    mDeltaY = dy;</span><br><span class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，在startScroll()里面并没有开始滚动，而是设置了一堆变量的初始值，那么到底是什么让View开始滚动的？我们应该把目标集中在startScroll()的下一句<code>invalidate();</code>身上。我们可以这样理解：首先在startScroll()设置好了一堆初始值，之后调用了<code>invalidate();</code>让View重新绘制，这里又有一个很重要的点，在draw()中会调用<code>computeScroll()</code>这个方法！</p>
<p>源码太长了，在这里就不贴出来了。想看的童鞋在View类里面搜<code>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>这个方法就能看到了。通过ViewGroup.drawChild()方法就会调用子View的draw()方法。而在View类里面的<code>computeScroll()</code>是一个空的方法，需要我们去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called by a parent to request that a child update its values for mScrollX</span><br><span class="line"> * and mScrollY if necessary. This will typically be done if the child is</span><br><span class="line"> * animating a scroll using a &#123;<span class="doctag">@link</span> android.widget.Scroller Scroller&#125;</span><br><span class="line"> * object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在上面“三部曲”的第二部中，我们就已经实现了<code>computeScroll()</code>。首先判断了<code>computeScrollOffset()</code>，我们来看看相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Call this when you want to know the new location.  If it returns true,</span><br><span class="line"> * the animation is not yet finished.</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SCROLL_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLING_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</span><br><span class="line">            <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</span><br><span class="line">            <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</span><br><span class="line">                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</span><br><span class="line">                distanceCoef = d_inf + (t - t_inf) * velocityCoef;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</span><br><span class="line">            </span><br><span class="line">            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</span><br><span class="line">            <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></span><br><span class="line">            mCurrX = Math.min(mCurrX, mMaxX);</span><br><span class="line">            mCurrX = Math.max(mCurrX, mMinX);</span><br><span class="line">            </span><br><span class="line">            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</span><br><span class="line">            <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></span><br><span class="line">            mCurrY = Math.min(mCurrY, mMaxY);</span><br><span class="line">            mCurrY = Math.max(mCurrY, mMinY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mCurrX = mFinalX;</span><br><span class="line">        mCurrY = mFinalY;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的返回值有讲究，若返回true则说明Scroller的滑动没有结束；若返回false说明Scroller的滑动结束了。再来看看内部的代码：先是计算出了已经滑动的时间，若已经滑动的时间小于总滑动的时间，则说明滑动没有结束；不然就说明滑动结束了，设置标记<code>mFinished = true;</code>。而在滑动未结束里面又分为了两个mode，不过这两个mode都干了差不多的事，大致就是根据刚才的时间<code>timePassed</code>和插补器来计算出该时间点滚动的距离<code>mCurrX</code>和<code>mCurrY</code>。也就是上面“三部曲”中第二部的mScroller.getCurrX(), mScroller.getCurrY()的值。</p>
<p>然后在第二部曲中调用scrollTo()方法滚动到指定点(即上面的<code>mCurrX</code>, <code>mCurrY</code>)。之后又调用了<code>postInvalidate();</code>，让View重绘并重新调用<code>computeScroll()</code>以此循环下去，一直到View滚动到指定位置为止，至此Scroller滚动结束。</p>
<p>其实Scroller的原理还是比较通俗易懂的。我们再来理清一下思路，以一张图的形式来终结今天的Scroller解析：</p>
<p><img src="/uploads/20160405/20160405235023.png" alt="这里写图片描述"></p>
<p>好了，如果有什么问题可以在下面留言。</p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android安全机制之反编译]]></title>
    <link href="http://yuqirong.me/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://yuqirong.me/2016/04/03/Android安全机制之反编译/</id>
    <published>2016-04-02T16:59:11.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米修斯方法”以及“宙斯类”(不得不感慨开发小哥的智商)。之后就是在阅读《Android群英传》时也有相关反编译的内容，觉得有必要记录一下。所以这就是本片写博文的起源了。</p>
<p>首先关于反编译，我们先要准备几个工具：</p>
<ul>
<li>apktool：aoktool主要是用来反编译资源文件的，也就是XML了。</li>
<li>Dex2jar：Dex2jar就是反编译源代码的，会把源代码反编译成一个jar包。</li>
<li>jd-gui ：在上面Dex2jar反编译出来的jar包，放入jd-gui中，就可以查看源代码了。</li>
</ul>
<p>关于上面的三个工具，我会在文末放出下载链接，大家可以去下载。</p>
<p>好了，那接下来我们就开始反编译之旅吧！</p>
<p>至于要反编译的apk，我只能选择自己的<a href="https://github.com/yuqirong/Koku" target="_blank" rel="external">Koku</a>了，<a href="http://www.wandoujia.com/apps/com.yuqirong.koku/download" target="_blank" rel="external">点击此处下载</a>。</p>
<p>我们把上面下载下来的apk用winrar打开(当然你也可以用其他的解压工具)，我们可以看到里面的文件内容如下图所示：</p>
<p><img src="/uploads/20160403/20160403112646.png" alt="这里写图片描述"></p>
<p>我们发现classes.dex这个文件，其实classes.dex反编译出来就是源代码。然后我们把Dex2jar解压出来，发现里面有d2j-dex2jar.bat，这就是主角了。</p>
<p><img src="/uploads/20160403/20160403124449.png" alt="这里写图片描述"></p>
<p>在Dex2jar解压出来的目录下，打开命令提示符输入：</p>
<pre><code>d2j-dex2jar.bat classes.dex所在的路径
</code></pre><p>比如：</p>
<p><img src="/uploads/20160403/20160403124911.png" alt="这里写图片描述"></p>
<p>运行后，我们发现在Dex2jar解压出来的目录下多了一个classes-dex2jar.jar。</p>
<p><img src="/uploads/20160403/20160403125136.png" alt="这里写图片描述"></p>
<p>然后我们把下载下来的jd-gui.zip解压，里面会有jd-gui.exe。相信大家都懂吧。用jd-gui.exe打开上面的classes-dex2jar.jar，你会惊喜地发现源代码就在你眼前！</p>
<p><img src="/uploads/20160403/20160403125619.png" alt="这里写图片描述"></p>
<p>看上面的代码截图，我们会发现比如说<code>setContentView()</code>里面是一串数字。不过别怕，我们都知道R文件是用来关联资源文件的，把上面的那串数字复制下来，再打开R.class，查找一下：</p>
<p><img src="/uploads/20160403/20160403130002.png" alt="这里写图片描述"></p>
<p>原来那串数字就代表了activity_my_favorite.xml这个layout。那么问题来了，我们如何反编译XML文件呢？那就要用到上面的apktool了。</p>
<p>打开apktool的所在目录，把koku.apk移动到apktool的同一目录下，输入命令符：</p>
<pre><code>java -jar apktool_2.1.0.jar d koku.apk
</code></pre><p>如果你配置了Java环境变量，则可以直接输入：</p>
<pre><code>apktool_2.1.0.jar d koku.apk
</code></pre><p>运行完成之后，我们可以发现在目录下多了一个名字叫koku的文件夹，而这就是我们反编译出来的XML文件了。</p>
<p><img src="/uploads/20160403/20160403131154.png" alt="这里写图片描述"></p>
<p>我们打开里面的AndroidManifest.xml：</p>
<p><img src="/uploads/20160403/20160403131326.png" alt="这里写图片描述"></p>
<p>里面真的有<uses-permission\>、<activity\>等信息！然后我们打开res里面的layout文件夹，会发现里面有我们上面提到的activity_my_favorite.xml：</activity\></uses-permission\></p>
<p><img src="/uploads/20160403/20160403131658.png" alt="这里写图片描述"></p>
<p>里面的布局一目了然。到这里，这样一个apk的基本的源代码我们都可以看得到。当然，反编译别人的apk应该是以学习为主，而不是恶意地二次打包以及破坏。</p>
<p>在这里额外多说一句，如果要反编译的apk经过了代码混淆，那么反编译出来的就变成了a.class、b.class、c.class等等，所以代码混淆可以有效地阻止apk反编译。</p>
<p>而如果你想要将代码混淆，只要打开项目中的build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能。proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><p>好了，差不多该讲的都讲完了，今天就到这里了。</p>
<p>下面给出反编译工具的下载链接：</p>
<p><a href="/uploads/20160403/apktool_2.1.0.jar">apktool_2.1.0.jar</a></p>
<p><a href="/uploads/20160403/dex2jar-2.0.zip">dex2jar-2.0.zip</a></p>
<p><a href="/uploads/20160403/jd-gui-0.3.5.windows.zip">jd-gui-0.3.5.windows.zip</a></p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/03/31/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/03/31/《Android开发艺术探索》笔记(上)/</id>
    <published>2016-03-31T11:49:28.000Z</published>
    <updated>2016-08-29T03:06:25.188Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="第一章：Activity的生命周期和启动模式"></a>第一章：Activity的生命周期和启动模式</h1><h2 id="1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790"><a href="#1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790" class="headerlink" title="1.1 Activity的生命周期全面分析"></a>1.1 Activity的生命周期全面分析</h2><p><strong>典型情况下的生命周期分析</strong></p>
<p>onStart()和onStop()是从Activity是否可见这个角度来回调的，而onResume()和onPause()是从Activity是否位于前台这个角度来回调的。</p>
<p>Activity A打开Activity B时，为了不影响B的显示，最好不要在Activity A的onPause()里执行一些耗时操作，可以考虑将这些操作放到onStop()里，这时B已经可见了。</p>
<p><strong>异常情况下的生命周期分析</strong></p>
<p>由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用时机是在onStop()之前，但它和onPause()没有既定的时序关系，它既可能在onPause()之前调用，也可能在onPause()之后调用。需要强调的一点是，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会调用onSaveInstanceState()这个方法。</p>
<p>当Activity被重新创建后，系统会调用onRestoreInstanceState()，并且把Activity销毁时onSaveInstanceState()方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState()和onCreate()方法。因此我们可以通过onRestoreInstanceState()和onCreate()方法来判断Activity是否重建了。如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart()之后。</p>
<p>和Activity一样，每个View都有onSaveInstanceState()和onRestoreInstanceState()这两个方法。关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorWindow。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父层委托子元素去处理一件事情。至于数据恢复过程也是类似的，这里就不再重复介绍了。</p>
<p>Activity按照优先级从高到低，可以分为如下三种：</p>
<ul>
<li>前台Activity——正在和用户交互的Activity，优先级最高。</li>
<li>可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。</li>
<li>后台Activity——已经被暂停的Activity，比如说执行了onStop，优先级最低。</li>
</ul>
<p>如果不想Activity在屏幕旋转的时候重新创建，则：</p>
<pre><code>android:configChanges=&quot;orientation&quot;
</code></pre><p>另外，若minSdkVersion和targetSdkVersion其中有一个低于13，则要在上面的基础上，加上screenSize，即：</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre><h2 id="1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F"><a href="#1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h2><p><strong>Activity的launchMode</strong></p>
<ul>
<li><p>standard 标准模式。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity就运行在启动仪它的那个Activity所在的栈里。另外要注意的是，当我们用ApplicationContext去启动standard模式的Activity的时候会报错，错误如下</p>
<pre><code>E/AndroidRuntime(674):andriod.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.Is this really what you want?
</code></pre><p>  这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈，所以这就有问题了。解决这个问题的方法是为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动Activity实际上是以singleTask模式启动的。</p>
</li>
<li><p>singleTop 栈顶复用模式。若该Activity已经位于任务栈的栈顶，那么该Activity不会被重新创建，同时它的onNewIntent()方法会被回调，通过此方法的参数我们可以取出当前请求的信息。而且它的onCreate()和onStart()并不会被调用。执行的是onPause() –&gt; onNewIntent() –&gt; onResume()。 如果该Activity已存在但不是位于栈顶，则该Activity仍然会被重新创建。</p>
</li>
<li><p>singleTask 栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewsIntent()。具体一点，当一个具有singleTask模式的Activity请求启动后，比如说Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在把A所需的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶(会把在栈中所有处于A之上的Activity全部出栈)并调用它的onNewsIntent()方法，如果实例不存在，就创建A的实例并把A压入栈中。</p>
<p>  设ActivityA的 android:launchMode=”singleTask” 方式，且ActivityA正处于栈中，但不是栈顶，栈顶为ActivityB，点击按钮启动ActivityA，则：<br>  B: onPause() -&gt; A: onNewIntent() -&gt; A:onRestart() -&gt; A: onStart() -&gt; A:onResume() -&gt; B: onStop() -&gt; B: onDestroy()</p>
</li>
<li><p>singleInstance 单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity。除非这个独特的任务栈被系统销毁了。</p>
</li>
</ul>
<p><code>android:taskAffinity</code>：可以翻译为任务相关性。这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为报名。当然，我们可以为每个Activity都单独制定TaskAffinity属性，这个属性必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>
<ul>
<li><p>当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。</p>
</li>
<li><p>当TaskAffinity和allowTaskReparenting结合的时候，这种情况比较复杂，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。</p>
</li>
</ul>
<p><strong>Activity的Flags</strong></p>
<ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性<code>android:excludeFromRecents=&quot;true&quot;</code>。</p>
</li>
</ul>
<h2 id="1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219"><a href="#1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219" class="headerlink" title="1.3 IntentFilter的匹配规则"></a>1.3 IntentFilter的匹配规则</h2><ul>
<li>action匹配规则：要求intent中的action 存在 且 必须和过滤规则中的其中一个相同 区分大小写；</li>
<li>category匹配规则：系统会默认加上一个android.intent.category.DEAFAULT，所以intent中可以不存在category，但如果存在就必须匹配其中一个；</li>
<li>data匹配规则：data由两部分组成，mimeType和URI，要求和action相似。如果没有指定URI，URI但默认值为content和file（schema）。如果要为intent指定完整的data，必须要调用setDataAndType方法。</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236"><a href="#u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236" class="headerlink" title="第二章：IPC机制"></a>第二章：IPC机制</h1><h2 id="2-1_Android_IPC_u7B80_u4ECB"><a href="#2-1_Android_IPC_u7B80_u4ECB" class="headerlink" title="2.1 Android IPC简介"></a>2.1 Android IPC简介</h2><h2 id="2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="2.2 Android中的多进程模式"></a>2.2 Android中的多进程模式</h2><p><strong>开启多进程模式</strong></p>
<p>在Android中使用多进程只有一个办法，那就是给四大组件(Activity、Service、Receiver、ContentProvider)在AndroidMenifest中指定android:process属性。另外还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程。</p>
<p>进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局过程，其他应用可以通过ShareUID方式和它跑在同一个进程中。</p>
<p>我们知道Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。这里要说明的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说他们看起来就像是一个应用的两个部分。</p>
<p><strong>多进程模式的运行机制</strong></p>
<p>Android会为每一个应用分配一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。</p>
<p>一般来说，使用多进程会造成如下几方面的问题：</p>
<ol>
<li>静态成员和单例模式完全失效；</li>
<li>线程同步机制完全失效；</li>
<li>SharedPreferences的可靠性下降；</li>
<li>Application会多次创建。</li>
</ol>
<h2 id="2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD"><a href="#2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD" class="headerlink" title="2.3 IPC基础概念介绍"></a>2.3 IPC基础概念介绍</h2><p><strong>Serializable接口</strong></p>
<p>Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，通过Serializable来实现对象的序列化和反序列化(User类实现了Serializable接口)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>,<span class="string">"jake"</span>,<span class="keyword">true</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>))；</span><br><span class="line">User newUser = (User)in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p>恢复的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>原则上序列化后的数据中的serialVerionUID只有和当前类的serialVersionUID相同才能够正常地被反序列化。</p>
<p>serialVersionUID的详细工作机制：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUID的值。</p>
<p>有两个需要注意一下：</p>
<ul>
<li>静态成员变量属于类不属于对像，所以不会参与序列化过程；</li>
<li>用transient关键字标记的成员变量不参与序列化过程。</li>
</ul>
<p><strong>Parcelable接口</strong></p>
<p>Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，因此推荐使用Parcelable。Parcelable接口可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(bookId);</span><br><span class="line">        out.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现反序列化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;<span class="comment">//创建指定长度的原始对象数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Binder</strong></p>
<p>Binder是Android的一个类，它继承了IBinder接口。从IPC的角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包含普通服务和基于AIDL的服务。</p>
<p>在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。</p>
<p>AIDL工具根据AIDL文件自动生成的Java接口的解析：首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。</p>
<p>AIDL接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>
<ul>
<li><code>DESCRIPTOR</code>:Binder的唯一标识，一般用当前Binder的类名表示，比如“com.example.android.MyAIDLInterface”。</li>
<li><code>asInterface(android.os.IBinder obj)</code>：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>
<li><code>asBinder()</code>：返回当前Binder对象。</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code>：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是<code>public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</code>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</li>
<li><code>Proxy#[Method]</code>：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</li>
</ul>
<p>Binder的工作机制原理图：</p>
<p><img src="/uploads/20160809/20160814201234.png" alt="Binder的工作机制原理图"></p>
<p>Binder的两个重要方法linkToDeath和unlinkToDeath：<br>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。<br>如何给Binder设置死亡代理呢？</p>
<p>(一). 声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteBookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">        mRemoteBookManager = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>这里重新绑定远程Service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(二). 在客户端绑定远程服务成功之后，给binder设置死亡代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-4_IPC_u65B9_u5F0F"><a href="#2-4_IPC_u65B9_u5F0F" class="headerlink" title="2.4 IPC方式"></a>2.4 IPC方式</h2><ol>
<li><p>使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。</p>
</li>
<li><p>使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。</p>
<p> SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。</p>
</li>
<li><p>使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形。</p>
<p> Messenger的工作原理：</p>
<p> <img src="/uploads/20160809/20160809234757.png" alt="Messenger的工作原理图"></p>
</li>
<li><p>使用AIDL:首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。</p>
<p> AIDL使用的注意点：</p>
<p> (1). AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；<br> (2). 某些类即使和AIDL文件在同一个包中也要显式import进来；<br> (3). AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；<br> (4). AIDL接口中支持方法，不支持声明静态变量；<br> (5). 为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。<br> (6). AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以要在AIDL方法中处理线程同步。<br> (7). RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。<br> (8). 客户端调用远程服务方法时，因为远程方法运行在服务端的binder线程池中，同时客户端线程会被挂起，所以如果该方法过于耗时，而客户端又是UI线程，会导致ANR，所以当确认该远程方法是耗时操作时，应避免客户端在UI线程中调用该方法。同理，当服务器调用客户端的listener方法时，该方法也运行在客户端的binder线程池中，所以如果该方法也是耗时操作，请确认运行在服务端的非UI线程中。另外，因为客户端的回调listener运行在binder线程池中，所以更新UI需要用到handler。<br> (9). 客户端通过IBinder.DeathRecipient来监听Binder死亡，也可以在onServiceDisconnected中监听并重连服务端。区别在于前者是在binder线程池中，访问UI需要用Handler，后者则是UI线程。<br> (10). AIDL可通过自定义权限在onBind或者onTransact中进行权限验证。</p>
</li>
<li><p>使用ContentProvider<br>1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；<br>2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；<br>3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；<br>4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</p>
</li>
<li><p>使用Socket<br>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。</p>
</li>
</ol>
<h2 id="2-5_Binder_u8FDE_u63A5_u6C60"><a href="#2-5_Binder_u8FDE_u63A5_u6C60" class="headerlink" title="2.5 Binder连接池"></a>2.5 Binder连接池</h2><p>(1). 当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。<br>Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>
<p>(2). 作者实现的Binder连接池BinderPool的<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/binderpool/BinderPool.java" target="_blank" rel="external">实现源码</a>，建议在AIDL开发工作中引入BinderPool机制。</p>
<h2 id="2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F"><a href="#2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F" class="headerlink" title="2.6 选用合适的IPC方式"></a>2.6 选用合适的IPC方式</h2><p><img src="/uploads/20160809/20160814191325.png" alt="选用合适的IPC方式"></p>
<p>// TODO</p>
<h1 id="u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB"><a href="#u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h1><h2 id="3-1_View_u57FA_u7840_u77E5_u8BC6"><a href="#3-1_View_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="3.1 View基础知识"></a>3.1 View基础知识</h2><p><strong>View的位置参数</strong></p>
<ul>
<li>View的宽高和坐标关系：width = right - left，height = top - bottom。</li>
<li>View在平移过程中，top和left表示的是原始左上角的位置信息，其值不会改变，发生改变的是x、y、translationX、translationY这四个参数。x是View左上角的坐标，translation是view移动后相对于父容器的偏移量，所以有x = left + translationX。y的原理相同。</li>
</ul>
<p><strong>MotionEvent和TouchSlop</strong></p>
<p>TouchSlop是系统所能识别出的被认为是滑动的最小距离。这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>。当两次滑动事件的滑动距离小于TouchSlop时就可以认为不是滑动。</p>
<p><strong>VelocityTracker、GestureDetector和Scroller</strong></p>
<p>1.VelocityTracker</p>
<p>速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。首先，在View的onTouchEvent方法中追踪当前单击事件的速度。</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></pre><p>获取当前的速度：</p>
<pre><code>velocityTracker.computeCurrentVelocity(1000); //表示的是一个时间单元或者说时间间隔
int xVelocity = (int) velocityTracker.getXVelocity();
int yVelocity = (int) velocityTracker.getYVelocity();
</code></pre><p>当不用它的时候，需要调用clear()方法来重置并回收内存：</p>
<pre><code>velocityTracker.clear();
velocityTracker.recycle();
</code></pre><p>2.GestureDetector</p>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行动。</p>
<p>首先，需要创建一个GestureDetector对象并实现OnGestureListener接口，根据需要我们还可以实现OnDoubleTapListener从而能够监听双击行为：</p>
<pre><code>GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false)；
</code></pre><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加如下实现：</p>
<pre><code>boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre><p>做完了上面两步，我们就可以有选择地实现OnGestureListener和OnDoubleTapListener中的方法了。</p>
<p>3.Scroller</p>
<p>在3.2节中详细介绍。</p>
<h2 id="3-2_View_u7684_u6ED1_u52A8"><a href="#3-2_View_u7684_u6ED1_u52A8" class="headerlink" title="3.2 View的滑动"></a>3.2 View的滑动</h2><ul>
<li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p>
</li>
<li><p>使用动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</p>
</li>
<li><p>改变布局参数：操作稍微复杂，使用于有交互的View</p>
</li>
</ul>
<h2 id="3-3__u5F39_u6027_u6ED1_u52A8"><a href="#3-3__u5F39_u6027_u6ED1_u52A8" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><ul>
<li><p>使用Scroller</p>
</li>
<li><p>通过动画</p>
</li>
<li><p>使用Handler延时策略</p>
</li>
</ul>
<h2 id="3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236"><a href="#3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236" class="headerlink" title="3.4 View的事件分发机制"></a>3.4 View的事件分发机制</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View。即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>主要过程：Activity的dispatchTouchEvent–&gt;Window的superDispatchTouchEvent(Window实际上是一个抽象类，而它的实现类为PhoneWindow)–&gt;DecorView的superDispatchTouchEvent(DecorView是继承自FrameLayout，是Activity的根View)–&gt;分发到子View中(即分发到contentView中)。</p>
<p>注意点：</p>
<ul>
<li><p>如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
</li>
<li><p>某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。</p>
</li>
<li><p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</p>
</li>
<li><p>通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
<li><p>ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</p>
</li>
</ul>
<h2 id="3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81"><a href="#3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81" class="headerlink" title="3.5 View的滑动冲突"></a>3.5 View的滑动冲突</h2><p><strong>常见的滑动冲突场景</strong></p>
<p>常见的滑动冲突场景可以简单分为如下三种：</p>
<ul>
<li>场景1——外部滑动方向和内部滑动方向不一致</li>
<li>场景2——外部滑动方向和内部滑动方向一致</li>
<li>场景3——上面两种情况的嵌套</li>
</ul>
<p><strong>滑动冲突处理规则</strong></p>
<p>可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等</p>
<p><strong>滑动冲突的解决方式</strong></p>
<p>外部拦截法：点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。</p>
<p>伪代码如下：</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastXIntercept;
        int deltaY = y - mLastYIntercept;
        if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }

    mLastXIntercept = x;
    mLastYIntercept = y;

    return intercepted;
}
</code></pre><p>内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。</p>
<p>伪代码如下：</p>
<p>子元素：</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            getParent().requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre><p>父元素：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    int action = event.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        return false;
    }else{
        return true;
    }
}
</code></pre><h1 id="u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406"><a href="#u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="第四章：View的工作原理"></a>第四章：View的工作原理</h1><h2 id="4-1__u521D_u8BC6ViewRoot_u548CDecorView"><a href="#4-1__u521D_u8BC6ViewRoot_u548CDecorView" class="headerlink" title="4.1 初识ViewRoot和DecorView"></a>4.1 初识ViewRoot和DecorView</h2><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，这个过程可参看如下源码：</p>
<pre><code>root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
</code></pre><p>View的绘制流程从ViewRoot的performTraversals方法开始，经过measure、layout和draw三大流程。</p>
<p>performMeasure方法中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素了，这样就完成了一次measure过程，layout和draw的过程类似。 (书中175页画出详细的图示)</p>
<p>measure过程决定了view的宽高，在几乎所有的情况下这个宽高都等同于view最终的宽高。layout过程决定了view的四个顶点的坐标和view实际的宽高，通过getWidth和getHeight方法可以得到最终的宽高。draw过程决定了view的显示。</p>
<p>DecorView其实是一个FrameLayout，其中包含了一个竖直方向的LinearLayout，上面是标题栏，下面是内容栏(id为android.R.id.content)。内容栏也是一个FrameLayout。</p>
<h2 id="4-2__u7406_u89E3MeasureSpec"><a href="#4-2__u7406_u89E3MeasureSpec" class="headerlink" title="4.2 理解MeasureSpec"></a>4.2 理解MeasureSpec</h2><ol>
<li><p><strong>MeasureSpec和LayoutParams的对应关系</strong></p>
<p> 在view测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽高。<br> MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定view的MeasureSpec，从而进一步确定view的宽高。对于DecorView，它的MeasureSpec由窗口的尺寸和其自身的LayoutParams来决定；对于普通view，它的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定。</p>
</li>
<li><p><strong>普通view的MeasureSpec的创建规则</strong></p>
<p> 当view采用固定宽高时，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式，并且大小是LayoutParams中的大小。<br> 当view的宽高是match_parent时，如果父容器的模式是精确模式，那么view也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么view也是最大模式，并且大小是不会超过父容器的剩余空间。<br> 当view的宽高是wrap_content时，不管父容器的模式是精确模式还是最大模式，view的模式总是最大模式，并且大小不超过父容器的剩余空间。</p>
</li>
</ol>
<h2 id="4-3_view_u7684_u5DE5_u4F5C_u6D41_u7A0B"><a href="#4-3_view_u7684_u5DE5_u4F5C_u6D41_u7A0B" class="headerlink" title="4.3 view的工作流程"></a>4.3 view的工作流程</h2><p><strong>measure过程</strong></p>
<p>getSuggestedMinimumWidth的逻辑：View如果没有背景，那么返回android:minWidth这个属性指定的值，这个值可以为0；如果设置了背景，则返回背景的最小宽度和minWidth中的较大值。</p>
<p>view的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个view已经测量完毕了。如果view还没有测量完毕，那么获得的宽高就都是0。下面是四种解决该问题的方法：</p>
<ol>
<li><p>Activity/View # onWindowFocusChanged<br>onWindowFocusChanged方法表示view已经初始化完毕了，宽高已经准备好了，这个时候去获取宽高是没问题的。这个方法会被调用多次，当Activity继续执行或者暂停执行的时候，这个方法都会被调用。</p>
</li>
<li><p>view.post(runnable)<br>通过post将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view也已经初始化好了。</p>
</li>
<li><p>ViewTreeObserver<br>使用ViewTreeObserver的众多回调方法可以完成这个功能，比如使用onGlobalLayoutListener接口，当view树的状态发生改变或者view树内部的view的可见性发生改变时，onGlobalLayout方法将被回调。伴随着view树的状态改变，这个方法也会被多次调用。</p>
</li>
<li><p>view.measure(int widthMeasureSpec, int heightMeasureSpec)<br>通过手动对view进行measure来得到view的宽高，这个要根据view的LayoutParams来处理：<br>match_parent：无法measure出具体的宽高；</p>
<p> 精确值：例如100px</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</span><br><span class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure>
<p> wrap_content：如下measure，设置最大值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</span><br><span class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>layout过程</strong></p>
<p>在view的默认实现中，view的测量宽高和最终宽高是相等的，只不过测量宽高形成于measure过程，而最终宽高形成于layout过程。</p>
<p><strong>draw过程</strong></p>
<p>draw过程大概有下面几步：</p>
<ol>
<li>绘制背景：background.draw(canvas)；</li>
<li>绘制自己：onDraw()；</li>
<li>绘制children：dispatchDraw；</li>
<li>绘制装饰：onDrawScrollBars。</li>
</ol>
<p>setWillNotDraw方法用于在一个View不需要绘制时的优化（设置为true时）。</p>
<h2 id="4-4__u81EA_u5B9A_u4E49view"><a href="#4-4__u81EA_u5B9A_u4E49view" class="headerlink" title="4.4 自定义view"></a>4.4 自定义view</h2><ol>
<li>直接继承View或ViewGroup的需要自己处理wrap_content。 </li>
<li>View要在onDraw方法中要处理padding，而ViewGroup要在onMeasure和onLayout中处理padding和margin。 </li>
<li>尽量不要在View中使用Handler，因为view内部本身已经提供了post系列的方法，完全可以替代Handler的作用。</li>
<li>view中如果有线程或者动画，需要在onDetachedFromWindow方法中及时停止。</li>
<li>处理好view的滑动冲突情况。</li>
</ol>
<h1 id="u7B2C6_u7AE0_Android_u7684Drawable"><a href="#u7B2C6_u7AE0_Android_u7684Drawable" class="headerlink" title="第6章 Android的Drawable"></a>第6章 Android的Drawable</h1><h2 id="6-1_Drawable_u7B80_u4ECB"><a href="#6-1_Drawable_u7B80_u4ECB" class="headerlink" title="6.1 Drawable简介"></a>6.1 Drawable简介</h2><ol>
<li>Android的Drawable表示的是一种可以在Canvas上进行绘制的概念，它的种类很多，最常见的就是图片和颜色了。它有两个重要的优点：一是比自定义view要简单；二是非图片类型的drawable占用空间小，利于减小apk大小。</li>
<li>Drawable是抽象类，是所有Drawable对象的基类。</li>
<li>Drawable的内部宽/高可以通过getIntrinsicWidth和getIntrinsicHeight方法获取，但是并不是所有Drawable都有内部宽/高。图片Drawable的内部宽高就是图片的宽高，但是颜色Drawable就没有宽高的概念，它一般是作为view的背景，所以会去适应view的大小，这两个方法都是返回-1。</li>
</ol>
<h2 id="6-2_Drawable_u5206_u7C7B"><a href="#6-2_Drawable_u5206_u7C7B" class="headerlink" title="6.2 Drawable分类"></a>6.2 Drawable分类</h2><ol>
<li><p>BitmapDrawable和NinePatchDrawable</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;bitmap / nine-patch
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:src=&quot;@[package:]drawable/drawable_resource&quot;
    android:antialias=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:filter=[&quot;true&quot; | &quot;false&quot;]
    android:gravity=[&quot;top&quot; | &quot;bottom&quot; | &quot;left&quot; | &quot;right&quot; | &quot;center_vertical&quot; |
                      &quot;fill_vertical&quot; | &quot;center_horizontal&quot; | &quot;fill_horizontal&quot; |
                      &quot;center&quot; | &quot;fill&quot; | &quot;clip_vertical&quot; | &quot;clip_horizontal&quot;]
    android:tileMode=[&quot;disabled&quot; | &quot;clamp&quot; | &quot;repeat&quot; | &quot;mirror&quot;] /&gt;
</code></pre><p> 属性分析：<br> android:antialias：是否开启图片抗锯齿功能。开启后会让图片变得平滑，同时也会一定程度上降低图片的清晰度，建议开启；<br> android:dither：是否开启抖动效果。当图片的像素配置和手机屏幕像素配置不一致时，开启这个选项可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，建议开启。<br> android:filter：是否开启过滤效果。当图片尺寸被拉伸或压缩时，开启过滤效果可以保持较好的显示效果，建议开启；<br> android:gravity：当图片小于容器的尺寸时，设置此选项可以对图片进行定位。<br> android:tileMode：平铺模式，有四种选项[“disabled” | “clamp” | “repeat” | “mirror”]。当开启平铺模式后，gravity属性会被忽略。repeat是指水平和竖直方向上的平铺效果；mirror是指在水平和竖直方向上的镜面投影效果；clamp是指图片四周的像素会扩展到周围区域，这个比较特别。</p>
</li>
<li><p>ShapeDrawable</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape    
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
    android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt;    
    &lt;corners        //当shape为rectangle时使用
        android:radius=&quot;integer&quot;        //半径值会被后面的单个半径属性覆盖，默认为1dp
        android:topLeftRadius=&quot;integer&quot;        
        android:topRightRadius=&quot;integer&quot;        
        android:bottomLeftRadius=&quot;integer&quot;        
        android:bottomRightRadius=&quot;integer&quot; /&gt;    
    &lt;gradient       //渐变
        android:angle=&quot;integer&quot;        
        android:centerX=&quot;integer&quot;        
        android:centerY=&quot;integer&quot;        
        android:centerColor=&quot;integer&quot;        
        android:endColor=&quot;color&quot;        
        android:gradientRadius=&quot;integer&quot;        
        android:startColor=&quot;color&quot;        
        android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]        
        android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt;    
    &lt;padding        //内边距
        android:left=&quot;integer&quot;        
        android:top=&quot;integer&quot;        
        android:right=&quot;integer&quot;        
        android:bottom=&quot;integer&quot; /&gt;    
    &lt;size           //指定大小，一般用在imageview配合scaleType属性使用
        android:width=&quot;integer&quot;        
        android:height=&quot;integer&quot; /&gt;    
    &lt;solid          //填充颜色
        android:color=&quot;color&quot; /&gt;    
       &lt;stroke         //边框
          android:width=&quot;integer&quot;        
        android:color=&quot;color&quot;        
        android:dashWidth=&quot;integer&quot;        
        android:dashGap=&quot;integer&quot; /&gt;
&lt;/shape&gt;
</code></pre><p> android:shape：默认的shape是矩形，line和ring这两种形状需要通过<stroke>来制定线的宽度和颜色，否则看不到效果。<br> gradient：solid表示纯色填充，而gradient表示渐变效果。andoid:angle指渐变的角度，默认为0，其值必须是45的倍数，0表示从左到右，90表示从下到上，其他类推。<br> padding：这个表示的是包含它的view的空白，四个属性分别表示四个方向上的padding值。<br> size：ShapeDrawable默认情况下是没有宽高的概念的，但是可以如果指定了size，那么这个时候shape就有了所谓的固有宽高，但是作为view的背景时，shape还是会被拉伸或者缩小为view的大小。</stroke></p>
</li>
<li><p>LayerDrawble<br>对应标签<layer-list>，表示层次化的Drawable集合，实现一种叠加后的效果。<br>属性android:top/left/right/bottom表示drawable相对于view的上下左右的偏移量，单位为像素。</layer-list></p>
</li>
<li><p>StateListDrawable<br>对应标签<selector>，也是表示Drawable集合，每个drawable对应着view的一种状态。<br>一般来说，默认的item都应该放在selector的最后一条并且不附带任何的状态。</selector></p>
</li>
<li><p>LevelListDrawable<br>对应标签<level-list>，同样是Drawable集合，每个drawable还有一个level值，根据不同的level，LevelListDrawable会切换不同的Drawable，level值范围从0到100000。</level-list></p>
</li>
<li><p>TransitionDrawable<br>对应标签<transition>，它用于是吸纳两个Drawable之间的淡入淡出效果。</transition></p>
<pre><code>&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_linear&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_radius&quot;/&gt;
&lt;/transition&gt;

TransitionDrawable drawable = (TransitionDrawable) v.getBackground();
drawable.startTransition(5000);
</code></pre></li>
<li><p>InsetDrawable<br>对应标签<inset>，它可以将其他drawable内嵌到自己当中，并可以在四周留出一定的间距。当一个view希望自己的背景比自己的实际区域小的时候，可以采用InsetDrawable来实现。</inset></p>
<pre><code>&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:insetBottom=&quot;15dp&quot;
    android:insetLeft=&quot;15dp&quot;
    android:insetRight=&quot;15dp&quot;
    android:insetTop=&quot;15dp&quot; &gt;

    &lt;shape android:shape=&quot;rectangle&quot; &gt;
        &lt;solid android:color=&quot;#ff0000&quot; /&gt;
    &lt;/shape&gt;

&lt;/inset&gt;
</code></pre></li>
<li><p>ScaleDrawable<br>对应标签<scale>，它可以根据自己的level将指定的Drawable缩放到一定比例。如果level越大，那么内部的drawable看起来就越大。</scale></p>
</li>
<li><p>ClipDrawable<br>对应标签<clip>，它可以根据自己当前的level来裁剪另一个drawable，裁剪方向由android:clipOrientation和andoid:gravity属性来共同控制。level越大，表示裁剪的区域越小。</clip></p>
<pre><code>&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:clipOrientation=&quot;vertical&quot;
    android:drawable=&quot;@drawable/image1&quot;
    android:gravity=&quot;bottom&quot; /&gt;
</code></pre></li>
</ol>
<h2 id="6-3__u81EA_u5B9A_u4E49Drawable"><a href="#6-3__u81EA_u5B9A_u4E49Drawable" class="headerlink" title="6.3 自定义Drawable"></a>6.3 自定义Drawable</h2><ol>
<li>Drawable的工作核心就是draw方法，所以自定义drawable就是重写draw方法，当然还有setAlpha、setColorFilter和getOpacity这几个方法。当自定义Drawable有固有大小的时候最好重写getIntrinsicWidth和getIntrinsicHeight方法。</li>
<li>Drawable的内部大小不等于Drawable的实际区域大小，Drawable的实际区域大小可以通过它的getBounds方法来得到，一般来说它和view的尺寸相同。</li>
</ol>
<h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790" class="headerlink" title="第七章：Android动画深入分析"></a>第七章：Android动画深入分析</h1><h2 id="7-1_View_u52A8_u753B"><a href="#7-1_View_u52A8_u753B" class="headerlink" title="7.1 View动画"></a>7.1 View动画</h2><p>(1)Android动画可分为三大类：view动画、帧动画和属性动画，属性动画是API 11(Android 3.0)的新特性，帧动画一般也认为是view动画。<br>(2)AnimationSet的属性android:shareInterpolator表示集合中的动画是否共享同一个插值器，如果集合不指定插值器，那么子动画需要单独指定所需的插值器或者使用默认值。<br>(3)自定义动画需要继承Animation抽象类，并重新它的initialize和applyTransformation方法，在initialize方法中做一些初始化工作，在applyTransformation方法中进行相应的矩阵变换，很多时候需要采用Camera类来简化矩阵变换的过程。<br>(4)帧动画使用比较简单，但是容易引起OOM，所以在使用的时候应尽量避免使用过多尺寸较大的图片。</p>
<h2 id="7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F"><a href="#7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F" class="headerlink" title="7.2 View动画的特殊使用场景"></a>7.2 View动画的特殊使用场景</h2><p><strong>Activity的切换效果</strong></p>
<p><code>overridePendingTransition(int enterAnim, int exitAnim)</code>这个方法必须在<code>startActivity(Intent)</code>或者<code>finish()</code>之后被调用才能生效。</p>
<p>Fragment也可以添加切换动画，可以通过FragmentTransaction中的setCustomAnimations()方法来添加切换动画，这个切换动画需要是View动画。</p>
<h2 id="7-3__u5C5E_u6027_u52A8_u753B"><a href="#7-3__u5C5E_u6027_u52A8_u753B" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h2><p><strong>使用属性动画</strong></p>
<p>动画默认时间间隔为300ms，默认帧率为10ms/帧。</p>
<p>nineoldandroids对属性动画做了兼容，在API 11以前的版本其内部是通过代理View动画来实现的，因此在Android低版本上，他的本质还是View动画，尽管使用方法看起来是属性动画。</p>
<p><strong>对任意属性做动画</strong></p>
<p>属性动画的原理：属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。总结一下，我们对object的属性abc做动画，如果想让动画生效，要同时满足两个条件：</p>
<p>(1). object必须提供setAbc方法，如果动画的时候没有传递初始值，那么还要提供getAbc方法，因为系统要去取abc属性的初始值(如果这条不满足，程序直接Crash)</p>
<p>(2). object的setAbc对属性abc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类(如果这条不满足，动画无效果但不会Crash)</p>
<p>如果有时动画不生效的原因只满足条件1而未满足条件2，官方文档上告诉我们有3种解决方法：</p>
<ul>
<li>给你的对象加上get和set方法，如果你有权限的话；</li>
<li>用一个类来包装原始对象，间接为其提供get和set方法；</li>
<li>采用ValueAnimator，监听动画过程，自己实现属性的改变。</li>
</ul>
<p><strong>属性动画的工作原理</strong></p>
<p>// TODO</p>
<h2 id="7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879"><a href="#7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879" class="headerlink" title="7.4 使用动画的注意事项"></a>7.4 使用动画的注意事项</h2><ul>
<li>OOM：尽量避免使用帧动画，使用的话应尽量避免使用过多尺寸较大的图片；</li>
<li>内存泄露：属性动画中的无限循环动画需要在Activity退出的时候及时停止，否则将导致Activity无法释放而造成内存泄露。view动画不存在这个问题；</li>
<li>兼容性问题：某些动画在3.0以下系统上有兼容性问题；</li>
<li>view动画的问题：view动画是对view的影像做动画，并不是真正的改变view的状态，因此有时候动画完成之后view无法隐藏，即setVisibility(View.GONE)失效了，此时需要调用view.clearAnimation()清除view动画才行。</li>
<li>不要使用px；</li>
<li>动画元素的交互：在android3.0以前的系统上，view动画和属性动画，新位置均无法触发点击事件，同时，老位置仍然可以触发单击事件。从3.0开始，属性动画的单击事件触发位置为移动后的位置，view动画仍然在原位置；</li>
<li>硬件加速：使用动画的过程中，建议开启硬件加速，这样会提高动画的流畅性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探MD式转场动画]]></title>
    <link href="http://yuqirong.me/2016/03/23/%E5%88%9D%E6%8E%A2MD%E5%BC%8F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yuqirong.me/2016/03/23/初探MD式转场动画/</id>
    <published>2016-03-23T08:44:22.000Z</published>
    <updated>2016-08-18T15:09:33.926Z</updated>
    <content type="html"><![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是Google在SDK中已经给我们提供了。<code>ActivityOptions</code>是 Android 5.0 及以上使用的，但是也提供了<code>ActivityOptionsCompat</code>向下兼容。</p>
<p>下面我们就来看看吧：</p>
<p>layout_item.xml(ListView的item布局)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@android:color/white"</span></span><br><span class="line">    <span class="attribute">android:padding</span>=<span class="value">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"90dip"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"65dip"</span></span><br><span class="line">        <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">        <span class="attribute">android:padding</span>=<span class="value">"1dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"2dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:singleLine</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Subhead"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"2"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_time"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentRight</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"1"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"2016-02-25 11:22:23"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorSecondary"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"12sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们会注意到在ImageView里有<code>android:transitionName=&quot;photos&quot;</code>，这正是后面需要用到的。在这里的<code>photos</code>可以任意取名。也就是说你想让哪个View在转场时表现出动画，就在哪个View的xml中添加<code>android:transitionName</code>。</p>
<p>之后就是我们点击Item时应该跳转到另一个Activity中(这里就跳转到NewsDetailActivity了)，这其中的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 5.0 使用转场动画</span></span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    ActivityOptions options = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(getActivity(),</span><br><span class="line">                    itemView.findViewById(R.id.iv_img), <span class="string">"photos"</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//让新的Activity从一个小的范围扩大到全屏</span></span><br><span class="line">    ActivityOptionsCompat options = ActivityOptionsCompat</span><br><span class="line">            .makeScaleUpAnimation(itemView, itemView.getWidth() / <span class="number">2</span>,</span><br><span class="line">                    itemView.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在Android 5.0时使用的<code>makeSceneTransitionAnimation()</code>方法中的第三个参数正是上面的<code>&quot;photos&quot;</code>。当然在5.0版本以下我们只能使用兼容的<code>ActivityOptionsCompat</code>了。</p>
<p>最后在要跳转的Activity的布局中也添加<code>android:transitionName=&quot;photos&quot;</code>，这样就形成了一个MD式转场动画了。</p>
<p>以下是NewsDetailActivity的布局xml(只截取了部分)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/iv_album"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"256dp"</span></span><br><span class="line">    <span class="attribute">android:scaleType</span>=<span class="value">"centerCrop"</span></span><br><span class="line">    <span class="attribute">android:src</span>=<span class="value">"@drawable/thumbnail_default"</span></span><br><span class="line">    <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseMode</span>=<span class="value">"parallax"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseParallaxMultiplier</span>=<span class="value">"0.7"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>好了，这样就完成了，如果你需要在NewsDetailActivity执行finish时也出现转场动画，你只需要这样做(这里只给出了<code>onBackPressed()</code>的样例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        finishAfterTransition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实关于<code>ActivityOptions</code>和<code>ActivityOptionsCompat</code>转场动画还有更多选择，可以深入研究一下。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.lxway.com/895445426.htm" target="_blank" rel="external">你所不知道的Activity转场动画——ActivityOptions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造仿Android联系人界面]]></title>
    <link href="http://yuqirong.me/2016/03/22/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E4%BB%BFAndroid%E8%81%94%E7%B3%BB%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <id>http://yuqirong.me/2016/03/22/快速打造仿Android联系人界面/</id>
    <published>2016-03-22T07:53:24.000Z</published>
    <updated>2016-08-18T15:09:33.973Z</updated>
    <content type="html"><![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这里写图片描述"></p>
<p>我们可以看到在右侧有一个支持快速索引的栏。接下来，我们就要实现这种索引栏。</p>
<p>首先是<code>attrs.xml</code>，定义了三个自定义属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"QuickIndexBar"</span>&gt;</span></span><br><span class="line">        // 字体的颜色</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"font_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        // 选中时字体的颜色</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_font_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        // 字体的大小</span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"font_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后我们创建一个类继承自<code>View</code>，类名就叫<code>QuickIndexBar</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultFontColor = Color.WHITE;</span><br><span class="line"><span class="comment">// 默认选中字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> defaultSelectedFontColor = Color.GRAY;</span><br><span class="line"><span class="comment">// 字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> fontColor;</span><br><span class="line"><span class="comment">// 选中字体颜色</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> selectedFontColor;</span><br><span class="line"><span class="comment">// 字体大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> fontSize;</span><br><span class="line"><span class="comment">// 默认字体大小</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> defaultfontSize = <span class="number">12</span>;</span><br><span class="line"><span class="comment">// 上次触摸的字母单元格</span></span><br><span class="line"><span class="keyword">int</span> lastSelected = -<span class="number">1</span>;</span><br><span class="line"><span class="comment">// 这次触摸的字母单元格</span></span><br><span class="line"><span class="keyword">int</span> selected = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">QuickIndexBar</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line"></span><br><span class="line">    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.QuickIndexBar);</span><br><span class="line">    fontColor = a.getColor(R.styleable.QuickIndexBar_font_color, defaultFontColor);</span><br><span class="line">    selectedFontColor = a.getColor(R.styleable.QuickIndexBar_selected_font_color, defaultSelectedFontColor);</span><br><span class="line">    fontSize = a.getDimension(R.styleable.QuickIndexBar_font_size,</span><br><span class="line">            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, defaultfontSize,</span><br><span class="line">                    getContext().getResources().getDisplayMetrics()));</span><br><span class="line">    a.recycle();</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(fontColor);</span><br><span class="line">    mPaint.setTypeface(Typeface.DEFAULT_BOLD);</span><br><span class="line">    mPaint.setTextSize(fontSize);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码就是在构造器中初始化了自定义属性，大家应该都能看懂。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速索引的字母</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String[] INDEX_ARRAYS = <span class="keyword">new</span> String[]&#123;<span class="string">"#"</span>, <span class="string">"A"</span>, <span class="string">"B"</span>,</span><br><span class="line">        <span class="string">"C"</span>, <span class="string">"D"</span>, <span class="string">"E"</span>, <span class="string">"F"</span>, <span class="string">"G"</span>, <span class="string">"H"</span>, <span class="string">"I"</span>, <span class="string">"J"</span>, <span class="string">"K"</span>, <span class="string">"L"</span>, <span class="string">"M"</span>, <span class="string">"N"</span>, <span class="string">"O"</span>,</span><br><span class="line">        <span class="string">"P"</span>, <span class="string">"Q"</span>, <span class="string">"R"</span>, <span class="string">"S"</span>, <span class="string">"T"</span>, <span class="string">"U"</span>, <span class="string">"V"</span>, <span class="string">"W"</span>, <span class="string">"X"</span>, <span class="string">"Y"</span>, <span class="string">"Z"</span>&#125;;</span><br><span class="line"><span class="comment">// 控件的宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line"><span class="comment">// 控件的高度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line"><span class="comment">// 字母单元格的宽度</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">float</span> cellHeight;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 得到控件的大小</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    width = getMeasuredWidth();</span><br><span class="line">    height = getMeasuredHeight();</span><br><span class="line">    <span class="comment">//  得到字母单元格的高度</span></span><br><span class="line">    cellHeight = height * <span class="number">1.0f</span> / INDEX_ARRAYS.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>中获取<code>width</code>和<code>height</code>。还要计算<code>cellHeight</code>,也就是<code>INDEX_ARRAYS</code>中每个字符串所占用的高度，以便在<code>onDraw(Canvas canvas)</code>中使用。</p>
<p>我们来看看<code>onDraw(Canvas canvas)</code>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 遍历画出index</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; INDEX_ARRAYS.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 测出字体的宽度</span></span><br><span class="line">        <span class="keyword">float</span> x = width / <span class="number">2</span> - mPaint.measureText(INDEX_ARRAYS[i]) / <span class="number">2</span>;</span><br><span class="line">        <span class="comment">// 得到字体的高度</span></span><br><span class="line">        Paint.FontMetrics fm = mPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">double</span> fontHeight = Math.ceil(fm.descent - fm.ascent);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">float</span> y = (<span class="keyword">float</span>) ((i + <span class="number">1</span>) * cellHeight - cellHeight / <span class="number">2</span> + fontHeight / <span class="number">2</span>);</span><br><span class="line">        <span class="keyword">if</span> (i == selected) &#123;</span><br><span class="line">            mPaint.setColor(lastSelected == -<span class="number">1</span> ? fontColor : selectedFontColor);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mPaint.setColor(fontColor);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 绘制索引的字母 (x,y)为字母左下角的坐标</span></span><br><span class="line">        canvas.drawText(INDEX_ARRAYS[i], x, y, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中去遍历<code>INDEX_ARRAYS</code>，测量出字母的宽度和高度。这里要注意的是，<code>canvas.drawText(String text, float x, float y, Paint paint)</code>中的 x,y 指的是字母左下角的坐标，并不是“原点”。</p>
<p>别忘了我们还要对<code>QuickIndexBar</code>的触摸事件作出处理。所以我们要重写onTouchEvent(MotionEvent event)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置当索引改变的监听器</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnIndexChangeListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当索引改变</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> selectIndex 索引值</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onIndexChange</span><span class="params">(<span class="keyword">int</span> selectIndex)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当手指抬起</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onActionUp</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnIndexChangeListener</span><span class="params">(OnIndexChangeListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> y;</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            y = event.getY();</span><br><span class="line">            <span class="comment">// 计算出触摸的是哪个字母单元格</span></span><br><span class="line">            selected = (<span class="keyword">int</span>) (y / cellHeight);</span><br><span class="line">            <span class="keyword">if</span> (selected &gt;= <span class="number">0</span> &amp;&amp; selected &lt; INDEX_ARRAYS.length) &#123;</span><br><span class="line">                <span class="keyword">if</span> (selected != lastSelected) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.onIndexChange(selected); <span class="comment">// 回调监听器的方法</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    Log.i(TAG, INDEX_ARRAYS[selected]);</span><br><span class="line">                &#125;</span><br><span class="line">                lastSelected = selected;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="comment">// 把上次的字母单元格重置</span></span><br><span class="line">            lastSelected = -<span class="number">1</span>;</span><br><span class="line">            listener.onActionUp();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    invalidate(); <span class="comment">// 重绘视图</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>ACTION_DOWN</code>和<code>ACTION_MOVE</code>计算出了触摸的y值对应的是索引中的哪个字母，然后回调了监听器；而在<code>ACTION_UP</code>中重置了<code>lastSelected</code>，回调了监听器。</p>
<p>这样，我们就把<code>QuickIndexBar</code>写好了，关于<code>QuickIndexBar</code>使用的代码就不贴出来了，太长了。如果有需要，可以下载下面的Demo，里面都有注释。Demo的效果图如下：</p>
<p><img src="/uploads/20160322/20160322211942.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这里了。have fun!</p>
<p>源码下载：</p>
<p><a href="/uploads/20160322/ContactPicker.rar">ContactPicker.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/ContactPicker" target="_blank" rel="external">ContactPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[夜半一忆]]></title>
    <link href="http://yuqirong.me/2016/03/17/%E5%A4%9C%E5%8D%8A%E4%B8%80%E5%BF%86/"/>
    <id>http://yuqirong.me/2016/03/17/夜半一忆/</id>
    <published>2016-03-17T15:13:58.000Z</published>
    <updated>2016-09-06T13:43:51.058Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>素时锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈何岁月，流于昨日。雁过一鸣，惊于何人？花开花谢，润土无声。</p>
<p>繁华落尽，只道是人间凄凉。穷极一生，只为还清一世业障。</p>
<p>高山流水，静谧成寂。秋风落叶，随风飘散。</p>
<p>别时易，相逢难，烈酒灼心，忆似水年华。</p>
<p>乍暖还寒，大梦初醒，此夜无眠。</p>
<p>仰天大笑，岂是蓬蒿人？</p>
<p>————记于开题答辩之日</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=0&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>素时锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/03/08/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/03/08/《Android群英传》笔记(下)/</id>
    <published>2016-03-08T12:22:27.000Z</published>
    <updated>2016-08-18T15:09:33.864Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7" class="headerlink" title="第六章：Android绘图机制与处理技巧"></a>第六章：Android绘图机制与处理技巧</h1><h2 id="6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F"><a href="#6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F" class="headerlink" title="6.1 屏幕的尺寸信息"></a>6.1 屏幕的尺寸信息</h2><p>系统屏幕密度如下</p>
<ul>
<li>ldpi—120—240X320分辨率</li>
<li>mdpi—160—320X480分辨率</li>
<li>hdpi—240—480X800分辨率</li>
<li>xhdpi—320—720X1280分辨率</li>
<li>xxhdpi—480—1080X1920分辨率</li>
</ul>
<p>Android系统使用mdpi即密度值为160的屏幕作为标准，在这屏幕上1px = 1dp。</p>
<p>所以各个分辨率直接的换算比例，即ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12</p>
<p>下面给出单位转换的源码：</p>
<pre><code>public class DisplayUtil {

    /**
     * 把px值转换为dip或dp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2dip(Context context, float pxValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (pxValue / scale + 0.5f);
    }

    /**
     * 把dip值或dp值转换为px值
     *
     * @param context
     * @param dipValue
     * @return
     */
    public static int dip2px(Context context, float dipValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (dipValue * scale + 0.5f);
    }

    /**
     * 将px值转换为sp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2sp(Context context, float pxValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (pxValue / fontScale + 0.5f);
    }

    /**
     * 将sp值转换为px值
     * @param context
     * @param spValue
     * @return
     */
    public static int sp2px(Context context, float spValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (spValue * fontScale + 0.5f);
    }

}
</code></pre><h2 id="6-2_2D_u7ED8_u56FE_u57FA_u7840"><a href="#6-2_2D_u7ED8_u56FE_u57FA_u7840" class="headerlink" title="6.2 2D绘图基础"></a>6.2 2D绘图基础</h2><p>Paint类的一些属性和对应的功能：</p>
<ul>
<li>setAntiAlias(); //设置画笔的锯齿效果</li>
<li>setColor(); //设置画笔的颜色</li>
<li>setARGB(); //设置画笔的A,R,G,B的值</li>
<li>setAlpha(); //设置画笔的Alpha值</li>
<li>setTextSize(); //设置字体的尺寸</li>
<li>setStyle(); //设置画笔的风格（空心或者实心）</li>
<li>setStrokeWidth(); //设置空心边框的宽度</li>
</ul>
<p>Canvas类主要的绘画功能：</p>
<ul>
<li>canvas.drawPoint(x,y,paint); //绘制点</li>
<li>canvas.drawLine(startX,startY,endX,endY,paint); //绘制直线</li>
<li>canvas.drawRect(left,top,right,bottom,paint); //绘制矩形</li>
<li>canvas.drawRoundRect(left,top,right,bottom,radiusX,radiusY,paint); //绘制圆角矩形</li>
<li>canvas.drawCircle(circleX,circleY,radius,paint); //绘制圆</li>
<li>canvas.drawOval(left,top,right,bottom,paint); //通过椭圆的外接矩形来绘制椭圆</li>
<li>canvas.drawText(text,startX,startY,paint); //绘制文字</li>
<li>canvas.drawPosText(text,new float[]{x1,y1,…,xn,yn},paint); //指定位置绘制文本</li>
</ul>
<h2 id="6-3_Android_XML_u7ED8_u56FE"><a href="#6-3_Android_XML_u7ED8_u56FE" class="headerlink" title="6.3 Android XML绘图"></a>6.3 Android XML绘图</h2><ul>
<li><p>Bitmap：</p>
<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:src=&quot;@drawable/ic_launcher&quot;/&gt;
</code></pre><p>  这样就能直接将图片转成bitmap在程序中使用了。</p>
</li>
<li><p>Shape:</p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:shape=&quot;line|oval|ring|rectangle&quot;&gt;
  &lt;!--默认为rectangle--&gt;
  &lt;corners
      android:bottomLeftRadius=&quot;integer&quot;
      android:bottomRightRadius=&quot;integer&quot;
      android:radius=&quot;integer&quot;
      android:topLeftRadius=&quot;integer&quot;
      android:topRightRadius=&quot;integer&quot; /&gt;
  &lt;!--当shape为rectangle时才有，radius默认为1dp--&gt;

  &lt;gradient
      android:angle=&quot;integer&quot;
      android:centerColor=&quot;color&quot;
      android:centerX=&quot;integer&quot;
      android:centerY=&quot;integer&quot;
      android:endColor=&quot;color&quot;
      android:gradientRadius=&quot;integer&quot;
      android:startColor=&quot;color&quot;
      android:type=&quot;linear|radial|sweep&quot;
      android:useLevel=&quot;boolean&quot; /&gt;

  &lt;padding
      android:bottom=&quot;integer&quot;
      android:left=&quot;integer&quot;
      android:right=&quot;integer&quot;
      android:top=&quot;integer&quot; /&gt;

  &lt;size
      android:width=&quot;integer&quot;
      android:height=&quot;integer&quot; /&gt;
  &lt;!--指定大小，一般用在imageview配合scaleType使用--&gt;

  &lt;solid android:color=&quot;color&quot; /&gt;
  &lt;!--填充颜色--&gt;
  &lt;stroke
      android:width=&quot;integer&quot;
      android:color=&quot;color&quot;
      android:dashGap=&quot;integer&quot;
      android:dashWidth=&quot;integer&quot; /&gt;
  &lt;!--边框,dashGap为虚线间隔宽度，dashWidth为虚线宽度--&gt;
&lt;/shape&gt;
</code></pre></li>
<li><p>Layer:实现类似Photoshop中图层的概念。</p>
<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:drawable=&quot;@mipmap/ic_launcher&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;10dp&quot;
      android:top=&quot;10dp&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;20dp&quot;
      android:top=&quot;20dp&quot; /&gt;
&lt;/layer-list&gt;
</code></pre></li>
<li><p>Selector：通常用于view的触摸反馈。</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:state_pressed=&quot;true&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#334444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
  &lt;item android:state_pressed=&quot;false&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#444444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
&lt;/selector&gt;
</code></pre></li>
</ul>
<h2 id="6-4_Android_u7ED8_u56FE_u6280_u5DE7"><a href="#6-4_Android_u7ED8_u56FE_u6280_u5DE7" class="headerlink" title="6.4 Android绘图技巧"></a>6.4 Android绘图技巧</h2><ul>
<li><p>Canvas.save():保存画布。它的作用就是将之前的所有已绘制图像保存起来，让后续的操作就好像在一个新的图层上操作一样。</p>
</li>
<li><p>Canvas.restore():合并图层操作。它的作用就是将我们在save()之后绘制的所有图像与save()之前的图像进行合并。</p>
</li>
<li><p>Canvas.translate():画布平移，可理解为坐标系的平移。如在之前绘制的坐标系原点在(0,0)。在translate(x,y)之后，坐标原点在(x,y)。要注意的是，并不是移动至(x,y)点，而是在原先的基础上加上x和y。比如原先canvas位于(100,200)，translate(x,y)后，canvas位于(100+x,200+y)</p>
</li>
<li><p>Canvas.rotate():画布翻转，可理解为坐标系的翻转。canvas.rotate(30);为按照坐标系的原点顺时针旋转30度。canvas.rotate(30,x,y);为按照坐标系的(x,y)点顺时针旋转30度。</p>
</li>
<li><p>Canvas.saveLayer()、Canvas.saveLayerAlpha():将一个图层入栈。</p>
</li>
<li><p>Canvas.restore()、Canvas.restoreToCount():将一个图层出栈。</p>
</li>
</ul>
<h2 id="6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406"><a href="#6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406" class="headerlink" title="6.5 Android图像处理之色彩特效处理"></a>6.5 Android图像处理之色彩特效处理</h2><ul>
<li><p>色调：<code>setRotate(int axis,float degree)</code>设置颜色的色调。第一个参数，系统分别使用0、1、2来代表Red、Green、Blue三种颜色的处理。而第二个参数就是需要处理的值。</p>
<pre><code>ColorMatrix hueMatrix = new ColorMatrix();
hueMatrix.setRotate(0, hue0);
hueMatrix.setRotate(1, hue1);
hueMatrix.setRotate(2, hue2);
</code></pre></li>
</ul>
<p>通过上面的方法，可以为RGB三种颜色分量分别重新设置了不同的色调值。</p>
<ul>
<li><p>饱和度：<code>setSaturation(float sat)</code>方法来设置颜色的饱和度，参数即代表设置颜色饱和度的值，代码如下所示。当饱和度为0时，图像就变成灰色图像了。</p>
<pre><code>ColorMatrix saturationMatrix = new ColorMatrix();
saturationMatrix.setSaturation(saturation);
</code></pre></li>
<li><p>亮度：当三原色以相同的比例进行混合的时候，就会显示出白色。系统也正是使用这个原理来改变一个图像的亮度的，代码如下所示。当亮度为0时，图像就变成全黑了。</p>
<pre><code>ColorMatrix lumMatrix = new ColorMatrix();
lumMatrix.setScale(lum,lum,lum,1);
</code></pre></li>
<li><p><code>postConcat()</code>方法将矩阵的作用效果混合，从而叠加处理效果，代码如下：</p>
<pre><code>ColorMatrix imageMatrix = new ColorMatrix();
imageMatrix.postConcat(hueMatrix);
imageMatrix.postConcat(saturationMatrix);
imageMatrix.postConcat(lumMatrix);
</code></pre></li>
</ul>
<h2 id="6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406"><a href="#6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h2><ul>
<li>matrix.setRotate()——旋转变换</li>
<li>matrix.setTranslate()——平移变换</li>
<li>matrix.setScale()——缩放变换</li>
<li>matrix.setSkew()——错切变换</li>
<li>pre()和post()——提供矩阵的前乘和后乘运算</li>
</ul>
<h2 id="6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406"><a href="#6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406" class="headerlink" title="6.7 Android图像处理之画笔特效处理"></a>6.7 Android图像处理之画笔特效处理</h2><pre><code>mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
</code></pre><p>可以实现圆形ImageView。</p>
<p>// TODO</p>
<p><strong>Shader</strong></p>
<p>Shader又称之为着色器、渲染器，它用来实现一系列的渐变、渲染效果。在Android中的Shader包括以下几种：</p>
<ul>
<li>BitmapShader 位图Shader</li>
<li>LinearGradient 线性Shader</li>
<li>RadialGradient 光束Shader</li>
<li>SweepGradient 梯度Shader</li>
<li>ComposeShader 混合Shader</li>
</ul>
<p>除第一个Shader以外 其他Shader都实现了名副其实的渐变。BitmapShader产生的是一个位图，它的作用就是通过Paint对画布进行指定Bitmap的填充，填充有以下几种模式可以选择：</p>
<ul>
<li>CLAMP拉伸——拉伸的是图片最后一个像素 不断重复</li>
<li>REPEAT重复——横向纵向不断重复</li>
<li>MIRROR镜像——横向不断翻转重复，纵向不断翻转重复</li>
</ul>
<p><strong>PathEffect</strong></p>
<p>PathEffect是指用各种笔触效果来绘制一个路径。</p>
<ul>
<li>ConrnerPathEffect 就是将拐角变得圆滑，具体圆滑的程度，则由参数决定</li>
<li>DiscretePathEffect 使用这个效果后，线段上就会产生许多杂点。</li>
<li>DashPathEffect 这个效果可以用来绘制虚线，用一个数组来设置各个点之间的间隔。另一个参数phase则用来控制绘制时数组的一个偏移量。通常可以通过设置值来实现路径的动态效果。</li>
<li>PathDashPathEffect 与前面的DashPathEffect类似，只不过它的功能更加强大，可以设置显示点的图形，即方形点的虚线，圆形点的虚线。</li>
<li>ComposePathEffect 组合PathEffect，将任意两种路径特性组合起来形成一种新的效果。</li>
</ul>
<h2 id="6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView"><a href="#6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView" class="headerlink" title="6.8 View之孪生兄弟——SurfaceView"></a>6.8 View之孪生兄弟——SurfaceView</h2><p>SurfaceView与view的区别：  </p>
<ul>
<li>View主要适用于主动更新的情况下，而SurfaceView 主要适用于被动更新，例如频繁的刷新。</li>
<li>View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新。 </li>
<li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了双缓冲。</li>
</ul>
<p>总结成一句话就是，如果你的自定义View需要频繁刷新，或者刷新时数据处理量比较大，那你就可以考虑使用SurfaceView来取代View了。</p>
<p>SurfaceView模版代码：</p>
<pre><code>public class MySurfaceView extends SurfaceView implements Runnable, SurfaceHolder.Callback {
  //SurfaceHolder
  private SurfaceHolder mSurfaceHolder;
  //用于绘图的Canvas
  private Canvas mCanvas;
  //子线程标志位
  private boolean mIsDrawing;

  public MySurfaceView(Context context) {
      super(context);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs) {
      super(context, attrs);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      init();
  }
  private void init() {
      mSurfaceHolder = getHolder();
      mSurfaceHolder.addCallback(this);
      setFocusable(true);
      setFocusableInTouchMode(true);
      this.setKeepScreenOn(true);
      //mSurfaceHolder.setFormat(PixelFormat.OPAQUE);
  }
  @Override
  public void surfaceCreated(SurfaceHolder holder) {
      mIsDrawing = true;
      new Thread(this).start();
  }
  @Override
  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
  }
  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
      mIsDrawing = false;
  }
  @Override
  public void run() {
      while (mIsDrawing) {
          draw();
      }
  }
  private void draw() {
      try {
          //每次获得的canvas对象都是上次的 因此上次的绘画操作都会保存
          mCanvas = mSurfaceHolder.lockCanvas();
          //draw here
      } catch (Exception e) {

      } finally {
          if (mCanvas != null) {
              // 对画布内容进行提交
              mSurfaceHolder.unlockCanvasAndPost(mCanvas);
          }
      }

  }
}
</code></pre><h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第七章：Android动画机制与使用技巧"></a>第七章：Android动画机制与使用技巧</h1><h2 id="7-1_Android_View_u52A8_u753B_u6846_u67B6"><a href="#7-1_Android_View_u52A8_u753B_u6846_u67B6" class="headerlink" title="7.1 Android View动画框架"></a>7.1 Android View动画框架</h2><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，而且控制的是整个View，实现的原理是绘制视图时 View 所在的 ViewGroup 中的 drawChild 函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix()),通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
<ul>
<li>透明度动画：AlphaAnimation</li>
<li>旋转动画：RotateAnimation</li>
<li>位移动画：TranslateAnimation</li>
<li>缩放动画：ScaleAnimation</li>
</ul>
<p>动画集合：AnimationSet</p>
<p>动画监听器：setAnimationListener(new Animation.AnimationListener(){…})</p>
<h2 id="7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790"><a href="#7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790" class="headerlink" title="7.2 Android属性动画分析"></a>7.2 Android属性动画分析</h2><p><strong>ObjectAnimator</strong>：属性动画框架中最重要的实行类。</p>
<p>用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.setDuration(300);
animator.start();
</code></pre><p>注意：操纵的属性(即上面的“translationX”)必须具有get、set方法，不然ObjectAnimator就无法起效。因为内部会通过Java反射机制来调用set函数修改对象属性值。</p>
<p>常用属性值：</p>
<ul>
<li>translationX和translationY</li>
<li>rotation、rotationX和rotationY</li>
<li>scaleX和scaleY</li>
<li>pivotX和pivotY</li>
<li>x和y</li>
<li>alpha</li>
</ul>
<p><strong>PropertyValuesHolder</strong>：类似于视图动画中的AnimationSet。在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</p>
<p>用法：</p>
<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;,300f);
PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0,1f);
PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;,1f,0,1f);
ObjectAnimator.ofPropertyValuesHolder(view,pvh1,pvh2,pvh3).setDuration(1000).start();
</code></pre><p><strong>ValueAnimator</strong>：ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</p>
<p>用法：</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0,100);
animator.setTarget(view);
animator.setDuration(1000).start();
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Float value = (Float) animation.getAnimatedValue();
        // TODO use the value
    }
});
</code></pre><p>在ValueAnimator的AnimatorUpdateListener中监听数值的变换，从而完成动画的变换。</p>
<p><strong>AnimatorListener和AnimatorListenerAdapter</strong>：动画事件的监听。</p>
<p>AnimatorListener用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
});
</code></pre><p>AnimatorListenerAdapter用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><p><strong>AnimatorSet</strong>：AnimatorSet不仅能实现一个属性同时作用多个属性动画效果，同时也能实现更为精确的顺序控制。</p>
<p>用法(实现上面使用PropertyValuesHolder的动画效果)：</p>
<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
    ObjectAnimator animator2 = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1f,0f,1f);
    ObjectAnimator animator3 = ObjectAnimator.ofFloat(view,&quot;scaleY&quot;,1f,0f,1f);
    AnimatorSet set = new AnimatorSet();
    set.setDuration(1000);
    set.playTogether(animator1,animator2,animator3);
    set.start();
</code></pre><p>还有playTogether()、playSequentially()、animSet.play()、with()、before()、after()来协同工作。</p>
<p><strong>在XML中使用属性动画</strong>：在res里新建文件夹animator。</p>
<p>anim_scalex.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:propertyName=&quot;scaleX&quot;
    android:valueFrom=&quot;1.0&quot;
    android:valueTo=&quot;2.0&quot;
    android:valueType=&quot;floatType&quot;&gt;
&lt;/objectAnimator&gt; 
</code></pre><p>在代码中加载xml属性动画：</p>
<pre><code>public void scaleX(View view) {
    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.anim_scalex);  
    anim.setTarget(view);  
    anim.start();
}
</code></pre><p>另附 XML文件中定义两个objectAnimator：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:ordering=&quot;together&quot; &gt;  

    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleX&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  
    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleY&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  

&lt;/set&gt; 
</code></pre><p><strong>View的animate方法</strong>：可以认为是属性动画的一种简写方式。</p>
<p>用法：</p>
<pre><code>view.animate()
    .alpha(0)
    .y(300)
    .setDuration(300)
    .withStartAction(new Runnable() {
        @Override
        public void run() {

        }
    }).withEndAction(new Runnable() {
        @Override
        public void run() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {

                }
            });
        }
    }).start();
</code></pre><h2 id="7-3_Android_u5E03_u5C40_u52A8_u753B"><a href="#7-3_Android_u5E03_u5C40_u52A8_u753B" class="headerlink" title="7.3 Android布局动画"></a>7.3 Android布局动画</h2><p>最简单的布局动画是在ViewGroup的XML中，使用以下打开布局动画。<br><code>android:animateLayoutChanges=&quot;true&quot;</code><br>通过上面的代码，当ViewGroup添加View时，子View会呈现逐渐显示的过渡效果，是Android默认的显示的过渡效果。</p>
<p><strong>LayoutAnimationController</strong></p>
<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);
// 设置过渡动画
ScaleAnimation scaleAnimation = new ScaleAnimation(0,1,0,1);
scaleAnimation.setDuration(2000);
// 设置布局动画的显示属性
LayoutAnimationController lac = new LayoutAnimationController(scaleAnimation,0.5f);
lac.setOrder(LayoutAnimationController.ORDER_NORMAL);
ll.setLayoutAnimation(lac);
</code></pre><p>LayoutAnimationController的第一个参数是作用的动画，第二个参数是每个View显示的delay时间。当delay时间不为0时，可以设置子View显示的顺序，如下所示。</p>
<ul>
<li>LayoutAnimationController.ORDER_NORMAL  顺序</li>
<li>LayoutAnimationController.ORDER_RANDOM  随机</li>
<li>LayoutAnimationController.ORDER_REVERSE 反序</li>
</ul>
<h2 id="7-4_Interpolators_28_u63D2_u503C_u5668_29"><a href="#7-4_Interpolators_28_u63D2_u503C_u5668_29" class="headerlink" title="7.4 Interpolators(插值器)"></a>7.4 Interpolators(插值器)</h2><h2 id="7-5__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#7-5__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="7.5 自定义动画"></a>7.5 自定义动画</h2><p>首先继承Animation类，实现<code>applyTransformation(float interpolatedTime, Transformation t)</code>的逻辑。不过通常情况下，还要覆盖父类的<code>initialize(int width, int height, int parentWidth, int parentHeight)</code>实现一些初始化的工作。</p>
<p><code>applyTransformation(float interpolatedTime, Transformation t)</code>第一个参数是插值器的时间因子，这个因子由动画当前完成的百分比和当前时间所对应的插值所计算得来的，取值为0到1.0。第二个参数是矩阵的封装类，一般使用这个类来获取当前的矩阵对象，代码如下：</p>
<pre><code>final Matrix matrix = t.getMatrix();
</code></pre><p>下面给出电视机关闭效果的动画：</p>
<pre><code>@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    final Matrix matrix = t.getMatrix();
    matrix.preScale(1, 1 - interpolatedTime, mCenterWidth, mCenterHeight);
}
</code></pre><p>//TODO</p>
<h2 id="7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236"><a href="#7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236" class="headerlink" title="7.6 Android 5.X SVG 矢量动画机制"></a>7.6 Android 5.X SVG 矢量动画机制</h2><p>Google在Android 5.X中提供了下面两个新的API来帮助支持SVG：</p>
<ul>
<li>VectorDrawable</li>
<li>AnimatedVectorDrawable</li>
</ul>
<p>下面给出SVG图形：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:width=&quot;200dp&quot;
    android:height=&quot;200dp&quot;
    android:viewportHeight=&quot;100&quot;
    android:viewportWidth=&quot;100&quot;&gt;

    &lt;group
        android:name=&quot;test&quot;
        android:rotation=&quot;0&quot;&gt;
        &lt;path
            android:fillColor=&quot;@android:color/holo_blue_light&quot;
            android:pathData=&quot;M 25 50
            a 25,25 0 1,0 50,0&quot; /&gt;
    &lt;/group&gt;

&lt;/vector&gt;
</code></pre><p> //TODO</p>
<h1 id="u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790"><a href="#u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790" class="headerlink" title="第八章：Activity与Activity调用栈分析"></a>第八章：Activity与Activity调用栈分析</h1><h2 id="8-1_Activity"><a href="#8-1_Activity" class="headerlink" title="8.1 Activity"></a>8.1 Activity</h2><p>Activity的形态：</p>
<ul>
<li><p>Active/Running : 这时候Activity处于Activity栈的最顶层，可见，并与用户进行交互。</p>
</li>
<li><p>Paused : 当Activity失去焦点，被一个新的非全屏的Activity或者一个透明的Activity放置在栈顶时，Activity就转化为Paused形态。但它只是失去了与用户交互的能力，所有状态信息、成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。</p>
</li>
<li><p>Stopped : 如果一个Activity被另一个Activity完全覆盖，那么Activity就会进入Stopped形态，此时，它不再可见，但却依然保持了所有状态信息和成员变量。</p>
</li>
<li><p>Killed : 当Activity被系统回收掉或者Activity从来没有创建过，Activity就处于Killed状态。</p>
</li>
</ul>
<p>Activity启动与销毁过程：</p>
<ul>
<li><p>onCreate() ： 创建基本的UI元素。</p>
</li>
<li><p>onPause()和onStop() ： 清除Activity的资源，避免浪费。</p>
</li>
<li><p>onDestory() ： 因为引用会在Activity销毁的时候销毁，而线程不会，所以清除开启的线程。</p>
</li>
</ul>
<p>Activity的暂停与恢复过程：</p>
<ul>
<li><p>onPause() ： 释放系统资源，如Camera、sensor、receivers。</p>
</li>
<li><p>onResume() ： 需要重新初始化在onPause()中释放资源。</p>
</li>
</ul>
<p>Activity的停止过程：</p>
<ul>
<li><p>由部分不可见到完全不可见 ： onPause() -&gt; onStop()</p>
</li>
<li><p>由部分不可见到可见： onPause() -&gt; onStop() -&gt; onRestart() -&gt; onStart() -&gt; onResume()</p>
</li>
</ul>
<p>Activity的重新创建过程：</p>
<p>如果用户finish()方法结束了Activity，则不会调用onSaveInstanceState()。</p>
<h2 id="8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB"><a href="#8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB" class="headerlink" title="8.2 Android任务栈简介"></a>8.2 Android任务栈简介</h2><p>一个Task中的Activity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</p>
<h2 id="8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F"><a href="#8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.3 AndroidMainifest启动模式"></a>8.3 AndroidMainifest启动模式</h2><ul>
<li><p>standard ： 默认的启动模式，每次都会创建新的实例</p>
</li>
<li><p>singleTop ：   通常适用于接收到消息后显示的界面</p>
</li>
<li><p>singleTask ： 通常可以用来退出整个应用：将主Activity设为singleTask模式，然后在要退出的Activity中转到主Activity，从而将主Activity之上的Activity都清除，然后重写主Activity的onNewIntent()方法，在方法中加上一句finish()，将最后一个Activity结束掉。</p>
</li>
<li><p>singleInstance ： 申明为singleInstance的Activity会出现在一个新的任务栈中，而且该任务栈中只存在这一个Activity。举个例子，如果应用A的任务栈中创建了MainActivity的实例，且启动模式为singleInstance，如果应用B的也要激活MainActivity，则不需要创建，两个应用共享该Activity实例。这种启动模式常用于需要与程序分离的界面。</p>
</li>
</ul>
<p>关于singleTop和singleInstance这两种启动模式还有一点需要特殊说明：如果在一个singleTop或者singleInstance的Activity A中通过startActivityForResult()方法来启动另一个Activity B，那么直接返回Activity.RESULT_CANCELED而不会再去等待返回。这是由于系统在Framework层做了对这两种启动模式的限制，因为Android开发者认为，不同Task之间，默认是不能传递数据的，如果一定要传递，那么只能通过Intent来绑定数据。</p>
<h2 id="8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F"><a href="#8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.4 Intent Flag启动模式"></a>8.4 Intent Flag启动模式</h2><ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于在Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：使用singleTask模式来启动一个Activity，与指定android:launchMode=”singleTask”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_NO_HISTORY：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。例如A-B，B中以这种模式启动C，C再启动D，则当前Activity栈为ABD。</p>
</li>
</ul>
<h2 id="8-5__u6E05_u7A7A_u4EFB_u52A1_u6808"><a href="#8-5__u6E05_u7A7A_u4EFB_u52A1_u6808" class="headerlink" title="8.5 清空任务栈"></a>8.5 清空任务栈</h2><ul>
<li><p>clearTaskOnLaunch：每次返回该Activity时，都将该Activity之上的所有Activity都清除。通过这个属性，可以让这个Task每次在初始化的时候，都只有这一个Activity。</p>
</li>
<li><p>finishOnTaskLaunch：finishOnTaskLaunch属性与clearTaskOnLaunch属性类似，只不过clearTaskOnLaunch作用在别人身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所处的Task，那么用户再返回时，该Activity就会被finish掉。</p>
</li>
<li><p>alwaysRetainTaskState：如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。</p>
</li>
</ul>
<h1 id="u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236"><a href="#u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236" class="headerlink" title="第九章：Android系统信息与安全机制"></a>第九章：Android系统信息与安全机制</h1><h2 id="9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6"><a href="#9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6" class="headerlink" title="9.1 Android系统信息获取"></a>9.1 Android系统信息获取</h2><p>要获取系统的配置信息，通常可以从以下两个方面获取：</p>
<ul>
<li>android.os.Build</li>
<li>SystemProperty</li>
</ul>
<p>下面列举了android.os.Build一些常用的信息：</p>
<ul>
<li>Build.BOARD // 主板</li>
<li>Build.BRAND // Android系统定制商</li>
<li>Build.SUPPORTED_ABIS // CPU指令集</li>
<li>Build.DEVICE // 设备参数</li>
<li>Build.DISPLAY // 显示屏参数</li>
<li>Build.FINGERPRINT // 唯一编号</li>
<li>Build.SERIAL // 硬件序列号</li>
<li>Build.ID // 修订版本列表</li>
<li>Build.MANUFACTURER // 硬件制造商</li>
<li>Build.MODEL // 版本</li>
<li>Build.HARDWARE // 硬件名</li>
<li>Build.PRODUCT // 手机产品名</li>
<li>Build.TAGS // 描述Build的标签</li>
<li>Build.TYPE // Builder类型</li>
<li>Build.VERSION.CODENAME // 当前开发代号</li>
<li>Build.VERSION.INCREMENTAL // 源码控制版本号</li>
<li>Build.VERSION.RELEASE // 版本字符串</li>
<li>Build.VERSION.SDK_INT // 版本号</li>
<li>Build.HOST // Host值</li>
<li>Build.USER // User名</li>
<li>Build.TIME // 编译时间</li>
</ul>
<p>下面列举了SystemProperty常用的信息：</p>
<ul>
<li>os.version // OS版本</li>
<li>os.name // OS名称</li>
<li>os.arch // OS架构</li>
<li>user.home // Home属性</li>
<li>user.name // Name属性</li>
<li>user.dir //Dir属性</li>
<li>user.timezone // 时区</li>
<li>path.separator // 路径分隔符</li>
<li>line.separator // 行分隔符</li>
<li>file.separator // 文件分隔符</li>
<li>java.vendor.url // Java Vendor URL 属性</li>
<li>java.class.path // Java Class 路径</li>
<li>java.class.version Java Class 版本</li>
<li>java.vendor // Java Vendor 属性</li>
<li>java.version // Java 版本</li>
<li>java.home // Java Home 属性</li>
</ul>
<p>我们可以访问到系统的属性值，代码如下所示：</p>
<pre><code>String board = Build.BOARD;
String brand = Build.BRAND;

String os_version = System.getProperty(&quot;os.version&quot;);
String os_name = System.getProperty(&quot;os.name&quot;);
</code></pre><h2 id="9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager"><a href="#9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager" class="headerlink" title="9.2 Android Apk应用信息获取之PackageManager"></a>9.2 Android Apk应用信息获取之PackageManager</h2><p>Android系统提供了PackageManager来负责管理所有已安装的App。其中封装的信息如下：</p>
<ul>
<li>ActivityInfo：Mainfest文件中<activity\></activity\>和<receiver\></receiver\>之间的所有信息，包括name、icon、label、launchmode等。</li>
<li>ServiceInfo：封装了<service\></service\>之间的所有信息。</li>
<li>ApplicationInfo：封装了<application\></application\>之间的信息，不过特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在SDCard上的应用等，通过这些Flag，可以很方便的判断应用类型。</li>
<li>PackageInfo：PackageInfo与前面三个Info类似，都是用于封装Mainfest文件的相关节点信息，而它包含了所以Activity、Service等信息。</li>
<li>ResolveInfo：封装的是包含<intent\>信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含<intent\>的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</intent\></intent\></li>
</ul>
<p>PackageManager常用方法如下：</p>
<ul>
<li>getPackageManager：通过调用这个方法返回一个PackageManager对象。</li>
<li>getApplicationInfo：以ApplicationInfo的形式返回指定包名的ApplicationInfo。</li>
<li>getApplicationIcon：返回指定包名的Icon。</li>
<li>getInstallApplication：以ApplicationInfo的形式返回安装的应用。</li>
<li>getInstalledPackages：以PackageInfo的形式返回安装的应用。</li>
<li>queryIntentActivities：返回指定intent的ResolveInfo对象、Activity集合。</li>
<li>queryIntentServices：返回指定intent的ResolveInfo对象、Service集合。</li>
<li>resolveActivity：返回指定Intent的Activity。</li>
<li>resolveService：返回指定Intent的Service。</li>
</ul>
<p>判断App类型的依据，就是利用ApplicationInfo中的FLAG_SYSTEM来进行判断，代码如下所示：</p>
<pre><code>app.flags &amp; ApplicationInfo.FLAG_SYSTEM
</code></pre><ul>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM != 0</code>则为系统应用；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM &lt;= 0</code>则为第三方应用；</li>
<li>特殊的，当系统应用经过升级后，也将成为第三方应用：<code>flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP != 0</code>；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE != 0</code>则为安装在SDCard上的应用。</li>
</ul>
<h2 id="9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager"><a href="#9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager" class="headerlink" title="9.3 Android Apk应用信息获取之ActivityManager"></a>9.3 Android Apk应用信息获取之ActivityManager</h2><p>ActivityManager可以获得在运行的应用程序信息。其中封装的信息如下：</p>
<ul>
<li>ActivityManager.MemoryInfo：MemoryInfo有几个非常重要的字段，availMem–系统可用内存，totalMem–总内存，threshold–低内存的阈值，即区分是否低内存的临界值，lowMemory–是否处于低内存。</li>
<li>Debug.MemoryInfo：ActivityManager.MemoryInfo用于统计全局的内存信息，而Debug.MemoryInfo用于统计进程下的内存信息。</li>
<li>RunningAppProcessInfo：进程相关的信息，processName–进程名，pid–进程pid，uid–进程uid，pkgList–该进程下的所有包。</li>
<li>RunningServiceInfo：用于封装运行的服务信息，在它里面包含一些服务进程的信息，同时还有一些其他信息。activeSince–第一次被激活的时间、方式，foreground–服务是否在后台执行。</li>
</ul>
<h2 id="9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F"><a href="#9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F" class="headerlink" title="9.4 解析Packages.xml获取系统信息"></a>9.4 解析Packages.xml获取系统信息</h2><p>packages.xml在 data/system/目录下。</p>
<h2 id="9-5_Android_u5B89_u5168_u673A_u5236"><a href="#9-5_Android_u5B89_u5168_u673A_u5236" class="headerlink" title="9.5 Android安全机制"></a>9.5 Android安全机制</h2><p>反编译：</p>
<ul>
<li>apktool(反编译XML) ： <code>java -jar apktool_2.1.0.jar d test.apk</code></li>
<li>apktool(重新打包) ： <code>java -jar apktool_2.1.0.jar b test</code></li>
<li>Dex2jar、jd-gui ：<code>d2j-dex2jar.bat classes.dex</code></li>
</ul>
<p>Android Apk 加密：</p>
<p>打开build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能，proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><h1 id="u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十章：Android性能优化"></a>第十章：Android性能优化</h1><h2 id="10-1__u5E03_u5C40_u4F18_u5316"><a href="#10-1__u5E03_u5C40_u4F18_u5316" class="headerlink" title="10.1 布局优化"></a>10.1 布局优化</h2><ul>
<li><p>Android UI渲染机制</p>
<p>  在Android中，系统通过VSYNC信号出发对UI的渲染、重绘，其间隔时间是16ms。这个16ms其实就是1000ms中显示60帧画面的单位时间（玩游戏的就该知道，大于等于60帧就感觉不到卡顿）。Android系统提供了检测UI渲染时间的工具，打开“开发者选项”，选择“Profile GPU Rendering”（我的手机是“GPU呈现模式分析”），选中“On screen as bars”（我的为“在屏幕上显示为条形图”）。每一条柱状线都包括三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间，中间绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。</p>
</li>
<li><p>避免Overdraw</p>
<p>  过渡绘制会浪费很多CPU、GPU资源，例如系统默认会绘制Activity的背景，而如果再给布局绘制了重叠的背景，那么默认Activity的背景就属于无效的过渡绘制。Android系统在开发者选项中提供了这样一个检测工具–“Enable GPU Overdraw”。借助它可以判断Overdraw的次数。尽量增大蓝色的区域，减少红色的区域。</p>
</li>
<li><p>优化布局层级</p>
<p>  在Android中系统对View的测量、布局和绘制都是通过遍历View树来进行的，如果View树太高，就会影响其速度，Google也建议View树的高度不宜超过10层。</p>
</li>
<li><p>避免嵌套过多无用布局</p>
<ul>
<li>使用<include\>标签重用Layout</include\></li>
<li><p>使用<viewstub\>实现View的延迟加载</viewstub\></p>
<p><viewstub\>是个非常轻量级的组件，不仅不可视而且大小为0。这个布局在初始化时不需要显示，只有在某些情况下才显示出来。下面是实例代码：</viewstub\></p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;TextView
      android:id=&quot;@+id/tv&quot;
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:text=&quot;not often use&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>使用<viewstub\>：</viewstub\></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;ViewStub
      android:id=&quot;@+id/view_stub&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerInParent=&quot;true&quot;
      android:layout=&quot;@layout/test&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>在<code>onCreate(Bundle savedInstanceState)</code>中：</p>
<pre><code>ViewStub viewStub= (ViewStub) findViewById(R.id.view_stub);
//下面两个方法都是用来实现延迟加载的，区别是inflate()方法会返回引用的布局。
viewStub.setVisibility(View.VISIBLE); // 第一种方法

View view=viewStub.inflate(); // 第二种方法
TextView tv= (TextView) view.findViewById(R.id.tv);
</code></pre><p><viewstub\>标签与设置View.GONE这种方式的区别在于<viewstub\>标签只在显示时渲染整个布局，而设置View.GONE这种方式在初始化布局树时就已经添加在布局树上了，所以相比之下<viewstub>更有效率。</viewstub></viewstub\></viewstub\></p>
</li>
</ul>
</li>
<li><p>Hierarchy Viewer</p>
</li>
</ul>
<p>这是个用来测试布局冗余的工具。<a href="http://blog.csdn.net/xyz_lmn/article/details/14222975" target="_blank" rel="external">可点击此处</a></p>
<h2 id="10-2__u5185_u5B58_u4F18_u5316"><a href="#10-2__u5185_u5B58_u4F18_u5316" class="headerlink" title="10.2 内存优化"></a>10.2 内存优化</h2><ul>
<li><p>什么是内存</p>
<ul>
<li>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制。</li>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。</li>
<li>堆：堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器(GC)来管理。</li>
<li>静态存储区域：是指在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量。</li>
<li><p>常量池：就是该类型所用到常量的一个有序集合，包括直接常量（基本类型，String）和对其他类型、字段和方法的符号引用。</p>
<p>在程序中，可以使用如下所示的代码来获得堆的大小，所谓的内存分析，正是分析Heap中的内存状态</p>
<pre><code>ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)；
int heapSize = manager.getLargeMemoryClass();
</code></pre></li>
</ul>
</li>
<li><p>获取Android系统内存信息</p>
<ul>
<li><p>进程状态</p>
<pre><code>adb shell dumpsys procstats
</code></pre></li>
<li><p>内存信息</p>
<pre><code>adb shell dumpsys meminfo
</code></pre></li>
</ul>
</li>
<li><p>内存优化实例</p>
<ul>
<li><p>Bitmap优化</p>
<p>Bitmap是造成内存占用过高甚至是OOM的最大威胁，可以通过以下技巧进行优化</p>
<p>① 使用适当分辨率和大小的图片：例如在图片列表界面可以使用图片的缩略图thumbnails，而在显示详细图片的时候再显示原图；或者在对图像要求不高的地方，尽量降低图片的精度。</p>
<p>② 及时回收内存：一旦使用完Bitmap后，一定要及时使用bitmap.recycle()方法释放内存资源。自Android3.0后，由于Bitmap被放到了堆中，其内存由GC管理，就不需要释放了。</p>
<p>③ 通过内存缓存LruCache和DiskLruCache可以更好地使用Bitmap。</p>
</li>
<li><p>代码优化</p>
<p>任何Java类都将占用大约500字节的内存空间，创建一个类的实例会消耗大约15字节内存。从代码的实现上，也可以对内存进行优化。</p>
<p>① 对常量使用static修饰符。</p>
<p>② 使用静态方法，静态方法会比普通方法提高15%左右的访问速度。</p>
<p>③ 减少不必要的成员变量，这点在Android Lint工具上已经集成检测了。</p>
<p>④ 减少不必要对象，使用基础类型会比使用对象更加节省资源，同时更应该避免频繁创建短作用域的变量。</p>
<p>⑤ 尽量不要使用枚举、少用迭代器。</p>
<p>⑥ 对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收和注册、反注册。</p>
<p>⑦ 避免使用IOC框架，IOC通常使用注解、反射来进行实现，大量使用反射会带来性能的下降。</p>
<p>⑧ 使用RenderScript、OpenGL来进行非常复杂的绘图操作。</p>
<p>⑨ 使用SurfaceView来代替View进行大量、频繁的绘图操作。</p>
<p>⑩ 尽量使用视图缓存，而不是每次都执行inflate()解析视图。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-3_Lint_u5DE5_u5177"><a href="#10-3_Lint_u5DE5_u5177" class="headerlink" title="10.3 Lint工具"></a>10.3 Lint工具</h2><h2 id="10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177"><a href="#10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177" class="headerlink" title="10.4 使用Android Studio的Memory Monitor工具"></a>10.4 使用Android Studio的Memory Monitor工具</h2><h2 id="10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD"><a href="#10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD" class="headerlink" title="10.5 使用TraceView工具优化App性能"></a>10.5 使用TraceView工具优化App性能</h2><h2 id="10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001"><a href="#10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001" class="headerlink" title="10.6 使用MAT工具分析App内存状态"></a>10.6 使用MAT工具分析App内存状态</h2><h2 id="10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001"><a href="#10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001" class="headerlink" title="10.7 使用Dumpsys命令分析系统状态"></a>10.7 使用Dumpsys命令分析系统状态</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现WebView中JS和App之间的交互]]></title>
    <link href="http://yuqirong.me/2016/03/07/%E5%AE%9E%E7%8E%B0WebView%E4%B8%ADJS%E5%92%8CApp%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yuqirong.me/2016/03/07/实现WebView中JS和App之间的交互/</id>
    <published>2016-03-07T11:53:12.000Z</published>
    <updated>2016-08-18T15:09:33.942Z</updated>
    <content type="html"><![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img src="/uploads/20160307/20160307200816.png" alt="这里写图片的描述"></p>
<p>之后在脑海中回想到 WebView 中的JS可以和app产生交互，于是搜索了一下，果然网上有类似的实现效果。看了一下，在这里就做一个简单的笔记了以便之后查看。</p>
<p>在 WebView 中想要JS和app产生交互，就不得不提一个方法，那就是<code>addJavascriptInterface(Object object, String name)</code>：</p>
<ul>
<li>第一个参数：绑定到 JavaScript 的类实例。</li>
<li>第二个参数：用来显示 JavaScript 中的实例的名称。</li>
</ul>
<p>这里只是给出了参数的解释，如果你没看懂，那接下来就告诉你答案。</p>
<p>那就开始吧，在创建新的 project 之前，我们先把要加载的 test.html 写好，放在 assets 目录下：<br><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">html</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">head</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">title</span>&gt;</span>WebView Test<span class="tag">&lt;/<span class="title">title</span>&gt;</span></span><br><span class="line">	    <span class="tag">&lt;<span class="title">script</span> <span class="attribute">type</span>=<span class="value">"text/javascript"</span>&gt;</span><span class="javascript"></span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">btnShowToast</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		    <span class="built_in">window</span>.testJS.showToast();</span><br><span class="line">		&#125;</span><br><span class="line">	</span><br><span class="line">		<span class="function"><span class="keyword">function</span> <span class="title">btnGoActivity</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">		    <span class="built_in">window</span>.testJS.goActivity();</span><br><span class="line">		&#125;</span><br><span class="line">	    </span><span class="tag">&lt;/<span class="title">script</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">head</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">body</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">p</span>&gt;</span>This is a website<span class="tag">&lt;/<span class="title">p</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">br</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">'btnShowToast();'</span>&gt;</span>show Toast<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">button</span> <span class="attribute">onclick</span>=<span class="value">'btnGoActivity();'</span>&gt;</span>go Activity<span class="tag">&lt;/<span class="title">button</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;/<span class="title">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">html</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面的 html 很简单，相信有点基础的同学都能看得懂。要注意的是在JS函数中的 testJS 是要和 WebView 约定好的，这里就取名叫 testJS 吧，在下面会用到。还有<code>showToast()</code>和<code>goActivity()</code>也是约定好的函数名。我们预期的效果是点击 show Toast 按钮会显示Toast，而点击 go Activity 按钮会跳转到另外一个 Activity 上。</p>
<p>下面创建了一个 project ，名叫 WebViewDemo ，工程中 MainActivity 的 layout.xml 就只有一个 WebView 了：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"com.yuqirong.webviewdemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">WebView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/mWebView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>MainActivity 的代码很短，就直接贴出来了：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> WebView mWebView;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        mWebView = (WebView) findViewById(R.id.mWebView);</span><br><span class="line">        <span class="comment">// 设置支持JS</span></span><br><span class="line">        mWebView.getSettings().setJavaScriptEnabled(<span class="keyword">true</span>);</span><br><span class="line">        <span class="comment">// 增加JS交互的接口</span></span><br><span class="line">        mWebView.addJavascriptInterface(<span class="keyword">new</span> AndroidJSInterface(<span class="keyword">this</span>), <span class="string">"testJS"</span>);</span><br><span class="line">        mWebView.setWebViewClient(<span class="keyword">new</span> WebViewClient() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldOverrideUrlLoading</span><span class="params">(WebView view, String url)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        String url = <span class="string">"file:///android_asset/test.html"</span>;</span><br><span class="line">        mWebView.loadUrl(url);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到，如果想要和JS交互，那么<code>mWebView.getSettings().setJavaScriptEnabled(true);</code>这句是必不可少的，再看到下面一行代码：<code>mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);</code>，这里注意一下第二个参数，没错，就是在 html 中的 testJS ！</p>
<p>再看回第一个参数，发现 new 了一个 AndroidJSInterface 类，下面就是 AndroidJSInterface 的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidJSInterface</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Context context;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidJSInterface</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.context = context;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">goActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        context.startActivity(<span class="keyword">new</span> Intent(context, SecondActivity.class));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@JavascriptInterface</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showToast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context, <span class="string">"hello js"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到上面的<code>showToast()</code>和<code>goActivity()</code>方法名和 html 里面的一定要一样，不然无法触发了。然后在方法的内部实现你想要的逻辑。</p>
<p>经过上面的步骤，就可以实现和JS交互了，一起来看看效果吧：</p>
<p><img src="/uploads/20160307/20160307225743.gif" alt="这里写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160307/WebViewDemo.rar">WebViewDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="WebView" scheme="http://yuqirong.me/tags/WebView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
</feed>
