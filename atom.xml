<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[blog for yuqirong]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-03-02T11:34:38.470Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[在AlertDialog中EditText无法弹出键盘的解决方案]]></title>
    <link href="http://yuqirong.me/2016/02/06/%E5%9C%A8AlertDialog%E4%B8%ADEditText%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yuqirong.me/2016/02/06/在AlertDialog中EditText无法弹出键盘的解决方案/</id>
    <published>2016-02-06T06:54:11.000Z</published>
    <updated>2016-03-02T11:34:38.470Z</updated>
    <content type="html"><![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这个问题。这次算是填了一个隐藏的坑。</p>
<p>例如下面给出了一个例子，首先贴上AlertDialog的<code>layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;200dp&quot;
    android:background=&quot;@android:color/white&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello friend!&quot;/&gt;

    &lt;EditText
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:hint=&quot;input content&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;submit&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>AlertDialog的效果图是这样的：</p>
<p><img src="/uploads/20160206/20160206160310.png" alt="这里填写图片的描述"></p>
<p>我们会发现无论怎么点击EditText也无法弹出键盘，其实我们只要加上<code>alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</code>这一句，就可以让键盘弹出了。</p>
<p><img src="/uploads/20160206/20160206161311.png" alt="这里填写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160206/AlertDialogDemo.rar">AlertDialogDemo.rar</a></p>
<p>StackOverFlow：</p>
<p><a href="http://stackoverflow.com/questions/9102074/android-edittext-in-dialog-doesnt-pull-up-soft-keyboard" target="_blank" rel="external">Android: EditText in Dialog doesn’t pull up soft keyboard</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对LayoutInflater的深入解析]]></title>
    <link href="http://yuqirong.me/2016/02/03/%E5%AF%B9LayoutInflater%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/02/03/对LayoutInflater的深入解析/</id>
    <published>2016-02-03T11:19:12.000Z</published>
    <updated>2016-03-02T11:28:20.568Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身影。比如说在Fragment的<code>onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</code>方法里，就需要我们返回Fragment的View。这时就可以用<code>inflater.inflate(R.layout.fragment_view, container, false)</code>来加载视图。那么下面就来探究一下LayoutInflater的真面目吧。</p>
<h1 id="from_28Context_context_29"><a href="#from_28Context_context_29" class="headerlink" title="from(Context context)"></a>from(Context context)</h1><p>首先我们在使用LayoutInflater时，通常用<code>LayoutInflater.from(Context context)</code>这个方法来得到其对象：</p>
<pre><code>/**
 * Obtains the LayoutInflater from the given context.
 */
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre><p>我们可以看到原来<code>from(Context context)</code>这个方法只不过把<code>context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</code>进行简单地封装了一下，方便开发者调用。相信大家都看得懂。</p>
<h1 id="inflate_28_u2026_29"><a href="#inflate_28_u2026_29" class="headerlink" title="inflate(…)"></a>inflate(…)</h1><p>在得到了LayoutInflater的对象之后，我们就要使用它的inflate()方法了。</p>
<p><img src="/uploads/20160203/20160203183605.png" alt="这里填写图片的描述"></p>
<p>可以看到inflate()有四个重载的方法。我们先来看看前三个的源码：</p>
<pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
    return inflate(resource, root, root != null);
}

public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}

public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre><p>看到这里，我们都明白了，前三个inflate()方法到最后都是调用了<code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>这个方法。原来第四个inflate()方法才是“幕后黑手”。那让我们来揭开它的黑纱吧：</p>
<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }

            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription()
                        + &quot;: No start tag found!&quot;);
            }

            final String name = parser.getName();

            if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot;
                        + name);
                System.out.println(&quot;**************************&quot;);
            }

            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                            + &quot;ViewGroup root and attachToRoot=true&quot;);
                }

                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(
                    parser.getPositionDescription()
                            + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don&apos;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return result;
    }
}
</code></pre><p>这段代码有点长，不过别担心，我们慢慢来看。首先把传入的<code>parser</code>进行解析，创建视图。其中我们可以注意到在Android的源码中是用Pull方式来解析xml得到视图的。接下来判断了传入的<code>root</code>是否为null，如果<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，<code>temp.setLayoutParams(params);</code>。也就是说把创建出来的视图的LayoutParams设置为params。那么params又是从哪里来的呢？可以在上面一行可以找到<code>params = root.generateLayoutParams(attrs);</code>我们来看看源码：</p>
<pre><code> public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new LayoutParams(getContext(), attrs);
}
</code></pre><p>也就是说，在<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，把<code>root</code>的LayoutParams设置给了新创建出来的View。</p>
<p>好了，再往下看，我们注意到了<code>root</code>不为null并且<code>attachToRoot</code>为true的情况。调用了<code>root.addView(temp, params);</code>，在其内部就是将temp添加进了root中。即最后得到的View的父布局就是root。</p>
<p>最后一个情况就是<code>(root == null || !attachToRoot)</code>时，直接返回了temp。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>到这里，关于LayoutInflater的讲解就差不多了，最后我们就来总结一下：</p>
<ul>
<li>在root!=null并且attachToRoot为false：将root的LayoutParams设置给了View。</li>
<li>在root!=null并且attachToRoot为true：把root作为View的父布局。</li>
<li>在root==null时：直接返回View，无视attachToRoot的状态。</li>
</ul>
<p>今天就到这，如有问题可以在下面留言。</p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义ViewGroup打造流式布局]]></title>
    <link href="http://yuqirong.me/2016/01/22/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%89%93%E9%80%A0%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yuqirong.me/2016/01/22/自定义ViewGroup打造流式布局/</id>
    <published>2016-01-22T12:31:37.000Z</published>
    <updated>2016-02-24T14:15:31.817Z</updated>
    <content type="html"><![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/38352503" target="_blank" rel="external">《Android 自定义ViewGroup 实战篇 -&gt; 实现FlowLayout》</a>，觉得文中的FlowLayout很多地方都可以用到。于是自己按照思路实现了一遍，这就是本片博文诞生的原因了。</p>
<p>首先流式布局相信大家都见到过，比如说下图中的京东热搜就是流式布局的应用。还有更多应用的地方在这里就不一一举例了。</p>
<p><img src="/uploads/20160222/20160222205447.png" alt="这里写图片描述"></p>
<p>下面我们就来看看是如何实现的。首先新建一个class，继承自ViewGroup。在<code>generateLayoutParams(AttributeSet attrs)</code>里直接返回MarginLayoutParams就行了。</p>
<pre><code> @Override
public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new MarginLayoutParams(getContext(), attrs);
}
</code></pre><p>然后就是<code>onLayout(boolean changed, int l, int t, int r, int b)</code>了，大部分的代码都添加了注释，相信大家都能看懂。</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int count = getChildCount();
    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    // 用来统计总宽度，初始值设为paddingLeft
    int lastWidth = getPaddingLeft();
    int lastHeight = getPaddingTop();

    for (int i = 0; i &lt; count; i++) {
        // 得到当前View
        View childView = getChildAt(i);
        // 测量得到当前View的宽度
        cWidth = childView.getMeasuredWidth();
        // 测量得到当前View的高度
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();
        // 宽度加上margin
        int width = cWidth + params.leftMargin + params.rightMargin;
        // 高度加上margin
        int height = cHeight + params.topMargin + params.bottomMargin;
        // 判断流式布局里的item总长度是否超过FlowLayout的宽度，如果是则需要换行  
        if (width + lastWidth &gt; r - getPaddingRight()) {
            // 如果超过，重置lastWidth
            lastWidth = getPaddingLeft();
            // lastHeight加上一个item的高度
            lastHeight += height;
        }
        // 给View布局
        childView.layout(lastWidth, lastHeight, lastWidth + cWidth, lastHeight + cHeight);
        //累加总宽度
        lastWidth += width;
    }
}
</code></pre><p>之后就是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);

    int totalWidth = getPaddingLeft() + getPaddingRight();
    int maxWidth = getPaddingLeft() + getPaddingRight();
    int maxHeight = getPaddingBottom() + getPaddingTop();
    int count = getChildCount();
    // 测量子view
    measureChildren(widthMeasureSpec, heightMeasureSpec);

    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    int width;
    int height;
    for (int i = 0; i &lt; count; i++) {
        View childView = getChildAt(i);
        cWidth = childView.getMeasuredWidth();
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();

        width = cWidth + params.leftMargin + params.rightMargin;
        height = cHeight + params.topMargin + params.bottomMargin;

        if (i == 0) {
            // 第一行时最大高度设为height
            maxHeight += height;
        }

        // 如果需要换行
        if (width + totalWidth &gt; widthSize) {
            // 得到最大的值作为setMeasuredDimension()的宽度
            maxWidth = Math.max(maxWidth, totalWidth);
            totalWidth = getPaddingLeft() + getPaddingRight();
            totalWidth += width;
            // 高度就是累加到最后
            maxHeight += height;
        } else {
            // 不换行就总长度累加
            totalWidth += width;
        }
        Log.i(TAG, &quot;i = &quot; + i + &quot;, width = &quot; + width + &quot;, totalWidth = &quot; + totalWidth + &quot;, widthSize = &quot; + widthSize + ((TextView) childView).getText());
        Log.i(TAG, &quot;height = &quot; + height);
        Log.i(TAG, &quot;i = &quot; + i + &quot;, maxHeight = &quot; + maxHeight);

    }
    // 设置宽高度
    setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? widthSize : maxWidth,
            heightMode == MeasureSpec.EXACTLY ? heightSize : maxHeight);

}
</code></pre><p>在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>中，如果测量模式是MeasureSpec.EXACTLY，则直接设置测量出来的宽和高；否则需要测量每个子View，根据item的行数来得到宽和高。</p>
<p>这样，FlowLayout就写好了，那就让我们来看看效果吧。当<code>android:layout_width=&quot;wrap_content&quot;</code>时</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220305.png" alt="这里写图片描述"></p>
<p>当<code>android:layout_width=&quot;300dp&quot;</code>时：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;哈尔滨&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;呼和浩特&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220718.png" alt="这里写图片描述"></p>
<p>最后，提供源码下载：</p>
<p><a href="/uploads/20160222/FlowLayout.rar">FlowLayout.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现导航Tab栏悬浮功能之改进版]]></title>
    <link href="http://yuqirong.me/2016/01/14/%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>http://yuqirong.me/2016/01/14/实现导航Tab栏悬浮功能之改进版/</id>
    <published>2016-01-14T12:34:25.000Z</published>
    <updated>2016-02-24T14:16:17.719Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/">《轻松实现app中的导航Tab栏悬浮功能》</a>。</p>
<p>当然，用WindowManager来实现由一个缺点就是当没有显示悬浮窗的权限时，该功能就无法体现出来。而在本篇博文中，我们用第二种方法，也就是不断地重新设置Tab栏的布局位置来实现悬浮功能，弥补了第一种方法的缺点。效果图这里就不放了，相信大家都看过啦。</p>
<p>不废话了，直接上代码。</p>
<p>activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;55dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>我们发现在activity_main.xml里Tab栏悬浮窗的布局放在了最后，这是因为当悬浮窗悬浮在顶部时，应该在所有的UI控件上方，所以在xml里放在了最后。</p>
<p>接下来看看MainActivity：</p>
<pre><code>public class MainActivity extends AppCompatActivity implements MyScrollView.OnScrollListener {

    private static final String TAG = &quot;MainActivity&quot;;
    private MyScrollView mScrollView;
    private LinearLayout ll_tab;
    private ImageView iv_pic;
    private int picBottom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getSupportActionBar().hide();
        mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
        mScrollView.setOnScrollListener(this);
        ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
        iv_pic = (ImageView) findViewById(R.id.iv_pic);
        findViewById(R.id.ll_main).getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                onScroll(mScrollView.getScrollY());
            }
        });
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            picBottom = iv_pic.getBottom();
        }
    }

    @Override
    public void onScroll(int scrollY) {
        int top = Math.max(scrollY, picBottom);
        ll_tab.layout(0, top, ll_tab.getWidth(), top + ll_tab.getHeight());
    }

}
</code></pre><p>我们惊奇地发现在Activity里的代码竟然这么短！但是这是这么短，实现了一模一样的功能。</p>
<p>首先在父布局中添加了OnGlobalLayoutListener，以便当布局的状态或者控件的可见性改变时去重新设置Tab栏的布局。之后在<code>onWindowFocusChanged(boolean hasFocus)</code>里得到<code>iv_pic.getBottom()</code>的值，也就是<code>iv_pic</code>的高度。也就是说你一开始想把<code>ll_tab</code>布局在<code>iv_pic</code>的下面。因此可以当作Tab栏距离ScrollView顶部的距离。</p>
<p>最后在<code>onScroll(int scrollY)</code>中比较scrollY，picBottom的最大值。当<code>scrollY&lt;picBottom</code>时，<code>ll_tab</code>会跟随ScrollView的滑动而滑动；当<code>scrollY&gt;picBottom</code>时，<code>ll_tab</code>布局的顶部的坐标始终是ScrollView的滑动距离，这样就造成了<code>ll_tab</code>悬浮在顶部的“假象”。</p>
<p>好了，一起来看看效果吧：</p>
<p><img src="/uploads/20160114/20160114223247.gif" alt="这里填写图片的描述"></p>
<p>是不是和第一种方法的效果一样呢，相信大家都学会了。如果有问题可以在下面留言。</p>
<p>最后，放出源码：</p>
<p><a href="/uploads/20160114/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻松实现app中的导航Tab栏悬浮功能]]></title>
    <link href="http://yuqirong.me/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/"/>
    <id>http://yuqirong.me/2016/01/12/轻松实现app中的导航Tab栏悬浮功能/</id>
    <published>2016-01-12T13:59:29.000Z</published>
    <updated>2016-02-22T12:45:22.651Z</updated>
    <content type="html"><![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160112/20160112210653.gif" alt="这里填写图片的描述"></p>
<p>可以看到上图中的“分类”、“排序”、“筛选”会悬浮在app的顶部，状态随着ScrollView(也可能不是ScrollView，在这里姑且把这滑动的UI控件当作ScrollView吧)的滚动而变化。像这种导航Tab栏悬浮的作用相信大家都能体会到，Tab栏不会随着ScrollView等的滚动而被滑出屏幕外，增加了与用户之间的交互性和方便性。</p>
<p>看到上面的效果，相信大家都跃跃欲试了，那就让我们开始吧。</p>
<p>首先大家要明白一点：Tab栏的状态变化是要监听ScrollView滑动距离的。至于如何得到ScrollView的滑动距离？可以看看我的一篇Tip：<a href="/2015/10/19/给你的ScrollView设置滑动距离监听器/">《给你的ScrollView设置滑动距离监听器》</a>，这里就不过多叙述了。</p>
<p>好了，根据上面的就得到了对ScrollView滑动的监听了。接下来要思考的问题就是如何让Tab栏实现悬浮的效果呢？这里给出的方法有两种，第一种就是使用WindowManager来动态地添加一个View悬浮在顶部；第二种就是随着ScrollView的滑动不断重新设置Tab栏的布局位置。</p>
<p>我们先来看看第一种实现方法，首先是xml布局了。</p>
<p>Activity的布局，activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>Tab栏的布局，tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面布局中的很多空白LinearLayout主要是拉长ScrollView，效果图就是这样的：</p>
<p><img src="/uploads/20160112/20160112201753.png" alt="这里填写图片的描述"></p>
<p>然后我们来看看<code>onCreate(Bundle savedInstanceState)</code>：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    setContentView(R.layout.activity_main);
    mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
    mScrollView.setOnScrollListener(this);
    ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
    windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
}
</code></pre><p>我们先在<code>onCreate(Bundle savedInstanceState)</code>中给ScrollView添加了滑动距离监听器以及得到了一个windowManager的对象。还有一点需要注意的是：我们调用了<code>getSupportActionBar().hide();</code>去掉了标题栏(MainActivity继承了AppCompatActivity)。这是因为标题栏的存在导致了在计算悬浮窗y轴的值时要额外加上标题栏的高度(当然你也可以保留标题栏，然后计算时再加上标题栏的高度^_^!)。</p>
<p>然后在onWindowFocusChanged(boolean hasFocus)得到Tab栏的高度、getTop()值等，以便下面备用。如果你对getLeft()、getTop()、getRight()和getBottom()还不了解的话，可以看看我的另一篇Tip： <a href="/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/">《对view的getLeft()、getTop()等的笔记》</a>。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        tabHeight = ll_tab.getHeight();
        tabTop = ll_tab.getTop();
        scrollTop = mScrollView.getTop();
    }
}
</code></pre><p>之后在滑动监听器的回调方法<code>onScroll(int scrollY)</code>中来控制显示还是隐藏悬浮窗。</p>
<pre><code> @Override
public void onScroll(int scrollY) {
    Log.i(TAG, &quot;scrollY = &quot; + scrollY + &quot;, tabTop = &quot; + tabTop);
    if (scrollY &gt; tabTop) {
        // 如果没显示
        if (!isShowWindow) {
            showWindow();
        }
    } else {
        // 如果显示了
        if (isShowWindow) {
            removeWindow();
        }
    }
}
</code></pre><p>上面的代码比较简单，不用我过多叙述了。下面是removeWindow()、showWindow()两个方法：</p>
<pre><code>// 显示window
private void removeWindow() {
    if (ll_tab_temp != null)
        windowManager.removeView(ll_tab_temp);
    isShowWindow = false;
}

// 移除window
private void showWindow() {
    if (ll_tab_temp == null) {
        ll_tab_temp = LayoutInflater.from(this).inflate(R.layout.tab_layout, null);
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE; //悬浮窗的类型，一般设为2002，表示在所有应用程序之上，但在状态栏之下
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.gravity = Gravity.TOP;  //悬浮窗的对齐方式
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.height = tabHeight;
        layoutParams.x = 0;  //悬浮窗X的位置
        layoutParams.y = scrollTop;  //悬浮窗Y的位置
    }
    windowManager.addView(ll_tab_temp, layoutParams);
    isShowWindow = true;
}
</code></pre><p>这两个方法也很简单，而且有注释，相信大家可以看懂。</p>
<p>最后，不要忘了在AndroidManifest.xml里申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
</code></pre><p>到这里，整体的代码就这些了。一起来看看效果吧：</p>
<p><img src="/uploads/20160112/20160112204356.gif" alt="这里填写图片的描述"></p>
<p>但是用这种方法来实现Tab栏悬浮功能有一个缺点，那就是如果该app没有被赋予显示悬浮窗的权限，那么该功能就变成鸡肋了。当然还有第二种方法来实现，不过只能等到下一篇博文再讲了。</p>
<p>本Demo源码下载：</p>
<p><a href="/uploads/20160112/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对view的getLeft()、getTop()等的笔记]]></title>
    <link href="http://yuqirong.me/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/01/05/对view的getLeft()、getTop()等的笔记/</id>
    <published>2016-01-05T12:01:48.000Z</published>
    <updated>2016-02-19T14:24:47.890Z</updated>
    <content type="html"><![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;


    &lt;LinearLayout
        android:id=&quot;@+id/ll_01&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_green_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_01&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第一行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/ll_02&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_blue_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_02&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第二行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面是一个很简单的布局，UI效果图如下：</p>
<p><img src="/uploads/20160105/20160105202531.png" alt="这里填写图片的描述"></p>
<p>当我们用<code>tv_01.getTop()</code>的时候，得到的返回值是0，符合我的想象。但是用<code>tv_02.getTop()</code>，得到的值也为0。而我原以为<code>tv_02.getTop()</code>的值为<code>ll_01</code>的高度，也就是<code>tv_02</code>距离屏幕顶部的长度。但是结果和我的想象不一致。</p>
<p>后来我才知道原来<code>getTop()</code>方法返回的是该view距离<strong>父容器顶部</strong>的距离，所以理所应当<code>tv_02.getTop()</code>距离<code>ll_02</code>顶部的距离也为0了，同样的<code>getLeft()</code>、<code>getBottom()</code>、<code>getRight()</code>也是一个道理，以此类推。</p>
<p>那么问题来了，如何按我之前的想法一样，得到<code>tv_02</code>距离<strong>屏幕顶部</strong>的值呢？很简单，我们只要<code>tv_02.getTop() + ll_02.getTop()</code>就好了。相信聪明的你已经懂了。</p>
<p>看来在开发中还有不少的细节需要我们注意，特此一记。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml versi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见2015，你好2016]]></title>
    <link href="http://yuqirong.me/2016/01/01/%E5%86%8D%E8%A7%812015%EF%BC%8C%E4%BD%A0%E5%A5%BD2016/"/>
    <id>http://yuqirong.me/2016/01/01/再见2015，你好2016/</id>
    <published>2016-01-01T12:54:54.000Z</published>
    <updated>2016-02-19T14:15:29.787Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>转眼间2015年悄然流走，而2016年已经来临。蓦然回首，在2015年里经历了太多。</p>
<p>在这短短的一年里，得到了很多，同时也失去了很多。</p>
<h1 id="u518D_u89C12015"><a href="#u518D_u89C12015" class="headerlink" title="再见2015"></a>再见2015</h1><p>2015，完成了我从大三到大四的转变，同时也是抉择人生道路的重要时刻。和其他人一样，在考研和就业的分叉路上也纠结了很久。但是在2015年里，努力地学习编程，幻想着有一天能够成为大牛，这似乎离考研的路越走越远。</p>
<p>细细回想似乎写程序也已经满一年多了，从一开始的Java到现在的Android，这中间也弯弯曲曲地走了不少的弯路。还记得刚开始学习Android时，对于一切知识都急于求成，但却似乎忘了基础；以为自己什么都懂，其实只是一只“纸老虎”。最关键的是，把心慢下来，一点一滴积累才是正道，学习的路上没有捷径。</p>
<h1 id="u4F60_u597D2016"><a href="#u4F60_u597D2016" class="headerlink" title="你好2016"></a>你好2016</h1><p>至于2016的到来，真的是“手足无措”。时间总是在不经意间流逝，而当你幡然醒悟时，只能扼腕叹息。其实更重要的是，在2016年的6月，我们要毕业了。离开同学，离开老师，离开校园。这其中纵然有千万缕不舍，但是人终究要面临着成长。之前从没想象过毕业，总以为离我们很遥远，但其实却很近。我们都已经习惯了在校园里慵懒的生活，闲暇之余可以和同学之间玩玩游戏，在草地上晒晒太阳，在图书馆安静地看看书。而这一切在2016都要发生重大的转变，这似乎就是我不愿意2016到来的原因了。</p>
<p>人们总是在展望未来，却忘了把握当下。最无厘头的一句话“我在2016年的新年目标就是完成2015年那些本该在2014年完成的我在2013年就信誓旦旦要完成的2012年制定的目标…”。当然希望每个人都要脚踏实地，认认真真地完成自己订下的目标。也希望自己在新的一年里积累更多的知识，技术节节高升，早日走向人生的巅峰。</p>
<p>最后，献上一首《同学的你》，纪念即将告别的校园生活。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28387594&auto=1&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" ti]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现水波纹动画，让你的app不再单调]]></title>
    <link href="http://yuqirong.me/2015/12/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%B0%B4%E6%B3%A2%E7%BA%B9%E5%8A%A8%E7%94%BB%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84app%E4%B8%8D%E5%86%8D%E5%8D%95%E8%B0%83/"/>
    <id>http://yuqirong.me/2015/12/27/自定义实现水波纹动画，让你的app不再单调/</id>
    <published>2015-12-27T15:05:17.000Z</published>
    <updated>2016-02-21T14:21:00.308Z</updated>
    <content type="html"><![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效果怎样，我们一起来看看：</p>
<p><img src="/uploads/20151227/20151227231546.gif" alt="这里填写图片描述"></p>
<p>是不是觉得有新意多了呢？那就一起来看看吧，先简单讲述一下思路：首先波浪的形状主要是根据三角函数决定的。三角函数相信大家在中学的课程中学习过吧。通用公式就是f(x)=Asin(ωx+φ) + b。其中A就是波浪的振幅，ω与时间周期有关，x就是屏幕宽度的像素点，φ是初相，可以让波浪产生偏移，最后的b就是水位的高度了。最后根据这公式算出y坐标，用<code>canvas.drawLine(startX, startY, stopX, stopY, paint);</code>来画出竖直的线条，这样就形成了波浪。</p>
<p>整体的思路就如下面示意图所示，当红色的线条间距越来越小，密度越来越大时就形成了波浪：</p>
<p><img src="/uploads/20151227/20151227230103.png" alt="这里填写图片描述"></p>
<p>讲完了思路，那下面我们就来分析一下代码吧。</p>
<p>首先看一下“自定义View三部曲”中的第一部，自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

    &lt;declare-styleable name=&quot;WaveView&quot;&gt;
        &lt;attr name=&quot;waveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;secondWaveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;waveHeight&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;

&lt;/resources&gt;
</code></pre><p>我们先定义了三个属性，分别是前波浪颜色、后波浪颜色以及波浪的振幅高度。</p>
<p>然后就是在构造器中初始化自定义的属性。</p>
<pre><code>public WaveView(Context context) {
    this(context, null);
}

public WaveView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public WaveView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.WaveView);
    defaultWaveColor = getResources().getColor(R.color.indigo_color);
    waveColor = a.getColor(R.styleable.WaveView_waveColor, defaultWaveColor);
    defaultSecondWaveColor = getResources().getColor(R.color.second_indigo_color);
    secondWaveColor = a.getColor(R.styleable.WaveView_secondWaveColor, defaultSecondWaveColor);
    defaultWaveHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, getResources().getDisplayMetrics());
    waveHeight = a.getDimension(R.styleable.WaveView_waveHeight, defaultWaveHeight);
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
}
</code></pre><p>前面的代码很简单，接下来要重写<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>:</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    this.w = (float) (Math.PI * 2 / w);
}
</code></pre><p>这里的w就是上面f(x)=Asin(ωx+φ) + b公式中的ω，而ω=2π/T。也就是说周期就是屏幕宽度。所以在一个屏幕内正好可以显示出正弦函数的一个周期。</p>
<p>下面就是三部曲的第二部：重写<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 200;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 200;
    }
    setMeasuredDimension(mWidth, mHeight);
}
</code></pre><p>onMeasure()中就是测量了View的宽高度，如果不是MeasureSpec.EXACTLY的模式就直接赋值200(这里没有把200px转化为200dp,偷懒了ㄟ(▔ ,▔)ㄏ)。相信大家都会了。</p>
<p>最后就是<code>onDraw(Canvas canvas)</code>，也就是三部曲中的最后一部：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 水位的高度
    waterHeight = waterHeight + 10;
    // 正弦函数y的坐标
    float startY;
    canvas.save();

    if (System.currentTimeMillis() - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    double temp = Math.toDegrees(speed);
    speed++;

    // 先绘制第二条波浪
    mPaint.setColor(secondWaveColor);
    // 遍历每个像素点，并在竖直上画线
    for (int i = 0; i &lt; mWidth; i++) {
        // 和第一条波浪相比产生的偏移量为8,至于偏移量大小可以自己决定
        startY = (float) (waveHeight * Math.sin(w * i + temp + 8) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }

    // 再绘制第一条波浪
    mPaint.setColor(waveColor);
    for (int i = 0; i &lt; mWidth; i++) {
        startY = (float) (waveHeight * Math.sin(w * i + temp) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }
    Log.i(TAG, &quot;waterHeight : &quot; + waterHeight);
    canvas.restore();
    // 不断重绘
    invalidate();
    startTime = System.currentTimeMillis();
}
</code></pre><p>在<code>onDraw(Canvas canvas)</code>的一开始waterHeight不断自增，以此来实现水位不断上涨的效果，然后就是线程的休眠来控制绘制的频率。之后在绘制第二条波浪时初相加上一个偏移量，这样就可以与第一条波浪形成交错的效果。整体代码并不复杂，主要是坐标上的计算。</p>
<p>到这里基本就讲得差不多了，以下是本案例的源码：</p>
<p><a href="/uploads/20151227/WaveView.rar">WaveView.rar</a></p>
<p>最后，预祝大家元旦快乐！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让你的ListView更炫酷，实现侧滑删除效果]]></title>
    <link href="http://yuqirong.me/2015/12/13/%E8%AE%A9%E4%BD%A0%E7%9A%84ListView%E6%9B%B4%E7%82%AB%E9%85%B7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2015/12/13/让你的ListView更炫酷，实现侧滑删除效果/</id>
    <published>2015-12-13T15:54:48.000Z</published>
    <updated>2016-03-02T08:51:02.245Z</updated>
    <content type="html"><![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接一下之前写的博文使用ViewDragHelper来实现侧滑菜单的，<a href="/2015/11/04/史上最简单粗暴实现侧滑菜单/">点击此处跳转</a>。如果你对ViewDragHelper不熟悉，你可以去看看<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">《Android ViewDragHelper完全解析 自定义ViewGroup神器》</a>。</p>
<p>好了，话说的那么多，先来看看我们实现的效果图吧：</p>
<p><img src="/uploads/20151213/20151213140251.gif" alt="这里填写图片描述"></p>
<p>可以看出来，我们实现的和QQ的效果相差无几。下面就是源码时间了。</p>
<p>先来看一下ListView的item的<code>slip_item_layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.swipelistview.view.SwipeListLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/sll_main&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;TextView
            android:id=&quot;@+id/tv_top&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#66ff0000&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;置顶&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_delete&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#330000ff&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;删除&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:background=&quot;#66ffffff&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;ImageView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_margin=&quot;10dp&quot;
            android:src=&quot;@drawable/head_1&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_name&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:gravity=&quot;center_vertical&quot;
            android:text=&quot;hello&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/com.yuqirong.swipelistview.view.SwipeListLayout&gt;
</code></pre><p>我们可以看出，要先把侧滑出的按钮布局放在SwipeListLayout的第一层，而item的布局放在第二层。还有一点要注意的是，侧滑出的按钮如果有两个或两个以上，那么必须用ViewGroup作为父布局。要整体保持SwipeListLayout的直接子View为2个。</p>
<p>而activity的布局文件里就是一个ListView，这里就不再给出了。</p>
<p>下面我们直接来看看SwipeListLayout的内容：</p>
<pre><code>public SwipeListLayout(Context context) {
    this(context, null);
}

public SwipeListLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
    mDragHelper = ViewDragHelper.create(this, callback);
}

// ViewDragHelper的回调
Callback callback = new Callback() {

    @Override
    public boolean tryCaptureView(View view, int arg1) {
        return view == itemView;
    }

    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == itemView) {
            if (left &gt; 0) {
                return 0;
            } else {
                left = Math.max(left, -hiddenViewWidth);
                return left;
            }
        }
        return 0;
    }

    @Override
    public int getViewHorizontalDragRange(View child) {
        return hiddenViewWidth;
    }

    @Override
    public void onViewPositionChanged(View changedView, int left, int top,
            int dx, int dy) {
        if (itemView == changedView) {
            hiddenView.offsetLeftAndRight(dx);
        }
        // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
        // 为了确保绘制成功 调用 invalidate
        invalidate();
    }

    public void onViewReleased(View releasedChild, float xvel, float yvel) {
        // 向右滑xvel为正 向左滑xvel为负
        if (releasedChild == itemView) {
            if (xvel == 0
                    &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                open(smooth);
            } else if (xvel &lt; 0) {
                open(smooth);
            } else {
                close(smooth);
            }
        }
    }

};
</code></pre><p>我们主要来看callback，首先在<code>tryCaptureView(View view, int arg1)</code>里设置了只有是itemView的时候才能被捕获，也就是说当你去滑动“删除”、“置顶”等按钮的时候，侧滑按钮是不会被关闭的，因为根本就没捕获。(当然你也可以设置都捕获，那样的话下面的逻辑要调整了)，剩余的几个函数中的逻辑较为简单，在<code>onView
Released(View releasedChild, float xvel, float yvel)</code>也是判断了当手指抬起时itemView所处的位置。如果向左滑或者停止滑动时按钮已经显示出1/2的宽度，则打开；其余情况下都将关闭按钮。</p>
<p>以下分别是close()和open()的方法：</p>
<pre><code>/**
 * 侧滑关闭
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void close(boolean smooth) {
    preStatus = status;
    status = Status.Close;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start close animation&quot;);
                listener.onStartCloseAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Open) {
        Log.i(TAG, &quot;close&quot;);
        listener.onStatusChanged(status);
    }
}

/**
 * 侧滑打开
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void open(boolean smooth) {
    preStatus = status;
    status = Status.Open;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start open animation&quot;);
                listener.onStartOpenAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Close) {
        Log.i(TAG, &quot;open&quot;);
        listener.onStatusChanged(status);
    }
}
</code></pre><p>SwipeListLayout大致的代码就这些，相信对于熟悉ViewDragHelper的同学们来说应该是不成问题的。其实整体的逻辑和之前用ViewDragHelper来实现侧滑菜单大同小异。</p>
<p>顺便下面贴出SwipeListLayout的全部代码：</p>
<pre><code>/**
 * 侧滑Layout
 */
public class SwipeListLayout extends FrameLayout {

    private View hiddenView;
    private View itemView;
    private int hiddenViewWidth;
    private ViewDragHelper mDragHelper;
    private int hiddenViewHeight;
    private int itemWidth;
    private int itemHeight;
    private OnSwipeStatusListener listener;
    private Status status = Status.Close;
    private boolean smooth = true;

    public static final String TAG = &quot;SlipListLayout&quot;;

    // 状态
    public enum Status {
        Open, Close
    }

    /**
     * 设置侧滑状态
     * 
     * @param status
     *            状态 Open or Close
     * @param smooth
     *            若为true则有过渡动画，否则没有
     */
    public void setStatus(Status status, boolean smooth) {
        this.status = status;
        if (status == Status.Open) {
            open(smooth);
        } else {
            close(smooth);
        }
    }

    public void setOnSwipeStatusListener(OnSwipeStatusListener listener) {
        this.listener = listener;
    }

    /**
     * 是否设置过渡动画
     * 
     * @param smooth
     */
    public void setSmooth(boolean smooth) {
        this.smooth = smooth;
    }

    public interface OnSwipeStatusListener {

        /**
         * 当状态改变时回调
         * 
         * @param status
         */
        void onStatusChanged(Status status);

        /**
         * 开始执行Open动画
         */
        void onStartCloseAnimation();

        /**
         * 开始执行Close动画
         */
        void onStartOpenAnimation();

    }

    public SwipeListLayout(Context context) {
        this(context, null);
    }

    public SwipeListLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDragHelper = ViewDragHelper.create(this, callback);
    }

    // ViewDragHelper的回调
    Callback callback = new Callback() {

        @Override
        public boolean tryCaptureView(View view, int arg1) {
            return view == itemView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            if (child == itemView) {
                if (left &gt; 0) {
                    return 0;
                } else {
                    left = Math.max(left, -hiddenViewWidth);
                    return left;
                }
            }
            return 0;
        }

        @Override
        public int getViewHorizontalDragRange(View child) {
            return hiddenViewWidth;
        }

        @Override
        public void onViewPositionChanged(View changedView, int left, int top,
                int dx, int dy) {
            if (itemView == changedView) {
                hiddenView.offsetLeftAndRight(dx);
            }
            // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
            // 为了确保绘制成功 调用 invalidate
            invalidate();
        }

        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            // 向右滑xvel为正 向左滑xvel为负
            if (releasedChild == itemView) {
                if (xvel == 0
                        &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                    open(smooth);
                } else if (xvel &lt; 0) {
                    open(smooth);
                } else {
                    close(smooth);
                }
            }
        }

    };
    private Status preStatus = Status.Close;

    /**
     * 侧滑关闭
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void close(boolean smooth) {
        preStatus = status;
        status = Status.Close;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start close animation&quot;);
                    listener.onStartCloseAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Open) {
            Log.i(TAG, &quot;close&quot;);
            listener.onStatusChanged(status);
        }
    }

    /**
     * 
     * @param status
     */
    private void layout(Status status) {
        if (status == Status.Close) {
            hiddenView.layout(itemWidth, 0, itemWidth + hiddenViewWidth,
                    itemHeight);
            itemView.layout(0, 0, itemWidth, itemHeight);
        } else {
            hiddenView.layout(itemWidth - hiddenViewWidth, 0, itemWidth,
                    itemHeight);
            itemView.layout(-hiddenViewWidth, 0, itemWidth - hiddenViewWidth,
                    itemHeight);
        }
    }

    /**
     * 侧滑打开
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void open(boolean smooth) {
        preStatus = status;
        status = Status.Open;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start open animation&quot;);
                    listener.onStartOpenAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Close) {
            Log.i(TAG, &quot;open&quot;);
            listener.onStatusChanged(status);
        }
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        // 开始执行动画
        if (mDragHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        final int action = ev.getAction();
        if (action == MotionEvent.ACTION_CANCEL) {
            mDragHelper.cancel();
            return false;
        }
        return mDragHelper.shouldInterceptTouchEvent(ev);
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onTouchEvent(MotionEvent event) {
        mDragHelper.processTouchEvent(event);
        return true;
    };

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        hiddenView = getChildAt(0); // 得到隐藏按钮的linearlayout
        itemView = getChildAt(1); // 得到最上层的linearlayout
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        // 测量子View的长和宽
        itemWidth = itemView.getMeasuredWidth();
        itemHeight = itemView.getMeasuredHeight();
        hiddenViewWidth = hiddenView.getMeasuredWidth();
        hiddenViewHeight = hiddenView.getMeasuredHeight();
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right,
            int bottom) {
        layout(Status.Close);
    }

}
</code></pre><p>最后，提供SwipeListLayout的源码下载：</p>
<p><a href="/uploads/20151213/SwipeListView.rar">SwipeListView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/SwipeListView" target="_blank" rel="external">SwipeListView</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现炫酷的CheckBox，就这么简单]]></title>
    <link href="http://yuqirong.me/2015/12/05/%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84CheckBox%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://yuqirong.me/2015/12/05/实现炫酷的CheckBox，就这么简单/</id>
    <published>2015-12-05T15:10:32.000Z</published>
    <updated>2016-03-02T08:52:24.219Z</updated>
    <content type="html"><![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andyxialm/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a>，它的效果预览触动到我了，于是趁着今天有空就试着自己写一写。尽管效果可能不如SmoothCheckBox那样动感，但是基本的效果还是实现了。按照惯例，下面就贴出我写的CheckBox的gif： </p>
<p><img src="/uploads/20151205/20151205234652.gif" alt="这里写图片描述"></p>
<p>gif的效果可能有点过快，在真机上运行的效果会更好一些。我们主要的思路就是利用属性动画来动态地画出选中状态以及对勾的绘制过程。看到上面的效果图，相信大家都迫不及待地要跃跃欲试了，那就让我们开始吧。</p>
<p>自定义View的第一步：自定义属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;SmoothCheckBox&quot;&gt;
        &lt;!-- 动画持续时间 --&gt;
        &lt;attr name=&quot;duration&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框宽度 --&gt;
        &lt;attr name=&quot;strikeWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框颜色 --&gt;
        &lt;attr name=&quot;borderColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 选中状态的颜色 --&gt;
        &lt;attr name=&quot;trimColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾颜色 --&gt;
        &lt;attr name=&quot;tickColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾宽度 --&gt;
        &lt;attr name=&quot;tickWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>我们把CheckBox取名为SmoothCheckBox(没办法(⊙﹏⊙)，这名字挺好听的)，定义了几个等等要用到的属性。这一步很简单，相信大家都熟练了。</p>
<p>接下来看一看<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>:</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 40;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 40;
    }
    setMeasuredDimension(mWidth, mHeight);
    int size = Math.min(mWidth, mHeight);
    center = size / 2;
    mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
    startPoint.set(center * 14 / 30, center * 28 / 30);
    breakPoint.set(center * 26 / 30, center * 40 / 30);
    endPoint.set(center * 44 / 30, center * 20 / 30);

    downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
    upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
    totalLength = downLength + upLength;
}
</code></pre><p>一开始是测量了SmoothCheckBox的宽、高度，默认的宽高度随便定义了一个，当然你们可以自己去修改和完善它。然后就是设置半径之类的，最后的startPoint、breakPoint、endPoint分别对应着选中时对勾的三个点(至于为何是这几个数字，那完全是经验值);downLength就是startPoint和breakPoint的距离，而相对应的upLength就是breakPoint和endPoint的距离。即以下图示：</p>
<p><img src="/uploads/20151205/20151205000130.png" alt="这里写图片描述"></p>
<p>在看<code>onDraw(Canvas canvas)</code>之前我们先来看两组动画，分别是选中状态时的动画以及未选中状态的动画：</p>
<pre><code> // 由未选中到选中的动画
private void checkedAnimation() {
    animatedValue = 0f;
    tickValue = 0f;
    // 选中时底色的动画
    mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    // 对勾的动画
    mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
    mTickValueAnimator.setInterpolator(new LinearInterpolator());
    mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            tickValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            //当底色的动画完成后再开始对勾的动画
            mTickValueAnimator.start();
            Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
        }
    });
    mValueAnimator.start();
}

// 由选中到未选中的动画
private void uncheckedAnimation() {
    animatedValue = 0f;
    mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateInterpolator());
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.start();
}
</code></pre><p>这两组动画在点击SmoothCheckBox的时候会调用。相似的，都是在动画执行中得到动画执行的进度，再来调用<code>postInvalidate();</code>让SmoothCheckBox重绘。看完这个之后就是终极大招<code>onDraw(Canvas canvas)</code>了:</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    drawBorder(canvas);
    drawTrim(canvas);
    if (isChecked) {
        drawTick(canvas);
    }
    canvas.restore();
}

// 画对勾
private void drawTick(Canvas canvas) {
    // 得到画对勾的进度
    float temp = tickValue * totalLength;
    Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
    //判断是否是刚开始画对勾的时候,即等于startPoint
    if (Float.compare(tickValue, 0f) == 0) {
        Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
        path.reset();
        path.moveTo(startPoint.x, startPoint.y);
    }
    // 如果画对勾的进度已经超过breakPoint的时候,即(breakPoint,endPoint]
    if (temp &gt; downLength) {
        path.moveTo(startPoint.x, startPoint.y);
        path.lineTo(breakPoint.x, breakPoint.y);
        Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
        path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
    } else {
        //画对勾的进度介于startPoinit和breakPoint之间，即(startPoint,breakPoint]
        Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
        path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
    }
    canvas.drawPath(path, tickPaint);
}

// 画边框
private void drawBorder(Canvas canvas) {
    float temp;
    // 通过animatedValue让边框产生一个“OverShooting”的动画
    if (animatedValue &gt; 1f) {
        temp = animatedValue * mRadius;
    } else {
        temp = mRadius;
    }
    canvas.drawCircle(center, center, temp, borderPaint);
}

// 画checkbox内部
private void drawTrim(Canvas canvas) {
    canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
}
</code></pre><p><code>onDraw(Canvas canvas)</code>代码中的逻辑基本都加了注释，主要就是原理搞懂了就比较简单了。在绘制对勾时要区分当前处于绘制对勾的哪种状态，然后对应做处理画出线条，剩下的就简单了。关于SmoothCheckBox的讲解到这里就差不多了。</p>
<p>下面就贴出SmoothCheckBox的完整代码：</p>
<pre><code>public class SmoothCheckBox extends View implements View.OnClickListener {

    // 动画持续时间
    private long duration;
    // 边框宽度
    private float mStrokeWidth;
    // 对勾宽度
    private float mTickWidth;
    // 内饰画笔
    private Paint trimPaint;
    // 边框画笔
    private Paint borderPaint;
    // 对勾画笔
    private Paint tickPaint;
    // 默认边框宽度
    private float defaultStrikeWidth;
    // 默认对勾宽度
    private float defaultTickWidth;
    // 宽度
    private int mWidth;
    // 高度
    private int mHeight;
    // 边框颜色
    private int borderColor;
    // 内饰颜色
    private int trimColor;
    // 对勾颜色
    private int tickColor;
    // 半径
    private int mRadius;
    // 中心点
    private int center;
    // 是否是选中
    private boolean isChecked;
    //对勾向下的长度
    private float downLength;
    //对勾向上的长度
    private float upLength;
    // 对勾的总长度
    private float totalLength;
    // 监听器
    private OnCheckedChangeListener listener;

    private ValueAnimator mValueAnimator;

    private ValueAnimator mTickValueAnimator;

    private float animatedValue;

    private float tickValue;
    // 对勾开始点
    private Point startPoint = new Point();
    // 对勾转折点
    private Point breakPoint = new Point();
    // 对勾结束点
    private Point endPoint = new Point();

    private static final String TAG = &quot;SmoothCheckBox&quot;;

    private static final String KEY_INSTANCE_STATE = &quot;InstanceState&quot;;

    private Path path = new Path();

    public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
        this.listener = listener;
    }

    public SmoothCheckBox(Context context) {
        this(context, null);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.SmoothCheckBox);
        duration = a.getInt(R.styleable.SmoothCheckBox_duration, 600);

        defaultStrikeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, getResources().getDisplayMetrics());
        mStrokeWidth = a.getDimension(R.styleable.SmoothCheckBox_strikeWidth, defaultStrikeWidth);
        defaultTickWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
        mTickWidth = a.getDimension(R.styleable.SmoothCheckBox_tickWidth, defaultTickWidth);
        borderColor = a.getColor(R.styleable.SmoothCheckBox_borderColor, getResources().getColor(android.R.color.darker_gray));
        trimColor = a.getColor(R.styleable.SmoothCheckBox_trimColor, getResources().getColor(android.R.color.holo_green_light));
        tickColor = a.getColor(R.styleable.SmoothCheckBox_tickColor, getResources().getColor(android.R.color.white));
        a.recycle();

        trimPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        trimPaint.setStyle(Paint.Style.FILL);
        trimPaint.setColor(trimColor);

        borderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        borderPaint.setStrokeWidth(mStrokeWidth);
        borderPaint.setColor(borderColor);
        borderPaint.setStyle(Paint.Style.STROKE);

        tickPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        tickPaint.setColor(tickColor);
        tickPaint.setStyle(Paint.Style.STROKE);
        tickPaint.setStrokeCap(Paint.Cap.ROUND);
        tickPaint.setStrokeWidth(mTickWidth);

        setOnClickListener(this);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = 40;
        }

        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = 40;
        }
        setMeasuredDimension(mWidth, mHeight);
        int size = Math.min(mWidth, mHeight);
        center = size / 2;
        mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
        startPoint.set(center * 14 / 30, center * 28 / 30);
        breakPoint.set(center * 26 / 30, center * 40 / 30);
        endPoint.set(center * 44 / 30, center * 20 / 30);

        downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
        upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
        totalLength = downLength + upLength;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        drawBorder(canvas);
        drawTrim(canvas);
        if (isChecked) {
            drawTick(canvas);
        }
        canvas.restore();
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INSTANCE_STATE, super.onSaveInstanceState());
        bundle.putBoolean(KEY_INSTANCE_STATE, isChecked);
        return bundle;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            Bundle bundle = (Bundle) state;
            boolean isChecked = bundle.getBoolean(KEY_INSTANCE_STATE);
            setChecked(isChecked);
            super.onRestoreInstanceState(bundle.getParcelable(KEY_INSTANCE_STATE));
            return;
        }
        super.onRestoreInstanceState(state);
    }

    // 切换状态
    private void toggle() {
        isChecked = !isChecked;
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
        if (isChecked) {
            checkedAnimation();
        } else {
            uncheckedAnimation();
        }
    }

    // 由未选中到选中的动画
    private void checkedAnimation() {
        animatedValue = 0f;
        tickValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
        mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
        mTickValueAnimator.setInterpolator(new LinearInterpolator());
        mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                tickValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                mTickValueAnimator.start();
                Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
            }
        });
        mValueAnimator.start();
    }

    // 由选中到未选中的动画
    private void uncheckedAnimation() {
        animatedValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateInterpolator());
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.start();
    }

    // 画对勾
    private void drawTick(Canvas canvas) {
        float temp = tickValue * totalLength;
        Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
        if (Float.compare(tickValue, 0f) == 0) {
            Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
            path.reset();
            path.moveTo(startPoint.x, startPoint.y);
        }
        if (temp &gt; downLength) {
            path.moveTo(startPoint.x, startPoint.y);
            path.lineTo(breakPoint.x, breakPoint.y);
            Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
            path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
        } else {
            Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
            path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
        }
        canvas.drawPath(path, tickPaint);
    }

    // 画边框
    private void drawBorder(Canvas canvas) {
        float temp;
        if (animatedValue &gt; 1f) {
            temp = animatedValue * mRadius;
        } else {
            temp = mRadius;
        }
        canvas.drawCircle(center, center, temp, borderPaint);
    }

    // 画checkbox内部
    private void drawTrim(Canvas canvas) {
        canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
    }

    @Override
    public void onClick(View view) {
        toggle();
    }

    /**
     * 判断checkbox是否选中状态
     *
     * @return
     */
    public boolean isChecked() {
        return isChecked;
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked 是否选中
     */
    public void setChecked(boolean isChecked) {
        this.setChecked(isChecked, false);
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked   是否选中
     * @param isAnimation 切换时是否有动画
     */
    public void setChecked(boolean isChecked, boolean isAnimation) {
        this.isChecked = isChecked;
        if (isAnimation) {
            if (isChecked) {
                checkedAnimation();
            } else {
                uncheckedAnimation();
            }
        } else {
            animatedValue = isChecked ? 1f : 0f;
            tickValue = 1f;
            invalidate();
        }
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
    }

    public interface OnCheckedChangeListener {
        void onCheckedChanged(SmoothCheckBox smoothCheckBox, boolean isChecked);
    }
}
</code></pre><p>下面是SmoothCheckBox的源码下载，如果有问题可以在下面留言来交流：</p>
<p><a href="/uploads/20151205/SmoothCheckBox.rar">SmoothCheckBox.rar</a></p>
<p>GitHub:</p>
<p><a href="https://github.com/yuqirong/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探Android ORM框架之greenDAO]]></title>
    <link href="http://yuqirong.me/2015/11/24/%E5%88%9D%E6%8E%A2Android%20ORM%E6%A1%86%E6%9E%B6%E4%B9%8BgreenDAO/"/>
    <id>http://yuqirong.me/2015/11/24/初探Android ORM框架之greenDAO/</id>
    <published>2015-11-24T13:14:30.000Z</published>
    <updated>2016-02-21T14:20:16.913Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许多ORM (对象关系映射 英语：Object Relational Mapping) 的第三方框架，比如greenDAO、ActiveAndroid、ormlite等。说到ORM，相信有过J2EE开发经验的童鞋对此并不陌生，在web开发中就有Hibernate、MyBatis等框架提供使用。那么今天就来介绍一下主角：greenDAO。</p>
<p>根据 <a href="http://greenrobot.org/" target="_blank" rel="external">greenrobot</a> 官方的介绍，greenDAO是一款轻量，快速，适用于Android数据库的ORM框架。具有很高的性能以及消耗很少的内存。其他的优点和特性就不在这里一一介绍了，想要了解的同学可以去访问它的项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a>。</p>
<p>说了这么多，下面就开始我们的正题吧。</p>
<p>在使用greenDAO之前，我们有一件事情不得不做，那就是用代码生成器生成数据模型以及xxxDao等</p>
<p>新建一个java module，取名greendaogeneration(名字随意取，不要在意细节↖(^ω^)↗)，然后在build.gradle(Module:greendaogeneration)中添加依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao-generator:2.0.0&#39;</code></p>
<p>在 src/main 目录下新建一个与 java 同层级的 java-gen 目录，然后配置 Android 工程的 build.gradle(Module:app)，分别添加如下sourceSets。</p>
<pre><code>android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.yuqirong.greendaodemo&quot;
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
    sourceSets {
        main {
            java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/java-gen&apos;]
        }
    }
}
</code></pre><p>然后在greendaogeneration中创建一个GreenDaoGeneration类，用于生成代码：</p>
<pre><code>public class GreenDaoGeneration {

    public static void main(String[] arg0) {

        try {
            Schema schema = new Schema(1, &quot;com.yuqirong.greendao&quot;);
            addLocation(schema);
            new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void addLocation(Schema schema){
        Entity location= schema.addEntity(&quot;Location&quot;);
        location.addIdProperty();
        location.addDoubleProperty(&quot;lon&quot;);
        location.addIntProperty(&quot;level&quot;);
        location.addStringProperty(&quot;address&quot;);
        location.addStringProperty(&quot;city_name&quot;);
        location.addIntProperty(&quot;alevel&quot;);
        location.addDoubleProperty(&quot;lat&quot;);
    }
}
</code></pre><p>其中在创建Schema对象的参数中，第一个表示数据库的版本号，我们传入了“1”，第二个参数是生成代码的包名，我们传入了”com.yuqirong.greendao”，那么生成的代码就自动在”com.yuqirong.greendao”包下了。</p>
<p>在addLocatiion方法中，我们打算把“Location”这个类(其实到现在为止，Location实体类还未生成)保存在数据库中，<code>schema.addEntity(&quot;Location&quot;)</code>传入的Location，那么该表的表名就叫Location，然后我们又定义了在Location表中会有lon、lat、city_name三个字段。所以如果你想创建多张表，那么就要像addLocation()这样的方法多写几个。好了，该做的差不多都做了，最后再<code>new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);</code>把之前的schema传入，第二个参数传的是之前创建的java-gen的路径(建议传入绝对路径，之前在这里被坑了好久↖(~^~)↗)。代码运行之后再到”com.yuqirong.greendao”路径下去看，发现会有许多类生成：</p>
<p><img src="/uploads/20151124/20151124235609.png" alt="这里写图片描述"></p>
<p>至于这些类的作用，我们到下面再说。</p>
<p>第二步在Android Studio的build.gradle(Module:app)中添加以下依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao:2.0.0&#39;</code>  </p>
<p>这样我们就可以在项目中使用greenDAO了。</p>
<p>在正式使用greenDAO前我们需要了解几个greenDAO中的类(也就是上面代码生成的几个类)：</p>
<ul>
<li><p>DaoMaster ：一看这个类名我们就知道这个类肯定是大总管级别的，DaoMaster继承自AbstractDaoMaster。在AbstractDaoMaster中保存了sqlitedatebase对象以及以Map的形式保存了各种操作DAO。DaoMaster还提供了一些创建和删除table的静态方法。另外在DaoMaster类里面有一个静态内部类DevOpenHelper，DevOpenHelper间接继承了SQLiteOpenHelper，通常我们会用<code>new DaoMaster.DevOpenHelper(this, &quot;notes-db&quot;, null)</code>来得到一个DevOpenHelper对象，第一个参数是Context，第二个参数是数据库名，第三个参数是CursorFactory，通常我们传入null。就上面这样简单的一句话你就实际上创建了一个SQLiteOpenHelper对象，而不需要输入<code>&quot;CREATE TABLE...&quot;</code> SQL语句，greenDAO已经帮你做好了一切。</p>
</li>
<li><p>DaoSession：会话层。主要功能就是操作具体的DAO对象，比如各种getXXXDao()方法。</p>
</li>
<li><p>XXXDao：实际生成的DAO类(即生成的LocationDao)，主要对应于某张表的CRUD，比如说LocationDao，那相对应就是对Location表的操作。</p>
</li>
<li><p>XXXEntity：主要是各个实体类(也就是上面生成的Location)，里面的属性与表中的字段相对应。比如上面的LocationDao，那么实体类就是Location，Location实体类中有lon，lat，city_name,alevel,level,address六个属性，那么在Location表中就有lon，lat，city_name,alevel,level,address六个字段。</p>
</li>
</ul>
<p>通过上面几个类作用的介绍，相信大家对greenDAO有了一个初步的印象，下面我们就要真枪实弹了，一起来看一个简单的Demo吧：</p>
<pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(context, &quot;location&quot;, null);
SQLiteDatabase writableDB = devOpenHelper.getWritableDatabase();
DaoMaster daoMaster = new DaoMaster(writableDB);
DaoSession daoSession = daoMaster.newSession();
</code></pre><p>上面的代码很简单，我们创建了一个名叫“location”的数据库，然后通过daoMaster得到了daoSession，有了daoSession，我们就可以得到各种xxxDao，之后的CRUD都是通过xxxDao来操作。</p>
<pre><code>LocationDao locationDao = daoSession.getLocationDao();
Location local = new Location(null,120.15507,2,&quot;&quot;,&quot;杭州市&quot;,4,30.27408);
locationDao.insert(local);
</code></pre><p>我们创建了一个Location的对象，然后调用<code>locationDao.insert()</code>方法就把local的数据插入到location的表中，是不是简单到难以让人置信?!只需要三行代码，而不再需要原生的ContentValues了。不得不感叹greenDAO太方便了。</p>
<p>除了添加数据的，greenDAO还提供删除数据的方法：<code>locationDao.deleteByKey(id);</code>id为当前要删除的那行的主键。</p>
<p>更新数据的方法：<code>locationDao.update(local);</code>local为新的数据。</p>
<p>查询数据的方法： </p>
<ul>
<li><code>locationDao.queryRaw(String where, String...selectionArg)</code>,可以看到greenDAO支持sql语句查询。</li>
<li><p>greenDAO还支持一种更为简单的查询方式，不再需要你去写sql语句(查询Location的lon大于120度和lat大于30度)： </p>
<pre><code>List&lt;Location&gt; list = locationDao.queryBuilder()
                        .where(LocationDao.Properties.Lat.gt(30d), LocationDao.Properties.Lon.gt(120d))
                        .build()
                        .list();
</code></pre></li>
</ul>
<p>好了，关于greenDAO的简单使用就先到这里，至于深入使用我们有机会再讲吧！</p>
<p>依据惯例，下面提供本Demo的源码:</p>
<p><a href="/uploads/20151124/GreenDaoDemo.rar">GreenDaoDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许]]>
    </summary>
    
      <category term="greenDAO" scheme="http://yuqirong.me/tags/greenDAO/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现满屏表情下落的动画效果，你也可以]]></title>
    <link href="http://yuqirong.me/2015/11/12/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%BB%A1%E5%B1%8F%E8%A1%A8%E6%83%85%E4%B8%8B%E8%90%BD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"/>
    <id>http://yuqirong.me/2015/11/12/简单实现满屏表情下落的动画效果，你也可以/</id>
    <published>2015-11-12T14:39:14.000Z</published>
    <updated>2016-02-21T14:20:31.424Z</updated>
    <content type="html"><![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img src="/uploads/20151112/20151112224542.gif" alt="这里写图片描述"></p>
<p>看完上面的效果图，大家一定都迫不及待地想要试一试了，那就让我们来动手吧。</p>
<p>首先我们定义一个实体类DropLook:</p>
<pre><code>/**
 * 下落的表情
 */
public class DropLook {

    // x轴坐标
    private float x;
    // y轴坐标
    private float y;
    // 初始旋转角度
    private float rotation;
    // 下落速度
    private float speed;
    // 旋转速度
    private float rotationSpeed;
    // 宽度
    private int width;
    // 高度
    private int height;
    // 图片
    private Bitmap bitmap;

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public float getRotationSpeed() {
        return rotationSpeed;
    }

    public void setRotationSpeed(float rotationSpeed) {
        this.rotationSpeed = rotationSpeed;
    }

    public float getRotation() {
        return rotation;
    }

    public void setRotation(float rotation) {
        this.rotation = rotation;
    }

    public float getSpeed() {
        return speed;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public Bitmap getBitmap() {
        return bitmap;
    }

    public void setBitmap(Bitmap bitmap) {
        this.bitmap = bitmap;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

}
</code></pre><p>我们定义的实体类很简单，只是设置了如宽高、x，y坐标、下落速度等。接下来我们再创建一个DropLookFactory类，用来创建DropLook对象。</p>
<pre><code>public class DropLookFactory {

    private DropLookFactory() {

    }

    public static DropLook createDropLook(int width, int height,Bitmap originalBitmap) {
        DropLook look = new DropLook();
        if (originalBitmap == null) {
            throw new NullPointerException(&quot;originalBitmap cannot be null&quot;);
        }
        // 设置与图片等宽
        look.setWidth(originalBitmap.getWidth());
        // 设置与图片等高
        look.setHeight(originalBitmap.getHeight());
        // 设置起始位置的X坐标
        look.setX((float) Math.random() * (width - look.getWidth()));
        // 设置起始位置的Y坐标
        look.setY((float) Math.random() * (height - look.getHeight()));
        // 设置速度
        look.setSpeed(20 + (float) Math.random() * 40);
        // 设置初始旋转角度
        look.setRotation((float) Math.random() * 180 - 90);
        // 设置旋转速度
        look.setRotationSpeed((float) Math.random() * 90 - 60);
        // 设置图片
        look.setBitmap(originalBitmap);
        return look;
    }

}
</code></pre><p>其中<code>createDropLook(Context context, float xRange, Bitmap originalBitmap)</code>的第一个参数代表着下落表情在x轴上的范围，第二个参数代表在y轴上的范围，第三个参数是表情的图片。在createDropLook方法中相信大家都看得懂，主要就是用随机数初始化DropLook的坐标及下落速度等。</p>
<p>好了，下面就是今天的重头戏DropLookView，先来看看onMeasure(): </p>
<pre><code> @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = Tools.dip2px(getContext(),200);
    }
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = Tools.dip2px(getContext(),200);
    }
    setMeasuredDimension(mWidth, mHeight);
    if (looks.size() == 0) {
        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
            looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
        }
        Log.i(TAG, &quot;num = &quot; + looks.size());
    }
}
</code></pre><p>onMeasure里主要是对View的测量，如果是<code>wrap_content</code>的话设置一个默认的宽高度200dp。然后就是初始化DropLook，looks是DropLook类的集合，用于管理DropLook。而<code>DEFAULT_LOOK_NUMS</code>是默认的looks集合的数量。</p>
<p>接下来就是最关键的onDraw():</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    long nowTime = System.currentTimeMillis();
    if (nowTime - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - nowTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

        DropLook look = looks.get(i);
        mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
        mMatrix.postRotate(look.getRotation());
        mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
        canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

        look.setY(look.getY() + look.getSpeed());
        if (look.getY() &gt; getHeight()) {
            look.setY((float) (0 - Math.random() * look.getHeight()));
        }

        look.setRotation(look.getRotation() + look.getRotationSpeed());
    }

    canvas.restore();
    startTime = System.currentTimeMillis();
    invalidate();
}
</code></pre><p>一开始判断时间间隔如果没有超过100ms，就让线程睡眠一会。然后就是用drawBitmap的方法把looks里面逐个绘制出来。并且再把look的y轴坐标加上下落速度等，旋转的角度也是如此。最后就是调用invalidate()不断地重绘。总体上并没有什么难点。</p>
<p>以下是DropLookView的完整代码：</p>
<pre><code>/**
 * 表情下落view
 */
public class DropLookView extends View {

    // 表情
    private Bitmap mBitmap;
    // 所有表情集合
    List&lt;DropLook&gt; looks = new ArrayList();
    // view开始时间
    private long startTime;
    // view宽度
    private int mWidth;
    // view高度
    private int mHeight;
    // 画笔
    private Paint mPaint;
    // 默认表情下落数
    private static final int DEFAULT_DROP_LOOK_NUMS = 35;

    private static final String TAG = &quot;DropLookView&quot;;

    private Matrix mMatrix = new Matrix();

    public DropLookView(Context context) {
        this(context, null);
    }

    public DropLookView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DropLookView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        // 图片
        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.d_5_xiaoku);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = Tools.dip2px(getContext(),200);
        }
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = Tools.dip2px(getContext(),200);
        }
        setMeasuredDimension(mWidth, mHeight);
        if (looks.size() == 0) {
            for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
                looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
            }
            Log.i(TAG, &quot;num = &quot; + looks.size());
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        long nowTime = System.currentTimeMillis();
        if (nowTime - startTime &lt; 100) {
            try {
                Thread.sleep(100 + startTime - nowTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

            DropLook look = looks.get(i);
            mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
            mMatrix.postRotate(look.getRotation());
            mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
            canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

            look.setY(look.getY() + look.getSpeed());
            if (look.getY() &gt; getHeight()) {
                look.setY((float) (0 - Math.random() * look.getHeight()));
            }

            look.setRotation(look.getRotation() + look.getRotationSpeed());
        }

        canvas.restore();
        startTime = System.currentTimeMillis();
        invalidate();
    }

}
</code></pre><p>该讲的也差不多讲完了，其实并没有想象中的那么有难度，实现起来也比较容易。当然DropLookView也有需要改进的地方。比如说可以在布局文件中自定义表情下落的数量等。这些就需要自己根据需求来更改了，那今天就先这样吧。</p>
<p>下面是本Demo的完整代码：<br><a href="/uploads/20151112/DropDownView.rar">DropLookView.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img sr]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[史上最简单粗暴实现侧滑菜单]]></title>
    <link href="http://yuqirong.me/2015/11/04/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95/"/>
    <id>http://yuqirong.me/2015/11/04/史上最简单粗暴实现侧滑菜单/</id>
    <published>2015-11-04T12:47:16.000Z</published>
    <updated>2016-02-21T14:20:45.816Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，相信侧滑菜单大家都不陌生吧，几乎是每个app都必备的。从早期的 <a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="external">SlidingMenu</a> 再到           <a href="https://github.com/SpecialCyCi/AndroidResideMenu" target="_blank" rel="external">AndroidResideMenu</a> 最后到Android自带的DrawerLayout，无处不体现着侧滑菜单的诱人魅力。侧滑菜单可以拓展app的内容，充分利用手机屏幕，增加程序的可玩性。既然有这么多可供选择的侧滑菜单使用，那为什么我们还要自己写呢？我觉得我们在使用侧滑菜单的时候应该要懂得其中的原理，更好的，可以自己写一个侧滑菜单来加深体会。</p>
<p>好了，话不多说。来看看我们所谓“史上最简单粗暴实现的侧滑菜单”的产物吧：</p>
<p><img src="/uploads/20151104/20151104205135.gif" alt="这里写图片描述"></p>
<p>看完了上面的gif，想不想自己也写一个呢，那还等什么，一起来看看喽。</p>
<p>首先来说一下侧滑菜单实现的思路：侧滑菜单的布局为MenuLayout，还有主页的布局为MainLayout。MenuLayout在MainLayout的左边，当手指向右滑动的时候，MainLayout就向右滑动，同时MenuLayout跟着向右滑动，于是就显示出了侧滑菜单。以下是示意图：</p>
<p><img src="/uploads/20151104/20151104000149.png" alt="这里写图片描述"></p>
<p>大概地了解思路以后，我们先来看看布局文件。</p>
<p>layout_slidemenu.xml(侧滑菜单的布局)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;@drawable/menu_bg&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;ListView
        android:id=&quot;@+id/lv_menu&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:cacheColorHint=&quot;@null&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>layout_activity_main.xml(主界面的布局)：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:background=&quot;#55666666&quot;
android:orientation=&quot;vertical&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:background=&quot;@drawable/top_bar_bg&quot;
        android:gravity=&quot;center_vertical&quot; &gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_menu&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_margin=&quot;10dp&quot;
            android:layout_gravity=&quot;center_vertical&quot;
            android:background=&quot;@drawable/img_menu&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginLeft=&quot;15dp&quot;
            android:text=&quot;SlidingMenu&quot;
            android:layout_gravity=&quot;center_vertical&quot;
            android:textColor=&quot;#ffffff&quot;
            android:textSize=&quot;22sp&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>layout_main.xml(activity的布局)，注意，主界面的布局一定要放在菜单布局的后面：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

    &lt;com.yuqirong.slidingmenu.view.SlidingMenu
        android:id=&quot;@+id/slideMenu1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; &gt;

        &lt;!-- 菜单界面的布局 --&gt;

        &lt;include layout=&quot;@layout/layout_slidemenu&quot; /&gt;

        &lt;!-- 主界面的布局 --&gt;

        &lt;include layout=&quot;@layout/layout_activity_main&quot; /&gt;
    &lt;/com.yuqirong.slidingmenu.view.SlidingMenu&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>看完了布局文件，下面我们就来看看代码(以下为部分代码，并非全部)：</p>
<pre><code>public class SlidingMenu extends FrameLayout {

    private ViewDragHelper mdDragHelper;

    public SlidingMenu(Context context) {
        this(context, null);
    }

    public SlidingMenu(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SlidingMenu(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        mdDragHelper = ViewDragHelper.create(this, callback);
    }
}
</code></pre><p>我们创建一个类名叫SlidingMenu，继承自FrameLayout，然后重写构造器。在构造器中新建了一个ViewDragHelper的对象。如果你还不知道ViewDragHelper为何物，建议你去看看<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">《Android ViewDragHelper完全解析 自定义ViewGroup神器》</a>，这里就不展开叙述了。在<code>ViewDragHelper.create(Context context,ViewDragHelper.Callback callback)</code>里我们传入了一个回调callback，那接下来就来看看这个callback：</p>
<pre><code> Callback callback = new Callback() {

    @Override
    public boolean tryCaptureView(View view, int arg1) {
        return true;
    }

    public int getViewHorizontalDragRange(View child) {
        return menuWidth;
    }

    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == mainView) {
            if (left &lt; 0)
                return 0;
            else if (left &gt; menuWidth)
                return menuWidth;
            else
                return left;
        } else if (child == menuView) {
            if (left &gt; 0)
                return 0;
            else if (left &gt; menuWidth)
                return menuWidth;
            else
                return left;
        }
        return 0;
    }

    public void onViewPositionChanged(View changedView, int left, int top,
                                      int dx, int dy) {
        if (changedView == mainView)
            menuView.offsetLeftAndRight(dx);
        else
            mainView.offsetLeftAndRight(dx);
        invalidate();
    }

    ;

    public void onViewReleased(View releasedChild, float xvel, float yvel) {
        if (releasedChild == mainView) {
            if (status == Status.Open) {
                // 关闭侧滑菜单
                close();
                return;
            }
            if (xvel == 0
                    &amp;&amp; Math.abs(mainView.getLeft()) &gt; menuWidth / 2.0f) {
                // 打开侧滑菜单
                open();
            } else if (xvel &gt; 0) {
                open();
            } else {
                close();
            }
        } else {
            if (xvel == 0
                    &amp;&amp; Math.abs(mainView.getLeft()) &gt; menuWidth / 2.0f) {
                // 打开侧滑菜单
                open();
            }else if (xvel &gt; 0) {
                open();
            } else {
                // 关闭侧滑菜单
                close();
            }
        }
    }

};
</code></pre><p>我们发现在callback中几乎完成了绝大部分的逻辑。首先在<code>tryCaptureView(View view, int arg1)</code>直接返回了true，因为无论在mainView(主View)还是在menuView(菜单View)都应该去捕获，而<code>getViewHorizontalDragRange(View child)</code>返回的应该是menuView的宽度，也就是说滑动的时候最多能滑menuWidth的距离。而menuWidth是在<code>onFinishInflate()</code>中得到的。至于<code>clampViewPositionHorizontal(View child, int left, int dx)</code>和<code>onViewPositionChanged(View changedView, int left, int top,int dx, int dy)</code>两个方法逻辑很简单，相信大家都看得懂。最后在<code>onViewReleased(View releasedChild, float xvel, float yvel)</code>方法中判断了菜单打开或关闭的逻辑，比如在菜单关闭的情况下，只要手指向右滑或是停止滑动时侧滑菜单在屏幕中的宽度大于menuWidth/2这两种情况下，侧滑菜单都是执行open()方法，其它的情况以此类推。下面就来看看open()和close()方法。</p>
<pre><code>/**
 * 打开菜单
 */
public void open() {
    if (mdDragHelper.smoothSlideViewTo(mainView, menuWidth, 0)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
    preStatus = status;
    status = Status.Open;
    if (listener != null &amp;&amp; preStatus == Status.Close) {
        listener.statusChanged(status);
    }
}

/**
 * 关闭菜单
 */
public void close() {
    if (mdDragHelper.smoothSlideViewTo(mainView, 0, 0)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
    preStatus = status;
    status = Status.Close;
    if (listener != null &amp;&amp; preStatus == Status.Open) {
        listener.statusChanged(status);
    }
}

/**
 * 切换菜单状态
 */
public void toggle() {
    if (status == Status.Close) {
        open();
    } else {
        close();
    }
} 

@Override
public void computeScroll() {
    super.computeScroll();
    // 开始执行动画
    if (mdDragHelper.continueSettling(true)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
}
</code></pre><p>我们发现在<code>open()</code>和<code>close()</code>两个方法中都调用了<code>ViewCompat.postInvalidateOnAnimation(this);</code>而<code>postInvalidateOnAnimation(View view)</code>需要重写<code>computeScroll()</code>来实现平滑滚动的效果，一般的写法都如上代码所示，不需要改动。再重新回到<code>open()</code>和<code>close()</code>两个方法，其中的listener就是菜单开关状态的监听器，当状态改变的时候都会回调listener的<code>statusChanged(Status status)</code>方法。</p>
<p>最后的最后，别忘了在<code>onLayout(boolean changed, int left, int top, int right, int bottom)</code>中把menuView设置在mainView的左边。而menuView和mainView都是在<code>onFinishInflate()</code>中得到的。</p>
<pre><code>@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    if(getChildCount()!=2){
        throw new IllegalArgumentException(&quot;子view的数量必须为2个&quot;);
    }
    menuView = getChildAt(0);
    mainView = getChildAt(1);
    menuWidth = menuView.getLayoutParams().width;
}

@Override
protected void onLayout(boolean changed, int left, int top, int right,
                        int bottom) {
    menuView.layout(-menuWidth, 0, 0, menuView.getMeasuredHeight());
    mainView.layout(0, 0, right, bottom);
}
</code></pre><p>好了，讲解了这么多，差不多把SlidingMenu的代码逻辑讲解完成了。如果有什么疑问，可以在下面留言。</p>
<p>国际惯例，下面贴出源码下载链接：</p>
<p><a href="/uploads/20151104/SlidingMenu.rar">SlidingMenu.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，相信侧滑菜单大家都不陌生吧，几乎是每个app都必备的。从早期的 <a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="external">SlidingM]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android onTouch事件传递机制解析]]></title>
    <link href="http://yuqirong.me/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2015/10/29/Android onTouch事件传递机制解析/</id>
    <published>2015-10-29T14:56:09.000Z</published>
    <updated>2016-02-21T14:20:08.513Z</updated>
    <content type="html"><![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事件传递的机制了，顺便写一篇博客来记录一下。下面就让我们来看看吧。</p>
<p>大家都知道一般我们使用的UI控件都是继承自共同的父类——View。所以View这个类应该掌管着onTouch事件的相关处理。那就让我们去看看：在View中寻找Touch相关的方法，其中一个很容易地引起了我们的注意：dispatchTouchEvent(MotionEvent event)。根据方法名的意思应该是负责分发触摸事件的，下面给出了源码：</p>
<pre><code>/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
 public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}
</code></pre><p>源码有点长，但我们不必每一行都看。首先注意到dispatchTouchEvent的返回值是boolean类型的，注释上的解释：<code>@return True if the event was handled by the view, false otherwise.</code>也就是说如果该触摸事件被这个View消费了就返回true，否则返回false。在方法中首先判断了该event是否是否得到了焦点，如果没有得到焦点直接返回false。然后让我们把目光转向<code>if (li != null &amp;&amp; li.mOnTouchListener != null&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED&amp;&amp; li.mOnTouchListener.onTouch(this, event))</code>这个片段，看到这里有一个名为li的局部变量，属于 ListenerInfo 类，经 mListenerInfo 赋值得到。ListenerInfo只是一个包装类，里面封装了大量的监听器。再在 View 类中去寻找 mListenerInfo ，可以看到下面的代码：</p>
<pre><code>  ListenerInfo getListenerInfo() {
    if (mListenerInfo != null) {
        return mListenerInfo;
    }
    mListenerInfo = new ListenerInfo();
    return mListenerInfo;
}
</code></pre><p>因此我们可以知道mListenerInfo是不为空的，所以li也不是空，第一个判断为true，然后看到li.mOnTouchListener，前面说过ListenerInfo是一个监听器的封装类，所以我们同样去追踪mOnTouchListener：</p>
<pre><code>/**
 * Register a callback to be invoked when a touch event is sent to this view.
 * @param l the touch listener to attach to this view
 */
public void setOnTouchListener(OnTouchListener l) {
    getListenerInfo().mOnTouchListener = l;
}
</code></pre><p>正是通过上面的方法来设置 mOnTouchListener 的，我想上面的方法大家肯定都很熟悉吧，正是我们平时经常用的 xxx.setOnTouchListener ，好了我们从中得知如果设置了OnTouchListener则第二个判断也为true，第三个判断为如果该View是否为enable，默认都是enable的，所以同样为true。还剩最后一个：<code>li.mOnTouchListener.onTouch(this, event)</code>，显然是回调了第二个判断中监听器的onTouch()方法，如果onTouch()方法返回true,则上面四个判断全部为true,dispatchTouchEvent()方法会返回true，并且不会执行<code>if (!result &amp;&amp; onTouchEvent(event))</code>这个判断；而在这个判断中我们又看到了一个熟悉的方法：onTouchEvent()。所以想要执行onTouchEvent，则在上面的四个判断中必须至少有一个false。</p>
<p>那就假定我们在onTouch()方法中返回的是false，这样就顺利地执行了onTouchEvent，那就看看onTouchEvent的源码吧：</p>
<pre><code>/**
 * Implement this method to handle touch screen motion events.
 * &lt;p&gt;
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * &lt;ul&gt;
 * &lt;li&gt;obeying click sound preferences
 * &lt;li&gt;dispatching OnClickListener calls
 * &lt;li&gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * &lt;/ul&gt;
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>这段源码比 dispatchTouchEvent 的还要长，不过同样我们挑重点的看：<br><code>if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE)</code><br>看到这句话就大概知道了主要是判断该view是否是可点击的，如果可以点击则接着执行，否则直接返回false。可以看到if里面用switch来判断是哪种触摸事件，但在最后都是返回true的。还有一点要注意：在 ACTION_UP 中会执行 performClick() 方法：</p>
<pre><code>public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}
</code></pre><p>可以看到上面的<code>li.mOnClickListener.onClick(this);</code>，没错，我们好像又有了新的发现。根据上面的经验，这句代码会去回调我们设置好的点击事件监听器。也就是我们平常用的xxx.setOnClickListener(listener);</p>
<pre><code>/**
 * Register a callback to be invoked when this view is clicked. If this view is not
 * clickable, it becomes clickable.
 *
 * @param l The callback that will run
 *
 * @see #setClickable(boolean)
 */
public void setOnClickListener(@Nullable OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}
</code></pre><p>我们可以看到上面方法设置正是mListenerInfo的点击监听器，验证了上面的猜想。到了这里onTouch事件的传递机制基本已经分析完成了,也算是告一段落了。</p>
<p>好了，这下我们可以解决开头的问题了，顺便我们再来小结一下：在dispatchTouchEvent中，如果设置了OnTouchListener并且View是enable的，那么首先被执行的是OnTouchListener中的<code>onTouch(View v, MotionEvent event)</code>。若onTouch返回true,则dispatchTouchEvent不再往下执行并且返回true；不然会执行onTouchEvent，在onTouchEvent中若View是可点击的，则返回true，不然为false。还有在onTouchEvent中若View是可点击以及当前触摸事件为ACTION_UP，会执行performClick()，回调OnClickListener的onClick方法。下面是我画的一张草图：<br><img src="/uploads/20151029/20151029230937.png" alt="这里写图片描述"></p>
<p>还有一点值得注意的地方是：假如当前事件是ACTION_DOWN，只有dispatchTouchEvent返回true了之后该View才会接收到接下来的ACTION_MOVE,ACTION_UP事件，也就是说只有事件被消费了才能接收接下来的事件。</p>
<p>好了，今天就到这里了，如果有什么问题可以在下面留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义View之实现文字百分比进度条]]></title>
    <link href="http://yuqirong.me/2015/10/23/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E7%99%BE%E5%88%86%E6%AF%94%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://yuqirong.me/2015/10/23/自定义View之实现文字百分比进度条/</id>
    <published>2015-10-23T15:26:56.000Z</published>
    <updated>2016-02-21T14:20:55.950Z</updated>
    <content type="html"><![CDATA[<p>之前在学习自定义View的时候看到<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的 <a href="http://blog.csdn.net/lmj623565791/article/details/43371299" target="_blank" rel="external">《Android 打造形形色色的进度条 实现可以如此简单》</a> 中自带百分比的进度条，于是照着例子自己实现了一下。下面是View的样子：<br><img src="/uploads/20151023/20151023211913.gif" alt="这里写图片描述"></p>
<p>大家都知道自定义View的主要步骤：  </p>
<ol>
<li>自定义View的一些属性  </li>
<li>在构造器中初始化属性  </li>
<li>重写onMeasure()方法  </li>
<li>重写onDraw()方法  </li>
</ol>
<p>下面就来实现第一步：<br>先在values文件夹中新建attrs.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;PercentProgressView&quot;&gt;
        &lt;!-- 进度条当前进度的颜色 --&gt;
        &lt;attr name=&quot;progress_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的当前进度 --&gt;
        &lt;attr name=&quot;progress&quot; format=&quot;integer|float&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的总进度 --&gt;
        &lt;attr name=&quot;total&quot; format=&quot;integer|float&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条总进度的颜色 --&gt;
        &lt;attr name=&quot;total_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 百分比字体的大小 --&gt;
        &lt;attr name=&quot;text_size&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的宽度 --&gt;
        &lt;attr name=&quot;progress_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- 百分比字体的偏移量 --&gt;
        &lt;attr name=&quot;text_offset&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>好了我差不多就定义以上几种属性，有需要的可以在后面再添加。这样我们的第一步就完成了。下面我们就来看看第二步吧。</p>
<pre><code>// 画笔
private Paint mPaint;
// 当前进度颜色
private int mProgressColor;
// 总进度颜色
private int mTotalColor;
// view的宽度
private int mWidth;
// view的高度
private int mHeight;
// 当前进度
private float mProgress;
// 总进度
private float mTotal;
// 字体大小
private float mTextSize;
// 进度文字偏移
private float mTextOffset;
// 进度条高度
private float mProgressHeight;
// 真实宽度
private int realWidth;
// 文字默认宽度
private static final float TEXT_SIZE = 20;
// 文字偏移
private static final float TEXT_OFFSET = 10;
// 默认进度条高度
private static final float DEFAULT_PROGRESS_HEIGHT = 4;

public PercentProgressView(Context context) {
    this(context, null);
}

public PercentProgressView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public PercentProgressView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PercentProgressView);
    // 当前进度颜色
    mProgressColor = a.getColor(R.styleable.PercentProgressView_progress_color, Color.RED);
    // 总进度颜色
    mTotalColor = a.getColor(R.styleable.PercentProgressView_total_color, Color.GRAY);
    // 当前的进度
    mProgress = a.getFloat(R.styleable.PercentProgressView_progress, 0f);
    // 总量
    mTotal = a.getFloat(R.styleable.PercentProgressView_total, 100f);
    // 字体大小
    float defaultTextSize = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_SP, TEXT_SIZE, getResources()
                    .getDisplayMetrics());
    mTextSize = a.getDimension(R.styleable.PercentProgressView_text_size, defaultTextSize);
    // 进度条高度
    float defaultProgressHeight = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, DEFAULT_PROGRESS_HEIGHT, getResources()
                    .getDisplayMetrics());
    mProgressHeight = a.getDimension(R.styleable.PercentProgressView_progress_height, defaultProgressHeight);
    // 进度文字偏移
    float defaultTextOffset = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, TEXT_OFFSET, getResources()
                    .getDisplayMetrics());
    mTextOffset = a.getDimension(R.styleable.PercentProgressView_text_offset, defaultTextOffset);
    // 回收TypedArray
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    mPaint.setTextSize(mTextSize);
    mPaint.setStrokeWidth(mProgressHeight);
    mPaint.setColor(mProgressColor);
}
</code></pre><p>在第二步中我们主要做的就是把上一步定义的属性在构造器中初始化，设置一些默认值以及创建一个新的Paint对象。其实并没什么难度，都是一些重复性的东西。</p>
<p>接下来要做的就是重写onMeasure()方法来测量View。宽度我们可以设置为match_parent，高度为可自定义，所以我们要测量一下高度。使用MeasureSpec.getMode(heightMeasureSpec)来判断用户设置的模式，如果是 MeasureSpec.EXACTLY 则不直接返回 MeasureSpec.getSize(heightMeasureSpec) 就可以了，不然的话要比较文字和进度条的高度，取两者的最大值。最后调用setMeasuredDimension(width,height)。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int mode = MeasureSpec.getMode(heightMeasureSpec);
    int size = MeasureSpec.getSize(heightMeasureSpec);
    mWidth = MeasureSpec.getSize(widthMeasureSpec);
    mHeight = measureHeight(mode, size);
    setMeasuredDimension(mWidth, mHeight);
    realWidth = getMeasuredWidth() - getPaddingLeft() - getPaddingRight();
}

//测量高度
private int measureHeight(int mode, int size) {
    int result;
    if (mode == MeasureSpec.EXACTLY) {
        //精确的情况下
        result = size;
    } else {
        int h = (int) (getPaddingBottom() + getPaddingTop() +
                Math.max(mProgressHeight, Math.abs(mPaint.descent() - mPaint.ascent())));
        result = h;
        if (mode == MeasureSpec.AT_MOST) {
            result = Math.min(h, size);
        }
    }
    return result;
}
</code></pre><p>上面三步完成之后就到了最后的重点onDraw()方法了。根据思路我们应该先画出已完成进度的矩形，再画出百分比文字，最后画出未完成的进度。需要注意的是绘制文字的时候Y轴起点为文字的baseline，而不是文字的顶部。下面给出了绘制时大概的思路图：<br><img src="/uploads/20151023/20151023214750.png" alt="这里写图片描述"></p>
<pre><code>   @Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);

    canvas.save();
    // 设置画笔颜色为已完成的颜色
    mPaint.setColor(mProgressColor);
    float p = getPercent();
    // 得到百分比
    String s = (int) (p * 100) + &quot;%&quot;;
    // 测量文字的宽度
    float textWidth = mPaint.measureText(s);

    canvas.drawRect(getPaddingLeft(), (mHeight - mProgressHeight) / 2,
            getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p, (mHeight + mProgressHeight) / 2, mPaint);
    // 测量文字的高度
    float textHeight = Math.abs((mPaint.descent() + mPaint.ascent()) / 2);

    canvas.drawText(s, getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p + mTextOffset / 2,
            textHeight + mHeight / 2, mPaint);
    // 设置画笔颜色为未完成的颜色
    mPaint.setColor(mTotalColor);

    canvas.drawRect(getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p + mTextOffset + textWidth, (mHeight - mProgressHeight) / 2,
            mWidth - getPaddingRight(), (mHeight + mProgressHeight) / 2, mPaint);
    canvas.restore();
}
</code></pre><p>到了这里整体的View差不多已经写完了，其实总体并没有什么难点。只要搞清思路，相信大家都能定义出自己想要的View。  </p>
<p>以下是完整代码下载地址：<br><a href="/uploads/20151023/PercentProgressView.rar">PercentProgressView.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在学习自定义View的时候看到<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的 <a href="http://blog.csdn.net/lmj62356]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[给你的ScrollView设置滑动距离监听器]]></title>
    <link href="http://yuqirong.me/2015/10/19/%E7%BB%99%E4%BD%A0%E7%9A%84ScrollView%E8%AE%BE%E7%BD%AE%E6%BB%91%E5%8A%A8%E8%B7%9D%E7%A6%BB%E7%9B%91%E5%90%AC%E5%99%A8/"/>
    <id>http://yuqirong.me/2015/10/19/给你的ScrollView设置滑动距离监听器/</id>
    <published>2015-10-19T11:44:21.000Z</published>
    <updated>2016-02-18T12:15:43.233Z</updated>
    <content type="html"><![CDATA[<p>ScrollView是我们经常使用的一个UI控件，也许你在使用ScrollView的过程中会发现，当你想监听ScrollView滑动的距离时却没有合适的监听器！当然在API 23中有<code>setOnScrollChangeListener(View.OnScrollChangeListener l)</code>可以使用，但是并不兼容低版本的API。那怎么办呢？只好重写ScrollView来实现对滑动距离的监听了。</p>
<p>话不多说，直接上代码：</p>
<pre><code>public class MyScrollView extends ScrollView {

    private OnScrollListener listener;

    /**
     * 设置滑动距离监听器
     */
    public void setOnScrollListener(OnScrollListener listener) {
        this.listener = listener;
    }

    public MyScrollView(Context context) {
        super(context);
    }

    public MyScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    // 滑动距离监听器
    public interface OnScrollListener{

        /**
         * 在滑动的时候调用，scrollY为已滑动的距离
         */
        void onScroll(int scrollY);
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        if(listener!=null){
            listener.onScroll(getScrollY());
        }
    }
}
</code></pre><p>上面重写的MyScrollView是在<code>computeScroll()</code>实现监听，因为ScrollView内部是通过Scroller来实现的，当滑动的时候会去调用<code>computeScroll()</code>方法，从而达到监听的效果。</p>
<p>当然还有另一种方法，就是在<code>onScrollChanged(int l, int t, int oldl, int oldt)</code>去监听，最后的效果是一样的：</p>
<pre><code>public class MyScrollView extends ScrollView {

    private OnScrollListener listener;

    public void setOnScrollListener(OnScrollListener listener) {
        this.listener = listener;
    }

    public MyScrollView(Context context) {
        super(context);
    }

    public MyScrollView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyScrollView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
    }

    public interface OnScrollListener{
        void onScroll(int scrollY);
    }

     @Override  
    protected void onScrollChanged(int l, int t, int oldl, int oldt) {  
        super.onScrollChanged(l, t, oldl, oldt);  
        if(listener != null){  
            listener.onScroll(t);  
        }  
    }  
}
</code></pre><p>下面提供MyScrollView的源码下载：</p>
<p><a href="/uploads/20151019/MyScrollView.java">MyScrollView.java(通过computeScroll监听)</a></p>
<p><a href="/uploads/20151019/MyScrollView2.java">MyScrollView.java(通过onScrollChanged监听)</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ScrollView是我们经常使用的一个UI控件，也许你在使用ScrollView的过程中会发现，当你想监听ScrollView滑动的距离时却没有合适的监听器！当然在API 23中有<code>setOnScrollChangeListener(View.OnScrollC]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="ScrollView" scheme="http://yuqirong.me/tags/ScrollView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ScrollView嵌套ListView问题的解决办法]]></title>
    <link href="http://yuqirong.me/2015/10/17/ScrollView%E5%B5%8C%E5%A5%97ListView%E9%97%AE%E9%A2%98%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/"/>
    <id>http://yuqirong.me/2015/10/17/ScrollView嵌套ListView问题的解决办法/</id>
    <published>2015-10-17T11:16:03.000Z</published>
    <updated>2016-02-18T11:52:40.750Z</updated>
    <content type="html"><![CDATA[<p>在平常的Android开发中我们经常会碰到ScrollView嵌套ListView或者是GridView的情况，若按照一般的流程我们会发现在ScrollView中的ListView显示不全的问题，其实我们可以重写ListView的<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法来解决。</p>
<p>以下是重写ListView的代码：</p>
<pre><code>/**
 * 重写ListView，解决与ScrollView的冲突
 */
public class MyListView extends ListView {

    public MyListView(Context context) {
        super(context);
    }

    public MyListView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyListView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,
                MeasureSpec.AT_MOST);
        super.onMeasure(widthMeasureSpec, expandSpec);
    }
}
</code></pre><p>同样的，GridView也可以通过重写来解决：</p>
<pre><code>/**
 * 重写GridView，解决与ScrollView的冲突
 */
public class MyGridView extends GridView {

    public MyGridView(Context context, AttributeSet attrs) {
        super(context, attrs);
    }

    public MyGridView(Context context) {
        super(context);
    }

    public MyGridView(Context context, AttributeSet attrs, int defStyle) {
        super(context, attrs, defStyle);
    }

    @Override
    public void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {

        int expandSpec = MeasureSpec.makeMeasureSpec(Integer.MAX_VALUE &gt;&gt; 2,
                MeasureSpec.AT_MOST);
        super.onMeasure(widthMeasureSpec, expandSpec);
    }

}
</code></pre><p>下面提供MyListView、MyGridView的源码下载：</p>
<p><a href="/uploads/20151017/MyListView.java">MyListView.java</a></p>
<p><a href="/uploads/20151017/MyGridView.java">MyGridView.java</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在平常的Android开发中我们经常会碰到ScrollView嵌套ListView或者是GridView的情况，若按照一般的流程我们会发现在ScrollView中的ListView显示不全的问题，其实我们可以重写ListView的<code>onMeasure(int wi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="ScrollView" scheme="http://yuqirong.me/tags/ScrollView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[探究Android异步消息的处理之Handler详解]]></title>
    <link href="http://yuqirong.me/2015/09/29/%E6%8E%A2%E7%A9%B6Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B9%8BHandler%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yuqirong.me/2015/09/29/探究Android异步消息的处理之Handler详解/</id>
    <published>2015-09-29T05:19:12.000Z</published>
    <updated>2016-02-21T14:20:49.855Z</updated>
    <content type="html"><![CDATA[<p>在学习Android的路上，大家肯定会遇到异步消息处理，Android提供给我们一个类来处理相关的问题，那就是Handler。相信大家大多都用过Handler了，下面我们就来看看Handler最简单的用法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"FirstActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Log.i(TAG, <span class="string">"handler receive msg.what = "</span> + msg.what);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_first);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里做相关操作</span></span><br><span class="line">                <span class="keyword">handler</span>.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码实现了在子线程中发出一个消息，然后在主线程中接收消息。Handler其他类似的用法在这就不过多叙述了。下面我们来看看Handler到底是怎么实现异步消息处理的吧！</p>
<p>先来看看我们new一个Handler的对象到底发生了什么（只截取了关键源码）：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们平常写的 new Handler()；其实是调用了另外一个构造方法，并且判断了mLooper是不是为空，为空则抛出一个异常<strong>“Can’t create handler inside thread that has not called Looper.prepare()”</strong>，mLooper其实是一个Looper类的成员变量，官方文档上对Looper类的解释是 <strong>Class used to run a message loop for a thread.</strong>也就是说Looper用于在一个线程中传递message的。  然后我们根据异常的提示知道要在new一个Handler的对象之前必须<br>先调用Looper.prepare()。那接下来就只能先去看看Looper.prepare()方法了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Printer mLogging;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** Initialize the current thread as a looper.</span><br><span class="line">      * This gives you a chance to create handlers that then reference</span><br><span class="line">      * this looper, before actually starting the loop. Be sure to call</span><br><span class="line">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span><br><span class="line">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</span><br><span class="line">      */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Run the message queue in this thread. Be sure to call</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.<span class="keyword">target</span>.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sThreadLocal.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>prepare()方法就是将一个sThreadLocal和新建的Looper对象相绑定，同时mQueue成员变量也创建了新的MessageQueue对象，MessageQueue这个类就是用于存储Message的队列。在prepare()方法的注释上写着在调用prepare()方法之后还要调用loop()方法，我们再看loop方法，可以看到方法里写了一个for的死循环，主要用于在MessageQueue里不断地去取Message，如果msg为空，则阻塞；不然会调用msg.target.dispatchMessage(msg)这个方法。dispatchMessage()这个方法我会在后面讲解，先暂时放一边不管。</p>
<p>好了，捋一捋思路，当你在新建一个Handler对象时，要先确保调用了Looper.prepare()方法，然后调用Looper.loop()方法让MessageQueue这个队列“动”起来。这样你就成功地创建了一个Handler的对象。然后我们再使用Handler的sendMessage系列方法来发送一个消息。下面我们就来看看sendMessage系列方法里到底干了什么：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">enqueueMessage</span><span class="params">(queue, msg, uptimeMillis)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.<span class="keyword">target</span> = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> queue.<span class="title">enqueueMessage</span><span class="params">(msg, uptimeMillis)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为什么我就贴出一个方法呢？这是因为Handler一系列的sendMessage方法基本上最后都是调用了sendMessageAtTime这个方法。从源码中我们看到主要就是干了把Message加入队列这个事,并把当前的Handler对象赋给了msg的target。再联系上面的Looper.loop方法，我们大概就懂了。好了，我们回过头来看看上面的msg.target.dispatchMessage(msg)主要的功能。其实就是调用了Handler的dispatchMessage方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了一行熟悉的代码：handleMessage(msg)，这不正是我们再创建Handler对象时重写的那个方法么！好了，这一切的逻辑我们似乎已经搞清了：首先调用Looper.prepare()创建一个Looper对象，然后handler发送消息后把消息加入到MessageQueue里，因为之前调用了Looper.loop(),所以MessageQueue在不断地做出队的操作，然后再根据message的target变量分发消息，回到handler的handleMessage()方法。</p>
<p>也许有人会有疑问了，为什么在主线程中创建Handler对象可以直接使用而不需要调用Looper.prepare()和Looper.loop()两个方法呢？这是因为在ActivityThread里面已经调用了，下面附上ActivityThread的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * This manages the execution of the main thread in an </span><br><span class="line"> * application process, scheduling and executing activities, </span><br><span class="line"> * broadcasts, and other operations on it as the activity </span><br><span class="line"> * manager requests. </span><br><span class="line"> * </span><br><span class="line"> * &#123;<span class="doctag">@hide</span>&#125; </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> ContextImpl mSystemContext = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> IPackageManager sPackageManager;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 创建ApplicationThread实例，以接收AMS指令并执行  </span></span><br><span class="line">    <span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> Looper mLooper = Looper.myLooper();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;IBinder, ActivityClientRecord&gt; mActivities  </span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;IBinder, ActivityClientRecord&gt;();  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// List of new activities (via ActivityRecord.nextIdle) that should  </span></span><br><span class="line">    <span class="comment">// be reported when next we idle.  </span></span><br><span class="line">    ActivityClientRecord mNewActivities = <span class="keyword">null</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Number of activities that are currently visible on-screen.  </span></span><br><span class="line">    <span class="keyword">int</span> mNumVisibleActivities = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;IBinder, Service&gt; mServices  </span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;IBinder, Service&gt;();  </span><br><span class="line">      </span><br><span class="line">    Application mInitialApplication;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;Application&gt; mAllApplications  </span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;Application&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ActivityThread&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;ActivityThread&gt;();  </span><br><span class="line">    Instrumentation mInstrumentation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Handler sMainThreadHandler;  <span class="comment">// set once in main()  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityClientRecord</span> </span>&#123;  </span><br><span class="line">        IBinder token;  </span><br><span class="line">        <span class="keyword">int</span> ident;  </span><br><span class="line">        Intent intent;  </span><br><span class="line">        Bundle state;  </span><br><span class="line">        Activity activity;  </span><br><span class="line">        Window window;  </span><br><span class="line">        Activity parent;  </span><br><span class="line">        String embeddedID;  </span><br><span class="line">        Activity.NonConfigurationInstances lastNonConfigurationInstances;  </span><br><span class="line">        <span class="keyword">boolean</span> paused;  </span><br><span class="line">        <span class="keyword">boolean</span> stopped;  </span><br><span class="line">        <span class="keyword">boolean</span> hideForNow;  </span><br><span class="line">        Configuration newConfig;  </span><br><span class="line">        Configuration createdConfig;  </span><br><span class="line">        ActivityClientRecord nextIdle;  </span><br><span class="line">  </span><br><span class="line">        String profileFile;  </span><br><span class="line">        ParcelFileDescriptor profileFd;  </span><br><span class="line">        <span class="keyword">boolean</span> autoStopProfiler;  </span><br><span class="line">  </span><br><span class="line">        ActivityInfo activityInfo;  </span><br><span class="line">        CompatibilityInfo compatInfo;  </span><br><span class="line">        LoadedApk packageInfo; <span class="comment">//包信息，通过调用ActivityThread.getPapckageInfo而获得  </span></span><br><span class="line">  </span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults;  </span><br><span class="line">        List&lt;Intent&gt; pendingIntents;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> startsNotResumed;  </span><br><span class="line">        <span class="keyword">boolean</span> isForward;  </span><br><span class="line">        <span class="keyword">int</span> pendingConfigChanges;  </span><br><span class="line">        <span class="keyword">boolean</span> onlyLocalRequest;  </span><br><span class="line">  </span><br><span class="line">        View mPendingRemoveWindow;  </span><br><span class="line">        WindowManager mPendingRemoveWindowManager;  </span><br><span class="line">  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePendingConfiguration</span><span class="params">(Configuration config)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (mPackages) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||  </span><br><span class="line">                        mPendingConfiguration.isOtherSeqNewer(config)) &#123;  </span><br><span class="line">                    mPendingConfiguration = config;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,  </span><br><span class="line">                <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges)</span> </span>&#123;  </span><br><span class="line">            queueOrSendMessage(  </span><br><span class="line">                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,  </span><br><span class="line">                    token,  </span><br><span class="line">                    (userLeaving ? <span class="number">1</span> : <span class="number">0</span>),  </span><br><span class="line">                    configChanges);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// we use token to identify this activity without having to send the  </span></span><br><span class="line">        <span class="comment">// activity itself back to the activity manager. (matters more with ipc)  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,  </span><br><span class="line">                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,  </span><br><span class="line">                Bundle state, List&lt;ResultInfo&gt; pendingResults,  </span><br><span class="line">                List&lt;Intent&gt; pendingNewIntents, <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward,  </span><br><span class="line">                String profileName, ParcelFileDescriptor profileFd, <span class="keyword">boolean</span> autoStopProfiler)</span> </span>&#123;  </span><br><span class="line">            ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();  </span><br><span class="line">  </span><br><span class="line">            r.token = token;  </span><br><span class="line">            r.ident = ident;  </span><br><span class="line">            r.intent = intent;  </span><br><span class="line">            r.activityInfo = info;  </span><br><span class="line">            r.compatInfo = compatInfo;  </span><br><span class="line">            r.state = state;  </span><br><span class="line">  </span><br><span class="line">            r.pendingResults = pendingResults;  </span><br><span class="line">            r.pendingIntents = pendingNewIntents;  </span><br><span class="line">  </span><br><span class="line">            r.startsNotResumed = notResumed;  </span><br><span class="line">            r.isForward = isForward;  </span><br><span class="line">  </span><br><span class="line">            r.profileFile = profileName;  </span><br><span class="line">            r.profileFd = profileFd;  </span><br><span class="line">            r.autoStopProfiler = autoStopProfiler;  </span><br><span class="line">  </span><br><span class="line">            updatePendingConfiguration(curConfig);  </span><br><span class="line">  </span><br><span class="line">            queueOrSendMessage(H.LAUNCH_ACTIVITY, r);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));  </span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;  </span><br><span class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;  </span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);  </span><br><span class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;  </span><br><span class="line">  </span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(  </span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">                    handleLaunchActivity(r, <span class="keyword">null</span>);  </span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line">                &#125; <span class="keyword">break</span>;  </span><br><span class="line">                ...  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));  </span><br><span class="line">        &#125;  </span><br><span class="line">         </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SamplingProfilerIntegration.start();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We  </span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via  </span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.  </span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        Environment.initForCurrentUser();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore  </span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());  </span><br><span class="line">  </span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);  </span><br><span class="line">  </span><br><span class="line">        Looper.prepareMainLooper();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建ActivityThread实例  </span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </span><br><span class="line">        thread.attach(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            sMainThreadHandler = thread.getHandler();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        AsyncTask.init();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;  </span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span>  </span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Looper.loop();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的main方法里已经调用了prepare和loop的方法。好了，今天该讲的差不多了，就到这吧。</p>
<p>由于第一次写讲解源码的博客，不便之处请大家多多包涵。有问题的可以在下面评论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习Android的路上，大家肯定会遇到异步消息处理，Android提供给我们一个类来处理相关的问题，那就是Handler。相信大家大多都用过Handler了，下面我们就来看看Handler最简单的用法：</p>
<figure class="highlight aspe]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Activity生命周期的小结]]></title>
    <link href="http://yuqirong.me/2015/08/26/%E5%85%B3%E4%BA%8EActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yuqirong.me/2015/08/26/关于Activity生命周期的小结/</id>
    <published>2015-08-26T14:13:31.000Z</published>
    <updated>2016-02-21T14:20:25.768Z</updated>
    <content type="html"><![CDATA[<p>开头先说一下写这篇博客的初衷，由于博主在找实习的过程中面试经常被问到Activity生命周期有关的问题，所以特此写一篇博客来记一下。 </p>
<p>Activity作为四大组件之一，几乎是每个人开始学习Android最先接触到的。常见的生命周期方法大家肯定都是非常熟悉的，所以Activity生命周期的顺序在这就不必过多叙述了。今天讲一下由FirstActivity启动SecondActivity而调用生命周期方法的顺序问题。</p>
<p>首先我们创建一个如下图的FirstActivity:<br><img src="/uploads/20150826/20150826213244536.jpg" alt="这里写图片描述"><br>很简单，LinearLayout里只有一个Button，用于启动SecondActivity。</p>
<p>以下为FirstActivity的布局 activity_first.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/second"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"start SecondActivity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>FirstActivity的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Activity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_first);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onCreate"</span>);</span><br><span class="line"></span><br><span class="line">        Button button = (Button) findViewById(R.id.second);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.i(TAG,<span class="string">"FirstActivity onStart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onResume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onRestart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState, PersistableBundle outPersistentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState, outPersistentState);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onSaveInstanceState"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onRestoreInstanceState"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onConfigurationChanged"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是在生命周期方法中设置了Log打印。</p>
<p>SecondActivity的代码与FirstActivity并无差异，主要将Log中的FirstActivity替换成了SecondActivity。</p>
<p>接下来我们就启动FirstActivity，可以看到Logcat中打印了如下的日志：<br><img src="/uploads/20150826/20150826212633880.jpg" alt="这里写图片描述"><br>一切如我们想象的一样，然后我们点击按钮用于启动SecondActivity，可以看到打印出来的日志：<br><img src="/uploads/20150826/20150826214443682.jpg" alt="这里写图片描述"><br>可以看到FirstActivity和SecondActivity的生命周期方法是交叉着的，并不是先让FirstActivity执行完然后再执行SecondActivity的方法，这正是我们需要注意的。</p>
<p>然后我们点击Back键，返回FirstActivity:<br><img src="/uploads/20150826/20150826214330231.jpg" alt="这里写图片描述"><br>FirstActivity调用的是onRestart方法，因为先前FirstActivity已经创建，所以并不会重新调用onCreate方法。最后再次点击Back键，退出Activity：<br><img src="/uploads/20150826/20150826214929167.jpg" alt="这里写图片描述"><br>写到这里本篇博客的要讲内容已经差不多了，下面再补充一下关于切换横竖屏时Activity的生命周期调用，先前在网上看的一些博文叙述的都已经过时了，大都是在Android 2.2 或者 2.3 时写的，已经不适用于Android 4.0以上的版本了。所以在这里重新写一下：</p>
<p>测试机型：红米2<br>Android版本：5.1.0</p>
<ol>
<li>不设置android:configChanges时，无论是切横屏还是切竖屏都会重新调用各个生命周期，<strong>但都是调用一次</strong>（原先Android 2.X 的说法是切横屏时会执行一次,切竖屏时会执行两次，只适用于Android 2.X 版本）</li>
<li>设置android:configChages=”orientation”时，结果和不设置一样，仍然是重新调用生命周期方法，而且横竖屏都是一次（Android2.X版本：设置Activity的android:configChanges=”orientation”时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次）。</li>
<li>设置为android:configChanges=”orientation|keyboardHidden”时，Android 4.0以上和不设置一样，仍然是重新调用生命周期方法，而且横竖屏都是一次；<strong>Android2.X版本切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法</strong>.</li>
<li>Android4.0版本只有设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，才不重新创建Activity，但会调用onConfigurationChanged方法.</li>
</ol>
<p>好了，今天就到这里吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开头先说一下写这篇博客的初衷，由于博主在找实习的过程中面试经常被问到Activity生命周期有关的问题，所以特此写一篇博客来记一下。 </p>
<p>Activity作为四大组件之一，几乎是每个人开始学习Android最先接触到的。常见的生命周期方法大家肯定都是非常熟悉的，]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.me/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo入门指南(二)]]></title>
    <link href="http://yuqirong.me/2015/07/18/Hexo%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2015/07/18/Hexo入门指南(二)/</id>
    <published>2015-07-18T11:09:24.000Z</published>
    <updated>2016-02-23T14:49:46.257Z</updated>
    <content type="html"><![CDATA[<p>在<a href="/2015/07/12/Hexo入门指南(一)/">Hexo入门指南(一)</a>中我们已经初步地搭建了我们的博客，但是我们发现Hexo另一大特点我们还没有尝试过——主题。下面我们就来试试更换<a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo的主题</a>吧。</p>
<p><a href="https://hexo.io/themes/" target="_blank" rel="external">Hexo的主题</a>非常多，有各式各样的，基本满足了大家的审美需求。其中我们就以<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a>为例吧。<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT主题</a>很简约，但有非常多的人用。</p>
<h1 id="u4E0B_u8F7D_NexT__u4E3B_u9898"><a href="#u4E0B_u8F7D_NexT__u4E3B_u9898" class="headerlink" title="下载 NexT 主题"></a>下载 NexT 主题</h1><p>在终端窗口下，定位到 Hexo 站点目录下</p>
<pre><code>$ cd your-hexo-site
$ git clone https://github.com/iissnan/hexo-theme-next themes/next
</code></pre><h1 id="u542F_u7528_NexT__u4E3B_u9898"><a href="#u542F_u7528_NexT__u4E3B_u9898" class="headerlink" title="启用 NexT 主题"></a>启用 NexT 主题</h1><p>克隆/下载 完成后，打开站点配置文件(也就是xxx.github.io/_config.yml)，找到 theme 字段，并将其值更改为 next。</p>
<h1 id="u9A8C_u8BC1_u4E3B_u9898_u662F_u5426_u542F_u7528"><a href="#u9A8C_u8BC1_u4E3B_u9898_u662F_u5426_u542F_u7528" class="headerlink" title="验证主题是否启用"></a>验证主题是否启用</h1><p>运行 hexo s –debug，并访问 <a href="http://localhost:4000，确保站点正确运行。" target="_blank" rel="external">http://localhost:4000，确保站点正确运行。</a></p>
<p>关于其它<a href="http://theme-next.iissnan.com/five-minutes-setup.html" target="_blank" rel="external">主题设定</a>等，这里就不过多叙述了，官方文档讲得很详细。可以参考<a href="http://theme-next.iissnan.com/" target="_blank" rel="external">NexT官方文档</a>。</p>
<h1 id="u589E_u52A0_u7559_u8A00_u677F"><a href="#u589E_u52A0_u7559_u8A00_u677F" class="headerlink" title="增加留言板"></a>增加留言板</h1><p>该功能的实现的前提必须是Next已安装了第三方评论系统，如多说等。如你的网站并未安装第三方评论，请<a href="http://theme-next.iissnan.com/third-party-services.html" target="_blank" rel="external">点击此处</a>。然后执行以下命令：</p>
<pre><code>$ hexo new page guestbook
</code></pre><p>我们会发现在xxx.github.io/source/里生成了一个名叫guestbook的文件夹，那就是我们想要的留言板。打开guestbook/index.md，设置<code>comments: true</code>，如下图所示：</p>
<p><img src="/uploads/20150718/20150718193734.png" alt="这里写图片描述"></p>
<p>然后找到你NexT主题中的<code>_config.yml</code>(即xxx.github.io/themes/next/_config.yml)，在menu中添加guestbook，即：</p>
<pre><code>menu:
  home: /
  categories: /categories
  archives: /archives
  tags: /tags
  guestbook: /guestbook
  about: /about
</code></pre><p>再找到你NexT主题zh-Hans.yml文件（如果你的网站是其它语言的，请选择相对应的语言文件），文件路径xxx.github.io/themes/next/languages/zh-Hans.yml，添加<code>guestbook: 留言板</code>，即：</p>
<pre><code>menu:
  home: 首页
  archives: 归档
  categories: 分类
  tags: 标签
  about: 关于
  search: 搜索
  guestbook: 留言板
  commonweal: 公益404
</code></pre><p>重新部署网站，你会发现在menu中多了一项“留言板”功能，这样就可以在留言板上留言了。</p>
<h1 id="u4FEE_u6539_u5E95_u680F"><a href="#u4FEE_u6539_u5E95_u680F" class="headerlink" title="修改底栏"></a>修改底栏</h1><p>关于修改底栏增加站长统计及访客记录等可参考此处 <a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a> 。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://theme-nekxt.iissnan.com/" target="_blank" rel="external">NexT官方文档</a></li>
<li><a href="http://www.arao.me/2015/hexo-next-theme-optimize-base/" target="_blank" rel="external">动动手指，NexT主题与Hexo更搭哦（基础篇）</a></li>
<li><a href="http://lovenight.github.io/2015/11/10/Hexo-3-1-1-%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA%E6%8C%87%E5%8D%97/" target="_blank" rel="external">Hexo 3.1.1 静态博客搭建指南</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>在<a href="/2015/07/12/Hexo入门指南(一)/">Hexo入门指南(一)</a>中我们已经初步地搭建了我们的博客，但是我们发现Hexo另一大特点我们还没有尝试过——主题。下面我们就来试试更换<a href="https://hexo.io/themes]]>
    </summary>
    
      <category term="Hexo" scheme="http://yuqirong.me/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://yuqirong.me/categories/Hexo/"/>
    
  </entry>
  
</feed>
