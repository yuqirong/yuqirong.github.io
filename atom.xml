<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2017-10-15T07:48:06.507Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Window源码解析(三)：Window的更新机制]]></title>
    <link href="http://yuqirong.me/2017/10/10/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%EF%BC%9AWindow%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2017/10/10/Window源码解析(三)：Window的更新机制/</id>
    <published>2017-10-10T12:53:03.000Z</published>
    <updated>2017-10-15T07:48:06.507Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a></p>
<p>第二篇：<a href="/2017/10/08/Window源码解析(二)：Window的添加机制/">《Window源码解析(二)：Window的添加机制》</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>在上一篇中，介绍了 Window 添加机制的实现。</p>
<p>那么今天就好好探究探究 Window 更新机制。其实 Window 的更新内部流程和添加 Window 并无什么差异，所以本篇可能会讲得比较简略。</p>
<p>但是还是值得我们去了解的，那么老死机开车了。</p>
<h1 id="Window_u7684_u66F4_u65B0_u673A_u5236"><a href="#Window_u7684_u66F4_u65B0_u673A_u5236" class="headerlink" title="Window的更新机制"></a>Window的更新机制</h1><p>我们更新 Window 的代码：</p>
<p><code>WindowManager.updateViewLayout</code></p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><h3 id="updateViewLayout_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29"><a href="#updateViewLayout_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29" class="headerlink" title="updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params)"></a>updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</h3><p>所以我们的入口就是 WindowManagerImpl 实现类的，先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.updateViewLayout(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然，内部还是交给了 WindowManagerGlobal 来处理了，而且这代码和 <code>addView</code> 的极其类似。</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="updateViewLayout_28View_view_2C_ViewGroup-LayoutParams_params_29"><a href="#updateViewLayout_28View_view_2C_ViewGroup-LayoutParams_params_29" class="headerlink" title="updateViewLayout(View view, ViewGroup.LayoutParams params)"></a>updateViewLayout(View view, ViewGroup.LayoutParams params)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 找到该 view 的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        <span class="comment">// 替换 params</span></span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码也基本上一看就懂的。因为是更新 Window ，所以肯定是要替换 params 了。</p>
<p>之后就是调用 <code>ViewRootImpl.setLayoutParams</code> 来设置新的 params 。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setLayoutParams_28WindowManager-LayoutParams_attrs_2C_boolean_newView_29"><a href="#setLayoutParams_28WindowManager-LayoutParams_attrs_2C_boolean_newView_29" class="headerlink" title="setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)"></a>setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(WindowManager.LayoutParams attrs, <span class="keyword">boolean</span> newView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        applyKeepScreenOnFlag(mWindowAttributes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入的 newView 是 false ，不执行这些代码</span></span><br><span class="line">        <span class="keyword">if</span> (newView) &#123;</span><br><span class="line">            mSoftInputMode = attrs.softInputMode;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't lose the mode we last auto-computed.</span></span><br><span class="line">        <span class="keyword">if</span> ((attrs.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)</span><br><span class="line">                == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">            mWindowAttributes.softInputMode = (mWindowAttributes.softInputMode</span><br><span class="line">                    &amp; ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)</span><br><span class="line">                    | (oldSoftInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 使 view 重走三大流程</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setLayoutParams</code> 中，调用了 <code>scheduleTraversals()</code> 方法。</p>
<p>在之前讲 View 工作原理的时候，我们都看过 <code>scheduleTraversals()</code> 最后会调用 <code>performTraversals()</code> 来开始 View 的测量、布局和绘制。所以在这，也就触发了 View 重新去调整自己。</p>
<h3 id="performTraversals_28_29"><a href="#performTraversals_28_29" class="headerlink" title="performTraversals()"></a>performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performTraversals()</code> 方法太长了，其他的都不看了，我们只注意这一句代码。</p>
<p>接着，在内部又调用了 <code>relayoutWindow(params, viewVisibility, insetsPending)</code> 方法。一看这方法名就知道这方法都干什么了。</p>
<h3 id="relayoutWindow_28_29"><a href="#relayoutWindow_28_29" class="headerlink" title="relayoutWindow()"></a>relayoutWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span><br><span class="line">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看得出来，这里又是调用 session 来走 IPC 流程，然后得到更新 window 的结果 relayoutResult</span></span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这一步，我们再次相遇熟悉的 <code>mWindowSession</code> 。</p>
<p>也知道了其实这是走了一个 IPC 的调用过程，在它内部肯定会利用 WindowManagerService 来完成 Window 的更新。</p>
<p>而 relayoutResult 就是这 IPC 最后返回的结果，也就是 Window 更新的结果。</p>
<p>虽然套路都懂了，但是有时候我们还是要吃。那么就去 Session 类中看看。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="relayout_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29"><a href="#relayout_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29" class="headerlink" title="relayout(IWindow window, int seq, WindowManager.LayoutParams attrs … )"></a>relayout(IWindow window, int seq, WindowManager.LayoutParams attrs … )</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span><br><span class="line">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span><br><span class="line">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span><br><span class="line">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG_WM, <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from "</span></span><br><span class="line">            + Binder.getCallingPid());</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG_WM, <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to "</span></span><br><span class="line">            + Binder.getCallingPid());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和我们预想的一样，内部是调用了 mService ，也就是 WindowManagerService 。</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><h3 id="relayoutWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29"><a href="#relayoutWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29" class="headerlink" title="relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs … )"></a>relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs … )</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span><br><span class="line">           <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span><br><span class="line">           Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span><br><span class="line">           Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span><br><span class="line">           Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> configChanged;</span><br><span class="line">       <span class="keyword">boolean</span> hasStatusBarPermission =</span><br><span class="line">               mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)</span><br><span class="line">                       == PackageManager.PERMISSION_GRANTED;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">		<span class="comment">// 根据 session 和client 得到 windowState 对象</span></span><br><span class="line">           WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将属性进行相应的转换后保存到 WindowState</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 去更新  window</span></span><br><span class="line">		<span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">               (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                mInputMonitor.updateInputWindowsLw(<span class="keyword">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Exception thrown when creating surface for client "</span></span><br><span class="line">                         + client + <span class="string">" ("</span> + win.mAttrs.getTitle() + <span class="string">")"</span>,</span><br><span class="line">                         e);</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...			</span><br><span class="line"></span><br><span class="line">           <span class="keyword">boolean</span> toBeDisplayed = (result &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (imMayMove &amp;&amp; (moveInputMethodWindowsIfNeededLocked(<span class="keyword">false</span>) || toBeDisplayed)) &#123;</span><br><span class="line">               <span class="comment">// Little hack here -- we -should- be able to rely on the</span></span><br><span class="line">               <span class="comment">// function to return true if the IME has moved and needs</span></span><br><span class="line">               <span class="comment">// its layer recomputed.  However, if the IME was hidden</span></span><br><span class="line">               <span class="comment">// and isn't actually moved in the list, its layer may be</span></span><br><span class="line">               <span class="comment">// out of data so we make sure to recompute it.</span></span><br><span class="line">               <span class="comment">// 如果窗口排序有改动，那么为 DisplayContent 的所有窗口分配最终的显示次序</span></span><br><span class="line">               mLayersController.assignLayersLocked(win.getWindowList());</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 更新 window 后设置一些变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WMS 的 <code>relayoutWindow</code> 方法中，先得到了需要更新的 WindowState 对象，接着去执行更新。如果 Window 的显示次序变化了的话，需要重新分配次序。最后就是设置一些 Window 更新完成后的一些变量了。</p>
<p>而其他的代码太复杂了，学艺不精，不能全部分析出来。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>总之，Window 更新也和添加一样，都是通过 session 来调用 IPC 过程完成的。并且最终实现都是在 WindowManagerService 里。</p>
<p>至此，还有一篇 Window 删除还没分析。不用猜也知道，这流程肯定也是差不多的。但是我们还是要深入其中一探究竟。</p>
<p>今天就完结了，bye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/amwihihc/article/details/7992329" target="_blank" rel="external">Android源码分析之WindowManager.LayoutParams属性更新过程</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(二)：Window的添加机制]]></title>
    <link href="http://yuqirong.me/2017/10/08/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%EF%BC%9AWindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2017/10/08/Window源码解析(二)：Window的添加机制/</id>
    <published>2017-10-08T07:34:03.000Z</published>
    <updated>2017-10-10T12:50:29.660Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>在上一篇中，我们讲了 Window 和 DecorView 的那些事，如果没有看过的同学请点击这里：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a>。</p>
<p>而今天就要来详细了解 Window 的添加机制了，到底在 WindowManager.addView 中做了什么事情？我们一起来看看吧！！</p>
<h1 id="Window_u7684_u6DFB_u52A0_u673A_u5236"><a href="#Window_u7684_u6DFB_u52A0_u673A_u5236" class="headerlink" title="Window的添加机制"></a>Window的添加机制</h1><p>上面我们看到了在 <code>makeVisible()</code> 中调用了 <code>wm.addView(mDecor, getWindow().getAttributes())</code> 将 DecorView 视图添加到 Window 上。</p>
<p>那么调用这句代码之后究竟发生了什么呢，这就需要我们一步一步慢慢去揭开了。</p>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>WindowManager 是一个接口，继承了 ViewManager 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ViewManager 中定义的方法非常熟悉，也是平时我们经常使用的，就是对 View 的增删改。</p>
<p>对 WindowManager 具体的实现就是 WindowManagerImpl 这个类了。在后面我们会接触到它的。</p>
<p>那么，我们就开始吧。</p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><h3 id="addView_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29"><a href="#addView_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29" class="headerlink" title="addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params)"></a>addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要使用默认的 token ，token 就是一个 binder 对象</span></span><br><span class="line">    <span class="comment">// 如果没有父 window ，那么我们需要使用默认的 token</span></span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    <span class="comment">// 调用 WindowManagerGlobal 来实现添加 view</span></span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 WindowManagerImpl 也没有直接实现 View 的添加，而是转交给了 WindowManagerGlobal 类来做这件事。其实除了 <code>addView</code> 之外，<code>updateViewLayout</code> 和 <code>removeView</code> 也都是通过 WindowManagerGlobal 来实现的，这是桥接模式的体现。</p>
<p>那么我们继续跟下去。</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29"><a href="#addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29" class="headerlink" title="addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)"></a>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数有无错误，如果是子 window 的话要调整一些参数</span></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is a panel window, then find the window it is being</span></span><br><span class="line">        <span class="comment">// attached to for future reference.</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建新的 viewrootimpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">// 保存当前界面这些参数</span></span><br><span class="line">        <span class="comment">// mViews 存储所有 window 所对应的 view</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="comment">// mRoots 存储所有 window 所对应的 ViewRootImpl</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="comment">// mParams 存储所有 window 所对应的布局参数</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 setview 来开始 view 的测量 布局 绘制流程，完成 window 的添加</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code> 中，我们捋一捋它干了什么事：</p>
<ol>
<li>检查了参数，如果是子 Window 的话，还要调整参数；</li>
<li>创建 ViewRootImpl ，然后将当前界面的参数保存起来；</li>
<li>调用 ViewRootImpl 的 setView 来更新界面并完成 Window 的添加；</li>
</ol>
<p>可以看出，Window 的添加还需要我们到 <code>ViewRootImpl.setView</code> 中去看，同时也即将开启 View 三大工作流程。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29"><a href="#setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29" class="headerlink" title="setView(View view, WindowManager.LayoutParams attrs, View panelParentView)"></a>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 开始了 view 的三大工作流程</span></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">               mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">               collectViewAttributes();</span><br><span class="line">               <span class="comment">// 利用 mWindowSession 来添加 window ，是一个 IPC 的过程</span></span><br><span class="line">               res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                       getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                       mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                       mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">               mAdded = <span class="keyword">false</span>;</span><br><span class="line">               mView = <span class="keyword">null</span>;</span><br><span class="line">               mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">               mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">               mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">               unscheduleTraversals();</span><br><span class="line">               setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">                   attrs.restore();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查 IPC 的结果，若不是 ADD_OKAY ，就说明添加 window 失败</span></span><br><span class="line">	<span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">               mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">               mAdded = <span class="keyword">false</span>;</span><br><span class="line">               mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">               unscheduleTraversals();</span><br><span class="line">               setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is not valid; is your activity running?"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is not for an application"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_APP_EXITING:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- app for token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is exiting"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_DUPLICATE_ADD:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- window "</span> + mWindow</span><br><span class="line">                               + <span class="string">" has already been added"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:</span><br><span class="line">                       <span class="comment">// Silently ignore -- we would have just removed it</span></span><br><span class="line">                       <span class="comment">// right away, anyway.</span></span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- another window of type "</span></span><br><span class="line">                               + mWindowAttributes.type + <span class="string">" already exists"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_PERMISSION_DENIED:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- permission denied for window type "</span></span><br><span class="line">                               + mWindowAttributes.type);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_INVALID_DISPLAY:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.InvalidDisplayException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- the specified display can not be found"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_INVALID_TYPE:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.InvalidDisplayException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- the specified window type "</span></span><br><span class="line">                               + mWindowAttributes.type + <span class="string">" is not valid"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to add window -- unknown error code "</span> + res);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，View 也开始了测量、布局、绘制的三大流程。</p>
<p>之后，利用 <code>mWindowSession</code> 来添加 window ，<code>mWindowSession</code> 的类型是 IWindowSession ，它是一个 Binder 对象，其真正的实现类是 Session 。所以这是一个 IPC 的过程。这步具体的实现我们下面再看。</p>
<p>在添加完成后，根据返回值 res 来判断添加 window 是否成功。若不是 WindowManagerGlobal.ADD_OKAY 则说明添加失败了，抛出对应的异常。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="addToDisplay_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29"><a href="#addToDisplay_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29" class="headerlink" title="addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)"></a>addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Session 中，发现添加 Window 的操作交给了 mService ，而 mService 其实就是 WindowManagerService 。终于来到了最终 boss 这里了，那我们直击要害吧！</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><h3 id="addWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29"><a href="#addWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29" class="headerlink" title="addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)"></a>addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="line">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 校验 window 的权限，如果不是 ADD_OKAY 就不通过</span></span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">// 初步校验一些参数，不通过就会返回错误的 res 值 </span></span><br><span class="line">    <span class="comment">// 比如检查子窗口，就要求父窗口必须已经存在等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 拿到 layoutparams.token ，进行校验</span></span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 token 有效性， 如果 token 为空或不正确的话，那么直接返回 ADD_BAD_APP_TOKEN 等异常</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.appWindowToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.w(TAG_WM, <span class="string">"Non-null appWindowToken for system window of type="</span> + type);</span><br><span class="line">        <span class="comment">// It is not valid to use an app token with other system types; we will</span></span><br><span class="line">        <span class="comment">// instead make a new token for it (as if null had been passed in for the token).</span></span><br><span class="line">        attrs.token = <span class="keyword">null</span>;</span><br><span class="line">        token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, <span class="keyword">null</span>, -<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        addToken = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新窗口创建了新的 WindowState 对象</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">    res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">        mInputMethodWindow = win;</span><br><span class="line">        addInputMethodWindowToListLocked(win);</span><br><span class="line">        imMayMove = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">        mInputMethodDialogs.add(win);</span><br><span class="line">        <span class="comment">// 将新的 WindowState 按显示次序插入到当前 DisplayContent 的 mWindows 列表中</span></span><br><span class="line">        addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">        moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">        imMayMove = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将新的 WindowState 按显示次序插入到当前 DisplayContent 的 mWindows 列表中</span></span><br><span class="line">        addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">            mWallpaperControllerLocked.clearLastWallpaperTimeoutTime();</span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWallpaperControllerLocked.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">            <span class="comment">// If there is currently a wallpaper being shown, and</span></span><br><span class="line">            <span class="comment">// the base layer of the new window is below the current</span></span><br><span class="line">            <span class="comment">// layer of the target window, then adjust the wallpaper.</span></span><br><span class="line">            <span class="comment">// This is to avoid a new window being placed between the</span></span><br><span class="line">            <span class="comment">// wallpaper and its target.</span></span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据窗口的排序结果，为 DisplayContent 的所有窗口分配最终的显示次序</span></span><br><span class="line">    mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回添加窗口的结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 WindowManagerService 中做的事情有很多，一开始利用 <code>mPolicy.checkAddPermission</code> 检查了权限，这里面可大有文章，利用 <code>type = WindowManager.LayoutParams.TYPE_TOAST</code> 来跳过权限显示悬浮窗的故事就来自于这里。想详细了解的同学请看<a href="http://blog.csdn.net/self_study/article/details/52859790" target="_blank" rel="external">《Android 悬浮窗权限各机型各系统适配大全》</a>。</p>
<p>然后就是校验了一些参数，比如 token 。token 是用来表示窗口的一个令牌，其实是一个 Binder 对象。只有符合条件的 token 才能被 WindowManagerService 通过并添加到应用上。</p>
<p>再然后就是创建了一个 WindowState 对象，利用这个对象按照显示次序插入 mWindows 列表中，最后就是依据排序来确定窗口的最终显示次序。并返回了 Window 添加的结果 res 。</p>
<p>到这，整个添加 Window 的过程就结束了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>Window 添加其实就是一个 IPC 的过程，而更新和删除 Window 也是如此，基本上步骤都是相似的。</p>
<p>接下来就顺便把 Window 更新和删除的流程都梳理一遍吧。</p>
<p>静静等待此系列第三篇出炉！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/innost/article/details/47660193" target="_blank" rel="external">《深入理解Android 卷III》第四章 深入理解WindowManagerService</a></li>
<li><a href="http://blog.csdn.net/self_study/article/details/52859790" target="_blank" rel="external">Android 悬浮窗权限各机型各系统适配大全</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(一)：与DecorView的那些事]]></title>
    <link href="http://yuqirong.me/2017/09/28/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%EF%BC%9A%E4%B8%8EDecorView%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yuqirong.me/2017/09/28/Window源码解析(一)：与DecorView的那些事/</id>
    <published>2017-09-28T06:39:03.000Z</published>
    <updated>2017-10-11T13:02:54.903Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>今天我们来讲讲 Window ，Window 代表着一个窗口。</p>
<p>比如在 Activity 中，我们可以设置自定义的视图 View ，其实 View 并不是直接附着在 Activity 上，而是 View 附着在 Window 上，Activity 又持有一个 Window 对象。可见，Window 是一个重要的角色，主要用来负责管理 View 的。而 Window 和 View 又是通过 ViewRootImpl 来建立联系的，这在之前的<a href="/2017/09/18/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">《View的工作原理》</a>中介绍过。</p>
<p>所以一个 Window 就对应着一个 View 和一个 ViewRootImpl 。</p>
<p>同理，Dialog 和 Toast 等的视图也都是附着在 Window 上。</p>
<p>除此之外，相信看过《Android开发艺术探索》的同学都知道。Window 有三种类型，分别对应着：</p>
<ol>
<li>应用 Window ，即 Activity 的 Window 。对应的 type 为1~99；</li>
<li>子 Window ，比如 Dialog 的 Window ，子 Window 并不能单独存在，需要有父 Window 的支持。对应的 type 为1000~1999；</li>
<li>系统 Window ，需要权限声明才可以创建，比如常用的 Toast 和状态栏等都是系统级别的 Window。对应的 type 为2000~2999；</li>
</ol>
<p>这三种 Window 的区分方法就是依靠 WindowManager.LayoutParams 中的 type 来决定的。type 越大，Window 就越显示在层级顶部。</p>
<p>粗看有这么多知识点，所以我们确实有必要对 Window 好好深入了解一下。在这，我们先详细介绍一下 Window 和 Activity 的那些“纠葛”，然后再深入 Window 的内部机制。</p>
<h1 id="u521D_u89C1Window"><a href="#u521D_u89C1Window" class="headerlink" title="初见Window"></a>初见Window</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="attach_28Context_context_2C_ActivityThread_aThread_2C__u2026_29"><a href="#attach_28Context_context_2C_ActivityThread_aThread_2C__u2026_29" class="headerlink" title="attach(Context context, ActivityThread aThread, …)"></a>attach(Context context, ActivityThread aThread, …)</h3><p>Window 第一次出现在 Activity 的视野中，是在 Activity 的 <code>attach</code> 方法中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 window 对象</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置回调，用来回调接收触摸、按键等事件</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置窗口管理器，其实是创建了 WindowManagerImpl 对象</span></span><br><span class="line">    <span class="comment">// WindowManager 是接口，而 WindowManagerImpl 是 WindowManger 的实现类</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中创建了一个 PhoneWindow 对象，而 PhoneWindow 其实就是 Window 的具体实现类，Window 只是一个接口而已。之后设置了回调，这样当 Window 接收到触摸或者按键等事件后，会回调给 Activity 。</p>
<p>另外还给 Window 对象设置了窗口管理器，也就是我们经常用到的 WindowManager 。</p>
<p>WindowManager 是外界接触 Window 的入口，也就是说，想要对 Window 进行一些操作需要用过 WindowManager 来完成。</p>
<h1 id="u4E0EDecorView_u7684_u90A3_u4E9B_u4E8B"><a href="#u4E0EDecorView_u7684_u90A3_u4E9B_u4E8B" class="headerlink" title="与DecorView的那些事"></a>与DecorView的那些事</h1><p>在开头中说到，Window 是用来负责管理 View 的。</p>
<p>现在 Window 已经创建完毕了，那么到底什么时候与 View 发生了交集了呢？</p>
<p>我们需要深入到 <code>onCreate()</code> 中一个熟悉的方法： <code>setContentView(R.layout.activity_main)</code> 。</p>
<h2 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h2><h3 id="setContentView_28@LayoutRes_int_layoutResID_29"><a href="#setContentView_28@LayoutRes_int_layoutResID_29" class="headerlink" title="setContentView(@LayoutRes int layoutResID)"></a>setContentView(@LayoutRes int layoutResID)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里 getWindow 得到的正是上面创建的 PhoneWindow 对象</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它调用的是 Window 中的同名方法。</p>
<p>接着到 PhoneWindow 中跟进，查看具体实现的逻辑。</p>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><h3 id="setContentView_28int_layoutResID_29"><a href="#setContentView_28int_layoutResID_29" class="headerlink" title="setContentView(int layoutResID)"></a>setContentView(int layoutResID)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">      <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">      <span class="comment">// before this happens.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mContentParent 是放置窗口内容的父 viewgroup ，可能是 decorView 本身，也有可能是它的子 viewgroup</span></span><br><span class="line"><span class="comment">// 如果 mContentParent 是空的，那么就说明 decorView 是空的</span></span><br><span class="line">      <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建 decorview</span></span><br><span class="line">          installDecor();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">          mContentParent.removeAllViews();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">          <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                  getContext());</span><br><span class="line">          transitionTo(newScene);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 将 layout 布局加入到 mContentParent 中并去解析 layout xml 文件</span></span><br><span class="line">          mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">      &#125;</span><br><span class="line">      mContentParent.requestApplyInsets();</span><br><span class="line"><span class="comment">// 通知 activity 窗口内容已经发生变化了</span></span><br><span class="line">      <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">      <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">          cb.onContentChanged();</span><br><span class="line">      &#125;</span><br><span class="line">      mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setContentView(int layoutResID)</code> 中，一开始判断了 mContentParent 。mContentParent 其实就是我们设置的 contentView 的父视图。</p>
<p>关于 mContentParent ，在 PhoneWindow 中有注释：</p>
<pre><code>// This is the view in which the window contents are placed. It is either
// mDecor itself, or a child of mDecor where the contents go.
</code></pre><p>意思就是说，当我们不需要 titlebar 的时候，mContentParent 其实就和 DecorView 一样了；有 titlebar 的时候，DecorView 的内容就分为了 titlebar 和 mContentParent 。</p>
<p>所以如果 mContentParent 为空，那么可以说明还没有创建过 DecorView 。</p>
<p>我们总结一下，在 <code>setContentView(int layoutResID)</code> 中主要就是这三件事：</p>
<ol>
<li>创建 DecorView 视图对象；</li>
<li>将自定义的视图 layout_main.xml 进行解析并添加到 mContentParent 中；</li>
<li>去通知 activity 窗口视图已经改变了，进行相关操作；</li>
</ol>
<p>我们去 <code>installDecor()</code> 中看看究竟怎么创建 DecorView 的。</p>
<h3 id="installDecor_28_29"><a href="#installDecor_28_29" class="headerlink" title="installDecor()"></a>installDecor()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 decorview 为空，调用 generateDecor 来创建 decorview</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 mContentParent ，也就是 contentView 的父视图</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>installDecor()</code> 中，调用了 <code>generateDecor()</code> 方法来创建 DecorView；</p>
<p>之后又调用 <code>generateLayout(mDecor)</code> 来创建 mContentParent 。</p>
<h3 id="generateDecor_28int_featureId_29"><a href="#generateDecor_28int_featureId_29" class="headerlink" title="generateDecor(int featureId)"></a>generateDecor(int featureId)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 context 上下文</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, getContext().getResources());</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 DecorView 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>generateDecor(int featureId)</code> 方法比较简单，之前初始化了一下 context ，然后直接 new 了一个 DecorView 完事！</p>
<h3 id="generateLayout_28DecorView_decor_29"><a href="#generateLayout_28DecorView_decor_29" class="headerlink" title="generateLayout(DecorView decor)"></a>generateLayout(DecorView decor)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 应用当前的主题，比如设置一些 window 属性等</span></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据主题设置去选择 layoutResource</span></span><br><span class="line">    <span class="comment">// 这个 layoutResource 也就是 DecorView 的子 View 的布局</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 比较常见的就是这种布局</span></span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    <span class="comment">// 这个方法里将上面 layoutResource 的布局转换并添加到 DecorVew 中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">// 得到 contentParent（id = android.R.id.content）, 也就是我们 setContentView 的父视图</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            progress.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        registerSwipeCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining setup -- of background and title -- that only applies</span></span><br><span class="line">    <span class="comment">// to top-level windows.</span></span><br><span class="line">    <span class="comment">// 背景设置和标题设置</span></span><br><span class="line">    <span class="keyword">if</span> (getContainer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background;</span><br><span class="line">        <span class="keyword">if</span> (mBackgroundResource != <span class="number">0</span>) &#123;</span><br><span class="line">            background = getContext().getDrawable(mBackgroundResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            background = mBackgroundDrawable;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable frame;</span><br><span class="line">        <span class="keyword">if</span> (mFrameResource != <span class="number">0</span>) &#123;</span><br><span class="line">            frame = getContext().getDrawable(mFrameResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frame = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">        mDecor.setElevation(mElevation);</span><br><span class="line">        mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitleColor == <span class="number">0</span>) &#123;</span><br><span class="line">            mTitleColor = mTextColor;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitleColor(mTitleColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中大致的逻辑就是，根据主题的设置情况来选择 DecorView 子 View 的 layoutResource 。在这，我们就看看最常用的一种布局 R.layout.screen_title (位于 /frameworks/base/core/res/res/layout/screen_title.xml ):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">    <span class="attribute">android:fitsSystemWindows</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ViewStub</span> <span class="attribute">android:id</span>=<span class="value">"@+id/action_mode_bar_stub"</span></span><br><span class="line">              <span class="attribute">android:inflatedId</span>=<span class="value">"@+id/action_mode_bar"</span></span><br><span class="line">              <span class="attribute">android:layout</span>=<span class="value">"@layout/action_mode_bar"</span></span><br><span class="line">              <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">              <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">              <span class="attribute">android:theme</span>=<span class="value">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">FrameLayout</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span> </span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"?android:attr/windowTitleSize"</span></span><br><span class="line">        <span class="attribute">style</span>=<span class="value">"?android:attr/windowTitleBackgroundStyle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@android:id/title"</span> </span><br><span class="line">            <span class="attribute">style</span>=<span class="value">"?android:attr/windowTitleStyle"</span></span><br><span class="line">            <span class="attribute">android:background</span>=<span class="value">"@null"</span></span><br><span class="line">            <span class="attribute">android:fadingEdge</span>=<span class="value">"horizontal"</span></span><br><span class="line">            <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">FrameLayout</span> <span class="attribute">android:id</span>=<span class="value">"@android:id/content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span> </span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"0dip"</span></span><br><span class="line">        <span class="attribute">android:layout_weight</span>=<span class="value">"1"</span></span><br><span class="line">        <span class="attribute">android:foregroundGravity</span>=<span class="value">"fill_horizontal|top"</span></span><br><span class="line">        <span class="attribute">android:foreground</span>=<span class="value">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，DecorView 的子 View 其实是一个 LinearLayout ，而 LinearLayout 中有分为 titlebar 和 id 为 android:id/content 的 FrameLayout（其实就是 mContentParent）。</p>
<p>之后将这个视图创建出来并添加到 DecorView 中。</p>
<p>具体的代码可以深入 DecorView 的 <code>onResourcesLoaded(LayoutInflater inflater, int layoutResource)</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    mStackId = getStackId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBackdropFrameRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBackgroundDrawablesIfNeeded();</span><br><span class="line">        mBackdropFrameRenderer.onResourcesLoaded(</span><br><span class="line">                <span class="keyword">this</span>, mResizingBackgroundDrawable, mCaptionBackgroundDrawable,</span><br><span class="line">                mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState),</span><br><span class="line">                getCurrentColor(mNavigationColorViewState));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    <span class="comment">// 解析之前选择出来的 layoutResource ，该 root 也就是 DecorView 的直接子 View</span></span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Put it below the color views.</span></span><br><span class="line">        <span class="comment">// 将 root 视图添加到 DecorView 中</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以看出成员变量 mContentRoot 就是 DecorView 的直接子 View</span></span><br><span class="line">    <span class="comment">// 也就是 mContentParent 的父视图</span></span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这，我们可以画一张图出来了，把 PhoneWindow 、DecorView 和 mContentParent 都理清楚：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170928/20170928102356.jpg" alt="View层级"> </p>
<p>然后进行标题设置之类的工作。最后得到并返回 mContentParent 。</p>
<p>到了这里，基本上把 Window 、DecorView 和 Activity 三者之间的关系整理清楚了，但是事情并没有结束。这时候的 DecorView 并没有真正添加到 Window 上去，只是创建出对象了并解析了视图而已。DecorView 还没有被 WindowManager 识别，Window 也还无法接受外界的输入信息。</p>
<p>那么，到底 DecorView 是什么时候附着到 Window 上去的？</p>
<p>这个答案需要我们到 ActivityThread 的 <code>handleResumeActivity()</code> 中找找了。回调  Activity 的 <code>onResume()</code> 生命周期后，又调用了 Activity 的 <code>makeVisible()</code> 方法。</p>
<h2 id="Activity-2"><a href="#Activity-2" class="headerlink" title="Activity"></a>Activity</h2><h3 id="makeVisible_28_29"><a href="#makeVisible_28_29" class="headerlink" title="makeVisible()"></a>makeVisible()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        <span class="comment">// WindowManager 是 ViewManager 的实现类</span></span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        <span class="comment">// 将 decorview 添加到 window 中</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 decorview 可见</span></span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>走完这步，DecorView 才完成添加和显示出来，Activity 的视图才能被用户看到。</p>
<p>整个 Window 创建的流程也结束了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>Window 和 Decor 的“爱恨情仇”到这里就告一段落了，但是 Window 的内部机制我们还可以好好叙一叙。</p>
<p>注意到上面 WindowManager 的 <code>addView</code> 方法了吧？</p>
<p>Window 是怎么添加上去的，究竟在这里面发生了什么事呢？</p>
<p>只能留到下一篇再详细讲讲了。</p>
<p>bye bye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/NZ1GFkEn4UGNljYPVpdfhw" target="_blank" rel="external">结合源码，探索Android中的Window与DecorView</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>今天我们]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <link href="http://yuqirong.me/2017/09/18/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2017/09/18/View的工作原理/</id>
    <published>2017-09-18T14:35:00.000Z</published>
    <updated>2017-09-21T13:38:35.602Z</updated>
    <content type="html"><![CDATA[<p>注：本文分析的源码基于 Android API 25</p>
<h1 id="View_u7ED8_u5236_u7684_u8D77_u70B9"><a href="#View_u7ED8_u5236_u7684_u8D77_u70B9" class="headerlink" title="View绘制的起点"></a>View绘制的起点</h1><h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29"><a href="#addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29" class="headerlink" title="addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)"></a>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</h3><p>在 <code>WindowManagerGlobal</code> 的 <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code> 方法中，创建了 <code>ViewRootImpl</code> 对象，将 <code>ViewRootImpl</code> 和 <code>DecorView</code> 相关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// view 是 PhoneWindow 的 DecorView</span></span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p><code>ViewRootImpl</code> 是用来连接 WindowManager 和 DecorView 的桥梁。通俗地来讲，Window 和 View 就是通过 <code>ViewRootImpl</code> 来建立联系的。</p>
<p>而 DecorView 是顶级的 View ，从它开始向下传递 measure 、 layout 和 draw 三个流程。</p>
<p>创建好了 <code>root</code> 之后，调用了 <code>ViewRootImpl</code> 的 <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</code> 方法。</p>
<p>将 DecorView 和 ViewRootImpl 相关联。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29"><a href="#setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29" class="headerlink" title="setView(View view, WindowManager.LayoutParams attrs, View panelParentView)"></a>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 将 decorView 设置给全局的 mView</span></span><br><span class="line">               mView = view;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 标记已经添加了 decorView</span></span><br><span class="line">			mAdded = <span class="keyword">true</span>;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 第一次发起布局，在添加到 WindowManager 之前</span></span><br><span class="line">			<span class="comment">// 确保在接收其他系统事件之前完成重新布局</span></span><br><span class="line">			requestLayout();</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 利用 mWindowSession 以跨进程的方式向 WMS 发起一个调用，从而将DecorView 最终添加到 Window 上</span></span><br><span class="line">		  	<span class="keyword">try</span> &#123;</span><br><span class="line">		  	    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">		  	    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">		  	    collectViewAttributes();</span><br><span class="line">		  	    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">               &#125; </span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</code> 方法中，主要做的事情有：</p>
<ol>
<li>保存 DecorView</li>
<li>第一次调用 <code>requestLayout()</code> ，发起整个 View 的绘制流程</li>
<li>将 View 添加到 Window 上去</li>
</ol>
<p>而在这，我们重点关注 <code>requestLayout()</code> 方法，因为恰恰这句代码引发了整个 View 的绘制。</p>
<h3 id="requestLayout_28_29"><a href="#requestLayout_28_29" class="headerlink" title="requestLayout()"></a>requestLayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="annotation">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line"><span class="comment">// 检查当前线程</span></span><br><span class="line">         checkThread();</span><br><span class="line">         mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 调用绘制</span></span><br><span class="line">         scheduleTraversals();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>requestLayout()</code> 中先检查了线程，若 OK 后调用 <code>scheduleTraversals()</code> 。</p>
<h3 id="scheduleTraversals_28_29"><a href="#scheduleTraversals_28_29" class="headerlink" title="scheduleTraversals()"></a>scheduleTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">		<span class="comment">// 发送消息，调用 mTraversalRunnable</span></span><br><span class="line">           mChoreographer.postCallback(</span><br><span class="line">                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">               scheduleConsumeBatchedInput();</span><br><span class="line">           &#125;</span><br><span class="line">           notifyRendererOfFramePending();</span><br><span class="line">           pokeDrawLockIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 内部调用了 performTraversals()</span></span><br><span class="line">           doTraversal();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>scheduleTraversals()</code> 中，其实是这样的：</p>
<p>scheduleTraversals() -&gt; 调用 mTraversalRunnable -&gt; doTraversal() -&gt; performTraversals()</p>
<p>所以最后还是要看 <code>performTraversals()</code> 。</p>
<h3 id="performTraversals_28_29"><a href="#performTraversals_28_29" class="headerlink" title="performTraversals()"></a>performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算 Activity 中 window 的宽高等等</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                       (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                       || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                       updatedConfiguration) &#123;</span><br><span class="line">                   <span class="comment">// 得到 view 宽高的规格</span></span><br><span class="line">                   <span class="comment">// mWidth 和 mHeight 即用来描述 Activity 窗口宽度和高度</span></span><br><span class="line">                   <span class="comment">// lp.width 和 lp.height 就是 DecorView 的宽高</span></span><br><span class="line">                   <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                   <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Ooops, something changed!  mWidth="</span></span><br><span class="line">                           + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</span><br><span class="line">                           + <span class="string">" mHeight="</span> + mHeight</span><br><span class="line">                           + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</span><br><span class="line">                           + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                    <span class="comment">// 开始执行测量工作，测量是从这里发起的</span></span><br><span class="line">                   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">                   <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">                   <span class="comment">// needs be</span></span><br><span class="line">                   <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                   <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                   <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 检查是否需要重新测量</span></span><br><span class="line">                   <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                       width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                       childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                       height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 需要再次测量的话，就再执行一遍 performMeasure</span></span><br><span class="line">                   <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                               <span class="string">"And hey let's measure once more: width="</span> + width</span><br><span class="line">                               + <span class="string">" height="</span> + height);</span><br><span class="line">                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">       <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">               || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">       <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">           <span class="comment">// 执行布局工作，布局是从这里发起的</span></span><br><span class="line">           performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                   mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingTransitions.clear();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 执行绘制工作，绘制是从这里发起的</span></span><br><span class="line">           performDraw();</span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performTraversals()</code> 方法的代码很长很长，但是我们关注点就可以放在三大流程上。其他的代码因为自己能力欠缺，并不能一一说出这些代码的作用。所以我们接下来就把重点放在：</p>
<ol>
<li>getRootMeasureSpec</li>
<li>performMeasure</li>
<li>performLayout</li>
<li>performDraw</li>
</ol>
<h1 id="u4E09_u5927_u6D41_u7A0B"><a href="#u4E09_u5927_u6D41_u7A0B" class="headerlink" title="三大流程"></a>三大流程</h1><h2 id="ViewRootImpl-1"><a href="#ViewRootImpl-1" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="measureHierarchy_28final_View_host_2C_final_WindowManager-LayoutParams_lp_2C_final_Resources_res_2C_final_int_desiredWindowWidth_2C_final_int_desiredWindowHeight_29"><a href="#measureHierarchy_28final_View_host_2C_final_WindowManager-LayoutParams_lp_2C_final_Resources_res_2C_final_int_desiredWindowWidth_2C_final_int_desiredWindowHeight_29" class="headerlink" title="measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)"></a>measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)</h3><p>其实在 <code>performTraversals()</code> 中有一句代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">        desiredWindowWidth, desiredWindowHeight);</span><br></pre></td></tr></table></figure>
<p>在 <code>measureHierarchy</code> 方法中已经调用了 <code>performMeasure</code> 来进行测量。不过作用不同，只是为了确定 window 的大小而做的测量辅助。所以可以说，并不算上在三大流程中。</p>
<p>在 <code>measureHierarchy</code> 中，确定了 DecorView 的 <code>MeasureSpec</code> 。其中 <code>childWidthMeasureSpec</code> 和 <code>childHeightMeasureSpec</code> 即为 DecorView 对应的 <code>MeasureSpec</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// desiredWindowWidth 和 desiredWindowHeight 是屏幕的宽高</span></span><br><span class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br></pre></td></tr></table></figure>
<h3 id="getRootMeasureSpec_28int_windowSize_2C_int_rootDimension_29"><a href="#getRootMeasureSpec_28int_windowSize_2C_int_rootDimension_29" class="headerlink" title="getRootMeasureSpec(int windowSize, int rootDimension)"></a>getRootMeasureSpec(int windowSize, int rootDimension)</h3><p>那么就来看看 <code>getRootMeasureSpec</code> 咯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简洁，也很易懂。</p>
<ol>
<li>如果是 MATCH_PARENT ，那么对应的就是窗口大小；</li>
<li>如果是 WRAP_CONTENT ，那么不能超过窗口大小；</li>
<li>固定大小，那么就是大小就是传入的 lp.width/lp.height 了。</li>
</ol>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="getChildMeasureSpec_28int_spec_2C_int_padding_2C_int_childDimension_29"><a href="#getChildMeasureSpec_28int_spec_2C_int_padding_2C_int_childDimension_29" class="headerlink" title="getChildMeasureSpec(int spec, int padding, int childDimension)"></a>getChildMeasureSpec(int spec, int padding, int childDimension)</h3><p>顺便，我们把平时自定义 ViewGroup 计算子 View 测量规格的 <code>getChildMeasureSpec</code> 方法也一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父容器的 mode</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="comment">// 父容器的 size</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="comment">// 子 view 可以使用空间，即父容器的 size - padding</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 switch/case 代码比较简单，而且容易理解。我们可以整理为一张表格（该表格来自于《Android开发艺术探索》）：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170918/20170821150637571.png" alt="measurespec"></p>
<p>在这里，我们小结一下。对于 DecorView 来说，其 <code>MeasureSpec</code> 是由窗口的大小和自身的 <code>LayoutParams</code> 来共同决定的；而对于普通的 View 来说，其 <code>MeasureSpec</code> 是由父容器的 <code>MeasureSpec</code> 和自身的 <code>LayoutParams</code> 共同决定的。</p>
<h1 id="measure_u8FC7_u7A0B"><a href="#measure_u8FC7_u7A0B" class="headerlink" title="measure过程"></a>measure过程</h1><h2 id="ViewRootImpl-2"><a href="#ViewRootImpl-2" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performMeasure_28int_childWidthMeasureSpec_2C_int_childHeightMeasureSpec_29"><a href="#performMeasure_28int_childWidthMeasureSpec_2C_int_childHeightMeasureSpec_29" class="headerlink" title="performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)"></a>performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)</h3><p>分析 measure 过程，我们的起点就是在 <code>ViewRootImpl</code> 的 <code>performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行测量</span></span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performMeasure</code> 中调用了 <code>measure</code> 方法。说到底，DecorView 只是一个所以我们又要进入 <code>View</code> 类中去看下。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h3 id="measure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29"><a href="#measure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29" class="headerlink" title="measure(int widthMeasureSpec, int heightMeasureSpec)"></a>measure(int widthMeasureSpec, int heightMeasureSpec)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">               <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">               <span class="comment">// 调用 onMeasure</span></span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">               <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">               setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>View</code> 的 <code>measure</code> 方法内部是调用了 <code>onMeasure</code> 。所以我们还要接着跟进到 <code>onMeasure</code> 中才行。另外， <code>measure</code> 方法是用 final 修饰的，所以子类是无法进行重写的。</p>
<h2 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><h3 id="onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29"><a href="#onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29" class="headerlink" title="onMeasure(int widthMeasureSpec, int heightMeasureSpec)"></a>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</h3><p>这里小提一下，我们都知道 DecorView 其实是一个 <code>FrameLayout</code> ，所以 <code>onMeasure</code> 应该在 <code>FrameLayout</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">// 判断当前 framelayout 布局的宽高是否至少一个是 match_parent 或者精确值 ，如果是则置 measureMatchParent 为 false .</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历不为 GONE 的子 view</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// 对每一个子 View 进行测量</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">// 寻找子 View 中宽高的最大者，因为如果 FrameLayout 是 wrap_content 属性</span></span><br><span class="line">            <span class="comment">// 那么它的宽高取决于子 View 中的宽高最大者</span></span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="comment">// 如果 FrameLayout 为 wrap_content 且 子 view 的宽或高为 match_parent ，那么就添加到 mMatchParentChildren 中</span></span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置测量结果</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子View中设置为match_parent的个数</span></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="comment">// 若 FrameLayout 为 wrap_content 且 count &gt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果子 View 的宽度是 match_parent 属性，那么对 childWidthMeasureSpec 修改：</span></span><br><span class="line">            <span class="comment">// 把 widthMeasureSpec 的宽度修改为:framelayout总宽度 - padding - margin，模式设置为 EXACTLY</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就按照正常的来就行了</span></span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 高度同理</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对于这部分的子 View 需要重新进行 measure 过程</span></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面 <code>FrameLayout</code> 的 <code>onMeasure</code> 流程没看懂的话也没关系。其实总的来说重要的就只有遍历 <code>child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</code> 这个方法，这是将父容器的 measure 过程传递到子 View 中。</p>
<h2 id="ViewGroup-1"><a href="#ViewGroup-1" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="measureChildWithMargins_28View_child_2C_int_parentWidthMeasureSpec_2C_int_widthUsed_2C_int_parentHeightMeasureSpec_2C_int_heightUsed_29"><a href="#measureChildWithMargins_28View_child_2C_int_parentWidthMeasureSpec_2C_int_widthUsed_2C_int_parentHeightMeasureSpec_2C_int_heightUsed_29" class="headerlink" title="measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)"></a>measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)</h3><p>可能有些人也有疑问，在上面 <code>measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0)</code> 后也没看到有 <code>child.measure</code> 的方法啊，这是因为在 <code>measureChildWithMargins</code> 中内部调用了 <code>child.measure</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span><br><span class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span><br><span class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="comment">// getChildMeasureSpec 我们上面分析过了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">    <span class="comment">// measure 传递给子 View</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下明白了吧？父容器就是遍历调用了 <code>child.measure</code> 这个方法将 measure 过程传递给每一个子 View 的。虽然不同的父容器 <code>onMeasure</code> 方法都不一样，但是相同的是，他们都会遍历调用 <code>child.measure</code> 。</p>
<h2 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h2><h3 id="onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29-1"><a href="#onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29-1" class="headerlink" title="onMeasure(int widthMeasureSpec, int heightMeasureSpec)"></a>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</h3><p>上面我们也讲过，<code>measure</code> 方法内部其实是调用了 <code>onMeasure</code> ，所以子 View 被父容器调用了 <code>measure</code> 后，也会调用属于自己的 <code>onMeasure</code> 方法。那么我们就直接看向 <code>View</code> 的 <code>onMeasure</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onMeasure</code> 方法只有一句代码，所以重点就是 <code>getDefaultSize(int size, int measureSpec)</code> 咯。</p>
<p><code>getSuggestedMinimumWidth()</code> 内部逻辑：</p>
<ol>
<li>若没有设置背景，就是 <code>android:minWidth</code> 的值；</li>
<li>若有设置背景，就是 max(android:minWidth, 背景 Drawable 的原始宽度)</li>
</ol>
<p><code>getSuggestedMinimumHeight()</code> 也是同理。</p>
<h3 id="getDefaultSize_28int_size_2C_int_measureSpec_29"><a href="#getDefaultSize_28int_size_2C_int_measureSpec_29" class="headerlink" title="getDefaultSize(int size, int measureSpec)"></a>getDefaultSize(int size, int measureSpec)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 直接返回 specSize</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到：</p>
<ul>
<li>若是 UNSPECIFIED ，则直接返回的就是 <code>getSuggestedMinimumWidth/getSuggestedMinimumHeight</code> 的值；</li>
<li>若是 AT_MOST/EXACTLY ，直接用的就是 specSize 。</li>
</ul>
<p>而根据我们之前总结出来的表可知，只要 view 不指定固定大小，那么无论是 AT_MOST 还是 EXACTLY ，都是按照 parentSize 来的。</p>
<p>这也是为什么我们在自定义 View 时，如果不重写 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> ，wrap_content 和 match_parent 效果一样的原因。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>我们把 measure 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performMeasure -&gt; DecorView.measure -&gt; DecorView.onMeasure -&gt; DecorView.measureChildWithMargins -&gt; ViewGroup.measure -&gt; ViewGroup.onMeasure -&gt; ViewGroup.measureChildWithMargins -&gt; … -&gt; View.measure -&gt; View.onMeasure</p>
<p>注：DecorView 其实就是 FrameLayout</p>
<h1 id="layout_u8FC7_u7A0B"><a href="#layout_u8FC7_u7A0B" class="headerlink" title="layout过程"></a>layout过程</h1><h2 id="ViewRootImpl-3"><a href="#ViewRootImpl-3" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performLayout_28WindowManager-LayoutParams_lp_2C_int_desiredWindowWidth_2C_int_desiredWindowHeight_29"><a href="#performLayout_28WindowManager-LayoutParams_lp_2C_int_desiredWindowWidth_2C_int_desiredWindowHeight_29" class="headerlink" title="performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)"></a>performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)</h3><p>在上面分析过，layout 过程是从 <code>ViewRootImpl</code> 中的 <code>performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)</code> 开始的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span><br><span class="line">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Laying out "</span> + host + <span class="string">" to ("</span> +</span><br><span class="line">                host.getMeasuredWidth() + <span class="string">", "</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// host 就是 DecorView，调用了 layout 方法开始布局</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// mLayoutRequesters 为需要重新请求布局的 view 集合数</span></span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码主要用于若有请求重新布局的 view ，那么再进行重新布局</span></span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">            <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">            <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">            <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                <span class="comment">// frame instead</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// view 请求布局，进行重新测量和布局</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                            <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对整个View树进行重新测量</span></span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进行第二次布局</span></span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                        <span class="string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本可知，<code>performLayout</code> 是通过调用 DecorView 的 <code>layout</code> 方法来向下传递布局的。所以我们应该继续追踪 <code>FrameLayout</code> 的 <code>layout</code> 方法，其实就是 <code>ViewGroup</code> 的 <code>layout</code> 方法。</p>
<h2 id="ViewGroup-2"><a href="#ViewGroup-2" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29"><a href="#layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29" class="headerlink" title="layout(int l, int t, int r, int b)"></a>layout(int l, int t, int r, int b)</h3><p><code>FrameLayout</code> 的 <code>layout</code> 是父类 <code>ViewGroup</code> 实现的，添加了 final 修饰符，无法被重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 view 的 layout 方法</span></span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ViewGroup</code> 的 <code>layout</code> 方法中又调用了父类的方法 <code>super.layout(l, t, r, b)</code> 。所以我们又要到 <code>View</code> 类中去看。</p>
<h2 id="View-2"><a href="#View-2" class="headerlink" title="View"></a>View</h2><h3 id="layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29-1"><a href="#layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29-1" class="headerlink" title="layout(int l, int t, int r, int b)"></a>layout(int l, int t, int r, int b)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前布局的四个顶点</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算四个顶点的值，判断布局位置是否改变</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果视图的大小和位置发生变化，会调用onLayout()</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空方法</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用布局位置改变监听器</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中做了这几件事：</p>
<ol>
<li>设置当前布局中的四个顶点；</li>
<li>调用 <code>setFrame</code> 来设置新的顶点位置；</li>
<li>调用 <code>onLayout</code> 方法；</li>
<li>回调布局位置改变监听器；</li>
</ol>
<h3 id="setOpticalFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#setOpticalFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="setOpticalFrame(int left, int top, int right, int bottom)"></a>setOpticalFrame(int left, int top, int right, int bottom)</h3><p>我们先来看 <code>setOpticalFrame</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">            ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line">    Insets childInsets = getOpticalInsets();</span><br><span class="line">    <span class="comment">// 调用 setFrame 方法</span></span><br><span class="line">    <span class="keyword">return</span> setFrame(</span><br><span class="line">            left   + parentInsets.left - childInsets.left,</span><br><span class="line">            top    + parentInsets.top  - childInsets.top,</span><br><span class="line">            right  + parentInsets.left + childInsets.right,</span><br><span class="line">            bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 <code>setOpticalFrame</code> 的内部也是调用 <code>setFrame</code> 方法的。</p>
<h3 id="setFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#setFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="setFrame(int left, int top, int right, int bottom)"></a>setFrame(int left, int top, int right, int bottom)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        Log.d(<span class="string">"View"</span>, <span class="keyword">this</span> + <span class="string">" View.setFrame("</span> + left + <span class="string">","</span> + top + <span class="string">","</span></span><br><span class="line">                + right + <span class="string">","</span> + bottom + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新值和旧值不相等，那就是布局位置改变了</span></span><br><span class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算新的宽高和旧的宽高</span></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">// 判断大小是否改变</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 view 的上下左右，赋予最新的值</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调大小改变的方法</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are visible, force the DRAWN bit to on so that</span></span><br><span class="line">            <span class="comment">// this invalidate will go through (at least to our parent).</span></span><br><span class="line">            <span class="comment">// This is because someone may have invalidated this view</span></span><br><span class="line">            <span class="comment">// before this call to setFrame came in, thereby clearing</span></span><br><span class="line">            <span class="comment">// the DRAWN bit.</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            <span class="comment">// parent display list may need to be recreated based on a change in the bounds</span></span><br><span class="line">            <span class="comment">// of any child</span></span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset drawn bit to original value (invalidate turns it off)</span></span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Android无障碍辅助功能通知</span></span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先回根据新旧的宽高进行比较，来确定是不是大小被改变了。如果是，会回调 <code>sizeChange(newWidth, newHeight, oldWidth, oldHeight)</code> 方法，这个方法是不是很眼熟呢？</p>
<p>之后还会把这消息通知给 <code>AccessibilityService</code> 无障碍服务。</p>
<p>最后返回布局是否改变的 boolean 值。</p>
<h2 id="FrameLayout-1"><a href="#FrameLayout-1" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><h3 id="onLayout_28boolean_changed_2C_int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#onLayout_28boolean_changed_2C_int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="onLayout(boolean changed, int left, int top, int right, int bottom)"></a>onLayout(boolean changed, int left, int top, int right, int bottom)</h3><p>接着，根据布局改变值 <code>changed</code> 会调用 <code>onLayout</code> 方法。</p>
<p><code>onLayout</code> 方法在 View/ViewGroup 都是空的，是需要子类来实现的。所以我们还是要看 <code>FrameLayout</code> 中的 <code>onLayout</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onLayout</code> 中调用了 <code>layoutChildren</code> 方法。</p>
<h3 id="layoutChildren_28int_left_2C_int_top_2C_int_right_2C_int_bottom_2C_boolean_forceLeftGravity_29"><a href="#layoutChildren_28int_left_2C_int_top_2C_int_right_2C_int_bottom_2C_boolean_forceLeftGravity_29" class="headerlink" title="layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity)"></a>layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历子 view</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 子 view 的宽高</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> childLeft;</span><br><span class="line">               <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 得到子 view 的 gravity</span></span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                   gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据不同的 gravity 来计算 childLeft</span></span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                       lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                           childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据不同的 gravity 来计算 childTop</span></span><br><span class="line">               <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                       lp.topMargin - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                       childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 调用子 view 的 layout 方法</span></span><br><span class="line">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，在 <code>layoutChildren</code> 中，遍历所有可见的子 View ，然后得到它们的宽高。</p>
<p>再根据不同的 gravity 来计算 childLeft 和 childTop ，最后调用 child.layout 来向子 View 传递下去。</p>
<h2 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h2><p>我们把 layout 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performLayout -&gt; DecorView(ViewGroup).layout -&gt; View.layout -&gt; DecorView(FrameLayout).onLayout -&gt;  DecorView(FrameLayout).layoutChildren -&gt; ViewGroup.layout -&gt; View.layout -&gt; ViewGroup.onLayout -&gt; … -&gt; View.layout -&gt; View.onLayout</p>
<p>注： </p>
<ul>
<li>ViewGroup.onLayout 是抽象方法，根据不同的 ViewGroup 都有不同的实现方式。但是相同的是，都会遍历调用 child.layout 方法；</li>
<li>View.onLayout 是空方法；</li>
</ul>
<h1 id="draw_u8FC7_u7A0B"><a href="#draw_u8FC7_u7A0B" class="headerlink" title="draw过程"></a>draw过程</h1><p>最后一个，draw 过程。 draw 过程应该来说是比较简单的。</p>
<h2 id="ViewRootImpl-4"><a href="#ViewRootImpl-4" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performDraw_28_29"><a href="#performDraw_28_29" class="headerlink" title="performDraw()"></a>performDraw()</h3><p>首先起点是 <code>performDraw()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 draw 方法，fullRedrawNeeded 为是否重新绘制全部视图</span></span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一次绘制视图，那么显然应该绘制所有的视图，<code>fullRedrawNeeded</code> 参数就为 true ；反之如果由于某些原因，导致了视图重绘，那么就没有必要绘制所有视图，即为 false 。</p>
<h3 id="draw_28boolean_fullRedrawNeeded_29"><a href="#draw_28boolean_fullRedrawNeeded_29" class="headerlink" title="draw(boolean fullRedrawNeeded)"></a>draw(boolean fullRedrawNeeded)</h3><p><code>performDraw()</code> 内部又调用了私有方法 <code>draw(boolean fullRedrawNeeded)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty 表示需要绘制的区域</span></span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The app owns the surface, we won't draw.</span></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        <span class="keyword">if</span> (animating &amp;&amp; mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要全部绘制，那么 dirty 就是整个屏幕了</span></span><br><span class="line">    <span class="keyword">if</span> (fullRedrawNeeded) &#123;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        dirty.set(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 drawSoftware ，把绘制区域 dirty 传入</span></span><br><span class="line">    <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在确定了绘制的区域 <code>dirty</code> 之后，调用了 <code>drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)</code> 。</p>
<h3 id="drawSoftware_28Surface_surface_2C_AttachInfo_attachInfo_2C_int_xoff_2C_int_yoff_2C_boolean_scalingRequired_2C_Rect_dirty_29"><a href="#drawSoftware_28Surface_surface_2C_AttachInfo_attachInfo_2C_int_xoff_2C_int_yoff_2C_boolean_scalingRequired_2C_Rect_dirty_29" class="headerlink" title="drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)"></a>drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span><br><span class="line">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁定画布，由 dirty 区域决定</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">"Could not lock surface"</span>, e);</span><br><span class="line">        <span class="comment">// Don't assume this is due to out of memory, it could be</span></span><br><span class="line">        <span class="comment">// something else, and if it is something else then we could</span></span><br><span class="line">        <span class="comment">// kill stuff (or ourself) for no reason.</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_DRAW) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" drawing to bitmap w="</span></span><br><span class="line">                    + canvas.getWidth() + <span class="string">", h="</span> + canvas.getHeight());</span><br><span class="line">            <span class="comment">//canvas.drawARGB(255, 255, 0, 0);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this bitmap's format includes an alpha channel, we</span></span><br><span class="line">        <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">        <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">        <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">        <span class="comment">// where the offset doesn't appear to avoid having garbage</span></span><br><span class="line">        <span class="comment">// left in the blank areas.</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">            Context cxt = mView.getContext();</span><br><span class="line">            Log.i(mTag, <span class="string">"Drawing: package:"</span> + cxt.getPackageName() +</span><br><span class="line">                    <span class="string">", metrics="</span> + cxt.getResources().getDisplayMetrics() +</span><br><span class="line">                    <span class="string">", compatibilityInfo="</span> + cxt.getResources().getCompatibilityInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 View 的 draw 方法</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(mTag, <span class="string">"Could not unlock surface"</span>, e);</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="comment">//noinspection ReturnInsideFinallyBlock</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" unlockCanvasAndPost"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-3"><a href="#View-3" class="headerlink" title="View"></a>View</h2><h3 id="draw_28Canvas_canvas_29"><a href="#draw_28Canvas_canvas_29" class="headerlink" title="draw(Canvas canvas)"></a>draw(Canvas canvas)</h3><p>之后调用了 <code>View</code> 的 <code>draw(Canvas canvas)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">     * in the appropriate order:</span><br><span class="line">     *</span><br><span class="line">     *      1. Draw the background</span><br><span class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</span><br><span class="line">     *      3. Draw view's content</span><br><span class="line">     *      4. Draw children</span><br><span class="line">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">     *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，画背景</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="comment">// 可能的话，跳过第二步和第五步</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// 第三步，画自己的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第四步，画自己子 view 的内容</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步，绘制View的装饰，比如 scrollbar 等 (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做完了，直接返回 we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Here we do the full fledged routine...</span><br><span class="line">     * (this is an uncommon case where speed matters less,</span><br><span class="line">     * this is why we repeat some of the tests that have been</span><br><span class="line">     * done above)</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> drawTop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawBottom = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawLeft = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> bottomFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> leftFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> rightFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，保存 canvas 图层</span></span><br><span class="line">    <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = mScrollX + paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    <span class="keyword">int</span> bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">    <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        bottomFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        rightFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步，绘制边缘效果和恢复图层</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>draw 过程大概有下面几步：</p>
<ol>
<li>绘制背景：<code>background.draw(canvas)</code> ；</li>
<li>保存当前的图层信息（一般来说跳过）；</li>
<li>绘制自己：<code>onDraw(canvas)</code> ；</li>
<li>绘制children：<code>dispatchDraw(canvas)</code> ；</li>
<li>绘制边缘效果，恢复图层（一般来说跳过）；</li>
<li>绘制前景装饰：<code>onDrawForeground(canvas)</code> 。</li>
</ol>
<p>在这里，我们继续看一下 <code>dispatchDraw(Canvas canvas)</code> 方法，这个方法是向子 View 分发绘制流程的。</p>
<p>因为 View 没有子 View ，所以 <code>dispatchDraw(Canvas canvas)</code> 方法是空的，所以我们要到 ViewGroup 中去看看。</p>
<h2 id="ViewGroup-3"><a href="#ViewGroup-3" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="dispatchDraw_28Canvas_canvas_29"><a href="#dispatchDraw_28Canvas_canvas_29" class="headerlink" title="dispatchDraw(Canvas canvas)"></a>dispatchDraw(Canvas canvas)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> buildCache = !isHardwareAccelerated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历子 view </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams params = child.getLayoutParams();</span><br><span class="line">                attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">                bindLayoutAnimation(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">        <span class="keyword">if</span> (controller.willOverlap()) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.start();</span><br><span class="line"></span><br><span class="line">        mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAnimationListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clipSaveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save();</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will draw our child's animation, let's reset the flag</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usingRenderNodeProperties) canvas.insertReorderBarrier();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> transientCount = mTransientIndices == <span class="keyword">null</span> ? <span class="number">0</span> : mTransientIndices.size();</span><br><span class="line">    <span class="keyword">int</span> transientIndex = transientCount != <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Only use the preordered list if not HW accelerated, since the HW pipeline will do the</span></span><br><span class="line">    <span class="comment">// draw reordering internally</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? <span class="keyword">null</span> : buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                transientIndex = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 drawChild 来绘制子 view</span></span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>dispatchDraw(Canvas canvas)</code> 中，遍历子 View ，然后调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法来执行子 View 的绘制流程。</p>
<h3 id="drawChild_28Canvas_canvas_2C_View_child_2C_long_drawingTime_29"><a href="#drawChild_28Canvas_canvas_2C_View_child_2C_long_drawingTime_29" class="headerlink" title="drawChild(Canvas canvas, View child, long drawingTime)"></a>drawChild(Canvas canvas, View child, long drawingTime)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中还是调用了 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 方法。但是这个 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 和上面的 <code>draw(Canvas canvas)</code> 参数不同，所以不是同一个方法。</p>
<h2 id="View-4"><a href="#View-4" class="headerlink" title="View"></a>View</h2><h3 id="draw_28Canvas_canvas_2C_ViewGroup_parent_2C_long_drawingTime_29"><a href="#draw_28Canvas_canvas_2C_ViewGroup_parent_2C_long_drawingTime_29" class="headerlink" title="draw(Canvas canvas, ViewGroup parent, long drawingTime)"></a>draw(Canvas canvas, ViewGroup parent, long drawingTime)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有绘制缓存</span></span><br><span class="line">       <span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line">           <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">               ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">               <span class="comment">// 如果设置了 willNotDraw 为 true ，那么不会绘制自己，直接跳过，优化绘制性能</span></span><br><span class="line">               <span class="comment">// View 默认是 false ，ViewGroup 默认是 true ，直接让自己的子 View 进入绘制</span></span><br><span class="line">               <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                   mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                   dispatchDraw(canvas);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 调用 draw 方法</span></span><br><span class="line">                   draw(canvas);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 有缓存就用缓存绘制</span></span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">           <span class="keyword">if</span> (layerType == LAYER_TYPE_NONE || mLayerPaint == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// no layer paint, use temporary paint to draw bitmap</span></span><br><span class="line">               Paint cachePaint = parent.mCachePaint;</span><br><span class="line">               <span class="keyword">if</span> (cachePaint == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   cachePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">                   cachePaint.setDither(<span class="keyword">false</span>);</span><br><span class="line">                   parent.mCachePaint = cachePaint;</span><br><span class="line">               &#125;</span><br><span class="line">               cachePaint.setAlpha((<span class="keyword">int</span>) (alpha * <span class="number">255</span>));</span><br><span class="line">               canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, cachePaint);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// use layer paint to draw the bitmap, merging the two alphas, but also restore</span></span><br><span class="line">               <span class="keyword">int</span> layerPaintAlpha = mLayerPaint.getAlpha();</span><br><span class="line">               <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                   mLayerPaint.setAlpha((<span class="keyword">int</span>) (alpha * layerPaintAlpha));</span><br><span class="line">               &#125;</span><br><span class="line">               canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, mLayerPaint);</span><br><span class="line">               <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                   mLayerPaint.setAlpha(layerPaintAlpha);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 中，若没有缓存的话：</p>
<ul>
<li>若 <code>willNotDraw</code> 设置为 false 的话，那么调用 <code>draw(canvas)</code> ；</li>
<li>否则直接调用 <code>dispatchDraw(canvas)</code> 分发给子 View ，一般适用于 ViewGroup ；</li>
</ul>
<p><code>willNotDraw</code> 代表一个 View 不需要绘制任何内容的话，那么系统会跳过，进行性能上的优化。</p>
<p>到这里，就调用了子 View 的 <code>draw(Canvas canvas)</code> 方法，从而实现了绘制过程的向下传递。</p>
<h2 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h2><p>我们把 draw 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performDraw -&gt; ViewRootImpl.draw(boolean fullRedrawNeeded) -&gt; ViewRootImpl.drawSoftware -&gt; DecorView(View).draw(Canvas canvas) -&gt; DecorView(ViewGroup).dispatchDraw -&gt; DecorView(ViewGroup).drawChild -&gt; ViewGroup(View).draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; ViewGroup.dispatchDraw -&gt; ViewGroup.drawChild -&gt; ViewGroup.draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; … -&gt; View.draw(Canvas canvas) -&gt; View.onDraw -&gt; View.dispatchDraw</p>
<p>注：</p>
<ul>
<li>其中 <code>View.dispatchDraw</code> 为空实现；</li>
<li>DecorView 在 <code>draw(Canvas canvas)</code> 的方法内不会调用 <code>onDraw</code> 方法；</li>
<li>ViewGroup 不会调用 <code>draw(Canvas canvas)</code> 方法；</li>
</ul>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>总体来说，三个流程中主要还是 measure 过程较复杂。其他的两个流程整体上来说还是比较清晰简单的。</p>
<p>可以说 View 工作的三大流程是每一位 Android 开发者都必须掌握的。之前虽然也了解，但是没有写成博客好好捋一下，现在终于完成了，篇幅真的太长了。 ^_^</p>
<p>另外，除了需要了解这三大流程外，还需要知道 <code>requestLayout</code> 和 <code>invalidate</code> 等方法的原理。这些东西等有空了我理一理再写出来给大家吧。</p>
<p>今天就这样了，如果有不懂的地方可以在下面留言。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/a65861e946cb" target="_blank" rel="external">View绘制流程及源码解析(一)——performTraversals()源码分析</a></li>
<li><a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程</a></li>
<li><a href="http://blog.csdn.net/a553181867/article/details/51494058" target="_blank" rel="external">Android View 测量流程(Measure)完全解析</a></li>
<li><a href="http://www.jianshu.com/p/6d66ea4998de" target="_blank" rel="external">Android学习笔记—深入理解View#04</a></li>
<li><a href="http://blog.csdn.net/a553181867/article/details/51570854" target="_blank" rel="external">Android View 绘制流程(Draw) 完全解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文分析的源码基于 Android API 25</p>
<h1 id="View_u7ED8_u5236_u7684_u8D77_u70B9"><a href="#View_u7ED8_u5236_u7684_u8D77_u70B9" class="headerlin]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Retrofit源码解析]]></title>
    <link href="http://yuqirong.me/2017/08/03/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/08/03/Retrofit源码解析/</id>
    <published>2017-08-03T15:19:17.000Z</published>
    <updated>2017-08-05T11:47:36.359Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前对 OkHttp 进行过源码分析了，那么今天就来讲讲 Retrofit 。</p>
<p>Retrofit 其实是对 OkHttp 进行了一层封装，让开发者对网络操作更加方便快捷。</p>
<p>相信绝大多数的 Android 开发者都有使用过的经历。其 restful 风格的编程俘获了众多人的心。</p>
<p>废话就不多讲了，下面就要对 Retrofit 进行源码解析。</p>
<p>本文解析的 Retrofit 基于 v2.3.0 ，GitHub 地址：<a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a></p>
<h1 id="Retrofit__u4F7F_u7528_u65B9_u6CD5"><a href="#Retrofit__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Retrofit 使用方法"></a>Retrofit 使用方法</h1><p>直接抄官网的：</p>
<p>第一步，声明 API 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="annotation">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，构造出 <code>Retrofit</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>第三步，得到 API 接口，直接调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<p>最后，就是调用 <code>repos</code> 执行 Call ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync</span></span><br><span class="line">repos.execute();</span><br><span class="line"><span class="comment">// async</span></span><br><span class="line">repos.enqueue(...);</span><br></pre></td></tr></table></figure>
<h1 id="u8BF7_u6C42_u6E90_u7801_u89E3_u6790"><a href="#u8BF7_u6C42_u6E90_u7801_u89E3_u6790" class="headerlink" title="请求源码解析"></a>请求源码解析</h1><p>我们先来看看发出网络请求部分的源码。</p>
<h2 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder"></a>Retrofit.Builder</h2><p>首先切入点就是 <code>Retrofit.Builder</code> 。</p>
<p>在 <code>Retrofit.Builder</code> 中有以下的方法：</p>
<ul>
<li>client ： 设置 http client，默认是 OkHttpClient，会调用 <code>callFactory</code> 方法</li>
<li>callFactory ： 设置网络请求 call 的工厂，默认就是上面的 OkHttpClient</li>
<li>baseUrl ： api 的 base url</li>
<li>addConverterFactory ： 添加数据转换器工厂</li>
<li>addCallAdapterFactory　：　添加网络请求适配器工厂</li>
<li>callbackExecutor ： 回调方法执行器</li>
<li>validateEagerly ： 是否提前解析接口方法</li>
</ul>
<p>这些都是用来配置 <code>Builder</code> 的。</p>
<p>那么我们来看下 <code>Builder</code> 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确定平台，有 Android Java8 默认Platform 三种</span></span><br><span class="line">  <span class="keyword">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(Platform platform) &#123;</span><br><span class="line">  <span class="keyword">this</span>.platform = platform;</span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">  <span class="comment">// 默认内置的数据转换器 BuiltInConverters</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来个小插曲，我们来看下 Retrofit 是如何确定平台的：</p>
<h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PLATFORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，是通过反射判断有没有该类来实现的。若以后在开发的过程中有需要判断平台的需求，我们可以直接将该段代码 copy 过来。</p>
<p>接着，在创建 <code>Builder</code> 对象并进行自定义配置后，我们就要调用 <code>build()</code> 方法来构造出 <code>Retrofit</code> 对象了。那么，我们来看下 <code>build()</code> 方法里干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认为 OkHttpClient</span></span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Android 平台下默认为 MainThreadExecutor</span></span><br><span class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">  <span class="comment">// 添加 ExecutorCallAdapterFactory</span></span><br><span class="line">  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters. 默认有 BuiltInConverters</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">      callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中，做的事情有：检查配置、设置默认配置、创建 <code>Retrofit</code> 对象。</p>
<p>关于上面种种奇怪的类，我们先不关心，因为之后我们遇到了再分析。我们先把目光聚焦在 <code>Retrofit</code> 类上。</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p><code>Retrofit</code> 类的构造方法没什么好看的，在这就不讲了。</p>
<p>得到 <code>Retrofit</code> 对象后就是调用 <code>create(final Class&lt;T&gt; service)</code> 方法来创建我们 API 接口的实例。</p>
<p>所以我们需要跟进 <code>create(final Class&lt;T&gt; service)</code> 中来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验是否为接口，且不能继承其他接口</span></span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="comment">// 是否需要提前解析接口方法</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 动态代理模式</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最关键的就是动态代理。实际上，进行网络操作的都是通过代理类来完成的。如果对动态代理不太懂的同学请自行百度了，这里就不多讲了。</p>
<p>重点就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<p>这三句代码，下面我们着重来看。</p>
<p>在代理中，会根据参数中传入的具体接口方法来构造出对应的 <code>serviceMethod</code> 。<code>ServiceMethod</code> 类的作用就是把接口的方法适配为对应的 HTTP call 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  ServiceMethod result;</span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line"> <span class="comment">// 先从缓存中取，若没有就去创建对应的 ServiceMethod</span></span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有缓存就创建，之后再放入缓存中</span></span><br><span class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在内部还维护了一个 <code>serviceMethodCache</code> 来缓存 <code>ServiceMethod</code> ，以便提高效率。我们就直接来看 <code>ServiceMethod</code> 是如何被创建的吧。</p>
<h2 id="ServiceMethod-Builder"><a href="#ServiceMethod-Builder" class="headerlink" title="ServiceMethod.Builder"></a>ServiceMethod.Builder</h2><p>发现 <code>ServiceMethod</code> 也是通过建造者模式来创建对象的。那就进入对应构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">  <span class="comment">// 接口方法的注解</span></span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="comment">// 接口方法的参数类型</span></span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 接口方法参数的注解</span></span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中没有什么大的动作，那么就单刀直入 <code>build()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据接口方法的注解和返回类型创建 callAdapter</span></span><br><span class="line">  <span class="comment">// 如果没有添加 CallAdapter 那么默认会用 ExecutorCallAdapterFactory</span></span><br><span class="line">  callAdapter = createCallAdapter();</span><br><span class="line">  <span class="comment">// calladapter 的响应类型中的泛型，比如 Call&lt;User&gt; 中的 User</span></span><br><span class="line">  responseType = callAdapter.responseType();</span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">        + Utils.getRawType(responseType).getName()</span><br><span class="line">        + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据之前泛型中的类型以及接口方法的注解创建 ResponseConverter</span></span><br><span class="line">  responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据接口方法的注解构造请求方法，比如 @GET @POST @DELETE 等</span></span><br><span class="line">  <span class="comment">// 另外还有添加请求头，检查url中有无带?，转化 path 中的参数</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若无 body 则不能有 isMultipart 和 isFormEncoded</span></span><br><span class="line">  <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">          + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的代码主要用来解析接口方法参数中的注解，比如 @Path @Query @QueryMap @Field 等等</span></span><br><span class="line">  <span class="comment">// 相应的，每个方法的参数都创建了一个 ParameterHandler&lt;?&gt; 对象</span></span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    Type parameterType = parameterTypes[p];</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">          parameterType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查构造出的请求有没有不对的地方？</span></span><br><span class="line">  <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中代码挺长的，总结起来就一句话：就是将 API 接口中的方法进行解析，构造成 <code>ServiceMethod</code> ，交给下面的 <code>OkHttpCall</code> 使用。</p>
<p>基本上做的事情就是：</p>
<ol>
<li>创建 CallAdapter ；</li>
<li>创建 ResponseConverter；</li>
<li>根据 API 接口方法的注解构造网络请求方法；</li>
<li>根据 API 接口方法参数中的注解构造网络请求的参数；</li>
<li>检查有无异常；</li>
</ol>
<p>代码中都是注释，在这里就不详细多讲了。</p>
<p><code>ServiceMethod serviceMethod = loadServiceMethod(method);</code> 这句代码我们看完了，那么看接下来的 <code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</code> 。</p>
<h2 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><p>在 <code>OkHttpCall</code> 的构造器中没什么大动作，搞不了大事情的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpCall(ServiceMethod&lt;T&gt; serviceMethod, Object[] args) &#123;</span><br><span class="line">  <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">  <span class="keyword">this</span>.args = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而真正搞事情的是 <code>serviceMethod.callAdapter.adapt(okHttpCall);</code> 这句代码。</p>
<h2 id="ExecutorCallAdapterFactory"><a href="#ExecutorCallAdapterFactory" class="headerlink" title="ExecutorCallAdapterFactory"></a>ExecutorCallAdapterFactory</h2><p>在 Retrofit 中默认的 callAdapterFactory 是 <code>ExecutorCallAdapterFactory</code> 。我们就进入它的 <code>get(Type returnType, Annotation[] annotations, Retrofit retrofit)</code> 看看吧，返回了一个匿名类 <code>CallAdapter&lt;Object, Call&lt;?&gt;&gt;</code> ，在其中有 <code>adapt(Call&lt;Object&gt; call)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它 <code>return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</code> 。<code>ExecutorCallbackCall</code> 是实现了 <code>retrofit2.Call</code> ，这里注意下，是 Retrofit 中的 Call 而不是 OkHttp 中的 Call 。使用了装饰者模式把 <code>retrofit2.Call</code> 又包装了一层。</p>
<p>在得到了 <code>ExecutorCallbackCall</code> ，我们可以调用同步方法 <code>execute()</code> 或异步方法 <code>enqueue(Callback&lt;T&gt; callback)</code> 来执行该 call 。</p>
<h2 id="ExecutorCallAdapterFactory-ExecutorCallbackCall"><a href="#ExecutorCallAdapterFactory-ExecutorCallbackCall" class="headerlink" title="ExecutorCallAdapterFactory.ExecutorCallbackCall"></a>ExecutorCallAdapterFactory.ExecutorCallbackCall</h2><p>那我们就跟进同步方法 <code>execute()</code> 吧，异步的 <code>enqueue(Callback&lt;T&gt; callback)</code> 就不看了。了解过 OkHttp 的同学应该都知道这两个方法的区别，就是多了异步执行和回调的步骤而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// delegate 就是构造器中传进来的 OkHttpCall</span></span><br><span class="line">  <span class="keyword">return</span> delegate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，其实就是调用了 <code>OkHttpCall</code> 的 <code>execute()</code> 方法。</p>
<p>所以我们又要回到 <code>OkHttpCall</code> 中了。</p>
<h2 id="OkHttpCall-1"><a href="#OkHttpCall-1" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">     executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     call = rawCall;</span><br><span class="line">     <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">// 根据 serviceMethod 中的众多数据创建出 Okhttp 中的 Request 对象</span></span><br><span class="line">	  <span class="comment">// 注意的一点，会调用上面的 ParameterHandler.apply 方法来填充网络请求参数</span></span><br><span class="line">	  <span class="comment">// 然后再根据 OkhttpClient 创建出 Okhttp 中的 Call</span></span><br><span class="line">	  <span class="comment">// 这一步也说明了在 Retrofit 中的 OkHttpCall 内部请求最后会转换为 OkHttp 的 Call</span></span><br><span class="line">         call = rawCall = createRawCall();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">         creationFailure = e;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 检查 call 是否取消</span></span><br><span class="line">   <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">     call.cancel();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 执行 call 并转换响应的 response</span></span><br><span class="line">   <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>execute()</code> 做的就是将 Retrofit 中的 call 转化为 OkHttp 中的 call 。</p>
<p>最后让 OkHttp 的 call 去执行。</p>
<p>至此，Retrofit 的网络请求部分源码已经全部解析一遍了。</p>
<p>剩下的就是响应部分了，趁热打铁。</p>
<h1 id="u54CD_u5E94_u6E90_u7801_u89E3_u6790"><a href="#u54CD_u5E94_u6E90_u7801_u89E3_u6790" class="headerlink" title="响应源码解析"></a>响应源码解析</h1><p>我们可以看到 <code>OkHttpCall.execute()</code> 中的最后一句：<code>parseResponse(call.execute())</code>。</p>
<p>所以对响应的处理就是 <code>parseResponse(okhttp3.Response rawResponse)</code> 这个方法了。</p>
<h2 id="OkHttpCall-2"><a href="#OkHttpCall-2" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="comment">// 如果返回的响应码不是成功的话，返回错误 Response</span></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果返回的响应码是204或者205，返回没有 body 的成功 Response</span></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 body 转换为对应的泛型，然后返回成功 Response</span></span><br><span class="line">    T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parseResponse(okhttp3.Response rawResponse)</code> 中主要是这句代码：</p>
<p><code>T body = serviceMethod.toResponse(catchingBody);</code> </p>
<p>将 <code>ResponseBody</code> 直接转化为了泛型，可以猜到这也是 Converter 的功劳。</p>
<h2 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然没错，内部是调用了 <code>responseConverter</code> 的。</p>
<h2 id="BuiltInConverters"><a href="#BuiltInConverters" class="headerlink" title="BuiltInConverters"></a>BuiltInConverters</h2><p><code>BuiltInConverters</code> 中有好几种内置的 Converter 。并且只支持返回 <code>ResponseBody</code> 。我们来看下它们的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingResponseBodyConverter</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BufferingResponseBodyConverter INSTANCE = <span class="keyword">new</span> BufferingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            <span class="keyword">return</span> Utils.buffer(value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实说白了就是将 <code>ResponseBody</code> 转化为对应的数据类型了。比如在 <code>GsonConverterFactory</code> 中就是把 <code>ResponseBody</code> 用 gson 转化为对应的类型，有兴趣的同学可以自己看下。这里也没什么神秘的，相信大家都懂的。</p>
<p>到这里就把 Retrofit 响应部分的源码解析完毕了。</p>
<p>大家自行消化一下吧。</p>
<p>我自己也写得头晕了。。。笑 cry</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>最后，相信大家已经了解了 Retrofit 到底是怎么一回事了。</p>
<p>Retrofit 内部访问网络仍然是通过 OkHttp ，而只是把构造请求和响应封装了一下，更加简单易用了。</p>
<p>还有，看过框架源码的都知道在源码中有很多设计模式的体现，比如建造者模式、装饰者模式以及 OkHttp 中的责任链模式等。这些也正是值得我们学习的地方。</p>
<p>好啦，今天结束了。如果有问题的同学可以留言咯。</p>
<p>Goodbye</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51304204" target="_blank" rel="external">Retrofit2 完全解析 探索与okhttp之间的关系</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前对 OkHttp 进行过源码分析了，那么今天就来讲讲 Retrofit 。</p>
<p>Retrofi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OkHttp源码解析]]></title>
    <link href="http://yuqirong.me/2017/07/25/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/07/25/OkHttp源码解析/</id>
    <published>2017-07-25T12:54:57.000Z</published>
    <updated>2017-08-03T15:13:44.879Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
<p>现如今，在 Android 开发领域大多数都是选择以 OkHttp 作为网络框架。</p>
<p>然而，简单地会使用 OkHttp 并不能让我们得到满足。更深层次的，我们需要阅读框架的源码，才能用起来得心应手，融会贯通。</p>
<p>An HTTP &amp; HTTP/2 client for Android and Java applications.</p>
<p>这是官网上对于 OkHttp 的介绍，简单明了。同时，也印证了那句经典的话：</p>
<p>Talk is cheap, show me the code.</p>
<h1 id="OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5"><a href="#OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="OkHttp的简单使用方法"></a>OkHttp的简单使用方法</h1><p>OkHttp 使用方法，直接抄官网的 \(╯-╰)/ 。</p>
<p>GET 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</span><br><span class="line">    = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(body)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6DF1_u5165_u6E90_u7801"><a href="#u6DF1_u5165_u6E90_u7801" class="headerlink" title="深入源码"></a>深入源码</h1><p>在这里，先分析下同步请求的源码，之后再回过头来看异步请求的源码。</p>
<p>Let’s go !</p>
<h1 id="u540C_u6B65_u8BF7_u6C42"><a href="#u540C_u6B65_u8BF7_u6C42" class="headerlink" title="同步请求"></a>同步请求</h1><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>首先创建一个 <code>OkHttpClient</code> 对象，那我们看看在构造器中做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher; <span class="comment">// 分发器</span></span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy; <span class="comment">// 代理</span></span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols; <span class="comment">// 协议</span></span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors); <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors); <span class="comment">// 网络拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector; <span class="comment">// 代理选择</span></span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar; <span class="comment">// cookie</span></span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache; <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">    isTLS = isTLS || spec.isTls();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    X509TrustManager trustManager = systemDefaultTrustManager();</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool; <span class="comment">// 连接复用池</span></span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout; <span class="comment">// 连接超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout; <span class="comment">// 读取超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout; <span class="comment">// 写入超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中利用建造者模式来构建 <code>OkHttpClient</code> 的对象。当然，如果你想自定义 <code>OkHttpClient</code> 配置的话，就要 new 一个 <code>OkHttpClient.Builder</code> 来配置自己的参数了。相信大家都干过这种事情了(∩_∩)。</p>
<p><code>OkHttpClient</code> 的构造器中主要是扎堆扎堆的配置，没别的。</p>
<p>之后再调用 <code>newCall(Request request)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法里面其实是创建了一个 <code>RealCall</code> 的对象，那么我们就进入 <code>RealCall</code> 中去看看吧。</p>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>在 <code>RealCall</code> 的构造器中只是给一些变量赋值或初始化而已，没什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再把目光转向 <code>RealCall</code> 中的 <code>execute()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 call 已经被执行过了，就设置 executed 为 true</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加入 runningSyncCalls 队列中</span></span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 得到响应 result</span></span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 从 runningSyncCalls 队列中移除</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execute()</code> 方法为执行该 <code>RealCall</code>，在方法里面一开始检查了该 call 时候被执行。</p>
<p>然后又加入了 <code>Dispatcher</code> 的 <code>runningSyncCalls</code> 中。<code>runningSyncCalls</code> 队列只是用来记录正在同步请求中的 call ，在 call 完成请求后又会从 <code>runningSyncCalls</code> 中移除。</p>
<p>可见，在同步请求中 <code>Dispatcher</code> 参与的部分很少。但是在异步请求中， <code>Dispatcher</code> 可谓是大展身手。</p>
<p>最重要的方法，那就是 <code>getResponseWithInterceptorChain()</code> 。我们可以看到这方法是直接返回 <code>Response</code> 对象的，所以，在这个方法中一定做了很多很多的事情。</p>
<p>那就继续深入吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); <span class="comment">// 加入用户自定义的拦截器</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor); <span class="comment">// 重试和重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar())); <span class="comment">// 加入转化请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache())); <span class="comment">// 加入缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client)); <span class="comment">// 加入连接拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors()); <span class="comment">// 加入用户自定义的网络拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket)); <span class="comment">// 加入发出请求和读取响应的拦截器</span></span><br><span class="line">    </span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.readTimeoutMillis());</span><br><span class="line">    <span class="comment">// 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>getResponseWithInterceptorChain()</code> 方法中有一堆的拦截器！！！</p>
<p>关于拦截器，之前在 <a href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OKHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/">一起来写OKHttp的拦截器</a> 这篇博客中有讲过，若不了解的同学可以先看下。</p>
<p>我们都知道，拦截器是 OkHttp 的精髓。</p>
<ol>
<li><code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；</li>
<li><code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；</li>
<li><code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；</li>
<li><code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；</li>
<li><code>ConnectInterceptor</code> 用来建立连接的拦截器；</li>
<li><code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ;</li>
<li><code>CallServerInterceptor</code> 是真正向服务器发出请求且得到响应的拦截器；</li>
</ol>
<p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是责任链模式。</p>
<h2 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h2><p><code>RealInterceptorChain</code> 可以说是真正把这些拦截器串起来的一个角色。一个个拦截器就像一颗颗珠子，而 <code>RealInterceptorChain</code> 就是把这些珠子串连起来的那根绳子。</p>
<p>进入 <code>RealInterceptorChain</code> ，主要是 <code>proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">                        RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到下一次对应的 RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">            connection, index + <span class="number">1</span>, request, call, eventListener, readTimeout);</span><br><span class="line">    <span class="comment">// 当前次数的 interceptor</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认下一次的 interceptor 调用过 chain.proceed()</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中是一次次链式调用拦截器，可能有些同学还是看不懂。那么，我就捉急地画了一张示意图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170725/20170722185657.png" alt="interceptors"></p>
<p>有了这张图就好懂多了，如果还没懂的话就只能自己慢慢体会了。</p>
<p>下面就要进入分析拦截器的步骤了，至于用户自定义的拦截器在这就略过了。还有，拦截器只分析主要的 <code>intercept(Chain chain)</code> 代码。</p>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()),</span><br><span class="line">            call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果取消，就释放资源</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">            response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">            <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">            <span class="comment">// 路由连接失败，请求将不会被发送</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">            <span class="comment">// 服务器连接失败，请求可能已被发送</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">            <span class="comment">// 抛出未检查的异常，释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">                streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                            .body(<span class="keyword">null</span>)</span><br><span class="line">                            .build())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不需要重定向，那么 followUp 为空，会根据响应码判断</span></span><br><span class="line">        Request followUp = followUpRequest(response);</span><br><span class="line">        <span class="comment">// 释放资源，返回 response</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 response 的 body</span></span><br><span class="line">        closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// response 和 followUp 比较是否为同一个连接</span></span><br><span class="line">        <span class="comment">// 若为重定向就销毁旧连接，创建新连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">                    createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">                    + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将重定向操作得到的新请求设置给 request</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p>
<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">    <span class="comment">// 将用户友好的 request 构造为发送给服务器的 request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">// 若有请求体，则构造</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">        MediaType contentType = body.contentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="comment">// 使用 gzip 压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">        requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UA</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    <span class="comment">// 保存 networkResponse 的 cookie</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    <span class="comment">// 将 networkResponse 构造为对用户友好的 response</span></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">            .request(userRequest);</span><br><span class="line">    <span class="comment">// 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">            &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">            &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">        GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        responseBuilder.headers(strippedHeaders);</span><br><span class="line">        responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p>
<p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p>
<p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p>
<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 request 对应缓存中的 response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前时间，会和之前缓存的时间进行比较</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 得到缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">    <span class="comment">// 追踪缓存，其实就是计数</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存不适用，关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 禁止网络并且没有缓存的话，返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(<span class="number">504</span>)</span><br><span class="line">                .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 不用网络请求，返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给下一个拦截器，返回 networkResponse</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们同时有缓存和 networkResponse ，根据情况使用</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line">            <span class="comment">// 更新原来的缓存至最新</span></span><br><span class="line">            <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">            <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 保存之前未缓存的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 创建 httpCodec （抽象类），分别对应着 http1.1 和 http 2</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>streamAllocation.newStream</code> 创建了一个 <code>HttpCodec</code> 的对象。</p>
<p>而 <code>HttpCodec</code> 是一个抽象类，其实现类分别是 <code>Http1Codec</code> 和 <code>Http2Codec</code> 。相对应的就是 HTTP/1.1 和 HTTP/2.0 。</p>
<p>我们来看下 <code>streamAllocation.newStream</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(OkHttpClient client, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在连接池中找到一个可用的连接，然后创建出 HttpCodec 对象</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>newStream(OkHttpClient client, boolean doExtensiveHealthChecks)</code> 中先在连接池中找到可用的连接 <code>resultConnection</code> ，再结合 <code>sink</code> 和 <code>source</code> 创建出 <code>HttpCodec</code> 的对象。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 整理请求头并写入</span></span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 检查是否为有 body 的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">        <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return what</span></span><br><span class="line">        <span class="comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">        <span class="comment">// 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            httpCodec.flushRequest();</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">            <span class="comment">// 写入请求体</span></span><br><span class="line">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">            request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            bufferedRequestBody.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">            <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span></span><br><span class="line">            <span class="comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span></span><br><span class="line">            <span class="comment">// connection in a consistent state.</span></span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">    <span class="comment">// 得到响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造 response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">// 如果为 web socket 且状态码是 101 ，那么 body 为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取 body</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(httpCodec.openResponseBody(response))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求头中有 close 那么断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">            || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们也完全明白了 OkHttp 中的分层思想，每一个 interceptor 只处理自己的事，而剩余的就交给其他的 interceptor 。这种思想可以简化一些繁琐复杂的流程，从而达到逻辑清晰、互不干扰的效果。</p>
<h1 id="u5F02_u6B65_u8BF7_u6C42"><a href="#u5F02_u6B65_u8BF7_u6C42" class="headerlink" title="异步请求"></a>异步请求</h1><p>与同步请求直接调用 <code>execute()</code> 不同的是，异步请求是调用了 <code>enqueue(Callback responseCallback)</code> 这个方法。那么我们对异步请求探究的入口就是 <code>enqueue(Callback responseCallback)</code> 了。</p>
<h2 id="RealCall-1"><a href="#RealCall-1" class="headerlink" title="RealCall"></a>RealCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">// 加入到 dispatcher 中，这里包装成了 AsyncCall</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的方法就是调用了 <code>Dispatcher</code> 的 <code>enqueue(AsyncCall call)</code> 方法。这里需要注意的是，传入的是 <code>AsyncCall</code> 对象，而不是同步中的 <code>RealCall</code> 。</p>
<p>那么我们就跟进到 <code>Dispatcher</code> 的源码中吧，至于 <code>AsyncCall</code> 我们会在下面详细讲到。</p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前正在运行的异步 call 数 &lt; 64 &amp;&amp; 队列中请求同一个 host 的异步 call 数 &lt; 5</span></span><br><span class="line">    <span class="comment">// maxRequests = 64，maxRequestsPerHost = 5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">// 加入正在运行异步队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">// 加入到线程池中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加入预备异步队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>enqueue(AsyncCall call)</code> 中可以知道，OkHttp 在运行中的异步请求数最多为 63 ，而同一个 host 的异步请求数最多为 4 。否则会加入到 <code>readyAsyncCalls</code> 中。</p>
<p>在加入到 <code>runningAsyncCalls</code> 后，就会进入线程池中被执行。到了这里，我们就要到 <code>AsyncCall</code> 中一探究竟了。</p>
<h2 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">        <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用一连串的拦截器，得到响应</span></span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调结果</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 runningAsyncCalls 中移除，并作推进其他 call 的工作</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p>
<p>在得到 <code>Response</code> 后，进行结果的回调。</p>
<p>最后，调用了 <code>Dispatcher</code> 的 <code>finished</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除该 call</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="comment">// 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中</span></span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls)</code> 中对该 call 移除。</p>
<p>若在 <code>readyAsyncCalls</code> 中其他的 call ，就移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p>
<p>这样，完整的流程就循环起来了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>基本上 OkHttp 的请求响应的流程就讲完了，篇幅有点长长长啊。</p>
<p>不过还有很多点没有涉及到的，比如连接池、缓存策略等等，都是值得我们去深究的。也是需要花很大的功夫才能了解透彻。</p>
<p>好了，那就到这里吧，有问题的同学可以留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="external">OKHttp源码解析</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
<li><a href="http://blog.csdn.net/qq_15274383/article/details/73729801" target="_blank" rel="external">OkHttp框架的RetryAndFollowUpInterceptor请求重定向源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可以伸缩的搜索栏，模仿华为应用市场]]></title>
    <link href="http://yuqirong.me/2017/07/03/%E5%8F%AF%E4%BB%A5%E4%BC%B8%E7%BC%A9%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%8F%EF%BC%8C%E6%A8%A1%E4%BB%BF%E5%8D%8E%E4%B8%BA%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA/"/>
    <id>http://yuqirong.me/2017/07/03/可以伸缩的搜索栏，模仿华为应用市场/</id>
    <published>2017-07-03T13:42:56.000Z</published>
    <updated>2017-07-04T14:55:44.586Z</updated>
    <content type="html"><![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
<p>关于搜索栏，可以说各种 app 都有不同的样式。影响比较深刻的就有华为应用市场的搜索栏（同样，简书的搜索栏也是类似的）。</p>
<p>而今天，就是带你来实现华为应用市场那样的搜索栏。</p>
<p>我们先放上我们实现的效果图吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170703150542.gif" alt="demo效果图"></p>
<p>怎么样，想不想学？</p>
<p>我们先来简述一下实现的思路吧，其实并不复杂。</p>
<p>首先，在搜索栏还未打开时，先确定半径 R ，然后假设一个变量 offset 用来动态改变搜索栏的宽度。如图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170704204905.png" alt="示意图"></p>
<p>所以可以得到一个公式：offset = total width - 2 * R ;</p>
<p>那么显而易见，offset 的取值就在 [0, total width - 2 * R] 之间了。</p>
<p>所以，我们可以借助属性动画来完成这数值的变化。在调用 <code>invalidate()</code> 进行重绘，达到动态增加搜索栏宽度的效果。反之，关闭搜索栏也是同理的。</p>
<p>那么下面就用代码来实现它咯！</p>
<h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>关于自定义的属性，我们可以想到的有搜索栏的背景颜色、搜索栏的位置（左或右）、搜索栏的状态（打开或关闭）等。具体的可以查看下面的 attrs.xml 。根据英文应该能知道对应属性的作用了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SearchBarView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_position"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_left"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_right"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_status"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_close"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_open"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_duration"</span> <span class="attribute">format</span>=<span class="value">"integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text"</span> <span class="attribute">format</span>=<span class="value">"string|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_icon"</span> <span class="attribute">format</span>=<span class="value">"reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>而在构造器中，肯定就是初始化一些 attrs 中的全局变量了，这也不是重点，都是机械式的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SearchBarView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.SearchBarView);</span><br><span class="line">    searchBarColor = array.getColor(R.styleable.SearchBarView_search_bar_color, DEFAULT_SEARCH_BAR_COLOR);</span><br><span class="line">    mPosition = array.getInteger(R.styleable.SearchBarView_search_bar_position, DEFAULT_RIGHT_POSITION);</span><br><span class="line">    mStatus = array.getInteger(R.styleable.SearchBarView_search_bar_status, STATUS_CLOSE);</span><br><span class="line">    <span class="keyword">int</span> mDuration = array.getInteger(R.styleable.SearchBarView_search_bar_duration, DEFAULT_ANIMATION_DURATION);</span><br><span class="line">    <span class="keyword">int</span> searchBarIcon = array.getResourceId(R.styleable.SearchBarView_search_bar_icon, android.R.drawable.ic_search_category_default);</span><br><span class="line">    mSearchText = array.getText(R.styleable.SearchBarView_search_bar_hint_text);</span><br><span class="line">    searchTextColor = array.getColor(R.styleable.SearchBarView_search_bar_hint_text_color, DEFAULT_SEARCH_TEXT_COLOR);</span><br><span class="line">    <span class="keyword">float</span> defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, DEFAULT_HINT_TEXT_SIZE, getResources().getDisplayMetrics());</span><br><span class="line">    <span class="keyword">float</span> searchTextSize = array.getDimension(R.styleable.SearchBarView_search_bar_hint_text_size, defaultTextSize);</span><br><span class="line">    defaultHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_HEIGHT, getResources().getDisplayMetrics());</span><br><span class="line">    array.recycle();</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    mPaint.setTextSize(searchTextSize);</span><br><span class="line">    mRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    mDstRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    bitmap = BitmapFactory.decodeResource(getResources(), searchBarIcon);</span><br><span class="line">    initAnimator(mDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initAnimator"><a href="#initAnimator" class="headerlink" title="initAnimator"></a>initAnimator</h2><p><code>initAnimator</code> 方法中是两个属性动画，打开和关闭动画。非常 easy 的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAnimator</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">    AccelerateInterpolator accelerateInterpolator = <span class="keyword">new</span> AccelerateInterpolator();</span><br><span class="line">    ValueAnimator.AnimatorUpdateListener animatorUpdateListener = <span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            mOffsetX = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// init open animator</span></span><br><span class="line">    openAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    openAnimator.setDuration(duration);</span><br><span class="line">    openAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    openAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_OPEN;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// init close animator</span></span><br><span class="line">    closeAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    closeAnimator.setDuration(duration);</span><br><span class="line">    closeAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    closeAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>同样，<code>onMeasure</code> 中的代码也是很机械的，基本上都是同一个套路了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mHeight = heightSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHeight = (<span class="keyword">int</span>) defaultHeight;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            mHeight = Math.min(heightSize, mHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索栏小圆圈的半径</span></span><br><span class="line">    mRadius = Math.min(mWidth, mHeight) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN) &#123;</span><br><span class="line">        mOffsetX = mWidth - mRadius * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>在 <code>onDraw</code> 中先画了搜索栏的背景，然后是搜索栏的图标，最后是搜索栏的提示文字。</p>
<p>画背景的时候，是需要根据搜索栏在左边还是右边的位置来确定值的。</p>
<p>而画图标的时候，是根据搜索栏关闭时那个圆的内切正方形作为 Rect 的。</p>
<p>最后画提示文字没什么好讲的了，都是定死的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// draw search bar</span></span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    <span class="keyword">int</span> left = mPosition == DEFAULT_RIGHT_POSITION ? mWidth - <span class="number">2</span> * mRadius - mOffsetX : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = mPosition == DEFAULT_RIGHT_POSITION ? mWidth : <span class="number">2</span> * mRadius + mOffsetX;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        canvas.drawRoundRect(left, <span class="number">0</span>, right, mHeight, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRectF.set(left, <span class="number">0</span>, right, mHeight);</span><br><span class="line">        canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// draw search bar icon</span></span><br><span class="line">    mDstRectF.set(left + (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius),</span><br><span class="line">            left + (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius));</span><br><span class="line">    canvas.drawBitmap(bitmap, <span class="keyword">null</span>, mDstRectF, mPaint);</span><br><span class="line">    <span class="comment">// draw search bar text</span></span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN &amp;&amp; !TextUtils.isEmpty(mSearchText)) &#123;</span><br><span class="line">        mPaint.setColor(searchTextColor);</span><br><span class="line">        Paint.FontMetrics fm = mPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">double</span> textHeight = Math.ceil(fm.descent - fm.ascent);</span><br><span class="line">        canvas.drawText(mSearchText.toString(), <span class="number">2</span> * mRadius, (<span class="keyword">float</span>) (mRadius + textHeight / <span class="number">2</span> - fm.descent), mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="startOpen_u3001startClose"><a href="#startOpen_u3001startClose" class="headerlink" title="startOpen、startClose"></a>startOpen、startClose</h2><p>最后，需要将 <code>startOpen</code> 和 <code>startClose</code> 方法暴露给外部，方便调用。在其内部就是调用两个属性动画而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为打开状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为关闭状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_CLOSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打开搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        closeAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    openAnimator.setIntValues(mOffsetX, mWidth - mRadius * <span class="number">2</span>);</span><br><span class="line">    openAnimator.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClose()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        openAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    closeAnimator.setIntValues(mOffsetX, <span class="number">0</span>);</span><br><span class="line">    closeAnimator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>到这也差不多了，该讲的都讲了，这篇写得真 TMD 简洁。至于和 <code>AppBarLayout</code> 的混合使用，见 GitHub 中的代码即可。</p>
<p>有问题的可以在下面留言。没问题的老铁可以来一波 star 。</p>
<p>FlexibleSearchBar：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/Flexibl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起来写OkHttp的拦截器]]></title>
    <link href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OkHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://yuqirong.me/2017/06/25/一起来写OkHttp的拦截器/</id>
    <published>2017-06-25T04:37:02.000Z</published>
    <updated>2017-07-22T08:23:55.849Z</updated>
    <content type="html"><![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。</p>
<p>现如今，做 Android 开发在选择网络框架时，大多数都会首推 Retrofit 。Retrofit 以其简洁优雅的代码俘获了大多数开发者的心。</p>
<p>然而 Retrofit 内部请求也是基于 OkHttp 的，所以在做一些自定义修改 HTTP 请求时，需要对 OkHttp 拦截器具有一定了解。相信熟悉 OkHttp 的同学都知道，OkHttp 内部是使用拦截器来完成请求和响应的，利用的是责任链设计模式。所以可以说，拦截器是 OkHttp 的精髓所在。</p>
<p>那么接下来，我们就通过一些例子来学习怎样编写 OkHttp 的拦截器吧，其实这些例子也正是之前我遇到的情景。</p>
<h1 id="00_3A01"><a href="#00_3A01" class="headerlink" title="00:01"></a>00:01</h1><h2 id="u6DFB_u52A0_u8BF7_u6C42_Header"><a href="#u6DFB_u52A0_u8BF7_u6C42_Header" class="headerlink" title="添加请求 Header"></a>添加请求 Header</h2><p>假设现在后台要求我们在请求 API 接口时，都在每一个接口的请求头上添加对应的 token 。使用 Retrofit 比较多的同学肯定会条件反射出以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FormUrlEncoded</span></span><br><span class="line"><span class="annotation">@POST</span>(<span class="string">"/mobile/login.htm"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">login</span><span class="params">(@Header(<span class="string">"token"</span>)</span> String token, @<span class="title">Field</span><span class="params">(<span class="string">"mobile"</span>)</span> String phoneNumber, @<span class="title">Field</span><span class="params">(<span class="string">"smsCode"</span>)</span> String smsCode)</span>;</span><br></pre></td></tr></table></figure>
<p>这样的写法自然可以，无非就是每次调用 login API 接口时都把 token 传进去而已。但是需要注意的是，假如现在有十多个 API 接口，每一个都需要传入 token ，难道我们去重复一遍又一遍吗？</p>
<p>相信有良知的程序员都会拒绝，因为这会导致代码的冗余。</p>
<p>那么有没有好的办法可以一劳永逸呢？答案是肯定的，那就要用到拦截器了。</p>
<p>代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenHeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// get token</span></span><br><span class="line">        String token = AppService.getToken();</span><br><span class="line">        Request originalRequest = chain.request();</span><br><span class="line">        <span class="comment">// get new request, add request header</span></span><br><span class="line">        Request updateRequest = originalRequest.newBuilder()</span><br><span class="line">                .header(<span class="string">"token"</span>, token)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(updateRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先拦截得到 originalRequest ，然后利用 originalRequest 生成新的 updateRequest ，再交给 chain 处理进行下一环。</p>
<p>最后，在 OkHttpClient 中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(GsonConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<h2 id="u6539_u53D8_u8BF7_u6C42_u4F53"><a href="#u6539_u53D8_u8BF7_u6C42_u4F53" class="headerlink" title="改变请求体"></a>改变请求体</h2><p>除了增加请求头之外，拦截器还可以改变请求体。</p>
<p>假设现在我们有如下需求：在上面的 login 接口基础上，后台要求我们传过去的请求参数是要按照一定规则经过加密的。</p>
<p>规则如下：</p>
<ul>
<li>请求参数名统一为content；</li>
<li>content值：JSON 格式的字符串经过 AES 加密后的内容；</li>
</ul>
<p>举个例子，根据上面的 login 接口，现有</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">mobile</span>":<span class="value"><span class="string">"157xxxxxxxx"</span></span>, "<span class="attribute">smsCode</span>":<span class="value"><span class="string">"xxxxxx"</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>JSON 字符串，然后再将其加密。最后以 content=[加密后的 JSON 字符串] 方式发送给后台。</p>
<p>看完了上面的 <code>TokenHeaderInterceptor</code> 之后，这需求对于我们来说可以算是信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestEncryptInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORM_NAME = <span class="string">"content"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RequestBody body = request.body();</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">            FormBody formBody = (FormBody) body;</span><br><span class="line">            Map&lt;String, String&gt; formMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从 formBody 中拿到请求参数，放入 formMap 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class="line">                formMap.put(formBody.name(i), formBody.value(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 formMap 转化为 json 然后 AES 加密</span></span><br><span class="line">            Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">            String jsonParams = gson.toJson(formMap);</span><br><span class="line">            String encryptParams = AESCryptUtils.encrypt(jsonParams.getBytes(CHARSET), AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 重新修改 body 的内容</span></span><br><span class="line">            body = <span class="keyword">new</span> FormBody.Builder().add(FORM_NAME, encryptParams).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    .post(body)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中已经添加了关键的注释，相信我已经不需要多解释什么了。</p>
<p>经过了这两种拦截器，相信同学们已经充分体会到了 OkHttp 的优点和与众不同。</p>
<p>最后，自定义拦截器的使用情景通常是对所有网络请求作统一处理。如果下次你也碰到这种类似的需求，别忘记使用自定义拦截器哦！</p>
<h1 id="00_3A02"><a href="#00_3A02" class="headerlink" title="00:02"></a>00:02</h1><p>呃呃呃，按道理来讲应该要结束了。</p>
<p>但是，我在这里开启一个番外篇吧，不过目标不是针对拦截器而是 ConverterFactory 。</p>
<p>还是后台需求，login 接口返回的数据也是经过 AES 加密的。所以需要我们针对所有响应体都做解密处理。</p>
<p>另外，还有很重要的一点，就是数据正常和异常时返回的 JSON 格式不一致。</p>
<p>在业务数据正常的时候（即 code 等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"请求成功"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">nickName</span>":<span class="value"><span class="string">"Hello"</span></span>,</span><br><span class="line">        "<span class="attribute">userId</span>": <span class="value"><span class="string">"1234567890"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>业务数据异常时（即 code 不等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">7008</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>而这会在使用 Retrofit 自动从 JSON 转化为 bean 类时报错。因为 data 中的正常数据中是 JSON ，而另一个异常数据中是字符串。</p>
<p>那么，如何解决上述的两个问题呢？</p>
<p>利用 <strong>自定义 ConverterFactory</strong> ！！</p>
<p>我们先创建包名 <code>retrofit2.converter.gson</code> ，为什么要创建这个包名呢？</p>
<p>因为自定义的 ConverterFactory 需要继承 Converter.Factory ，而 Converter.Factory 类默认是包修饰符。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>) <span class="comment">// Guarding public API nullability.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomConverterFactory(gson);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="comment">// attention here!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomResponseConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>CustomConverterFactory</code> 内部是根据 <code>CustomResponseConverter</code> 来转化 JSON 的，这才是我们的重点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomResponseConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CODE = <span class="string">"code"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA = <span class="string">"data"</span>;</span><br><span class="line"></span><br><span class="line">    CustomResponseConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String originalBody = value.string();</span><br><span class="line">            <span class="comment">// 先 AES 解密</span></span><br><span class="line">            String body = AESCryptUtils.decrypt(originalBody, AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 再获取 code </span></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject(body);</span><br><span class="line">            <span class="keyword">int</span> code = json.optInt(CODE);</span><br><span class="line">            <span class="comment">// 当 code 不为 200 时，设置 data 为 null，这样转化就不会出错了</span></span><br><span class="line">            <span class="keyword">if</span> (code != <span class="number">200</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = gson.fromJson(body, <span class="keyword">new</span> TypeToken&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">                &#125;.getType());</span><br><span class="line">                map.put(DATA, <span class="keyword">null</span>);</span><br><span class="line">                body = gson.toJson(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> adapter.fromJson(body);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也是很简单的，相信也不需要解释了。o(∩_∩)o</p>
<p>最后就是使用了 <code>CustomConverterFactory</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> RequestEncryptInterceptor())</span><br><span class="line">                .build();</span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(CustomConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<p>好了，这下真的把该讲的都讲完了，大家可以散了。</p>
<p>完结了。</p>
<p>再见！</p>
<p>再见！</p>
<p>再见！</p>
<p>重要的说三遍！！！</p>
<p>再说最后一遍，再见！！！</p>
<h1 id="00_3A03"><a href="#00_3A03" class="headerlink" title="00:03"></a>00:03</h1><p><strong>References</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/2263242fa02d" target="_blank" rel="external">如何使用Retrofit请求非Restful API</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(二)]]></title>
    <link href="http://yuqirong.me/2017/06/13/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2017/06/13/Kotlin入入入门(二)/</id>
    <published>2017-06-13T12:16:20.000Z</published>
    <updated>2017-06-14T14:14:52.084Z</updated>
    <content type="html"><![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a> 中已经介绍了如何配置 Kotlin 。另外，还把 Java 代码转换为了 Kotlin 代码。所以今天我们就来比较一下这两者代码之间的区别，从而实现快速入门 Kotlin 。</p>
<p>Now ，我们把之前相同含义的 Java 和 Kotlin 代码粘贴出来（上面是 Java 代码，下面是 Kotlin 代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>我们先慢慢地从上往下看，第一句 <code>package</code> 语句就有所不同。我们发现 Kotlin 中的所有代码没有以 <code>;</code> 结尾。另外，在 Kotlin 中并不要求包与目录匹配。即源文件可以在文件系统中的任意位置。</p>
<p>比如 <code>package me.yuqirong.kotlintest</code> 可能位于 /me/yuqirong/kotlintest2/ 文件夹下，并不会报错；而在 Java 中，包与目录必须匹配。</p>
<p>但是需要注意的一点是，在 AndroidManifest.xml 中配置的 Activity 的全类名必须和其路径一致，否则会找不到！</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>在 Kotlin 中，<code>class</code> 默认是 <code>public</code> 的，所以平常都省略不写。</p>
<p>继承父类和实现接口都用 <code>:</code> 来表示。不同的是继承父类是带 <code>()</code> 的，即表示构造器，比如上面的 <code>AppCompatActivity()</code> ；而接口则不需要 <code>()</code> 。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AppCompatActivity()</code> 就是继承，而 <code>View.OnClickListener</code> 就是实现。</p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>从比较的代码中可以知道：</p>
<ol>
<li>在 Kotlin 中默认方法的修饰符就是 <code>public</code> ，可以省略不写。</li>
<li>在 Kotlin 中重写的方法是要加 <code>override</code> 关键字的，而 Java 是以注解 <code>@Override</code> 来修饰的；</li>
<li>在 Kotlin 中方法都是用 <code>fun</code> 关键字来声明的；</li>
<li>在 Kotlin 中方法的参数是参数名在前，参数类型在后，中间以 <code>:</code> 隔开；若参数可能为空，则在参数类型后加 <code>?</code> 来表示。即上面代码中的 <code>(savedInstanceState: Bundle?)</code> ；</li>
<li><p>和参数表示类似，返回值也是以 <code>: 返回类型</code> 的方式表示的。比如上面的 Kotlin 代码可写为</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span>: Unit &#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Kotlin 中的 <code>Unit</code> 类型即 Java 中的 void 类型，可以省略不写。</p>
</li>
</ol>
<p>举个例子：</p>
<p>方法名 <code>multiplication</code> ，参数 <code>int a</code> 和 <code>int b</code> ，返回 <code>a</code> 和 <code>b</code> 相乘的值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人也许会有疑问，这和 Java 代码行数也差不多嘛。</p>
<p>当然还有更加简单的写法，函数体可以是表达式，并可从中推断出返回值类型。返回类型就可以省略不写了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a * b</span></span><br></pre></td></tr></table></figure>
<h1 id="u9644_u52A0_u9898"><a href="#u9644_u52A0_u9898" class="headerlink" title="附加题"></a>附加题</h1><h2 id="u5B9A_u4E49_u53D8_u91CF"><a href="#u5B9A_u4E49_u53D8_u91CF" class="headerlink" title="定义变量"></a>定义变量</h2><p>只读变量 val</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 推测为 Int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> j</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Kotlin 中的 <code>val</code> 关键字就类似于 Java 中的 <code>final</code> 。</p>
<p>可变变量 var</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="u5B57_u7B26_u4E32_u6A21_u677F"><a href="#u5B57_u7B26_u4E32_u6A21_u677F" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式，即可求值的代码片段，并将其结果连接到字符串中。一个模板表达式由一个 $ 开始并包含另一个简单的名称。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> text</span> = <span class="string">"World!"</span></span><br><span class="line">    println(<span class="string">"Hello, $&#123;text&#125;"</span>) <span class="comment">// 也可以去掉&#123;&#125;，即 println("Hello, $text")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：Hello, World!</p>
<h2 id="u57FA_u672C_u7C7B_u578B"><a href="#u57FA_u672C_u7C7B_u578B" class="headerlink" title="基本类型"></a>基本类型</h2><p>Kotlin 基本类型包括了数值、字符、布尔、字符串和数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment">// double 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Double</span> = <span class="number">125.2</span></span><br><span class="line"><span class="comment">// float 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Float</span> = <span class="number">123.2</span>f</span><br><span class="line"><span class="comment">// long 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> d</span>: <span class="typename">Long</span> = <span class="number">1234</span>L</span><br><span class="line"><span class="comment">// boolean 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> e</span>: <span class="typename">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// char 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> f</span>: <span class="typename">Char</span> = 'e'</span><br><span class="line"><span class="comment">// string 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> g</span>: String = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">// byte 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> h</span>: <span class="typename">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// short 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Short</span> = <span class="number">3</span></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> x</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="u6D41_u7A0B_u63A7_u5236"><a href="#u6D41_u7A0B_u63A7_u5236" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><p>if 表达式<br>  除了 Java 中 if 使用方法外，在 Kotlin 中还支持如下的写法：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> a</span> = <span class="number">101</span></span><br><span class="line">	<span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">100</span>)&#123;</span><br><span class="line">		print(<span class="string">"a &gt; 100 "</span>)</span><br><span class="line">		<span class="literal">true</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		print(<span class="string">"a &lt;= 100 "</span>)</span><br><span class="line">		<span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">    println(b)</span><br><span class="line">	<span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果：a &gt; 100 true</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    println(testIf(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testIf</span><span class="params">(a: <span class="typename">Int</span>)</span> = <span class="title">if</span><span class="params">(a &gt; 100)</span> true <span class="keyword">else</span> false</span></span><br></pre></td></tr></table></figure>
<p>  运行结果：false</p>
</li>
<li><p>when 表达式<br>  Kotlin 中的 when 表达式就是 Java 中的 switch 表达式，具体例子如下：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> collection</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;</span><br><span class="line">	print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 循环<br>  while 循环与 Java 中的无异。</p>
</li>
</ul>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>今天就讲到这里了，更多 Kotlin 的使用方法就期待下一篇吧！</p>
<p>Goodbye ! ~ ~</p>
<p>更多关于 Kotlin 的博客：</p>
<ul>
<li><a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(一)]]></title>
    <link href="http://yuqirong.me/2017/06/07/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://yuqirong.me/2017/06/07/Kotlin入入入门(一)/</id>
    <published>2017-06-07T12:10:22.000Z</published>
    <updated>2017-06-14T14:15:16.961Z</updated>
    <content type="html"><![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio 配置</h1><p>Android Studio 3.0 版本已经默认添加了对 Kotlin 的支持，所以以下 Android Studio 配置是针对于 3.0 版本以下的。</p>
<ol>
<li><p>安装 Kotlin 插件</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607210549.png" alt="Kotlin Plugin"></p>
</li>
<li><p>将 Java 代码转化为 Kotlin 代码</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607221409.png" alt="Converting Java code to Kotlin"></p>
<p> 之后代码就变成了如下：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件编辑之后，会跳出一个配置 Kotlin 的提示：</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222519.png" alt="Kotlin Configure"></p>
<p> 点击配置后，出现如下弹窗，点击 OK 即可</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222730.png" alt="Kotlin Configure Dialog"></p>
</li>
<li><p>配置完成后，可以看到项目的 build.gradle 多了一些：</p>
<pre><code>buildscript {
    ext.kotlin_version = &apos;1.1.2-4&apos;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre><p> app/build.gradle 的配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;

...

dependencies {
    ...
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
}
</code></pre></li>
</ol>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1><p>学习一门编程语言的首要任务就是写出 “Hello World” ，那就让我们迈下第一步吧。</p>
<p>activity_main.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/activity_main"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"me.yuqirong.kotlindemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/textView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 <code>onCreate(savedInstanceState: Bundle?)</code> 去得到 <code>textView</code> 。这里就体现出 Kotlin 的好处了，不再需要 <code>findViewById</code> 。而是先需要在 app/build.gradle 中添加如下配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;
// 添加以下这行
apply plugin: &apos;kotlin-android-extensions&apos;

...
</code></pre><p>配置好后，在代码中就可以直接使用了，是不是很方便呢！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，demo的效果图就是这样滴，不加特效！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607231545.png" alt="Demo效果图"></p>
<p>Goodbye ~ ~</p>
<p>Demo下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170607/KotlinDemo.rar" target="_blank" rel="external">KotlinDemo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[玩转仿探探卡片式滑动效果]]></title>
    <link href="http://yuqirong.me/2017/03/05/%E7%8E%A9%E8%BD%AC%E4%BB%BF%E6%8E%A2%E6%8E%A2%E5%8D%A1%E7%89%87%E5%BC%8F%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2017/03/05/玩转仿探探卡片式滑动效果/</id>
    <published>2017-03-05T14:45:22.000Z</published>
    <updated>2017-03-08T15:26:51.789Z</updated>
    <content type="html"><![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的原理肯定和 ListView / RecyclerView 类似，涉及到 Item View 的回收和重用，否则早就因为大量的 Item View 而 OOM 了。</p>
<p>再到后来，看到许多大神也推出了同样仿探探效果的博客，从头到尾阅读下来，写得通俗易懂，基本上没什么问题。于是，实现仿探探效果的想法再次出现在脑海中。那么，还犹豫什么，趁热来一发吧！就这么愉快地决定了。</p>
<p>首先面临的问题就是关于实现 View 上的考虑。毫无疑问，</p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p>重要的话讲三遍！！！</p>
<p>究其原因，第一，RecyclerView 是自带 Item View 回收和重用功能的，就不需要我们考虑这个问题了；第二，RecyclerView 的布局方式是通过设置 LayoutManager 来实现的，这样就充分地把布局和 RecyclerView “解耦”开来了。而 LayoutManager 是可以通过自定义的方式来实现的。这恰恰是我们想要的！！！再说一点，这也正是不选用 ListView 的原因之一。</p>
<p>下面，我们就开始动手了。带你见证奇迹的时刻。</p>
<h2 id="CardLayoutManager"><a href="#CardLayoutManager" class="headerlink" title="CardLayoutManager"></a>CardLayoutManager</h2><p>创建 <code>CardLayoutManager</code> 并继承自 <code>RecyclerView.LayoutManager</code> 。需要我们自己实现 <code>generateDefaultLayoutParams()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，像上面这样写即可。</p>
<p>下面这个方法就是我们的重点了。 <code>onLayoutChildren(final RecyclerView.Recycler recycler, RecyclerView.State state)</code> 方法就是用来实现 Item View 布局的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(<span class="keyword">final</span> RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayoutChildren(recycler, state);</span><br><span class="line">    <span class="comment">// 先移除所有view</span></span><br><span class="line">    removeAllViews();</span><br><span class="line">    <span class="comment">// 在布局之前，将所有的子 View 先 Detach 掉，放入到 Scrap 缓存中</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    <span class="keyword">int</span> itemCount = getItemCount();</span><br><span class="line">    <span class="comment">// 在这里，我们默认配置 CardConfig.DEFAULT_SHOW_ITEM = 3。即在屏幕上显示的卡片数为3</span></span><br><span class="line">    <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">    <span class="keyword">if</span> (itemCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">        <span class="comment">// 把数据源倒着循环，这样，第0个数据就在屏幕最上面了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = CardConfig.DEFAULT_SHOW_ITEM; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            <span class="comment">// 将 Item View 加入到 RecyclerView 中</span></span><br><span class="line">            addView(view);</span><br><span class="line">            <span class="comment">// 测量 Item View</span></span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// getDecoratedMeasuredWidth(view) 可以得到 Item View 的宽度</span></span><br><span class="line">            <span class="comment">// 所以 widthSpace 就是除了 Item View 剩余的值</span></span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="comment">// 同理</span></span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line">            <span class="comment">// 将 Item View 放入 RecyclerView 中布局</span></span><br><span class="line">            <span class="comment">// 在这里默认布局是放在 RecyclerView 中心</span></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line">            <span class="comment">// 其实屏幕上有四张卡片，但是我们把第三张和第四张卡片重叠在一起，这样看上去就只有三张</span></span><br><span class="line">            <span class="comment">// 第四张卡片主要是为了保持动画的连贯性</span></span><br><span class="line">            <span class="keyword">if</span> (position == CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">                <span class="comment">// 按照一定的规则缩放，并且偏移Y轴。</span></span><br><span class="line">                <span class="comment">// CardConfig.DEFAULT_SCALE 默认为0.1f，CardConfig.DEFAULT_TRANSLATE_Y 默认为14</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((position - <span class="number">1</span>) * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 mTouchListener 的意义就在于我们想让处于顶层的卡片是可以随意滑动的</span></span><br><span class="line">                <span class="comment">// 而第二层、第三层等等的卡片是禁止滑动的</span></span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据源个数小于或等于最大显示数时，和上面的代码差不多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = itemCount - <span class="number">1</span>; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            addView(view);</span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line"></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> View.OnTouchListener mOnTouchListener = <span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(v);</span><br><span class="line">        <span class="comment">// 把触摸事件交给 mItemTouchHelper，让其处理卡片滑动事件</span></span><br><span class="line">        <span class="keyword">if</span> (MotionEventCompat.getActionMasked(event) == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            mItemTouchHelper.startSwipe(childViewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>CardLayoutManager</code> 主要就是为 Item View 布局，然后根据 <code>position</code> 做相对应的偏差。我们一起来看下完成的效果图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306221018.jpg" alt="layout效果图"></p>
<p>可以看出，大致的效果已经有了。缺少的就是处理触摸滑动事件了。</p>
<h2 id="OnSwipeListener"><a href="#OnSwipeListener" class="headerlink" title="OnSwipeListener"></a>OnSwipeListener</h2><p>在看滑动事件的代码之前，我们先定义一个监听器。主要用于监听卡片滑动事件，代码就如下所示，注释也给出来了。应该都看得懂吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSwipeListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片还在滑动时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑动卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> ratio      滑动进度的比例</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑动的方向，CardConfig.SWIPING_LEFT 为向左滑，CardConfig.SWIPING_RIGHT 为向右滑，</span><br><span class="line">     *                   CardConfig.SWIPING_NONE 为不偏左也不偏右</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiping</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">float</span> ratio, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片完全滑出时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑出卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> t          该滑出卡片的数据</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑出的方向，CardConfig.SWIPED_LEFT 为左边滑出；CardConfig.SWIPED_RIGHT 为右边滑出</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, T t, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 所有的卡片全部滑出时回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipedClear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CardItemTouchHelperCallback"><a href="#CardItemTouchHelperCallback" class="headerlink" title="CardItemTouchHelperCallback"></a>CardItemTouchHelperCallback</h2><p>现在，我们可以回过头来看看卡片滑动了。对于 ItemTouchHelper 来处理 Item View 的触摸滑动事件相必都不陌生吧，如果对这方面不太了解的同学可以看一下我之前的博客：<a href="/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/">《RecyclerView实现拖拽排序和侧滑删除》</a>。</p>
<p>我们暂且命名为 CardItemTouchHelperCallback 。对于 ItemTouchHelper.Callback 而言，需要在 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中配置 <code>swipeFlags</code> 和 <code>dragFlags</code> 。</p>
<p>具体的方法如下，对于 <code>swipeFlags</code> 只关心左右两个方向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> swipeFlags = <span class="number">0</span>;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> CardLayoutManager) &#123;</span><br><span class="line">        swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意，前面说过，为了防止第二层和第三层卡片也能滑动，因此我们需要设置 <code>isItemViewSwipeEnabled()</code> 返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemViewSwipeEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是去重写 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 和 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法。但是因为在上面我们对于 <code>dragFlags</code> 配置的是 0 ，所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 中直接返回 false 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把目光投向 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移除之前设置的 onTouchListener, 否则触摸滑动会乱了</span></span><br><span class="line">    viewHolder.itemView.setOnTouchListener(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 删除相对应的数据	</span></span><br><span class="line">    <span class="keyword">int</span> layoutPosition = viewHolder.getLayoutPosition();</span><br><span class="line">    T remove = dataList.remove(layoutPosition);</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">    <span class="comment">// 卡片滑出后回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onSwiped(viewHolder, remove, direction == ItemTouchHelper.LEFT ? CardConfig.SWIPED_LEFT : CardConfig.SWIPED_RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当没有数据时回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (adapter.getItemCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mListener.onSwipedClear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好后，我们先来看看滑动效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307214251.gif" alt="swipe效果图"></p>
<p>发现还是差了点什么，没错！是缺少了动画。在滑动的过程中我们可以重写 <code>onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,
                            float dX, float dY, int actionState, boolean isCurrentlyActive)</code> 方法来添加动画：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildDraw</span><span class="params">(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,</span><br><span class="line">                        <span class="keyword">float</span> dX, <span class="keyword">float</span> dY, <span class="keyword">int</span> actionState, <span class="keyword">boolean</span> isCurrentlyActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);</span><br><span class="line">    View itemView = viewHolder.itemView;</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123;</span><br><span class="line">        <span class="comment">// 得到滑动的阀值</span></span><br><span class="line">        <span class="keyword">float</span> ratio = dX / getThreshold(recyclerView, viewHolder);</span><br><span class="line">        <span class="comment">// ratio 最大为 1 或 -1</span></span><br><span class="line">        <span class="keyword">if</span> (ratio &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ratio = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">            ratio = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认最大的旋转角度为 15 度</span></span><br><span class="line">        itemView.setRotation(ratio * CardConfig.DEFAULT_ROTATE_DEGREE);</span><br><span class="line">        <span class="keyword">int</span> childCount = recyclerView.getChildCount();</span><br><span class="line">        <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">1</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                <span class="comment">// 和之前 onLayoutChildren 是一个意思，不过是做相反的动画</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当数据源个数小于或等于最大显示数时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调监听器</span></span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratio != <span class="number">0</span>) &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, ratio &lt; <span class="number">0</span> ? CardConfig.SWIPING_LEFT : CardConfig.SWIPING_RIGHT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, CardConfig.SWIPING_NONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getThreshold</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recyclerView.getWidth() * getSwipeThreshold(viewHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们加上动画后，来看看效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307222247.gif" alt="swipe效果图"></p>
<p>发现还是有问题，第一层的卡片滑出去之后第二层的就莫名其妙地偏了。这正是因为 Item View 重用机制“捣鬼”。所以我们应该在 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中重置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setRotation(<span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成，我们试一下效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306234152.gif" alt="swipe效果图"></p>
<p>Perfect !</p>
<p>这正是我们梦寐以求的效果。我们终于实现了！！！</p>
<p>总结一下，在这整个代码流程中我们主要是运用了自定义 LayoutManager 以及 ItemTouchHelper.Callback 。总体来说还是比较简单的，相信你已经会啦。</p>
<p>Goodbye ~~</p>
<p>最后，放上 GitHub 地址：<a href="https://github.com/yuqirong/CardSwipeLayout" target="_blank" rel="external">yuqirong/CardSwipeLayout</a></p>
<p>喜欢的可以来一波 star 哦。@^_^@</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android-architecture之todo-mvp源码分析]]></title>
    <link href="http://yuqirong.me/2017/02/22/android-architecture%E4%B9%8Btodo-mvp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/02/22/android-architecture之todo-mvp源码分析/</id>
    <published>2017-02-22T13:08:02.000Z</published>
    <updated>2017-02-28T15:09:06.682Z</updated>
    <content type="html"><![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 下半年来，MVP 渐渐崛起成为了现在普遍流行的架构模式。但是各种不同实现方式的 MVP 架构层出不穷，也让新手不知所措。而 Google 作为“老大哥”，针对此现象为 Android 架构做出了“规范示例”：<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a> 。 </p>
<p>目前已有的架构示例如下图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170222230352.png" alt="stable sample"></p>
<p>而今天给大家带来的就是分析 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目的架构。那就快进入正题吧！</p>
<h1 id="todo-mvp"><a href="#todo-mvp" class="headerlink" title="todo-mvp"></a>todo-mvp</h1><p>先来看看项目包的目录结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227212108.png" alt="目录结构"></p>
<p>基本上目录结构可以分为四种：</p>
<ol>
<li>addedittask、statistics、taskdetail、tasks ：可以看出在 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目中是按功能来分包的，这些包中的结构都是一致的，待会我们只需要分析其中一个包即可；</li>
<li>data ：该分包下主要是数据层的代码，即 MVP 中的 Model 层；</li>
<li>util ：工具类包，在这里就不展开细讲了；</li>
<li>BaseView、BasePresenter ：MVP 中 View 和 Presenter 的基类。</li>
</ol>
<p>然后是官方给出的 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170228224356.png" alt="MVP"></p>
<h2 id="BaseView__u548C_BasePresenter"><a href="#BaseView__u548C_BasePresenter" class="headerlink" title="BaseView 和 BasePresenter"></a>BaseView 和 BasePresenter</h2><p>这里就先看一下 BaseView 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseView 是一个泛型接口，里面只有一个抽象方法 <code>setPresenter(T presenter)</code> ，用来设置 Presenter 。</p>
<p>然后是 BasePresenter 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasePresenter 接口也只有一个抽象方法 <code>start()</code> ，用于在 Activity/Fragment 的 <code>onResume()</code> 方法中调用。</p>
<h2 id="addedittask_u3001statistics_u3001taskdetail_u3001tasks"><a href="#addedittask_u3001statistics_u3001taskdetail_u3001tasks" class="headerlink" title="addedittask、statistics、taskdetail、tasks"></a>addedittask、statistics、taskdetail、tasks</h2><p>这四个分包从结构上来讲都是一样的，那么在这里我们就分析 tasks 这个分包吧。下面是该分包下的源码文件：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227215628.png" alt="task分包的结构"></p>
<p>我们以 <code>TasksContract</code> 为切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setLoadingIndicator</span><span class="params">(<span class="keyword">boolean</span> active)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasks</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskDetailsUi</span><span class="params">(String taskId)</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadTasks</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNewTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 <code>TasksContract</code> 接口其实就是用来定义 <code>View</code> 和 <code>Presenter</code> 的。 <code>View</code> 和 <code>Presenter</code> 继承了 <code>BaseView</code> 和 <code>BasePresenter</code> 。再回头看看上面的 <code>TaskPresenter</code> ，想必大家都猜到了，肯定是继承了 <code>Presenter</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksPresenter</span> <span class="keyword">implements</span> <span class="title">TasksContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksContract.View mTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TasksPresenter</span><span class="params">(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView)</span> </span>&#123;</span><br><span class="line">        mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null"</span>);</span><br><span class="line">        mTasksView = checkNotNull(tasksView, <span class="string">"tasksView cannot be null!"</span>);</span><br><span class="line"></span><br><span class="line">        mTasksView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadTasks(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TasksPresenter</code> 的构造方法中把 <code>tasksRepository</code> 和 <code>tasksView</code> 传入，并且把 <code>TasksPresenter</code> 对象设置给了 <code>mTasksView</code> 。这样，Presenter 就实现了 Model 和 View 的解耦。</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>data 代表了 MVP 中的 Model 。我们根据上面出现过的 <code>TasksRepository</code> 来分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TasksRepository INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksRemoteDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksLocalDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TasksRepository</span><span class="params">(@NonNull TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                            @NonNull TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</span><br><span class="line">        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">getInstance</span><span class="params">(TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                                              TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TasksRepository</code> 实现了 <code>TasksDataSource</code> 接口，<code>TasksDataSource</code> 接口定义了一些对 <code>Task</code> 的增删改查操作。在 <code>TasksRepository</code> 的构造方法中传入两个 <code>TasksDataSource</code> 对象，其实是模拟了本地数据存储和网络数据存储两种方式。至于其他的就不详细展开了，无非就是对数据读写之类的操作。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里，基本上把 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构的代码大致地讲了一遍。本篇博客就不对其他的代码展开分析了，因为我们注重的是该项目中的 MVP 架构实现方式。另外，todo 系列还有其他几种 MVP 实现的方式，只能下次有空再讲了。</p>
<p>就到这吧，Goodbye !</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android架构" scheme="http://yuqirong.me/tags/Android%E6%9E%B6%E6%9E%84/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NotificationListenerService的那些事儿]]></title>
    <link href="http://yuqirong.me/2017/02/09/NotificationListenerService%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://yuqirong.me/2017/02/09/NotificationListenerService的那些事儿/</id>
    <published>2017-02-09T13:00:04.000Z</published>
    <updated>2017-02-11T03:19:31.471Z</updated>
    <content type="html"><![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</code> 支持的事件监听类型中有 <code>TYPE_NOTIFICATION_STATE_CHANGED</code> ，该事件类型就是用来监听通知栏消息状态改变的，众多的抢红包插件利用的就是这个原理。</p>
<p>之后在 Github 上看到了 <a href="https://github.com/lendylongli/qianghongbao" target="_blank" rel="external">qianghongbao</a> 这个抢红包的项目，发现代码里面有一个 <a href="https://github.com/lendylongli/qianghongbao/blob/master/app/src/main/java/com/codeboy/qianghongbao/QHBNotificationService.java" target="_blank" rel="external">QHBNotificationService</a> 继承了 <code>NotificationListenerService</code> ，这个 <code>NotificationListenerService</code> 极大地引起了我的兴趣。查了一下资料，发现 <code>NotificationListenerService</code> 是在 Android 4.3 （API 18）时被加入的，作用就是用来监听通知栏消息。并且官方建议在 Android 4.3 及以上使用 <code>NotificationListenerService</code> 来监听通知栏消息，以此取代 <code>AccessibilityService</code> 。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170209/20170209220914.png" alt="Notification Listener"></p>
<p><code>NotificationListenerService</code> 的使用范围也挺广的，比如我们熟知的抢红包，智能手表同步通知，通知栏去广告工具等，都是利用它来完成的。所以，我也想赶时髦地好好利用这把“利器”。最后方案也就出来了：在 Android 4.3 以下（API &lt; 18）使用 <code>AccessibilityService</code> 来读取新通知，在 Android 4.3 及以上（API &gt;= 18）使用 <code>NotificationListenerService</code> 来满足需求。</p>
<p>这也正是本篇博客诞生的“起源”。</p>
<h1 id="NotificationListenerService"><a href="#NotificationListenerService" class="headerlink" title="NotificationListenerService"></a>NotificationListenerService</h1><p>在这里，我们就做一个小需求：实时检测微信的新通知，如果该通知是微信红包的话，就进入微信聊天页面。</p>
<p>准备好了吗，我们开始吧！</p>
<p>首先创建一个 <code>WeChatNotificationListenerService</code> 继承 <code>NotificationListenerService</code> 。然后在 <code>AndroidManifest.xml</code> 中进行声明相关权限和 <code>&lt;intent-filter&gt;</code> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">"com.yuqirong.listenwechatnotification.WeChatNotificationListenerService"</span></span><br><span class="line">          <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">          <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.service.notification.NotificationListenerService"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后一般会重写下面这三个方法：</p>
<ul>
<li><code>onNotificationPosted(StatusBarNotification sbn)</code> ：当有新通知到来时会回调；</li>
<li><code>onNotificationRemoved(StatusBarNotification sbn)</code> ：当有通知移除时会回调；</li>
<li><code>onListenerConnected()</code> ：当 <code>NotificationListenerService</code> 是可用的并且和通知管理器连接成功时回调。</li>
</ul>
<h2 id="onNotificationPosted_28StatusBarNotification_sbn_29"><a href="#onNotificationPosted_28StatusBarNotification_sbn_29" class="headerlink" title="onNotificationPosted(StatusBarNotification sbn)"></a>onNotificationPosted(StatusBarNotification sbn)</h2><p>下面我们来看看 <code>NotificationListenerService</code> 中的重点： <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationPosted</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该通知的包名不是微信，那么 pass 掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"com.tencent.mm"</span>.equals(sbn.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Notification notification = sbn.getNotification();</span><br><span class="line">    <span class="keyword">if</span> (notification == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PendingIntent pendingIntent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当 API &gt; 18 时，使用 extras 获取通知的详细信息</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Bundle extras = notification.extras;</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取通知标题</span></span><br><span class="line">            String title = extras.getString(Notification.EXTRA_TITLE, <span class="string">""</span>);</span><br><span class="line">            <span class="comment">// 获取通知内容</span></span><br><span class="line">            String content = extras.getString(Notification.EXTRA_TEXT, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(content) &amp;&amp; content.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                pendingIntent = notification.contentIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 API = 18 时，利用反射获取内容字段</span></span><br><span class="line">        List&lt;String&gt; textList = getText(notification);</span><br><span class="line">        <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp; text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                    pendingIntent = notification.contentIntent;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 pendingIntent 以此打开微信</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingIntent.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，对于分析 <code>Notification</code> 的内容分为了两种：</p>
<ul>
<li>当 API &gt; 18 时，利用 <code>Notification.extras</code> 来获取通知内容。<code>extras</code> 是在 API 19 时被加入的；</li>
<li>当 API = 18 时，利用反射获取 <code>Notification</code> 中的内容。具体的代码在下方。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getText</span><span class="params">(Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == notification) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteViews views = notification.bigContentView;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        views = notification.contentView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use reflection to examine the m_actions member of the given RemoteViews object.</span></span><br><span class="line">    <span class="comment">// It's not pretty, but it works.</span></span><br><span class="line">    List&lt;String&gt; text = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = views.getClass().getDeclaredField(<span class="string">"mActions"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        ArrayList&lt;Parcelable&gt; actions = (ArrayList&lt;Parcelable&gt;) field.get(views);</span><br><span class="line">        <span class="comment">// Find the setText() and setTime() reflection actions</span></span><br><span class="line">        <span class="keyword">for</span> (Parcelable p : actions) &#123;</span><br><span class="line">            Parcel parcel = Parcel.obtain();</span><br><span class="line">            p.writeToParcel(parcel, <span class="number">0</span>);</span><br><span class="line">            parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// The tag tells which type of action it is (2 is ReflectionAction, from the source)</span></span><br><span class="line">            <span class="keyword">int</span> tag = parcel.readInt();</span><br><span class="line">            <span class="keyword">if</span> (tag != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// View ID</span></span><br><span class="line">            parcel.readInt();</span><br><span class="line">            String methodName = parcel.readString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == methodName) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"setText"</span>)) &#123;</span><br><span class="line">                <span class="comment">// Parameter type (10 = Character Sequence)</span></span><br><span class="line">                parcel.readInt();</span><br><span class="line">                <span class="comment">// Store the actual string</span></span><br><span class="line">                String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();</span><br><span class="line">                text.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            parcel.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>凭着 <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法就已经可以完成监听微信通知并打开的动作了。下面我们来看一下其他关于 <code>NotificationListenerService</code> 的二三事。</p>
<h2 id="u53D6_u6D88_u901A_u77E5"><a href="#u53D6_u6D88_u901A_u77E5" class="headerlink" title="取消通知"></a>取消通知</h2><p>有了监听，<code>NotificationListenerService</code> 自然提供了可以取消通知的方法。取消通知的方法有：</p>
<ul>
<li><code>cancelNotification(String key)</code> ：是 API &gt;= 21 才可以使用的。利用 <code>StatusBarNotification</code> 的 <code>getKey()</code> 方法来获取 <code>key</code> 并取消通知。</li>
<li><code>cancelNotification(String pkg, String tag, int id)</code> ：在 API &lt; 21 时可以使用，在 API &gt;= 21 时使用此方法来取消通知将无效，被废弃。</li>
</ul>
<p>最后，取消通知的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelNotification</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        cancelNotification(sbn.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cancelNotification(sbn.getPackageName(), sbn.getTag(), sbn.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743"><a href="#u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743" class="headerlink" title="检测通知监听服务是否被授权"></a>检测通知监听服务是否被授权</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNotificationListenerEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; packageNames = NotificationManagerCompat.getEnabledListenerPackages(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (packageNames.contains(context.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762"><a href="#u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762" class="headerlink" title="打开通知监听设置页面"></a>打开通知监听设置页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openNotificationListenSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(<span class="string">"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898"><a href="#u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898" class="headerlink" title="被杀后再次启动时，监听不生效的问题"></a>被杀后再次启动时，监听不生效的问题</h2><p>这个问题来源于知乎问题： <a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></p>
<p>从问题的回答中可以了解到，是因为 <code>NotificationListenerService</code> 被杀后再次启动时，并没有去 <code>bindService</code> ，所以导致监听效果无效。</p>
<p>最后，在回答中还给出了解决方案：利用 <code>NotificationListenerService</code> 先 disable 再 enable ，重新触发系统的 rebind 操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toggleNotificationListenerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PackageManager pm = getPackageManager();</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用前提是 <code>NotificationListenerService</code> 已经被用户授予了权限，否则无效。另外，在自己的小米手机上实测，重新完成 rebind 操作需要等待 10 多秒（我的手机测试过大概在 13 秒左右）。幸运的是，官方也已经发现了这个问题，在 API 24 中提供了 <code>requestRebind(ComponentName componentName)</code> 方法来支持重新绑定。</p>
<h1 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h1><p>讲完了 <code>NotificationListenerService</code> 之后，按照前面说的那样，在 API &lt; 18 的时候使用 <code>AccessibilityService</code> 。</p>
<p>同样，创建一个 <code>WeChatAccessibilityService</code> ，并且在 <code>AndroidManifest.xml</code> 中进行声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name="com.yuqirong.listenwechatnotification.WeChatAccessibilityService"</span><br><span class="line">    android:label="@string/app_name"</span><br><span class="line">    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name="android.accessibilityservice"</span><br><span class="line">        android:resource="@xml/accessible_service_config" /&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>声明之后，还要对 <code>WeChatAccessibilityService</code> 进行配置。需要在 res 目录下新建一个 xml 文件夹，在里面新建一个 accessible_service_config.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">accessibility-service</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:accessibilityEventTypes</span>=<span class="value">"typeNotificationStateChanged"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFeedbackType</span>=<span class="value">"feedbackAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFlags</span>=<span class="value">"flagIncludeNotImportantViews"</span></span><br><span class="line">    <span class="attribute">android:canRetrieveWindowContent</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:description</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:notificationTimeout</span>=<span class="value">"100"</span></span><br><span class="line">    <span class="attribute">android:packageNames</span>=<span class="value">"com.tencent.mm"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后就是代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatAccessibilityService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            Notification notification = (Notification) event.getParcelableData();</span><br><span class="line">            List&lt;String&gt; textList = getText(notification);</span><br><span class="line">            <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp;</span><br><span class="line">                            text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">final</span> PendingIntent pendingIntent = notification.contentIntent;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pendingIntent.send();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了一圈 <code>WeChatAccessibilityService</code> 的代码，发现和 <code>WeChatNotificationListenerService</code> 在 API &lt; 18 时处理的逻辑是一样的，<code>getText(notification)</code> 方法就是上面那个，在这里就不复制粘贴了，基本没什么好讲的了。</p>
<p>有了 <code>WeChatAccessibilityService</code> 之后，在 API &lt; 18 的情况下也能监听通知啦。\(^ο^)/</p>
<p>我们终于实现了当初许下的那个需求了。 cry …</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>除了监听通知之外，<code>AccessibilityService</code> 还可以进行模拟点击、检测界面变化等功能。具体的可以在 GitHub 上搜索抢红包有关的 Repo 进行深入学习。</p>
<p>而 <code>NotificationListenerService</code> 的监听通知功能更加强大，也更加专业。在一些设备上，如果 <code>NotificationListenerService</code> 被授予了权限，那么可以做到该监听进程不死的效果，也算是另类的进程保活。</p>
<p>今天就到这儿了，拜拜！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170209/ListenWeChatNotification.rar" target="_blank" rel="external">ListenWeChatNotification.rar</a></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/about/versions/android-4.3.html#NotificationListener" target="_blank" rel="external">Android 4.3 APIs</a></li>
<li><a href="https://developer.android.google.cn/reference/android/service/notification/NotificationListenerService.html" target="_blank" rel="external">NotificationListenerService</a></li>
<li><a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView实现拖拽排序和侧滑删除]]></title>
    <link href="http://yuqirong.me/2017/02/03/RecyclerView%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4/"/>
    <id>http://yuqirong.me/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/</id>
    <published>2017-02-03T07:23:59.000Z</published>
    <updated>2017-02-06T15:00:50.672Z</updated>
    <content type="html"><![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提供了相应的功能。</p>
<p>接下来，我们就来看一下怎么用系统 API 来实现排序和删除的效果。</p>
<h2 id="u521B_u5EFA_ItemTouchHelper"><a href="#u521B_u5EFA_ItemTouchHelper" class="headerlink" title="创建 ItemTouchHelper"></a>创建 ItemTouchHelper</h2><p>创建一个 <code>ItemTouchHelper</code> 对象，然后其调用 <code>attachToRecyclerView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);</span><br><span class="line">recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="keyword">false</span>));</span><br><span class="line">RecyclerViewAdapter adapter = <span class="keyword">new</span> RecyclerViewAdapter();</span><br><span class="line">ItemTouchHelper helper = <span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> MyItemTouchCallback(adapter));</span><br><span class="line">helper.attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure>
<p>在创建 <code>ItemTouchHelper</code> 对象时候，需要我们传入一个实现了 <code>ItemTouchHelper.Callback</code> 接口的对象。而排序和删除的逻辑都封装在了这个 <code>ItemTouchHelper.Callback</code> 的对象里面了。</p>
<h2 id="u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3"><a href="#u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3" class="headerlink" title="实现 ItemTouchHelper.Callback 接口"></a>实现 ItemTouchHelper.Callback 接口</h2><p>创建 <code>MyItemTouchCallback</code> 类，实现 <code>ItemTouchHelper.Callback</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemTouchCallback</span> <span class="keyword">extends</span> <span class="title">ItemTouchHelper</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemTouchCallback</span><span class="params">(RecyclerViewAdapter adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>ItemTouchHelper.Callback</code> 接口后有三个方法需要重写：</p>
<ol>
<li><code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> ：设置滑动类型的标记。需要设置两种类型的 flag ，即 <code>dragFlags</code> 和 <code>swipeFlags</code> ，分别代表着拖拽标记和滑动标记。最后需要调用 <code>makeMovementFlags(dragFlags, swipeFlags)</code> 方法来合成返回。</li>
<li><code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> ：当用户拖拽列表某个 item 时会回调。很明显，拖拽排序的代码应该在这个方法中实现。</li>
<li><code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> ：当用户滑动列表某个 item 时会回调。所以侧滑删除的代码应该在这个方法中实现。</li>
</ol>
<h2 id="u91CD_u5199_u65B9_u6CD5"><a href="#u91CD_u5199_u65B9_u6CD5" class="headerlink" title="重写方法"></a>重写方法</h2><p>我们先来看看 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlag;</span><br><span class="line">    <span class="keyword">int</span> swipeFlag;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP</span><br><span class="line">                | ItemTouchHelper.RIGHT | ItemTouchHelper.LEFT;</span><br><span class="line">        swipeFlag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP;</span><br><span class="line">        swipeFlag = ItemTouchHelper.END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlag, swipeFlag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中根据 <code>layoutManager</code> 分为了两种情况：</p>
<ol>
<li>如果是 <code>GridLayoutManager</code> ，那么拖拽排序就可以细分为上下左右四个方向了，而且 <code>GridLayoutManager</code> 没有侧滑删除的功能；</li>
<li>若是其他的 <code>LayoutManager</code> ，比如说 <code>LinearLayoutManager</code> ，那么拖拽排序就只有上下两个方向了，并且设置 <code>swipeFlag</code> 为 <code>ItemTouchHelper.END</code> 类型；</li>
<li>对于其他自定义类型的 <code>LayoutManager</code> 可以自己根据自身情况补充。</li>
</ol>
<p>下面就是 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fromPosition = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">int</span> toPosition = target.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (fromPosition &lt; toPosition) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &lt; toPosition; i++) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &gt; toPosition; i--) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说过了，<code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法是用户在拖拽 item 的时候会回调。所以关于列表排序的代码应该写在这里。方法参数中的 <code>viewHolder</code> 代表的是用户当前拖拽的 item ，而 <code>target</code> 代表的是被用户拖拽所覆盖的那个 item 。所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法中的逻辑就是把 <code>fromPosition</code> 至 <code>toPosition</code> 为止改变它们的位置。</p>
<p>最后就是 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法了：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> void onSwiped(RecyclerView.ViewHolder viewHolder, <span class="built_in">int</span> direction) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">position</span> = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (direction == ItemTouchHelper.<span class="keyword">END</span>) &#123;</span><br><span class="line">        adapter.getDataList().remove(<span class="keyword">position</span>);</span><br><span class="line">        adapter.notifyItemRemoved(<span class="keyword">position</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在用户进行侧滑删除操作的时候会回调，其中的逻辑就是得到当前用户进行侧滑删除操作的 item ，然后将其删除。</p>
<p>到了这里，大功告成了。那么来看看效果吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170206222813.gif" alt="效果图"></p>
<h2 id="u6539_u5584_u7528_u6237_u4F53_u9A8C"><a href="#u6539_u5584_u7528_u6237_u4F53_u9A8C" class="headerlink" title="改善用户体验"></a>改善用户体验</h2><p>我们发现还有一些不完美的地方：比如当用户在拖拽排序的时候，可以改变当前拖拽 item 的透明度，这样就可以和其他 item 区分开来了。那么，我们需要去重写 <code>onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectedChanged</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> actionState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState);</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        viewHolder.itemView.setBackgroundColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应地，当用户手指从拖拽 item 中抬起的时候，我们需要把 item 的透明度复原。需要我们重写 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setBackgroundColor(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，来看看改进之后的效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170203223341.gif" alt="改进效果图"></p>
<p>今天就这样吧，拜拜啦！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170206/TestRV.rar" target="_blank" rel="external">TestRV.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于使用AlarmManager的注意事项]]></title>
    <link href="http://yuqirong.me/2017/01/21/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8AlarmManager%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yuqirong.me/2017/01/21/关于使用AlarmManager的注意事项/</id>
    <published>2017-01-21T15:25:16.000Z</published>
    <updated>2017-01-23T15:34:02.880Z</updated>
    <content type="html"><![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任务，比如设置闹铃、发送心跳包等。也许有人会有疑问：为什么不能使用相同具有定时效果的 <code>Timer</code> 和 <code>Handler</code> 呢？</p>
<p>其实答案非常简单，相对于 <code>Handler</code> 来说，使用 <code>sendEmptyMessageDelayed</code> 方法是依赖于 <code>Handler</code> 所在的线程的，如果线程结束，就起不到定时任务的效果；而 <code>AlarmManager</code> 依赖的是 Android 系统的服务，具备唤醒机制。比起 <code>Handler</code> 也就更合适了。</p>
<p>而至于 <code>Timer</code> 可以精确地做到定时操作，但是相比于 <code>AlarmManager</code> 而言还是差了一截。同理，如果手机关屏后长时间不使用， CPU 就会进入休眠模式。这个使用如果使用 <code>Timer</code> 来执行定时任务就会失败，因为 <code>Timer</code> 无法唤醒 CPU 。</p>
<p>所以，综上所述，<code>AlarmManager</code> 就成为了最佳选择。</p>
<h1 id="SDK_API__26lt_3B_19"><a href="#SDK_API__26lt_3B_19" class="headerlink" title="SDK API &lt; 19"></a>SDK API &lt; 19</h1><p>一般情况下，使用 <code>AlarmManager</code> 来执行重复定时任务的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p><code>setRepeating</code> 该方法用于设置重复定时任务。</p>
<ul>
<li>第一个参数表示闹钟类型：一般为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> 或者 <code>AlarmManager.RTC_WAKEUP</code> 。它们之间的区别就是前者是从手机开机后的时间，包含了手机睡眠时间；而后者使用的就是手机系统设置中的时间。所以如果设置为 <code>AlarmManager.RTC_WAKEUP</code> ，那么可以通过修改手机系统的时间来提前触发定时事件。另外，对于相似的 <code>AlarmManager.ELAPSED_REALTIME</code> 和 <code>AlarmManager.RTC</code> 来说，它们不会唤醒 CPU 。所以使用的频率较少；</li>
<li>第二个参数表示任务首次执行时间：与第一个参数密切相关。第一个参数若为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> ，那么当前时间就为 <code>SystemClock.elapsedRealtime()</code> ；若为 <code>AlarmManager.RTC_WAKEUP</code> ，那么当前时间就为 <code>System.currentTimeMillis()</code> ；</li>
<li>第三个参数表示两次执行的间隔时间：这个参数没什么好讲的，一般为常量；</li>
<li>第四个参数表示对应的响应动作：一般都是去发送广播，然后在广播接收 <code>onReceive(Context context, Intent intent)</code> 中做相关操作。</li>
</ul>
<p>至此，一切顺利，畅通无阻。</p>
<h1 id="SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23"><a href="#SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23" class="headerlink" title="SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23"></a>SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23</h1><p>当你写好代码、满心欢喜地将程序跑在手机上的时候，傻眼了！你会发现在 Android 4.4 及以上版本的定时任务不是按照规定时间间隔来执行的。比如你设置了每隔 3 分钟发出一个 HTTP 请求，结果你一看莫名其妙地变成了隔 5 分钟发一次。</p>
<p>What the fuck?</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122224816.png" alt="what the fuck"></p>
<p>然后你查阅 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a> 会看到如下几句话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122225322.png" alt="Android 4.4 API"></p>
<p>恍然大悟！原来是 Google 为了追求系统省电，所以“偷偷加工”了一下唤醒的时间间隔。但也正如上面官网中所说的那样，如果在 Android 4.4 及以上的设备还要追求精准的闹钟定时任务，要使用 <code>setExact()</code> 方法。</p>
<p>所以，相应的代码就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你写好了“加强版”的 <code>AlarmManager</code> 之后，内心肯定无比小激动。这下总应该行了吧？运行一下，果然没错！在 Android 4.4 上的确按照规定的时间间隔在执行任务。哈哈，这下大功告成了！！！</p>
<h1 id="SDK_API__26gt_3B_3D_23"><a href="#SDK_API__26gt_3B_3D_23" class="headerlink" title="SDK API &gt;= 23"></a>SDK API &gt;= 23</h1><p>在 Android 4.4 上品尝到胜利的甜头后，你顺便在 Android 6.0 的设备上测试了一下。结果。。。。。。你又 TMD 傻眼了！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122232341.png" alt="What the fuck"></p>
<p>发现在设备关屏静止一段时间后， <code>AlarmManager</code> 又又又不能正常工作了。相必此时你连日狗的心都有了吧！强忍着泪水，再次打开 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a> ，发现在 Android 6.0 中引入了低电耗模式和应用待机模式。然后接着往下看 <a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a> ，发现会有下面一段话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122234141.png" alt="Android 6.0 API"></p>
<p>啊啊啊啊啊啊！之前在 Android 4.4 上能用的 <code>setExact()</code> 方法在 Android 6.0 上因为低电耗模式又不能正常使用了。但是，Google 又又又提供了新的方法 <code>setExactAndAllowWhileIdle()</code> 来解决在低电耗模式下的闹钟触发。</p>
<p>所以，Attention！相关的代码又被改写为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到了这里，总算是把因 Android 版本差异导致 <code>AlarmManager</code> 的“坑”填完了。这份代码已经可以满足日常的重复定时任务了。</p>
<p>好了，该讲的都讲完了，上床睡觉。仓促地结尾，预祝大家新年快乐！</p>
<p>Goodbye ！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html" target="_blank" rel="external">AlarmManager</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Say Hello To 2017]]></title>
    <link href="http://yuqirong.me/2017/01/14/Say%20Hello%20To%202017/"/>
    <id>http://yuqirong.me/2017/01/14/Say Hello To 2017/</id>
    <published>2017-01-14T07:53:56.000Z</published>
    <updated>2017-01-14T08:47:28.645Z</updated>
    <content type="html"><![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h1><p>现在回望 2016 年，发现过得也是浑浑噩噩，时间总是在不知不觉中流逝。自从 2016 年的 6 月份毕业开始，算是真正地踏上社会了。尽管万般不情愿，但还是离开了温暖的校园生活，这也意味着自己需要承担更多的责任和义务，加油！</p>
<p>在工作上也并不是一帆风顺，经历过之前八月份的贸然离职后，也懂得了做任何事都需要理性思考，而不是凭着自己的“任性”，不然迟早会付出惨痛的代价。这也教导我要学会珍惜现在，才能放眼于未来。</p>
<p>在过去的 2016 一年里，自己对于 Android 的学习也从“表面”进入到“里面”。不再满足于常规、机械地使用 API ，而是乐于探究其中内在的原理，这也是 Android 进阶开发的必经之路。对于每一位做技术的人员而言，更多地要求自己寻求积累和沉淀，而不应该是盲目地处于一种“会用就好”的状态。</p>
<h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>新的 2017 年，做一个更好的自己。</p>
<p>学习计划：</p>
<ol>
<li>继续深入学习 Android ，理解其中的原理以及解析热门的第三方框架源码，书籍《深入理解 Android 》系列、《 Android 系统源代码情景分析》等；</li>
<li>学习 React JS ，学会利用 React Native 框架开发 APP 。并适当地深入理解其中的原理；</li>
<li>重温 Java ，书籍：《Java编程思想》 、《Effective Java》等；</li>
<li>学习设计模式以及数据结构和算法等，书籍《 Head First 设计模式》等。</li>
<li>更多。。。</li>
</ol>
<p>不念过去，不畏将来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>201]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus源码解析]]></title>
    <link href="http://yuqirong.me/2016/12/20/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/20/EventBus源码解析/</id>
    <published>2016-12-20T15:46:27.000Z</published>
    <updated>2017-01-08T04:28:26.103Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码。那就正好今天来说说 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的那些事儿。</p>
<p>EventBus 是什么呢（相信地球人都知道→_→）？</p>
<p>EventBus is a publish/subscribe event bus optimized for Android.</p>
<p>这是官方给的介绍，简洁、明了、霸气。翻译过来就是：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一种为 Android 而优化设计的发布/订阅事件总线。这官方的套词可能有些人看了还是不懂。。。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20161226232951.jpg" alt="???"></p>
<p>简单地举了栗子，<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 就好像一辆公交车（快上车，老司机要飙车 乀(ˉεˉ乀) ）。相对应的，发布事件就可以类比为乘客，订阅事件就好似接站服务的人。乘客想要到达指定目的地就必须上车乘坐该公交车，公交车会做统一配置管理每位乘客（发布事件流程）。达到目的地后，打开下车门，把乘客交任给接站服务的人做相应的处理（订阅事件流程）。不知道这个栗子你们懂不懂，反正我是懂了(￣ε ￣)。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170107005159.jpg" alt="快上车"></p>
<p>所以总的来说，对于一个事件，你只要关心发送和接收就行了，而其中的收集、分发等都交给 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 来处理，你不需要做任何事。不得不说这太方便了，能让代码更见简洁，大大降低了模块之间的耦合性。</p>
<h1 id="0002B__u4F7F_u7528_u65B9_u6CD5"><a href="#0002B__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0002B 使用方法"></a>0002B 使用方法</h1><p>现在，来看一下 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的使用方法，直接复制粘贴 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 中的例子：</p>
<ol>
<li><p>第一步，定义一个事件类 <code>MessageEvent</code> :</p>
<pre><code>public static class MessageEvent { 
    /* Additional fields if needed */ 
}
</code></pre></li>
<li><p>定义一个订阅方法，可以使用 <code>@Subscribe</code> 注解来指定订阅方法所在的线程：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    /* Do something */
};
</code></pre><p> 注册和反注册你的订阅方法。比如在 Android 中，Activity 和 Fragment 通常在如下的生命周期中进行注册和反注册：</p>
<pre><code>@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}
</code></pre></li>
</ol>
<p>3.发送事件：</p>
<pre><code>EventBus.getDefault().post(new MessageEvent());
</code></pre><p>可以看出 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 使用起来很简单，就这么几行代码解决了许多我们备受困扰的问题。那么接下来我们就深入 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码内部，一探究竟。</p>
<h1 id="0003B_EventBus"><a href="#0003B_EventBus" class="headerlink" title="0003B EventBus"></a>0003B EventBus</h1><p>在 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 上对于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 整体有一张示意图，很明确地画出了整个框架的设计原理：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170102003651.png" alt="EventBus示意图"></p>
<p>那么依据这张图，我们先从 “Publisher” 开始讲起吧。PS : 本文分析的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 源码版本为 3.0.0 。</p>
<h2 id="EventBus-getDefault_28_29"><a href="#EventBus-getDefault_28_29" class="headerlink" title="EventBus.getDefault()"></a>EventBus.getDefault()</h2><p>来看一下 <code>EventBus.getDefault()</code> 的源码（文件路径：org/greenrobot/eventbus/EventBus.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span><br><span class="line"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    <span class="comment">// key 为事件的类型，value 为所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// key 为某个订阅者，value 为该订阅者所有的事件类型</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 粘性事件的集合，key 为事件的类型，value 为该事件的对象</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 主线程事件发送者</span></span><br><span class="line">    mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 子线程事件发送者</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 异步线程事件发送者</span></span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 索引类的数量</span></span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 订阅方法查找者</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    <span class="comment">// 是否打印订阅者异常的日志，默认为 true</span></span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    <span class="comment">// 是否打印没有订阅者的异常日志，默认为 true</span></span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    <span class="comment">// 是否允许发送 SubscriberExceptionEvent ，默认为 true</span></span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    <span class="comment">// 是否允许发送 sendNoSubscriberEvent ，默认为 true</span></span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    <span class="comment">// 是否允许抛出订阅者的异常，默认是 false</span></span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    <span class="comment">// 是否支持事件继承，默认是 true</span></span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中可以看出，平时的我们经常调用的 <code>EventBus.getDefault()</code> 代码，其实是获取了 <code>EventBus</code> 类的单例。若该单例未实例化，那么会根据 <code>DEFAULT_BUILDER</code> 采用构造者模式去实例化该单例。在 <code>EventBus</code> 构造器中初始化了一堆的成员变量，这些都会在下面中使用到。</p>
<h2 id="register_28Object_subscriber_29"><a href="#register_28Object_subscriber_29" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h2><p>事件订阅者必须调用 <code>register(Object subscriber)</code> 方法来进行注册，一起来看看在 <code>register(Object subscriber)</code> 中到底做了一些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅者的类 class</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 找到该 class 下所有的订阅方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;		</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>register(Object subscriber)</code> 中，利用 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法找到订阅者 class 下所有的订阅方法，然后用 <code>for</code> 循环建立订阅关系。其中 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法我们暂时先不看了，跳过。在这里只要知道作用是找到该订阅者所有的订阅方法就好了。具体 <code>SubscriberMethodFinder</code> 的代码会在后面的章节中详细分析。</p>
<p>而 <code>SubscriberMethod</code> 其实就是订阅方法的包装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅的方法</span></span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="comment">// 订阅所在的线程</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">    <span class="comment">// 订阅事件的类型</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">    <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="comment">// 订阅是否是粘性的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">    <span class="comment">// 特定字符串，用来比较两个 SubscriberMethod 是否为同一个</span></span><br><span class="line">    String methodString;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是轮到了 <code>subscribe(subscriber, subscriberMethod)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅方法的事件类型</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// 根据订阅方法的事件类型得到所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 subscriptions 已经包含了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据该 subscriberMethod 优先级插入到 subscriptions 中</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入 subscribedEvents 中，key：订阅者  value：该订阅者的所有订阅事件的类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">    <span class="comment">// 如果订阅的方法支持 sticky</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">// 如果支持事件继承</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="comment">// 遍历 stickyEvents</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="comment">// 判断 eventType 类型是否是 candidateEventType 的父类</span></span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="comment">// 得到对应 eventType 的子类事件，类型为 candidateEventType</span></span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到之前 sticky 的事件，然后发送给 newSubscription</span></span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>subscribe(subscriber, subscriberMethod)</code> 方法主要就做了三件事：</p>
<ol>
<li>得到 <code>subscriptions</code> ，然后根据优先级把 <code>subscriberMethod</code> 插入到 <code>subscriptions</code> 中；</li>
<li>将 <code>eventType</code> 放入到 <code>subscribedEvents</code> 中；</li>
<li>如果订阅方法支持 <code>sticky</code> ，那么发送相关的粘性事件。</li>
</ol>
<p>粘性事件发送调用了 <code>checkPostStickyEventToSubscription(newSubscription, stickyEvent);</code> 。从方法的命名上来看，知道应该是事件发送到订阅者相关的代码。那么继续跟进代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程模式执行对应</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING: <span class="comment">// 和发送事件处于同一个线程</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN: <span class="comment">// 主线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND: <span class="comment">// 子线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC: <span class="comment">// 和发送事件处于不同的线程</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行订阅方法</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent)</code> 方法的内部调用了 <code>postToSubscription(Subscription subscription, Object event, boolean isMainThread)</code> 。主要的操作都在 <code>postToSubscription</code> 中。根据 <code>threadMode</code> 共分为四种：</p>
<ol>
<li>同一个线程：表示订阅方法所处的线程和发布事件的线程是同一个线程；</li>
<li>主线程：如果发布事件的线程是主线程，那么直接执行订阅方法；否则利用 Handler 回调主线程来执行；</li>
<li>子线程：如果发布事件的线程是主线程，那么调用线程池中的子线程来执行订阅方法；否则直接执行；</li>
<li>异步线程：无论发布事件执行在主线程还是子线程，都利用一个异步线程来执行订阅方法。</li>
</ol>
<p>这四种线程模式其实最后都会调用 <code>invokeSubscriber(Subscription subscription, Object event)</code> 方法通过反射来执行。至此，关于粘性事件的发送就告一段落了。</p>
<p>另外，在这里因篇幅原因就不对 <code>mainThreadPoster</code> 和 <code>backgroundPoster</code> 等细说了，可以自行回去看相关源码，比较简单。</p>
<h2 id="unregister_28Object_subscriber_29"><a href="#unregister_28Object_subscriber_29" class="headerlink" title="unregister(Object subscriber)"></a>unregister(Object subscriber)</h2><p>看完 <code>register(Object subscriber)</code> ，接下来顺便看看 <code>unregister(Object subscriber)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 subscriber 来找到 subscribedTypes</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">// 解除每个订阅的事件类型</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 typesBySubscriber 中移除</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞟了一眼 <code>unregister(Object subscriber)</code> 方法，我们基本上就已经知道其中做了什么。在之前 <code>register(Object subscriber)</code> 中 <code>subscriptionsByEventType</code> 和 <code>typesBySubscriber</code> 会对 <code>subscriber</code> 间接进行绑定。而在 <code>unregister(Object subscriber)</code> 会对其解绑，这样就防止了造成内存泄露的危险。</p>
<h2 id="post_28Object_event_29"><a href="#post_28Object_event_29" class="headerlink" title="post(Object event)"></a>post(Object event)</h2><p>最后，我们来分析下发送事件 <code>post(Object event)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前线程的 postingState</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">// 加入到队列中</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    <span class="comment">// 如果没有持续在发送事件，那么开始发送事件并一直保持发送ing</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 发送单个事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>post(Object event)</code> 中，首先根据 <code>currentPostingThreadState</code> 获取当前线程状态 <code>postingState</code> 。<code>currentPostingThreadState</code> 其实就是一个 <code>ThreadLocal</code> 类的对象，不同的线程根据自己独有的索引值可以得到相应属于自己的 <code>postingState</code> 数据。</p>
<p>然后把事件 <code>event</code> 加入到 <code>eventQueue</code> 队列中排队。只要 <code>eventQueue</code> 不为空，就不间断地发送事件。而发送单个事件的代码在 <code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中，我们跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    <span class="comment">// 得到事件的类型</span></span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="comment">// 是否找到订阅者</span></span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果支持事件继承</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 查找 eventClass 的所有父类和接口</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">// 依次向订阅方法类型为 eventClass 的父类或接口的发送事件</span></span><br><span class="line">            <span class="comment">// 只要其中有一个 postSingleEventForEventType 返回 true ，那么 subscriptionFound 就为 true</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送事件</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            <span class="comment">// 发送 NoSubscriberEvent 事件，可以自定义接收</span></span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中的代码逻辑还是比较清晰的，会根据 <code>eventInheritance</code> 分成两种：</p>
<ol>
<li>支持事件继承：得到 <code>eventClass</code> 的所有父类和接口，然后循环依次发送事件；</li>
<li>不支持事件继承：直接发送事件。</li>
</ol>
<p>另外，若找不到订阅者，在默认配置下还会发送 <code>NoSubscriberEvent</code> 事件。需要开发者自定义订阅方法接收这个事件。</p>
<p>关于发送的具体操作还是要到 <code>postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 得到订阅者</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 依次遍历订阅者</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送事件</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                <span class="comment">// 是否被取消了</span></span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果被取消，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看上面的代码，我们应该能发现一个重要的线索—— <code>postToSubscription</code> 。没错，就是上面讲解发送粘性事件中的 <code>postToSubscription</code> 方法。神奇地绕了一圈又绕回来了。</p>
<p>而 <code>postSingleEventForEventType</code> 方法做的事情只不过是遍历了订阅者，然后一个个依次调用 <code>postToSubscription</code> 方法，之后就是进入 <code>switch</code> 四种线程模式（<code>POSTING</code> 、<code>MAIN</code> 、<code>BACKGROUND</code> 和 <code>ASYNC</code>）并执行订阅者的订阅方法的逻辑了。这里就不重复讲了，具体可以查看上面发送粘性事件中的分析。</p>
<p>至此，整个 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 发布/订阅的原理就讲完了。<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一款典型的运行观察者模式的开源框架，设计巧妙，代码也通俗易懂，值得我们学习。</p>
<p>别以为到这里就本文结束了，可不要忘了，在前面我们还留下一个坑没填—— <code>SubscriberMethodFinder</code> 。想不想知道 <code>SubscriberMethodFinder</code> 到底是如何工作的呢？那还等什么，我们赶快进入下一章节。</p>
<h1 id="0004B_SubscriberMethodFinder"><a href="#0004B_SubscriberMethodFinder" class="headerlink" title="0004B SubscriberMethodFinder"></a>0004B SubscriberMethodFinder</h1><p><code>SubscriberMethodFinder</code> 的作用说白了其实就是寻找订阅者的订阅方法。正如在上面的代码中提到的那样， <code>findSubscriberMethods</code> 方法可以返回指定订阅者中的所有订阅方法。</p>
<h2 id="findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findSubscriberMethods(Class&lt;?&gt; subscriberClass)"></a>findSubscriberMethods(Class&lt;?&gt; subscriberClass)</h2><p>我们看下内部的源码（文件路径：org/greenrobot/eventbus/SubscriberMethodFinder.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果忽略索引，就根据反射来获取</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则使用索引</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放入缓存中</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有两种途径获取：<code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 和 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 。另外，还有缓存可以提高索引效率。</p>
<h2 id="findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingReflection(Class&lt;?&gt; subscriberClass)"></a>findUsingReflection(Class&lt;?&gt; subscriberClass)</h2><p>那么我们先来看看 <code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    <span class="comment">// 做初始化操作</span></span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射查找订阅方法</span></span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        <span class="comment">// 查找 clazz 的父类</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 findState 中的 subscriberMethods</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现一个新的类 <code>FindState</code> ，而 <code>FindState</code> 的作用可以对订阅方法做一些校验，以及查找到的所有订阅方法也是封装在 <code>FindState.subscriberMethods</code> 中的。另外，在 <code>SubscriberMethodFinder</code> 类内部还维持着一个 <code>FIND_STATE_POOL</code> ，可以循环利用，节省内存。</p>
<p>接着往下看，就发现了一个关键的方法： <code>findUsingReflectionInSingleClass(FindState findState)</code> 。根据这方法名可以知道反射获取订阅方法的操作就在这儿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 方法的修饰符只能为 public 并且不能是 static 和 abstract</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 订阅方法的参数只能有一个</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 @Subscribe 注解，如果注解不为空那就认为是订阅方法</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 将该 method 做校验</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 解析 @Subscribe 注解中的 threadMode</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">// 加入到 findState.subscriberMethods 中</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个个循环订阅者中的方法，筛选得到其中的订阅方法后，保存在 <code>findState.subscriberMethods</code> 中。最后在 <code>getMethodsAndRelease(FindState findState)</code> 方法中把 <code>findState.subscriberMethods</code> 返回。（这里就不对 <code>getMethodsAndRelease(FindState findState)</code> 做解析了，可以下去自己看代码，比较简单 *^ο^* ）</p>
<h2 id="findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingInfo(Class&lt;?&gt; subscriberClass)"></a>findUsingInfo(Class&lt;?&gt; subscriberClass)</h2><p>最后，剩下另外一种获取订阅方法的途径还没讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接获取 subscriberInfo 中的 SubscriberMethods</span></span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 subscriberInfo 没有，就通过反射的方式</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 SubscriberInfoIndex 来获取 SubscriberInfo</span></span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 中是通过 <code>SubscriberInfo</code> 类来获取订阅方法的；如果没有 <code>SubscriberInfo</code> ，就直接通过反射的形式来获取。那么 <code>SubscriberInfo</code> 又是如何得到的呢？还要继续跟踪到 <code>getSubscriberInfo(FindState findState)</code> 方法中。然后又有一个新的类蹦出来—— <code>SubscriberInfoIndex</code> 。那么 <code>SubscriberInfoIndex</code> 又是什么东东啊（文件路径：org/greenrobot/eventbus/meta/SubscriberInfoIndex.java）？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="function">SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进去后发现 <code>SubscriberInfoIndex</code> 只是一个接口而已，是不是感到莫名其妙。What the hell is it!</p>
<p>我们把这个疑问先放在心里，到 <code>EventBusPerformance</code> 这个 module 中，进入 build/generated/source/apt/debug/org/greenrobot/eventbusperf 目录下，发现有一个类叫 <code>MyEventBusIndex</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.SubscribeClassEventBusDefault.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEvent"</span>, TestEvent.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusBackground.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventBackgroundThread"</span>, TestEvent.class, ThreadMode.BACKGROUND),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusMain.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>MyEventBusIndex</code> 其实是 <code>SubscriberInfoIndex</code> 的实现类，并且是 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 自动生成的（根据注释可知这点）。而 <code>getSubscriberInfo(Class&lt;?&gt; subscriberClass)</code> 方法已经实现了，内部维持着一个 <code>SUBSCRIBER_INDEX</code> 的 <code>HashMap</code> ，用来保存订阅类的相关信息 <code>info</code> 。然后在需要的时候可以通过 <code>info</code> 快速返回 <code>SubscriberMethod</code> 。这样就达到了不用反射获取订阅方法的目的，提高了执行效率。</p>
<p>到了这里我们明白了上面关于 <code>SubscriberInfoIndex</code> 的疑问，但是又有一个新的疑问产生了：<code>MyEventBusIndex</code> 到底是如何生成的？想要解开这个疑问，我们就要去 <code>EventBusAnnotationProcessor</code> 类中寻找答案了。</p>
<h1 id="0005B_EventBusAnnotationProcessor"><a href="#0005B_EventBusAnnotationProcessor" class="headerlink" title="0005B EventBusAnnotationProcessor"></a>0005B EventBusAnnotationProcessor</h1><p>一看到 <code>EventBusAnnotationProcessor</code> ，菊花一紧，料想肯定逃不了注解。我们可以猜出个大概： <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 在编译时通过 <code>EventBusAnnotationProcessor</code> 寻找到所有标有 <code>@Subscribe</code> 注解的订阅方法，然后依据这些订阅方法自动生成像 <code>MyEventBusIndex</code> 一样的索引类代码，以此提高索引效率。</p>
<p>总体来说，这种注解的思路和 <a href="https://github.com/square/dagger" target="_blank" rel="external">Dagger</a> 、<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 等框架类似。想要了更多，可以阅读我的上一篇博客<a href="/2016/12/18/ButterKnife源码解析/">《ButterKnife源码分析》</a>。</p>
<p>在这里由于篇幅的原因只能简单粗略地解析 <code>EventBusAnnotationProcessor</code> 的源码了，还请多多谅解。</p>
<h2 id="process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)"></a>process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)</h2><p>我们简单地来分析一下 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Messager messager = processingEnv.getMessager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 省略一堆代码</span></span><br><span class="line">        <span class="comment">// 根据 @Subscribe 的注解得到所有订阅方法</span></span><br><span class="line">        collectSubscribers(annotations, env, messager);</span><br><span class="line">        <span class="comment">// 校验这些订阅方法，过滤掉不符合的</span></span><br><span class="line">        checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 生成索引类，比如 MyEventBusIndex</span></span><br><span class="line">            createInfoIndexFile(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">"No @Subscribe annotations found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writerRoundDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// IntelliJ does not handle exceptions nicely, so log and print a message</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Unexpected error in EventBusAnnotationProcessor: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> 方法中重要的代码就这么几行，其他不重要的代码都省略了。那现在我们顺着一个一个方法来看。</p>
<h2 id="collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29"><a href="#collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29" class="headerlink" title="collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)"></a>collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)</h2><p>我们先从 <code>collectSubscribers(annotations, env, messager);</code> 开始入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectSubscribers</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 根据注解去获得 elements</span></span><br><span class="line">        Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> ExecutableElement) &#123;</span><br><span class="line">                ExecutableElement method = (ExecutableElement) element;</span><br><span class="line">                <span class="keyword">if</span> (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    TypeElement classElement = (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    <span class="comment">// 添加该订阅方法</span></span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"@Subscribe is only valid for methods"</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHasNoErrors</span><span class="params">(ExecutableElement element, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法不能是 static 的</span></span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must not be static"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法要是 public 的</span></span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must be public"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数只能有一个</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must have exactly 1 parameter"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码做的事情就是根据注解获取了对应的方法，然后初步筛选了一些方法，放入 <code>methodsByClass</code> 中。</p>
<h2 id="checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29"><a href="#checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29" class="headerlink" title="checkForSubscribersToSkip(Messager messager, String myPackage)"></a>checkForSubscribersToSkip(Messager messager, String myPackage)</h2><p>得到这些初选的订阅方法后，就要进入 <code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 环节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForSubscribersToSkip</span><span class="params">(Messager messager, String myPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        TypeElement subscriberClass = skipCandidate;</span><br><span class="line">        <span class="keyword">while</span> (subscriberClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该订阅类是 public 的，可以通过</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是 private 或者 protected 的，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是默认修饰符，但是订阅类的包和索引类的包不是同一个包，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    <span class="keyword">if</span> (subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because class is not public"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because "</span> + skipCandidate +</span><br><span class="line">                                <span class="string">" has a non-public super class"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 校验订阅方法是否合格</span></span><br><span class="line">                <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">                    String skipReason = <span class="keyword">null</span>;</span><br><span class="line">                    VariableElement param = method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">                    TypeMirror typeMirror = getParamTypeMirror(param, messager);</span><br><span class="line">                    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">                            !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                        skipReason = <span class="string">"event type cannot be processed"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = <span class="string">"event type is not public"</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                            String msg = <span class="string">"Falling back to reflection because "</span> + skipReason;</span><br><span class="line">                            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += <span class="string">" (found in super class for "</span> + skipCandidate + <span class="string">")"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找父类</span></span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一句话来概括，<code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 做的事情就是如果这些订阅类中牵扯到不可见状态，那么就会被加入到 <code>classesToSkip</code> 中，导致后面生成索引类中跳过这些订阅类。</p>
<h2 id="createInfoIndexFile_28String_index_29"><a href="#createInfoIndexFile_28String_index_29" class="headerlink" title="createInfoIndexFile(String index)"></a>createInfoIndexFile(String index)</h2><p>经过筛选后，<code>EventBusAnnotationProcessor</code> 最终要生成一个索引类，具体的代码就在 <code>createInfoIndexFile(String index)</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInfoIndexFile</span><span class="params">(String index)</span> </span>&#123;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index);</span><br><span class="line">        <span class="keyword">int</span> period = index.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        String myPackage = period &gt; <span class="number">0</span> ? index.substring(<span class="number">0</span>, period) : <span class="keyword">null</span>;</span><br><span class="line">        String clazz = index.substring(period + <span class="number">1</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(sourceFile.openWriter());</span><br><span class="line">        <span class="comment">// 下面都是自动生成的代码</span></span><br><span class="line">        <span class="keyword">if</span> (myPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            writer.write(<span class="string">"package "</span> + myPackage + <span class="string">";\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.ThreadMode;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.HashMap;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.Map;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"/** This class is generated by EventBus, do not edit. */\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"public class "</span> + clazz + <span class="string">" implements SubscriberInfoIndex &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    static &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n"</span>);</span><br><span class="line">        writeIndexLines(writer, myPackage);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static void putIndex(SubscriberInfo info) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    @Override\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        if (info != null) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return info;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125; else &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return null;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"&#125;\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not write source for "</span> + index, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">//Silent</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeIndexLines</span><span class="params">(BufferedWriter writer, String myPackage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 如果是被包含在 classesToSkip 中的，就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (classesToSkip.contains(subscriberTypeElement)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成对应的 index</span></span><br><span class="line">        String subscriberClass = getClassString(subscriberTypeElement, myPackage);</span><br><span class="line">        <span class="keyword">if</span> (isVisible(myPackage, subscriberTypeElement)) &#123;</span><br><span class="line">            writeLine(writer, <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"putIndex(new SimpleSubscriberInfo("</span> + subscriberClass + <span class="string">".class,"</span>,</span><br><span class="line">                    <span class="string">"true,"</span>, <span class="string">"new SubscriberMethodInfo[] &#123;"</span>);</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement);</span><br><span class="line">            writeCreateSubscriberMethods(writer, methods, <span class="string">"new SubscriberMethodInfo"</span>, myPackage);</span><br><span class="line">            writer.write(<span class="string">"        &#125;));\n\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(<span class="string">"        // Subscriber not visible to index: "</span> + subscriberClass + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这几行代码应该很眼熟吧，<code>MyEventBusIndex</code> 就是从这个模子里“刻”出来的，都是写死的代码。不同的是在 <code>writeIndexLines(BufferedWriter writer, String myPackage)</code> 中会把之前包含在 <code>classesToSkip</code> 里的跳过，其他的都自动生成 index 。最后就能得到一个像 <code>MyEventBusIndex</code> 一样的索引类了。</p>
<p>另外补充一句，如果你想使用像 <code>MyEventBusIndex</code> 一样的索引类，需要在初始化 <code>EventBus</code> 时通过 <code>EventBus.builder().addIndex(new MyEventBusIndex()).build();</code> 形式来将索引类配置进去。</p>
<p>话已至此，整个 <code>EventBusAnnotationProcessor</code> 我们大致地分析了一遍。利用编译时注解的特性来生成索引类是一种很好的解决途径，避免了程序在运行时利用反射去获取订阅方法，提高了运行效率的同时又提高了逼格。</p>
<h1 id="0006B__u603B_u7ED3"><a href="#0006B__u603B_u7ED3" class="headerlink" title="0006B 总结"></a>0006B 总结</h1><p>从头到尾分析下来，发现 EventBus 真的是一款不错的开源框架，完美诠释了观察者模式。从之前的 2.0 版本到现在的 3.0 版本，加入了注解的同时也减少了反射，提高了性能，为此增添了不少的色彩。</p>
<p>与 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 相似的还有 <a href="https://github.com/square/otto" target="_blank" rel="external">Otto</a> 框架，当然现在业内也有不少使用 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 来实现具备发布/订阅功能的 “RxBus” 。对此我的看法是，如果是小型项目，可以使用 RxBus 来代替 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> ，但是一旦项目成熟起来，涉及到模块之前通信和解耦，那么还是使用更加专业的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 吧。毕竟若是新手想上手 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 还是需要一段时间的。</p>
<p>今天就到这了，对 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 有问题的同学可以留言，bye bye ！</p>
<h1 id="0007B_References"><a href="#0007B_References" class="headerlink" title="0007B References"></a>0007B References</h1><ul>
<li><a href="http://www.jianshu.com/p/f057c460c77e" target="_blank" rel="external">EventBus 3.0 源码分析</a></li>
<li><a href="https://segmentfault.com/a/1190000005089229?utm_source=tuicool&amp;utm_medium=referral#articleHeader11" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ButterKnife源码分析]]></title>
    <link href="http://yuqirong.me/2016/12/18/ButterKnife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/18/ButterKnife源码解析/</id>
    <published>2016-12-18T15:19:02.000Z</published>
    <updated>2016-12-18T16:58:46.683Z</updated>
    <content type="html"><![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而程序员一般都是懒惰了（懒惰促使人进步 ^ο^ ），所以就出现了很多可以减少重复工作的框架或者工具。比如今天要分析的主角—— <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> ，如果你做 Android 开发却没有听说过 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 那就 Out 啦。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 使用依赖注入的方式来减少程序员去编写一堆 <code>findViewById</code> 的代码，使用起来很方便。那么接下来就一步步地带你深入理解 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 框架。PS：最近写的博客篇幅都有点长，请耐心阅读！Logo 图镇楼！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161208143552.png" alt="butterknife_logo"></p>
<h1 id="0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0x02 ButterKnife 的使用方法"></a>0x02 ButterKnife 的使用方法</h1><p>我们先讲下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法：</p>
<ol>
<li><p>在 <code>app/build.gradle</code> 中添加依赖：</p>
<pre><code>dependencies {
  compile &apos;com.jakewharton:butterknife:8.4.0&apos;
  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;
}
</code></pre></li>
<li><p>在 <code>Activity</code> 中添加注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.user)</span><br><span class="line">  EditText username;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.pass)</span><br><span class="line">  EditText password;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@OnClick</span>(R.id.submit)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO onClick View...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// TODO Use fields...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用方法非常简单，不得不赞叹 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 实在是太方便了。彻底跟 <code>findViewById</code> say goodbye 啦。但是我们也认识到，如果一个框架使用起来越简单，那么这个框架内部做的事情就越多。所以在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 内部一定做了很多事情。</p>
<p>今天我们主要分析下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的三个部分：Annotation 、ButterKnifeProcessor 和 ButterKnife 。这三个部分就把整个 View 依赖注入的原理串联起来了。</p>
<p>准备好了吗？下面我们就一探究竟。（PS：本文分析的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 源码为 8.4.0 版本）</p>
<h1 id="0x03_Annotation"><a href="#0x03_Annotation" class="headerlink" title="0x03 Annotation"></a>0x03 Annotation</h1><p>我们先来看一下其中的注解部分。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的注解都在 butterknife-annotations 模块下：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161210153211.png" alt="butterknife注解"></p>
<p>发现我们平时常用的 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 都在里面。我们就挑 <code>@BindView</code> (路径：butterknife-annotations/butterknife/BindView.java) 来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(CLASS)</span><br><span class="line"><span class="annotation">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="annotation">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解都是用 <code>@interface</code> 来表示。在 BindView 注解的上面还有 <code>@Retention</code> 和 <code>@Target</code> 。</p>
<ul>
<li><code>@Retention</code> ：表示注解的保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS ；</li>
<li><code>@Target</code> ：表示可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有。</li>
</ul>
<p>所以我们可知，<code>@BindView</code> 是用来修饰 field 的，并且保留至编译时刻。内部有一个默认属性 <code>value</code> ，用来表示 View 的 id ，即平时程序中的 <code>R.id.xxx</code> 。</p>
<h1 id="0x04_ButterKnifeProcessor"><a href="#0x04_ButterKnifeProcessor" class="headerlink" title="0x04 ButterKnifeProcessor"></a>0x04 ButterKnifeProcessor</h1><p>如果只有 <code>@BindView</code> 是不行的，我们还需要去解析注解。如何去解析编译时的注解呢？我们可以创建一个继承自 <code>AbstractProcessor</code> 的注解处理器，然后实现相关方法。在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 中 <code>ButterKnifeProcessor</code> (路径：butterknife-compiler/butterknife/compiler/ButterKnifeProcessor.java) 就是用来解析这些注解的注解处理器。</p>
<h2 id="init_28ProcessingEnvironment_env_29"><a href="#init_28ProcessingEnvironment_env_29" class="headerlink" title="init(ProcessingEnvironment env)"></a>init(ProcessingEnvironment env)</h2><p>我们先来看看 <code>ButterKnifeProcessor</code> 中的 <code>init(ProcessingEnvironment env)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.init(env);</span><br><span class="line">	</span><br><span class="line">	String sdk = env.getOptions().get(OPTION_SDK_INT);</span><br><span class="line">	<span class="keyword">if</span> (sdk != <span class="keyword">null</span>) &#123;</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="keyword">this</span>.sdk = Integer.parseInt(sdk);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">	    env.getMessager()</span><br><span class="line">	        .printMessage(Kind.WARNING, <span class="string">"Unable to parse supplied minSdk option '"</span></span><br><span class="line">	            + sdk</span><br><span class="line">	            + <span class="string">"'. Falling back to API 1 support."</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到一些有用的工具类</span></span><br><span class="line">	elementUtils = env.getElementUtils();</span><br><span class="line">	typeUtils = env.getTypeUtils();</span><br><span class="line">	filer = env.getFiler();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	  trees = Trees.instance(processingEnv);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalArgumentException ignored) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>init</code> 中主要根据 <code>env</code> 得到一些工具类。其中的 <code>filter</code> 主要是用来生成 Java 代码，而 <code>elementUtils</code> 和 <code>typeUtils</code> 会在下面源码中用到。</p>
<h2 id="getSupportedAnnotationTypes_28_29"><a href="#getSupportedAnnotationTypes_28_29" class="headerlink" title="getSupportedAnnotationTypes()"></a>getSupportedAnnotationTypes()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(<span class="comment">//</span></span><br><span class="line">	OnCheckedChanged.class, <span class="comment">//</span></span><br><span class="line">	OnClick.class, <span class="comment">//</span></span><br><span class="line">	OnEditorAction.class, <span class="comment">//</span></span><br><span class="line">	OnFocusChange.class, <span class="comment">//</span></span><br><span class="line">	OnItemClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemSelected.class, <span class="comment">//</span></span><br><span class="line">	OnLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnPageChange.class, <span class="comment">//</span></span><br><span class="line">	OnTextChanged.class, <span class="comment">//</span></span><br><span class="line">	OnTouch.class <span class="comment">//</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回注解处理器支持处理的注解</span></span><br><span class="line">	Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">	  types.add(annotation.getCanonicalName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有的注解</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123;</span><br><span class="line">	Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	annotations.add(BindArray.class);</span><br><span class="line">	annotations.add(BindBitmap.class);</span><br><span class="line">	annotations.add(BindBool.class);</span><br><span class="line">	annotations.add(BindColor.class);</span><br><span class="line">	annotations.add(BindDimen.class);</span><br><span class="line">	annotations.add(BindDrawable.class);</span><br><span class="line">	annotations.add(BindFloat.class);</span><br><span class="line">	annotations.add(BindInt.class);</span><br><span class="line">	annotations.add(BindString.class);</span><br><span class="line">	annotations.add(BindView.class);</span><br><span class="line">	annotations.add(BindViews.class);</span><br><span class="line">	annotations.addAll(LISTENERS);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> annotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSupportedAnnotationTypes()</code> 方法的作用就是返回该注解处理器所支持处理的注解集合。在 <code>getSupportedAnnotations()</code> 中我们可以看到一些熟悉的注解，比如 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 等。</p>
<h2 id="process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)"></a>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</h2><p>接下来就是重头戏了，注解处理器中最重要的方法 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 。<code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 的代码看上去没几行，其实大部分都写在其他私有方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扫描所有注解，最后生成 map</span></span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line">	<span class="comment">// 遍历 bindingMap 并且通过 Filer 生成 Java 代码</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">	  TypeElement typeElement = entry.getKey();</span><br><span class="line">	  BindingSet binding = entry.getValue();</span><br><span class="line">	</span><br><span class="line">	  JavaFile javaFile = binding.brewJava(sdk);</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    javaFile.writeTo(filer);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来看 <code>process</code> 方法就干了两件事情：</p>
<ol>
<li>扫描所有的注解，然后生成以 <code>TypeElement</code> 为 key ，<code>BindingSet</code> 为 value 的 Map ；</li>
<li>根据生成的 Map ，遍历后通过 Filter 来生成对应的辅助类源码。PS：<a href="">ButterKnife</a> 使用了 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 来生成 Java 源码。如果对 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 不太熟悉，可以先阅读这篇文章 <a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">《javapoet——让你从重复无聊的代码中解放出来》</a> 。</li>
</ol>
<p>我们慢慢来看，先来分析一下 <code>findAndParseTargets(env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描所有的ButterKnife注解，并且生成以TypeElement为键，BindingSet为值的HashMap</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line">	Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	scanForRClasses(env);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略一堆解析各种注解的源码，这些源码做的事情和下面这个 for 循环一样</span></span><br><span class="line">	<span class="comment">// 所以只要看这个解析 @BindView 就够了</span></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Process each @BindView element.</span></span><br><span class="line">	<span class="comment">// 遍历所有被 @BindView 标注的元素</span></span><br><span class="line">	<span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">	  <span class="comment">// we don't SuperficialValidation.validateElement(element)</span></span><br><span class="line">	  <span class="comment">// so that an unresolved View type can be generated by later processing rounds</span></span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	    logParsingError(element, BindView.class, e);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看关于 <code>BindView</code> 的那个 for 循环，它会遍历所有被 <code>@BindView</code> 注解的属性，然后调用 <code>parseBindView</code> 方法。那么我们就先看到 <code>findAndParseTargets</code> 的前半段，一起跟进 <code>parseBindView</code> 的方法中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span><br><span class="line">      Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到注解 @BindView 元素所在的类元素</span></span><br><span class="line">    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start by verifying common generated code restrictions.</span></span><br><span class="line">    <span class="comment">// ---------- 类型校验逻辑 start ---------------</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在属性上，如果该属性是被 private 或者 static 修饰的，则出错</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在错误的包中，若包名以“android”或者“java”开头，则出错</span></span><br><span class="line">    <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">"fields"</span>, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that the target type extends from View.</span></span><br><span class="line">    TypeMirror elementType = element.asType();</span><br><span class="line">    <span class="keyword">if</span> (elementType.getKind() == TypeKind.TYPEVAR) &#123;</span><br><span class="line">      TypeVariable typeVariable = (TypeVariable) elementType;</span><br><span class="line">      elementType = typeVariable.getUpperBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断元素是不是View及其子类或者Interface</span></span><br><span class="line">    <span class="keyword">if</span> (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elementType.getKind() == TypeKind.ERROR) &#123;</span><br><span class="line">        note(element, <span class="string">"@%s field with unresolved type (%s) "</span></span><br><span class="line">                + <span class="string">"must elsewhere be generated as a View or interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error(element, <span class="string">"@%s fields must extend from View or be an interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">        hasError = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有错误 不执行下面代码</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------- 类型校验逻辑 end -----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assemble information on the field.  //得到被注解的注解值，即 R.id.xxx</span></span><br><span class="line">    <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">    <span class="comment">// 根据所在的类元素去查找 builder</span></span><br><span class="line">    BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">    <span class="comment">// 如果相应的 builder 已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 得到相对应的 View 绑定的属性名</span></span><br><span class="line">      String existingBindingName = builder.findExistingBindingName(getId(id));</span><br><span class="line">      <span class="comment">// 若该属性名已经存在，则说明之前已经绑定过，会报错</span></span><br><span class="line">      <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(element, <span class="string">"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没有对应的 builder ，就通过 getOrCreateBindingBuilder 方法生成，并且放入 builderMap 中</span></span><br><span class="line">      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到注解名</span></span><br><span class="line">    String name = element.getSimpleName().toString();</span><br><span class="line">    <span class="comment">// 得到注解元素的类型</span></span><br><span class="line">    TypeName type = TypeName.get(elementType);</span><br><span class="line">    <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line">    <span class="comment">// 根据 id ，添加相对应的 Field 的绑定信息</span></span><br><span class="line">    builder.addField(getId(id), <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    <span class="comment">// 添加到待 unbind 的序列中</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parseBindView</code> 方法中基本上都加了注释，在方法的开头会对该 <code>element</code> 去做校验。如果校验没通过的话，就没有下面代码的什么事了。若校验通过之后，生成该 <code>element</code> 所在的类元素对应的 builder ，builder 中添加相应的 Field 绑定信息，最后添加到待 unbind 的序列中去。</p>
<p>现在，我们回过头来看看 <code>findAndParseTargets(env)</code> 方法的后半段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 省略前半部分源码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Associate superclass binders with their subclass binders. This is a queue-based tree walk</span></span><br><span class="line">	<span class="comment">// which starts at the roots (superclasses) and walks to the leafs (subclasses).</span></span><br><span class="line">	Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</span><br><span class="line">	    <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entrySet());</span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!entries.isEmpty()) &#123;</span><br><span class="line">	  <span class="comment">// 一个个取出遍历</span></span><br><span class="line">	  Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</span><br><span class="line">	  <span class="comment">// 得到对应的 key 和 value</span></span><br><span class="line">	  TypeElement type = entry.getKey();</span><br><span class="line">	  BindingSet.Builder builder = entry.getValue();</span><br><span class="line">	  <span class="comment">// 找到该类元素的父元素</span></span><br><span class="line">	  TypeElement parentType = findParentType(type, erasedTargetNames);</span><br><span class="line">	  <span class="keyword">if</span> (parentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 生成 BindingSet ，放入 Map 中</span></span><br><span class="line">	    bindingMap.put(type, builder.build());</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    BindingSet parentBinding = bindingMap.get(parentType);</span><br><span class="line">	    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">	      <span class="comment">// 设置父元素的 BindingSet</span></span><br><span class="line">	      builder.setParent(parentBinding);</span><br><span class="line">	      bindingMap.put(type, builder.build());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	      <span class="comment">// Has a superclass binding but we haven't built it yet. Re-enqueue for later.</span></span><br><span class="line">	      <span class="comment">// 有父元素，但是父元素的 BindingSet 还没有被 build 出来，</span></span><br><span class="line">	      <span class="comment">// 所以再放入 entries 中等待遍历 </span></span><br><span class="line">	      entries.addLast(entry);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析结果都会存放在 bindingMap 中</span></span><br><span class="line">	<span class="keyword">return</span> bindingMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>findAndParseTargets(env)</code> 方法的后半段中，主要就是把之前的 <code>builderMap</code> 转换为了 <code>bindingMap</code> 并返回。</p>
<p>到了这里，我们把 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 做的第一件事情搞清楚了，下面就接着来看第二件事情了。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 遍历 <span class="keyword">bindingMap </span>并且通过 Filer 生成 Java 代码</span><br><span class="line"><span class="label">for</span> (<span class="preprocessor">Map</span>.Entry&lt;TypeElement, <span class="keyword">BindingSet&gt; </span><span class="preprocessor">entry</span> : <span class="keyword">bindingMap.entrySet()) </span>&#123;</span><br><span class="line">  TypeElement typeElement = <span class="preprocessor">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">  <span class="keyword">BindingSet </span><span class="keyword">binding </span>= <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  JavaFile javaFile = <span class="keyword">binding.brewJava(sdk);</span><br><span class="line"></span>  try &#123;</span><br><span class="line">    javaFile.writeTo(filer)<span class="comment">;</span></span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage())<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="brewJava_28int_sdk_29"><a href="#brewJava_28int_sdk_29" class="headerlink" title="brewJava(int sdk)"></a>brewJava(int sdk)</h2><p>从上面可以看到，遍历了之前得到的 <code>bindingMap</code> ，然后利用 <code>binding</code> 中的信息生成相应的 Java 源码。所以在 <code>binding.brewJava(sdk)</code> 这个方法是我们重点关注对象。那么就进入 <code>BindingSet</code> (路径：butterknife-compiler/butterknife/compiler/BindingSet.java) 这个类中去看看吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 JavaFile，添加相应的注释</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), createType(sdk))</span><br><span class="line">            .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>brewJava(int sdk)</code> 方法的代码竟然这么短 O_o ，就是利用了 <code>JavaFile.builder</code> 生成了一个 <code>JavaFile</code> 对象而已。但是我们发现其中有一个 <code>createType(int sdk)</code> 方法，隐隐约约感觉一定是这个方法在搞大事情。继续跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TypeSpec <span class="title">createType</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成类名为 bindingClassName 的公共类，比如 MainActivity_ViewBinding</span></span><br><span class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 是否修饰为 final ，默认是 false</span></span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">        result.addModifiers(FINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有父类的话，那么要继承父类</span></span><br><span class="line">        result.superclass(parentBinding.bindingClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有父类，那么实现 Unbinder 接口</span></span><br><span class="line">        result.addSuperinterface(UNBINDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个变量名为target，类型为targetTypeName的成员变量</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        result.addField(targetTypeName, <span class="string">"target"</span>, PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// Add a delegating constructor with a target type + view signature for reflective use.</span></span><br><span class="line">        <span class="comment">// 该生成的构造方法被 @deprecated ，一般作为反射使用</span></span><br><span class="line">        result.addMethod(createBindingViewDelegateConstructor(targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成构造方法，另外 findViewById 类似的代码都在这里生成</span></span><br><span class="line">    <span class="comment">// Xxxx_ViewBinding 一般都是执行这个方法生成构造器</span></span><br><span class="line">    result.addMethod(createBindingConstructor(targetTypeName, sdk));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings() || parentBinding == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//生成unBind方法</span></span><br><span class="line">        result.addMethod(createBindingUnbindMethod(result, targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>createType(int sdk)</code> 方法中，基本构建好了一个类的大概，其中对于构造器以及类似 <code>findViewById</code> 的操作都是在 <code>createBindingConstructor(targetTypeName, sdk)</code> 中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodSpec <span class="title">createBindingConstructor</span><span class="params">(TypeName targetType, <span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建构造方法，方法修饰符为 public ，并且添加注解为UiThread</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">            .addAnnotation(UI_THREAD)</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 如果有方法绑定，比如 @OnClick</span></span><br><span class="line">    <span class="keyword">if</span> (hasMethodBindings()) &#123;</span><br><span class="line">        <span class="comment">// 如果有，那么添加 targetType 类型，final 修饰，参数名为 target 的构造方法参数</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>, FINAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有，和上面比起来就少了一个 final 修饰符</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有注解的 View</span></span><br><span class="line">    <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// 那么添加 View source 参数</span></span><br><span class="line">        constructor.addParameter(VIEW, <span class="string">"source"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则添加 Context context 参数</span></span><br><span class="line">        constructor.addParameter(CONTEXT, <span class="string">"context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasUnqualifiedResourceBindings()) &#123;</span><br><span class="line">        <span class="comment">// Aapt can change IDs out from underneath us, just suppress since all will work at runtime.</span></span><br><span class="line">        constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)</span><br><span class="line">                .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"ResourceType"</span>)</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类，那么会根据不同情况调用不同的 super 语句</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentBinding.constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source.getContext())"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, context)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有绑定 Field 或者方法，那么添加 this.target = target 语句</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">"this.target = target"</span>);</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasViewLocal()) &#123;</span><br><span class="line">            <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">            constructor.addStatement(<span class="string">"$T view"</span>, VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">            <span class="comment">// 为 View 绑定生成类似于 findViewById 之类的代码</span></span><br><span class="line">            addViewBinding(constructor, binding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为 View 的集合或者数组绑定</span></span><br><span class="line">        <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">            constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 resource 资源的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T context = source.getContext()"</span>, CONTEXT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasResourceBindingsNeedingResource(sdk)) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T res = context.getResources()"</span>, RESOURCES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render(sdk));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> constructor.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码就生成了构造器，但是我们还是没有看到具体 <code>findViewById</code> 操作的代码。别急，这些代码都在 <code>addViewBinding(constructor, binding)</code> 里会看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewBinding</span><span class="params">(MethodSpec.Builder result, ViewBinding binding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (binding.isSingleFieldBinding()) &#123;</span><br><span class="line">        <span class="comment">// Optimize the common case where there's a single binding directly to a field.</span></span><br><span class="line">        FieldViewBinding fieldBinding = binding.getFieldBinding();</span><br><span class="line">        <span class="comment">// 注意这里直接使用了 target. 的形式，所以属性肯定是不能 private 的</span></span><br><span class="line">        CodeBlock.Builder builder = CodeBlock.builder()</span><br><span class="line">                .add(<span class="string">"target.$L = "</span>, fieldBinding.getName());</span><br><span class="line">        <span class="comment">// 下面都是 View 绑定的代码</span></span><br><span class="line">        <span class="keyword">boolean</span> requiresCast = requiresCast(fieldBinding.getType());</span><br><span class="line">        <span class="keyword">if</span> (!requiresCast &amp;&amp; !fieldBinding.isRequired()) &#123;</span><br><span class="line">            builder.add(<span class="string">"source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.add(<span class="string">"$T.find"</span>, UTILS);</span><br><span class="line">            builder.add(fieldBinding.isRequired() ? <span class="string">"RequiredView"</span> : <span class="string">"OptionalView"</span>);</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">"AsType"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">"(source, $L"</span>, binding.getId().code);</span><br><span class="line">            <span class="keyword">if</span> (fieldBinding.isRequired() || requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $S"</span>, asHumanDescription(singletonList(fieldBinding)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $T.class"</span>, fieldBinding.getRawType());</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.addStatement(<span class="string">"$L"</span>, builder.build());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</span><br><span class="line">    <span class="keyword">if</span> (requiredBindings.isEmpty()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.isBoundToRoot()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = $T.findRequiredView(source, $L, $S)"</span>, UTILS,</span><br><span class="line">                binding.getId().code, asHumanDescription(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addFieldBinding(result, binding);</span><br><span class="line">    <span class="comment">// OnClick 等监听事件绑定</span></span><br><span class="line">    addMethodBindings(result, binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个 <code>ButterKnifeProcessor</code> 解析注解、生成 Java 代码的流程就走完了。我们来看看生成的代码到底长成什么样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> T target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view2131427413;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> T target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.button, <span class="string">"field 'button' and method 'onClick'"</span>);</span><br><span class="line">    target.button = Utils.castView(view, R.id.button, <span class="string">"field 'button'"</span>, Button.class);</span><br><span class="line">    view2131427413 = view;</span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.onClick(p0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    target.tv = Utils.findRequiredViewAsType(source, R.id.tv, <span class="string">"field 'textView'"</span>, TextView.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="annotation">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line"></span><br><span class="line">    target.button = <span class="keyword">null</span>;</span><br><span class="line">    target.tv = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    view2131427413.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view2131427413 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不赞叹一句，<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 生成的代码跟我们手写的基本上没什么区别。<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 实在是太强大了 *^ο^* 。</p>
<h1 id="0x05_ButterKnife"><a href="#0x05_ButterKnife" class="headerlink" title="0x05 ButterKnife"></a>0x05 ButterKnife</h1><h2 id="bind_28_29"><a href="#bind_28_29" class="headerlink" title="bind()"></a>bind()</h2><p>通过之前介绍 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法，我们知道 View 绑定是通过调用 <code>ButterKnife.bind()</code> 方法来实现的。下面我们来看看其内部原理 (路径：butterknife/butterknife/ButterKnife.java) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">  View sourceView = target.getWindow().getDecorView();</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull View target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29"><a href="#createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29" class="headerlink" title="createBinding(@NonNull Object target, @NonNull View source)"></a>createBinding(@NonNull Object target, @NonNull View source)</h2><p>发现 <code>bind()</code> 方法内都会去调用 <code>createBinding(@NonNull Object target, @NonNull View source)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 target 的类名，比如 MainActivity </span></span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</span><br><span class="line">    <span class="comment">// 找到 target 对应的构造器</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建对应的对象</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Nullable</span> <span class="annotation">@CheckResult</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    <span class="comment">// 对构造器的查找进行了缓存，可以直接从 Map 中获取</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到对应的 class 对象，比如 MainActivity_ViewBinding</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = Class.forName(clsName + <span class="string">"_ViewBinding"</span>);</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="comment">// 得到对应的构造器</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded binding class and constructor."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行缓存</span></span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>createBinding(@NonNull Object target, @NonNull View source)</code> 方法做的事情就是根据 <code>target</code> 创建对应的 <code>targetClassName_ViewBinding</code> 。在 <code>targetClassName_ViewBinding</code> 的构造器中会把对应的 View 进行绑定（具体可以查看上面的 <code>MainActivity_ViewBinding</code> ）。而在 <code>findBindingConstructorForClass(Class&lt;?&gt; cls)</code> 方法中也使用了 <code>Class.forName()</code> 反射来查找 <code>Class</code> ，这也是无法避免的。但是仅限于一个类的第一次查找，之后都会从 <code>BINDINGS</code> 缓存中获取。</p>
<h1 id="0x06__u603B_u7ED3"><a href="#0x06__u603B_u7ED3" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>总体来说，<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 是一款十分优秀的依赖注入框架，方便，高效，减少代码量。最重要的是解放程序员的双手，再也不用去写无聊乏味的 <code>findViewById</code> 了 \(╯-╰)/ 。与 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 原理相似的，还有 <a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="external">androidannotations</a> 框架。感兴趣的同学可以自己研究一下。那么，今天的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 解析到这里就结束了。如果对此有问题或疑惑的同学可以留言，欢迎探讨。</p>
<p>Goodbye !~~</p>
<h1 id="0x07_References"><a href="#0x07_References" class="headerlink" title="0x07 References"></a>0x07 References</h1><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232205&amp;idx=1&amp;sn=6c24e6eef2b18f253284b9dd92ec7efb&amp;chksm=f1d9eaaec6ae63b82fd84f72c66d3759c693f164ff578da5dde45d367f168aea0038bc3cc8e8&amp;scene=0#wechat_redirect" target="_blank" rel="external">浅析ButterKnife</a></li>
<li><a href="http://dev.qq.com/topic/578753c0c9da73584b025875#rd" target="_blank" rel="external">深入理解 ButterKnife，让你的程序学会写代码</a></li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="external">公共技术点之 Java 注解 Annotation</a></li>
<li><a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">javapoet——让你从重复无聊的代码中解放出来</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android项目中集成React Native]]></title>
    <link href="http://yuqirong.me/2016/12/04/Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90React%20Native/"/>
    <id>http://yuqirong.me/2016/12/04/Android项目中集成React Native/</id>
    <published>2016-12-04T13:04:35.000Z</published>
    <updated>2016-12-14T14:52:19.621Z</updated>
    <content type="html"><![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Native的步骤"></a>集成React Native的步骤</h1><ol>
<li><p>运行以下命令 ：</p>
<pre><code>$ npm init
</code></pre><p> 生成 <code>package.json</code> ，下面给出一份 Demo ：</p>
<pre><code>{
  &quot;name&quot;: &quot;HelloWorld&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;main&quot;: &quot;index.android.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,
    &quot;test&quot;: &quot;jest&quot;
  },
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^15.4.1&quot;,
    &quot;react-native&quot;: &quot;^0.39.0&quot;
  }
}
</code></pre></li>
<li><p>运行以下命令安装 React Native , Android 项目根目录就生成了 <code>node_modules/</code> 文件夹：</p>
<pre><code>$ npm install --save react react-native
</code></pre><p> 在 <code>.gitignore</code> 中添加：</p>
<pre><code># node.js
node_modules/
npm-debug.log
</code></pre><p> 执行 <code>react-native upgrade</code> 可以更新已有组件。</p>
</li>
<li><p>运行以下命令生成 <code>.flowconfig</code> 文件：</p>
<pre><code>$ curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig
</code></pre></li>
<li><p>修改 <code>package.json</code> 中 <code>scripts</code> 的 <code>start</code> 部分：</p>
<pre><code>&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;
</code></pre></li>
<li><p>在 Android 项目的根目录下新建 <code>index.android.js</code> ：</p>
<pre><code>&apos;use strict&apos;;

import React from &apos;react&apos;;
import {
  AppRegistry,
  StyleSheet,
  Text,
  View
} from &apos;react-native&apos;;

class HelloWorld extends React.Component {
  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;Hello, World&lt;/Text&gt;
        &lt;Text&gt;Hello, React Native&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
}

AppRegistry.registerComponent(&apos;HelloWorld&apos;, () =&gt; HelloWorld);
</code></pre></li>
<li><p>在 <code>app/build.gradle</code> 中添加：</p>
<pre><code>defaultConfig {
    ...
    ndk {
        abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;
    }
}

dependencies {
    ...
    compile &quot;com.facebook.react:react-native:0.39.0&quot; // From node_modules.
}
</code></pre><p> react-native 依赖的版本和 <code>package.json</code> 中保持一致。</p>
</li>
<li><p>在 Android 项目根目录下的 <code>build.gradle</code> 文件添加如下内容：</p>
<pre><code>allprojects {
    repositories {
        maven {
            // All of React Native (JS, Android binaries) is installed from npm
            url &quot;$rootDir/node_modules/react-native/android&quot;
        }
    }
}
</code></pre></li>
<li><p>新建一个 <code>MyApplication</code> 继承自 <code>Application</code> ，在 <code>AndroidManifest.xml</code> 中修改成相应的 <code>MyApplication</code> ：</p>
<pre><code>public class MyApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage()
            );
        }

    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        SoLoader.init(this, /* native exopackage */ false);
    }

}
</code></pre></li>
<li><p>新建一个 <code>ReactNativeActivity</code> ，用来展示 React Native 的页面：</p>
<pre><code>public class ReactNativeActivity extends ReactActivity {

    @Override
    protected String getMainComponentName() {
        return &quot;HelloWorld&quot;;
    }

}
</code></pre><p> 其中 <code>getMainComponentName()</code> 返回的字符串要和 index.android.js 中的 <code>AppRegistry.registerComponent</code> 中保持一致。</p>
</li>
<li><p>在 <code>AndroidManifest.xml</code> 里需要添加相关内容</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;

&lt;activity android:name=&quot;.ReactNativeActivity&quot; /&gt;
&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;
</code></pre></li>
<li><p>启动服务。debug 模式下需要在 <code>package.json</code> 所在目录下执行 </p>
<pre><code>$ npm start
</code></pre><p>之后按照正常的 Android 程序调试即可。</p>
</li>
<li><p>发布正式包</p>
<p>JS Bundle 打包：</p>
<p>在 <code>app/src/main/</code> 下创建 <code>assets/</code> 文件夹，执行以下命令将 JS Bundle 保存到资源目录下</p>
<pre><code>$ react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/
</code></pre><p>在 <code>app/src/main/assets/</code> 下就会生成 <code>index.android.bundle</code> 文件。图片会生成在 <code>app/sec/main/res/drawable-mdpi/</code> 目录下。之后按照 Android 项目正常打包即可，但别忘了添加 React Native 的混淆：</p>
<pre><code>-dontobfuscate

# React Native

# Keep our interfaces so they can be used by other ProGuard rules.
# See http://sourceforge.net/p/proguard/bugs/466/
-keep,allowobfuscation @interface com.facebook.proguard.annotations.DoNotStrip
-keep,allowobfuscation @interface com.facebook.proguard.annotations.KeepGettersAndSetters
-keep,allowobfuscation @interface com.facebook.common.internal.DoNotStrip

# Do not strip any method/class that is annotated with @DoNotStrip
-keep @com.facebook.proguard.annotations.DoNotStrip class *
-keep @com.facebook.common.internal.DoNotStrip class *
-keepclassmembers class * {
    @com.facebook.proguard.annotations.DoNotStrip *;
    @com.facebook.common.internal.DoNotStrip *;
}

-keepclassmembers @com.facebook.proguard.annotations.KeepGettersAndSetters class * {
  void set*(***);
  *** get*();
}

-keep class * extends com.facebook.react.bridge.JavaScriptModule { *; }
-keep class * extends com.facebook.react.bridge.NativeModule { *; }
-keepclassmembers,includedescriptorclasses class * { native &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.UIProp &lt;fields&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactProp &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactPropGroup &lt;methods&gt;; }

-dontwarn com.facebook.react.**

# okhttp

-keepattributes Signature
-keepattributes *Annotation*
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }
-dontwarn okhttp3.**

# okio

-keep class sun.misc.Unsafe { *; }
-dontwarn java.nio.file.*
-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-dontwarn okio.**
</code></pre></li>
</ol>
<h1 id="u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898"><a href="#u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="在集成React Native中遇到的问题"></a>在集成React Native中遇到的问题</h1><h2 id="Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details"><a href="#Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details" class="headerlink" title="Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details."></a>Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See <a href="http://g.co/androidstudio/app-test-app-conflict" target="_blank" rel="external">http://g.co/androidstudio/app-test-app-conflict</a> for details.</h2><p>在 app/build.gradle 中添加如下：</p>
<pre><code>android {
    ...
    configurations.all {
        resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos;
    }
}
</code></pre><h2 id="Cannot_find_module__u2018invariant_u2019"><a href="#Cannot_find_module__u2018invariant_u2019" class="headerlink" title="Cannot find module ‘invariant’"></a>Cannot find module ‘invariant’</h2><p>在调用 <code>react-native init Test</code> 初始化某个项目时，抛出如下异常：</p>
<pre><code>$ react-native init Test
This may take some time...
This will walk you through creating a new React Native project in C:\Users\Administrator\Desktop\Test
Installing react-native package from npm...
module.js:327
    throw err;
    ^

Error: Cannot find module &apos;invariant&apos;
    at Function.Module._resolveFilename (module.js:325:15)
    at Function.Module._load (module.js:276:25)                
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.&lt;anonymous&gt; (C:/Users/Administrator/Desktop/Test/node_modules/react-native/packager/react-packager/src/node-haste/Module.js:18:19)
    at Module._compile (module.js:409:26)
    at loader (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:144:5)
    at Object.require.extensions.(anonymous function) [as .js] (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:154:7)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
</code></pre><p>解决方案：调用 <code>npm i --save-dev invariant</code> 命令，详见 <a href="https://github.com/facebook/react-native/issues/11327" target="_blank" rel="external">Cannot find module ‘invariant’ - react-native-cli</a></p>
<h2 id="java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019"><a href="#java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019" class="headerlink" title="java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’"></a>java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.<init\>()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’</init\></h2><p>在 React Native 程序运行时，报错：</p>
<pre><code>E/AndroidRuntime: FATAL EXCEPTION: AsyncTask #1
    Process: com.fanwei.reactnativeupdate, PID: 3139
    java.lang.RuntimeException: An error occured while executing doInBackground()
        at android.os.AsyncTask$3.done(AsyncTask.java:304)
        at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:355)
        at java.util.concurrent.FutureTask.setException(FutureTask.java:222)
        at java.util.concurrent.FutureTask.run(FutureTask.java:242)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
        at java.lang.Thread.run(Thread.java:818)
     Caused by: java.lang.IllegalAccessError: Method &apos;void android.support.v4.net.ConnectivityManagerCompat.&lt;init&gt;()&apos; is inaccessible to class &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; (declaration of &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; appears in /data/data/com.fanwei.reactnativeupdate/files/instant-run/dex/slice-com.facebook.react-react-native-0.20.1_3b7c8d9b91d5c989075fbd631ac74b192cee741b-classes.dex)
        at com.facebook.react.modules.netinfo.NetInfoModule.&lt;init&gt;(NetInfoModule.java:55)
        at com.facebook.react.shell.MainReactPackage.createNativeModules(MainReactPackage.java:67)
        at com.facebook.react.ReactInstanceManagerImpl.processPackage(ReactInstanceManagerImpl.java:793)
        at com.facebook.react.ReactInstanceManagerImpl.createReactContext(ReactInstanceManagerImpl.java:730)
        at com.facebook.react.ReactInstanceManagerImpl.access$600(ReactInstanceManagerImpl.java:91)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:184)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:169)
        at android.os.AsyncTask$2.call(AsyncTask.java:292)
        at java.util.concurrent.FutureTask.run(FutureTask.java:237)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231) 
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
        at java.lang.Thread.run(Thread.java:818) 
</code></pre><p>解决方案：修改依赖为 <code>com.android.support:appcompat-v7:23.0.1</code> ，详见 <a href="https://github.com/facebook/react-native/issues/6152" target="_blank" rel="external">Android java.lang.IllegalAccessError Method void android.support.v4.net.ConnectivityManagerCompat</a></p>
<h2 id="ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29"><a href="#ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29" class="headerlink" title="ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)"></a>ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)</h2><p>在调用命令 <code>npm start</code> 时，出现以下错误：</p>
<pre><code>ERROR  EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
{&quot;errno&quot;:-4048,&quot;code&quot;:&quot;EPERM&quot;,&quot;syscall&quot;:&quot;lstat&quot;,&quot;path&quot;:&quot;C:\\Users\\Administrator\\Desktop\\ReactNativeUpdate\\app\\build\\generated\\assets\\shaders\\debug&quot;}
Error: EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
    at Error (native)
</code></pre><p>解决方案：打开项目中 <code>node_modules/react-native/local-cli/server/server.js</code> 找到  <code>process.on(&#39;uncaughtException&#39;, error =&gt; {</code> 这个方法，把最后一句 <code>process.exit(11);</code> 注释掉。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://facebook.github.io/react-native/docs/integration-with-existing-apps.html" target="_blank" rel="external">Integration With Existing Apps</a></li>
<li><a href="http://www.lcode.org/react-native%e7%a7%bb%e6%a4%8d%e5%8e%9f%e7%94%9fandroid%e9%a1%b9%e7%9b%ae-%e5%b7%b2%e6%9b%b4%e6%96%b0%e7%89%88%e6%9c%ac/" target="_blank" rel="external">React Native移植原生Android项目-已更新版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Na]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley框架源码解析]]></title>
    <link href="http://yuqirong.me/2016/11/19/Volley%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/11/19/Volley框架源码解析/</id>
    <published>2016-11-19T13:19:17.000Z</published>
    <updated>2016-11-30T14:46:18.722Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用于网络请求非常频繁但是数据量并不是特别大的情景，正如它的名字一样。Volley 相比其他网络框架而言，采用了在 Android 2.3 以下使用 HttpClient ，而 Android 2.3 及以上使用 HttpUrlConnection 的方案。这是因为在 Android 2.3 以下时，HttpUrlConnection 并不完善，有很多 bug 存在。因此在 Android 2.3 以下最好使用 HttpClient 来进行网络通信；而在 Android 2.3 及以上，HttpUrlConnection 比起 HttpClient 来说更加简单易用，修复了之前的 bug 。所以在 Android 2.3 及以上我们使用 HttpUrlConnection 来进行网络通信。</p>
<p>除此之外，Volley 框架还具有优先级处理、可扩展性强等特点。虽然现在有 Retrofit 、OkHttp 等十分优秀的网络通信框架，但是深入理解 Volley 框架内部的思想可以大大提高我们自身的技术水平，毕竟仅仅停留在只会使用的阶段是不行的哦。那么，下面就进入我们今天的正题吧！（ ps ：本文篇幅过长，可能会引起不适，请在家长的陪同下观看）</p>
<h1 id="0010B"><a href="#0010B" class="headerlink" title="0010B"></a>0010B</h1><h2 id="Volley__u4F7F_u7528_u65B9_u6CD5"><a href="#Volley__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Volley 使用方法"></a>Volley 使用方法</h2><p>在长篇大论地解析 Volley 框架源码之前，我们先来看看平时是怎样使用 Volley 的。（大牛可直接跳过 -_- ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br><span class="line">JsonObjectRequest request = <span class="keyword">new</span> JsonObjectRequest(url, <span class="keyword">null</span>,</span><br><span class="line">        <span class="keyword">new</span> Response.Listener&lt;JSONObject&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line">            	<span class="comment">// TODO </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mQueue.add(request);</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Volley.newRequestQueue(context)</code> 来得到一个请求队列的对象 <code>mQueue</code>，在队列中暂存了我们所有 add 进去的 request ，之后一个个取出 request 来进行网络通信。一般来说，在一个应用程序中，只保持一个请求队列的对象。</p>
<p>之后创建了 JsonObjectRequest 对象用来请求 JSON 数据，并把它加入 <code>mQueue</code> 的队列中。Volley 框架的使用方法非常简单，并且有多种 request 请求方式可以选择，使用方法都是和上面类似的。</p>
<h1 id="0011B"><a href="#0011B" class="headerlink" title="0011B"></a>0011B</h1><p>在这先把 Volley 框架中几个重要的类的作用讲一下，以便看源码时能够更加明白：</p>
<ul>
<li>RequestQueue ：这个大家一看都明白，用来缓存 request 的请求队列，根据优先级高低排列；</li>
<li>Request ：表示网络请求，本身是一个抽象类，子类有 StringRequest 、JsonRequest 、ImageRequest 等；</li>
<li>Response ：表示网络请求后的响应，也是一个抽象类。内部定义了 Listener 、ErrorListener 接口；</li>
<li>NetworkResponse ：对返回的 HttpResponse 内容进行了封装，虽然类名和 Response 差不多，但是不是 Response 的子类；</li>
<li>CacheDispatcher ：一个处理请求缓存的线程。不断从 RequestQueue 中取出 Request ，然后取得该 Request 对应的缓存，若缓存存在就调用 ResponseDelivery 做后续分发处理；如果没有缓存或者缓存失效需要进入 NetworkDispatcher 中从网络上获取结果；</li>
<li>NetworkDispatcher ：一个处理网络请求的线程。和 CacheDispatcher 类似，从网络上得到响应后调用 ResponseDelivery 做后续分发处理。而且根据需求判断是否需要做缓存处理；</li>
<li>ResponseDelivery ：用作分发处理。利用 Handler 把结果回调到主线程中，即 Listener 、ErrorListener 接口。主要实现类为 ExecutorDelivery ；</li>
<li>HttpStack ：主要作用就是发起 Http 请求。子类分为 HurlStack 和 HttpClientStack ，分别对应着 HttpUrlConnection 和 HttpClient ；</li>
<li>Network ：处理 Stack 发起的 Http 请求，把 Request 转换为 Response ，主要实现类为 BasicNetwork ；</li>
<li>RetryPolicy ：请求重试策略。主要实现类为 DefaultRetryPolicy ；</li>
<li>Cache ：网络请求的缓存。在 CacheDispatcher 中获取 Cache ，在 NetworkDispatcher 中判断是否保存 Cache 。主要实现类为 DiskBasedCache ，缓存在磁盘中。</li>
</ul>
<h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h2><p>看完了之后，我们就要开始源码解析。我们入手点就是 <code>Volley.newRequestQueue(context)</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volley</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认的磁盘缓存目录名 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        <span class="comment">// 设置 UA</span></span><br><span class="line">        String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 Android SDK 版本设置 HttpStack ，分为 HurlStack 和 HttpClientStack</span></span><br><span class="line">        <span class="comment">// 分别对应着 HttpUrlConnection 和 HttpClient</span></span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">                <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到 network</span></span><br><span class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">        <span class="comment">// 创建 RequestQueue</span></span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面 Volley 类的源码中可知，Volley 类主要就是用来创建 RequestQueue 的。我们之前使用的 <code>newRequestQueue(Context context)</code> 方法最终会调用 <code>newRequestQueue(Context context, HttpStack stack)</code> 。Volley 允许我们使用自定义的 HttpStack ，从这也可以看出 Volley 具有很强的扩展性。</p>
<h2 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h2><p>接下来继续跟踪 RequestQueue 构造方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认线程池数量为 4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中创建了 ExecutorDelivery 对象，ExecutorDelivery 中传入的 Handler 为主线程的，方便得到 Response 后回调；NetworkDispatcher[] 数组对象，默认数组的长度为 4 ，也就意味着默认处理请求的线程最多为 4 个。</p>
<p>在 <code>Volley.newRequestQueue(Context context, HttpStack stack)</code> 中创建完 RequestQueue 对象 <code>queue</code> 之后，还调用了 <code>queue.start()</code> 方法。主要用于启动 <code>queue</code> 中的 <code>mCacheDispatcher</code> 和 <code>mDispatchers</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 请求缓存队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 网络请求队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// 确保当前 RequestQueue 中的 mCacheDispatcher 和 mDispatchers[] 是关闭的</span></span><br><span class="line">    <span class="comment">// 创建 mCacheDispatcher ，并且开启</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 mDispatchers[] 数组的长度创建 networkDispatcher ，并且开启</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前的 mCacheDispatcher 和 mDispatchers[]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCacheDispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatchers[i].quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove from the set of requests currently being processed.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">// 从 mCurrentRequests 中移除该 request</span></span><br><span class="line">        mCurrentRequests.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 request 是可以被缓存的，那么从 mWaitingRequests 中移除，加入到 mCacheQueue 中 	</span></span><br><span class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">            String cacheKey = request.getCacheKey();</span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</span><br><span class="line">                            waitingRequests.size(), cacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></span><br><span class="line">                <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></span><br><span class="line">                mCacheQueue.addAll(waitingRequests);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么看到这里我们意识到有必要看一下 CacheDispatcher 和 NetworkDispatcher 的代码。我们先暂且放一下，来看看 RequestQueue 的 <code>add</code> 方法。<code>add</code> 方法就是把 Request 加入到 RequestQueue 中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的 Set 集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">//加入到当前请求队列中</span></span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置序列号，该序列号为 AtomInteger 自增的值</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该 request 不该缓存，则直接加入 mNetworkQueue ，跳过下面的步骤</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">        <span class="comment">// 其实 cacheKey 就是 request 的 url</span></span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">// 如果该 mWaitingRequests 已经包含了有该 cacheKey</span></span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 得到该 cacheKey 对应的 Queue</span></span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            <span class="comment">// 把该 request 加入到 mWaitingRequests</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有，那么将该 request 加入到 mCacheQueue 中</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">            mCacheQueue.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>add(Request&lt;T&gt; request)</code> 方法中，额外使用了两个集合来维护 Request ，其中 </p>
<ul>
<li>mCurrentRequests ：用来维护正在做请求操作的 Request；</li>
<li>mWaitingRequests ：主要作用是如果当前有一个 Request 正在请求并且是可以缓存的，那么 Volley 会去 mWaitingRequests 中根据该 cacheKey 查询之前有没有一样的 Request 被加入到 mWaitingRequests 中。若有，那么该 Request 就不需要再被缓存了；若没有就加入到 mCacheQueue 中进行后续操作。</li>
</ul>
<p>现在我们来看看 CacheDispatcher 和 NetworkDispatcher 类的源码。</p>
<h2 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h2><p>首先是 CacheDispatcher 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 mCache ，读取磁盘中的缓存文件，加载到 mCache 中的 map 中</span></span><br><span class="line">        <span class="comment">// 会造成线程阻塞，要在子线程中调用</span></span><br><span class="line">        mCache.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从缓存队列中取出 request ，若没有则会阻塞</span></span><br><span class="line">                <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 被标记为取消，则跳过该 request ，不分发</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 request 的 url 去获得缓存</span></span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                    <span class="comment">// 没有缓存，把 Request 放入网络请求队列中 </span></span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若缓存失效，也放入网络请求队列中</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存存在，把缓存转换为 Response</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">                <span class="comment">// 判断缓存是否需要刷新</span></span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    <span class="comment">// 不需要刷新就直接让 mDelivery 分发</span></span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要刷新缓存</span></span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先设置一个标志，表明该缓存可以先分发，之后需要重新刷新</span></span><br><span class="line">                    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 利用 mDelivery 先把 response 分发下去，之后还要把该 request 加入到 mNetworkQueue 重新请求一遍</span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheDispatcher 类主要的代码就如上面所示了，在主要的 <code>run()</code> 方法中都添加了注释，阅读起来应该比较简单。那么在这里就贡献一张 CacheDispatcher 类的流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161122231354.png" alt="CacheDispatcher 类的流程图"></p>
<h2 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h2><p>然后是 NetworkDispatcher 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTrafficStatsTag</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 取出 request</span></span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否被取消，和 CacheDispatcher 中的步骤一致</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置线程标识</span></span><br><span class="line">                addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理网络请求</span></span><br><span class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果服务端返回 304 并且已经分发了一个响应，那么不再进行二次分发</span></span><br><span class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 得到 response</span></span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 需要进行缓存，那么保存缓存</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记该 request 对应的 response 正在分发中</span></span><br><span class="line">                request.markDelivered();</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 response</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAndDeliverNetworkError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        error = request.parseNetworkError(error);</span><br><span class="line">        mDelivery.postError(request, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，根据 NetworkDispatcher 我们也可以梳理出一张流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161123222635.png" alt="NetworkDispatcher 类的流程图"></p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>到这里，我们把目光转向 Request 。Request 是一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	...<span class="comment">// 省略绝大部分源码-_- !</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> VolleyError <span class="title">parseNetworkError</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> volleyError;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverError</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mErrorListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        mErrorListener.onErrorResponse(error);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// request 完成响应分发后调用 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="comment">// 跳转到 RequestQueue.finish 方法</span></span><br><span class="line">	        mRequestQueue.finish(<span class="keyword">this</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</span><br><span class="line">	        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">	        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">	            <span class="comment">// If we finish marking off of the main thread, we need to</span></span><br><span class="line">	            <span class="comment">// actually do it on the main thread to ensure correct ordering.</span></span><br><span class="line">	            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">	            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	                <span class="annotation">@Override</span></span><br><span class="line">	                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                    mEventLog.add(tag, threadId);</span><br><span class="line">	                    mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;);</span><br><span class="line">	            <span class="keyword">return</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        mEventLog.add(tag, threadId);</span><br><span class="line">	        mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">long</span> requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;</span><br><span class="line">	        <span class="keyword">if</span> (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">	            VolleyLog.d(<span class="string">"%d ms: %s"</span>, requestTime, <span class="keyword">this</span>.toString());</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Request&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">	    Priority left = <span class="keyword">this</span>.getPriority();</span><br><span class="line">	    Priority right = other.getPriority();</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// request 优先级高的比低的排在队列前面，优先被请求</span></span><br><span class="line">	    <span class="comment">// 如果优先级一样，按照 FIFO 的原则排列</span></span><br><span class="line">	    <span class="keyword">return</span> left == right ?</span><br><span class="line">	            <span class="keyword">this</span>.mSequence - other.mSequence :</span><br><span class="line">	            right.ordinal() - left.ordinal();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request 实现了 Comparable 接口，这是因为 Request 是有优先级的，优先级高比优先级低的要先响应，排列在前。默认有四种优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">    LOW,</span><br><span class="line">    NORMAL,</span><br><span class="line">    HIGH,</span><br><span class="line">    IMMEDIATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，子类继承 Request 还要实现两个抽象方法：</p>
<ul>
<li>parseNetworkResponse ：把 NetworkResponse 转换为合适类型的 Response；</li>
<li>deliverResponse ：把解析出来的类型分发给监听器回调。</li>
</ul>
<p>另外，Request 还支持八种请求方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Supported request methods.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEPRECATED_GET_OR_POST = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> GET = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> POST = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PUT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> DELETE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> HEAD = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> OPTIONS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> TRACE = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> PATCH = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Volley 中，Request 的子类众多，有 StringRequest 、JsonObjectRequest(继承自  JsonRequest ) 、JsonArrayRequest(继承自  JsonRequest ) 和 ImageRequest 等。当然这些子类并不能满足全部的场景要求，而这就需要我们开发者自己动手去扩展了。</p>
<p>下面我就分析一下 StringRequest 的源码，其他子类的源码都是类似的，可以回去自行研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Listener&lt;String&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,</span><br><span class="line">            ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到相应的 response 后，回调 Listener 的接口</span></span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">        String parsed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把字节数组转化为字符串</span></span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));(response.headers));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 StringRequest 的源码十分简洁。在 <code>parseNetworkResponse</code> 方法中主要把 response 中的 data 转化为对应的 String 类型。然后回调 <code>Response.success</code> 即可。</p>
<p>看完了 Request 之后，我们来分析一下 Network 。</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Network 是一个接口，里面就一个方法 <code>performRequest(Request&lt;?&gt; request)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光看这个方法的定义就知道这个方法是用来干什么了！就是根据传入的 Request 执行，转换为对应的 NetworkResponse 的，并且该 NetworkResponse 不为空。我们就跳到它的实现类中看看该方法具体是怎么样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = VolleyLog.DEBUG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SLOW_REQUEST_THRESHOLD_MS = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HttpStack mHttpStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteArrayPool mPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 ByteArrayPool 可以实现复用，节约内存</span></span><br><span class="line">        <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">        mHttpStack = httpStack;</span><br><span class="line">        mPool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">            Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 得到请求头</span></span><br><span class="line">                Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                <span class="comment">// 添加缓存头部信息</span></span><br><span class="line">                addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">                httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">                <span class="comment">// 得到响应行</span></span><br><span class="line">                StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">                <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">                <span class="comment">// 转化得到响应头</span></span><br><span class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">                <span class="comment">// 如果返回的状态码是304（即：HttpStatus.SC_NOT_MODIFIED）</span></span><br><span class="line">                <span class="comment">// 那么说明服务端的数据没有变化，就直接从之前的缓存中取</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                            request.getCacheEntry() == <span class="keyword">null</span> ? <span class="keyword">null</span> : request.getCacheEntry().data,</span><br><span class="line">                            responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">                <span class="comment">// 有一些响应可能没有内容，比如，所以要判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把 entiity 转为 byte[]</span></span><br><span class="line">                  responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                  <span class="comment">// no-content request.</span></span><br><span class="line">                  responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS(即 3000ms) ，会打印相应的日志</span></span><br><span class="line">                <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">                <span class="comment">// 响应码不是在 200-299 之间就抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">                NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">                <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                            responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                        <span class="comment">// 启动重试策略, 认证错误</span></span><br><span class="line">                        attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                                request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 如果请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS ，就打印相应的日志</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logSlowRequests</span><span class="params">(<span class="keyword">long</span> requestLifetime, Request&lt;?&gt; request,</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents, StatusLine statusLine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">            VolleyLog.d(<span class="string">"HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], "</span> +</span><br><span class="line">                    <span class="string">"[rc=%d], [retryCount=%s]"</span>, request, requestLifetime,</span><br><span class="line">                    responseContents != <span class="keyword">null</span> ? responseContents.length : <span class="string">"null"</span>,</span><br><span class="line">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 进行重试策略，如果不满足重试的条件会抛出异常</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span><br><span class="line">            VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = request.getRetryPolicy();</span><br><span class="line">        <span class="keyword">int</span> oldTimeout = request.getTimeoutMs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            retryPolicy.retry(exception);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">            request.addMarker(</span><br><span class="line">                    String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在请求行中添加缓存相关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">            headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">            headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(String what, String url, <span class="keyword">long</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">        VolleyLog.v(<span class="string">"HTTP ERROR(%s) %d ms to fetch %s"</span>, what, (now - start), url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**把 HttpEntity 的内容读取到 byte[] 中. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</span><br><span class="line">        PoolingByteArrayOutputStream bytes =</span><br><span class="line">                <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = entity.getContent();</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = mPool.getBuf(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></span><br><span class="line">                entity.consumeContent();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// This can happen if there was an exception above that left the entity in</span></span><br><span class="line">                <span class="comment">// an invalid state.</span></span><br><span class="line">                VolleyLog.v(<span class="string">"Error occured when calling consumingContent"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPool.returnBuf(buffer);</span><br><span class="line">            bytes.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 把 Headers[] 转换为 Map&lt;String, String&gt;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line">            result.put(headers[i].getName(), headers[i].getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把 BasicNetwork 的源码全部看下来，发现 BasicNetwork 干的事情就如下：</p>
<ul>
<li>利用 HttpStack 执行请求，把响应 HttpResponse 封装为 NetworkResponse ;</li>
<li>如果在这过程中出错，会有重试策略。</li>
</ul>
<p>至于 NetworkResponse 的源码在这里就不分析了，主要是一个相对于 HttpResponse 的封装类，可以自己去看其源码。</p>
<p>得到 NetworkResponse 之后，在 NetworkDispatcher 中经过 Request 的 <code>parseNetworkResponse</code> 方法把 NetworkResponse 转化为了 Response 。(具体可参考上面分析的 NetworkDispatcher 和 StringRequest 源码)</p>
<p>那么接下来就把目光转向 Response 吧。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 类的源码比较简单，一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应结果的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** Called when a response is received. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应错误的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Callback method that an error has been occurred with the</span><br><span class="line">         * provided error code and optional user-readable message.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过这个静态方法构造 Response */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">success</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(result, cacheEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过这个静态方法构造错误的 Response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">error</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Parsed response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache metadata for this response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Cache.Entry cacheEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detailed error information if &lt;code&gt;errorCode != OK&lt;/code&gt;. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> VolleyError error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if this response was a soft-expired one and a second one MAY be coming. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> intermediate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 是否成功</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = cacheEntry;</span><br><span class="line">        <span class="keyword">this</span>.error = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Response 类主要通过 <code>success</code> 和 <code>error</code> 两个方法分别来构造正确的响应结果和错误的响应结果。另外，在 Response 类中还有 Listener 和 ErrorListener 两个接口。在最终的回调中会使用到它们。</p>
<p>在得到了 Response 之后，就要使用 ResponseDelivery 来分发了。那下面就轮到 ResponseDelivery 了，go on !!</p>
<h2 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的response ，runnable 会在分发之后执行</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 错误的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 的接口就定义了三个方法，我们需要在其实现类中看看具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 用来分发 Response , 一般都是在主线程中*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 传入的 Handler 为主线程的</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                handler.post(command);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a new response delivery interface, mockable version</span><br><span class="line">     * for testing.</span><br><span class="line">     * <span class="doctag">@param</span> executor For running delivery tasks</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"post-error"</span>);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A Runnable 用来分发 response 到主线程的回调接口中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 request 被标记为取消，那么不用分发</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 mResponse 是否成功来分发到不同的方法</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">            <span class="comment">// and the request can be finished. </span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行 mRunnable</span></span><br><span class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 将根据 mResponse 是否成功来调用不同的方法 <code>mRequest.deliverResponse</code> 和 <code>mRequest.deliverError</code> 。在 <code>mRequest.deliverResponse</code> 中会回调 Listener 的 <code>onResponse</code> 方法；而在 <code>mRequest.deliverError</code> 中会回调 ErrorListener 的 <code>onErrorResponse</code> 方法。至此，一个完整的网络请求及响应流程走完了。</p>
<h2 id="HttpStack"><a href="#HttpStack" class="headerlink" title="HttpStack"></a>HttpStack</h2><p>现在回过头来看看 Volley 框架中是如何发起网络请求的。在本文的开头中说过，Volley 是会根据 Android 的版本来选择对应的 HttpStack。那么下面我们来深入看一下 HttpStack 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过所给的参数执行请求</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpStack 接口中定义的方法就只有一个。我们要分别来看看 HurlStack 和 HttpClientStack 各自的实现。</p>
<p>HurlStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 把请求头放入 map 中</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="comment">// 使用 HttpURLConnection 来发起请求</span></span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求方法</span></span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把响应封装进 response 中</span></span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpClientStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求方法生成对应的 HttpUriRequest</span></span><br><span class="line">    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">    addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">    addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">    onPrepareRequest(httpRequest);</span><br><span class="line">    HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></span><br><span class="line">    <span class="comment">// data collection and possibly different for wifi vs. 3G.</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">5000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">    <span class="keyword">return</span> mClient.execute(httpRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里只给出 HurlStack 和 HttpClientStack 的 <code>performRequest</code> 方法。我们可以看到 HurlStack 和 HttpClientStack 已经把 HttpUrlConnection 和 HttpClient 封装得很彻底了，以后哪里有需要的地方可以直接使用。</p>
<h2 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h2><p>RetryPolicy 接口主要的作用就是定制重试策略，我们从下面的源码可以看出该接口有三个抽象方法：</p>
<ul>
<li>getCurrentTimeout ：得到当前超时时间；</li>
<li>getCurrentRetryCount ：得到当前重试的次数；</li>
<li>retry ：是否进行重试，其中的 <code>error</code> 参数为异常的信息。若在 <code>retry</code> 方法中跑出 <code>error</code> 异常，那 Volley 就会停止重试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current timeout (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current retry count (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Prepares for the next retry by applying a backoff to the timeout.</span><br><span class="line">     * <span class="doctag">@param</span> error The error code of the last attempt.</span><br><span class="line">     * <span class="doctag">@throws</span> VolleyError In the event that the retry could not be performed (for example if we</span><br><span class="line">     * ran out of attempts), the passed in error is thrown.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetryPolicy 接口有一个默认的实现类 DefaultRetryPolicy ，DefaultRetryPolicy 的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The default socket timeout in milliseconds */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default number of retries */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default backoff multiplier */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a new retry policy.</span><br><span class="line"> * <span class="doctag">@param</span> initialTimeoutMs The initial timeout for the policy.</span><br><span class="line"> * <span class="doctag">@param</span> maxNumRetries The maximum number of retries.</span><br><span class="line"> * <span class="doctag">@param</span> backoffMultiplier Backoff multiplier for the policy.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</span><br><span class="line">    mCurrentTimeoutMs = initialTimeoutMs;</span><br><span class="line">    mMaxNumRetries = maxNumRetries;</span><br><span class="line">    mBackoffMultiplier = backoffMultiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，在 Volley 内部已经有一套默认的参数配置了。当然，你也可以通过自定义的形式来设置重试策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="comment">// 重试次数自增</span></span><br><span class="line">    mCurrentRetryCount++;</span><br><span class="line">    <span class="comment">// 超时时间自增，mBackoffMultiplier 为超时时间的因子</span></span><br><span class="line">    mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">    <span class="comment">// 如果超过最大次数，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns true if this policy has attempts remaining, false otherwise.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>分析完了前面这么多的类，终于轮到了最后的 Cache 。Cache 接口中定义了一个内部类 Entry ，还有定义了几个方法：</p>
<ul>
<li>get(String key) ：根据传入的 <code>key</code> 来获取 entry ；</li>
<li>put(String key, Entry entry) ：增加或者替换缓存；</li>
<li>initialize() ：初始化，是耗时的操作，在子线程中调用；</li>
<li>invalidate(String key, boolean fullExpire) ：根据 <code>key</code> 使之对应的缓存失效；</li>
<li>remove(String key) ：根据 <code>key</code> 移除某个缓存；</li>
<li>clear() ：清空缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieves an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@return</span> An &#123;<span class="doctag">@link</span> Entry&#125; or null in the event of a cache miss</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Adds or replaces an entry to the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> entry Data to store and metadata for cache coherency, TTL, etc.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs any potentially long-running actions needed to initialize the cache;</span><br><span class="line">     * will be called from a worker thread.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Invalidates an entry in the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> fullExpire True to fully expire the entry, false to soft expire</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Removes an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Empties the cache.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类 Entry ，Entry 中有一个属性为 etag ，上面的源码中也有 etag 的身影。如果你对 ETag 不熟悉，可以查看这篇文章<a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">《Etag与HTTP缓存机制》</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 缓存中数据，即响应中的 body */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HTTP头部的一个定义，允许客户端进行缓存协商 */</span></span><br><span class="line">    <span class="keyword">public</span> String etag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 服务端响应的时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存过期的时间，若小于当前时间则过期 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存的有效时间，若小于当前时间则可以进行刷新操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 响应的头部信息 */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否有效，若返回 true 则缓存失效. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否需要刷新 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了 Cache 接口之后，我们来看一下实现类 DiskBasedCache 。首先是它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DISK_USAGE_BYTES = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory, <span class="keyword">int</span> maxCacheSizeInBytes)</span> </span>&#123;</span><br><span class="line">    mRootDirectory = rootDirectory;</span><br><span class="line">    mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法中传入的参数可知，Volley 默认最大磁盘缓存为 5M 。</p>
<p>DiskBasedCache 的 <code>get(String key)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到对应的缓存摘要信息</span></span><br><span class="line">    CacheHeader entry = mEntries.get(key);</span><br><span class="line">    <span class="comment">// if the entry does not exist, return.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到缓存文件</span></span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="comment">// CountingInputStream 为自定义的 IO 流，继承自 FilterInputStream</span></span><br><span class="line">    <span class="comment">// 具有记忆已读取的字节数的功能</span></span><br><span class="line">    CountingInputStream cis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cis = <span class="keyword">new</span> CountingInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        CacheHeader.readHeader(cis); <span class="comment">// eat header</span></span><br><span class="line">        <span class="comment">// 得到缓存中的数据 data[] </span></span><br><span class="line">        <span class="keyword">byte</span>[] data = streamToBytes(cis, (<span class="keyword">int</span>) (file.length() - cis.bytesRead));</span><br><span class="line">        <span class="keyword">return</span> entry.toCacheEntry(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"%s: %s"</span>, file.getAbsolutePath(), e.toString());</span><br><span class="line">        <span class="comment">// 若出错则移除缓存</span></span><br><span class="line">        remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 url 分成两半，分别得到对应的 hashcode ，拼接后得到对应的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFilenameForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstHalfLength = key.length() / <span class="number">2</span>;</span><br><span class="line">    String localFilename = String.valueOf(key.substring(<span class="number">0</span>, firstHalfLength).hashCode());</span><br><span class="line">    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">    <span class="keyword">return</span> localFilename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a file object for the given cache key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFileForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(mRootDirectory, getFilenameForKey(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiskBasedCache 的 <code>putEntry(String key, CacheHeader entry)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查磁盘空间是否足够，若不够会删除一些缓存文件</span></span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</span><br><span class="line">        e.writeHeader(fos);</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deleted = file.delete();</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(String key, CacheHeader entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算总缓存的大小</span></span><br><span class="line">    <span class="keyword">if</span> (!mEntries.containsKey(key)) &#123;</span><br><span class="line">        mTotalSize += entry.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHeader oldEntry = mEntries.get(key);</span><br><span class="line">        mTotalSize += (entry.size - oldEntry.size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加或者替换缓存</span></span><br><span class="line">    mEntries.put(key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initialize()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRootDirectory.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRootDirectory.mkdirs()) &#123;</span><br><span class="line">            VolleyLog.e(<span class="string">"Unable to create cache dir %s"</span>, mRootDirectory.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取缓存文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 得到缓存文件的摘要信息</span></span><br><span class="line">            CacheHeader entry = CacheHeader.readHeader(fis);</span><br><span class="line">            entry.size = file.length();</span><br><span class="line">            <span class="comment">// 放入 map 中</span></span><br><span class="line">            putEntry(entry.key, entry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">               file.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>invalidate(String key, boolean fullExpire)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span> </span>&#123;</span><br><span class="line">    Entry entry = get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 有效时间置零</span></span><br><span class="line">        entry.softTtl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fullExpire) &#123;</span><br><span class="line">            entry.ttl = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove(String key)</code> 和 <code>clear()</code> 方法比较简单，就不需要注释了：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> remove(<span class="keyword">String</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">boolean</span> deleted = getFileForKey(<span class="variable">key</span>).delete();</span><br><span class="line">    removeEntry(<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                <span class="variable">key</span>, getFilenameForKey(<span class="variable">key</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.<span class="built_in">clear</span>();</span><br><span class="line">    mTotalSize = <span class="number">0</span>;</span><br><span class="line">    VolleyLog.d(<span class="string">"Cache cleared."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0100B"><a href="#0100B" class="headerlink" title="0100B"></a>0100B</h1><p>至此，Volley 源码解析差不多已经结束了。基本上在整个 Volley 框架中至关重要的类都讲到了。当然，还有一些 NetworkImageView 、ImageLoader 等源码还没解析。由于本篇文章内容太长了(有史以来写过最长的一篇─=≡Σ((( つ•̀ω•́)つ)，只能等到下次有机会再给大家补上了。</p>
<p>在这还给出了一张整个 Volley 框架大致的网络通信流程图，对上面源码没看懂的童鞋可以参考这张图再看一遍：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161130214351.png" alt="Volley网络通信流程图"></p>
<p>最后，只剩下总结了。从头到尾分析了一遍，发现 Volley 真的是一款很优秀的框架，面向接口编程在其中发挥到极致。其中有不少值得我们借鉴的地方，但是 Volley 并不是没有缺点的，对于大文件传输 Volley 就很不擅长，搞不好会 OOM 。另外，在源码中还有不少可以继续优化的地方，有兴趣的同学可以自定义一个属于自己的 Volley 。</p>
<p>好了，如果你对本文哪里有问题或者不懂的地方，欢迎留言一起交流。</p>
<h1 id="0101B"><a href="#0101B" class="headerlink" title="0101B"></a>0101B</h1><p>References</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></li>
<li><a href="http://blog.csdn.net/zoudifei/article/details/45623121" target="_blank" rel="external">volley 框架剖析(四） 之HTTPCache设计</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/17656437" target="_blank" rel="external">Android Volley完全解析(四)，带你从源码的角度理解Volley  
</a></li>
<li><a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">Etag与HTTP缓存机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
