<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[blog for yuqirong]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-03-23T15:27:42.318Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[初探MD式转场动画]]></title>
    <link href="http://yuqirong.me/2016/03/23/%E5%88%9D%E6%8E%A2MD%E5%BC%8F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yuqirong.me/2016/03/23/初探MD式转场动画/</id>
    <published>2016-03-23T08:44:22.000Z</published>
    <updated>2016-03-23T15:27:42.318Z</updated>
    <content type="html"><![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是Google在SDK中已经给我们提供了。<code>ActivityOptions</code>是 Android 5.0 及以上使用的，但是也提供了<code>ActivityOptionsCompat</code>向下兼容。</p>
<p>下面我们就来看看吧：</p>
<p>layout_item.xml(ListView的item布局)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;@android:color/white&quot;
    android:padding=&quot;10dp&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/iv_img&quot;
        android:layout_width=&quot;90dip&quot;
        android:layout_height=&quot;65dip&quot;
        android:transitionName=&quot;photos&quot;
        android:padding=&quot;1dp&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_title&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:layout_marginTop=&quot;2dp&quot;
        android:layout_toRightOf=&quot;@id/iv_img&quot;
        android:singleLine=&quot;true&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Subhead&quot;
        android:textColor=&quot;?android:attr/textColorPrimary&quot;
        tools:text=&quot;标题&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_content&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/tv_title&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:layout_marginTop=&quot;8dp&quot;
        android:layout_toRightOf=&quot;@id/iv_img&quot;
        android:maxLines=&quot;2&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Small&quot;
        android:textColor=&quot;?android:attr/textColorPrimary&quot;
        tools:text=&quot;标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_time&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentRight=&quot;true&quot;
        android:layout_below=&quot;@+id/tv_content&quot;
        android:maxLines=&quot;1&quot;
        android:text=&quot;2016-02-25 11:22:23&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Small&quot;
        android:textColor=&quot;?android:attr/textColorSecondary&quot;
        android:textSize=&quot;12sp&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>我们会注意到在ImageView里有<code>android:transitionName=&quot;photos&quot;</code>，这正是后面需要用到的。在这里的<code>photos</code>可以任意取名。也就是说你想让哪个View在转场时表现出动画，就在哪个View的xml中添加<code>android:transitionName</code>。</p>
<p>之后就是我们点击Item时应该跳转到另一个Activity中(这里就跳转到NewsDetailActivity了)，这其中的逻辑如下：</p>
<pre><code>// Android 5.0 使用转场动画
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {
    ActivityOptions options = ActivityOptions
            .makeSceneTransitionAnimation(getActivity(),
                    itemView.findViewById(R.id.iv_img), &quot;photos&quot;);
    startActivity(NewsDetailActivity.class, bundle, options.toBundle());
} else {
    //让新的Activity从一个小的范围扩大到全屏
    ActivityOptionsCompat options = ActivityOptionsCompat
            .makeScaleUpAnimation(itemView, itemView.getWidth() / 2,
                    itemView.getHeight() / 2, 0, 0);
    startActivity(NewsDetailActivity.class, bundle, options.toBundle());
}
</code></pre><p>可以看到在Android 5.0时使用的<code>makeSceneTransitionAnimation()</code>方法中的第三个参数正是上面的<code>&quot;photos&quot;</code>。当然在5.0版本以下我们只能使用兼容的<code>ActivityOptionsCompat</code>了。</p>
<p>最后在要跳转的Activity的布局中也添加<code>android:transitionName=&quot;photos&quot;</code>，这样就形成了一个MD式转场动画了。</p>
<p>以下是NewsDetailActivity的布局xml(只截取了部分)：</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/iv_album&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;256dp&quot;
    android:scaleType=&quot;centerCrop&quot;
    android:src=&quot;@drawable/thumbnail_default&quot;
    android:transitionName=&quot;photos&quot;
    app:layout_collapseMode=&quot;parallax&quot;
    app:layout_collapseParallaxMultiplier=&quot;0.7&quot; /&gt;
</code></pre><p>好了，这样就完成了，如果你需要在NewsDetailActivity执行finish时也出现转场动画，你只需要这样做(这里只给出了<code>onBackPressed()</code>的样例)：</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
        finishAfterTransition();
    }
}
</code></pre><p>其实关于<code>ActivityOptions</code>和<code>ActivityOptionsCompat</code>转场动画还有更多选择，可以深入研究一下。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.lxway.com/895445426.htm" target="_blank" rel="external">你所不知道的Activity转场动画——ActivityOptions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造仿Android联系人界面]]></title>
    <link href="http://yuqirong.me/2016/03/22/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E4%BB%BFAndroid%E8%81%94%E7%B3%BB%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <id>http://yuqirong.me/2016/03/22/快速打造仿Android联系人界面/</id>
    <published>2016-03-22T07:53:24.000Z</published>
    <updated>2016-03-22T13:24:29.627Z</updated>
    <content type="html"><![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这里写图片描述"></p>
<p>我们可以看到在右侧有一个支持快速索引的栏。接下来，我们就要实现这种索引栏。</p>
<p>首先是<code>attrs.xml</code>，定义了三个自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;QuickIndexBar&quot;&gt;
        // 字体的颜色
        &lt;attr name=&quot;font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 选中时字体的颜色
        &lt;attr name=&quot;selected_font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 字体的大小
        &lt;attr name=&quot;font_size&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们创建一个类继承自<code>View</code>，类名就叫<code>QuickIndexBar</code>：</p>
<pre><code>// 默认字体颜色
private int defaultFontColor = Color.WHITE;
// 默认选中字体颜色
private int defaultSelectedFontColor = Color.GRAY;
// 字体颜色
private int fontColor;
// 选中字体颜色
private int selectedFontColor;
 // 字体大小
private float fontSize;
// 默认字体大小
private float defaultfontSize = 12;
// 上次触摸的字母单元格
int lastSelected = -1;
// 这次触摸的字母单元格
int selected = -1;

public QuickIndexBar(Context context) {
    this(context, null);
}

public QuickIndexBar(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public QuickIndexBar(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.QuickIndexBar);
    fontColor = a.getColor(R.styleable.QuickIndexBar_font_color, defaultFontColor);
    selectedFontColor = a.getColor(R.styleable.QuickIndexBar_selected_font_color, defaultSelectedFontColor);
    fontSize = a.getDimension(R.styleable.QuickIndexBar_font_size,
            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, defaultfontSize,
                    getContext().getResources().getDisplayMetrics()));
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    mPaint.setColor(fontColor);
    mPaint.setTypeface(Typeface.DEFAULT_BOLD);
    mPaint.setTextSize(fontSize);

}
</code></pre><p>上面的代码就是在构造器中初始化了自定义属性，大家应该都能看懂。</p>
<pre><code>// 快速索引的字母
public static final String[] INDEX_ARRAYS = new String[]{&quot;#&quot;, &quot;A&quot;, &quot;B&quot;,
        &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;,
        &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};
// 控件的宽度
private int width;
// 控件的高度
private int height;
// 字母单元格的宽度
private float cellHeight;

/**
 * 得到控件的大小
 */
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    width = getMeasuredWidth();
    height = getMeasuredHeight();
    //  得到字母单元格的高度
    cellHeight = height * 1.0f / INDEX_ARRAYS.length;
}
</code></pre><p>然后在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>中获取<code>width</code>和<code>height</code>。还要计算<code>cellHeight</code>,也就是<code>INDEX_ARRAYS</code>中每个字符串所占用的高度，以便在<code>onDraw(Canvas canvas)</code>中使用。</p>
<p>我们来看看<code>onDraw(Canvas canvas)</code>：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 遍历画出index
    for (int i = 0; i &lt; INDEX_ARRAYS.length; i++) {
        // 测出字体的宽度
        float x = width / 2 - mPaint.measureText(INDEX_ARRAYS[i]) / 2;
        // 得到字体的高度
        Paint.FontMetrics fm = mPaint.getFontMetrics();
        double fontHeight = Math.ceil(fm.descent - fm.ascent);

        float y = (float) ((i + 1) * cellHeight - cellHeight / 2 + fontHeight / 2);
        if (i == selected) {
            mPaint.setColor(lastSelected == -1 ? fontColor : selectedFontColor);
        } else {
            mPaint.setColor(fontColor);
        }
        // 绘制索引的字母 (x,y)为字母左下角的坐标
        canvas.drawText(INDEX_ARRAYS[i], x, y, mPaint);
    }

}
</code></pre><p>在代码中去遍历<code>INDEX_ARRAYS</code>，测量出字母的宽度和高度。这里要注意的是，<code>canvas.drawText(String text, float x, float y, Paint paint)</code>中的 x,y 指的是字母左下角的坐标，并不是“原点”。</p>
<p>别忘了我们还要对<code>QuickIndexBar</code>的触摸事件作出处理。所以我们要重写onTouchEvent(MotionEvent event)：</p>
<pre><code>/**
 * 设置当索引改变的监听器
 */
public interface OnIndexChangeListener {
    /**
     * 当索引改变
     *
     * @param selectIndex 索引值
     */
    void onIndexChange(int selectIndex);

    /**
     * 当手指抬起
     */
    void onActionUp();
}

public void setOnIndexChangeListener(OnIndexChangeListener listener) {
    this.listener = listener;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    float y;
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            y = event.getY();
            // 计算出触摸的是哪个字母单元格
            selected = (int) (y / cellHeight);
            if (selected &gt;= 0 &amp;&amp; selected &lt; INDEX_ARRAYS.length) {
                if (selected != lastSelected) {
                    if (listener != null) {
                        listener.onIndexChange(selected); // 回调监听器的方法
                    }
                    Log.i(TAG, INDEX_ARRAYS[selected]);
                }
                lastSelected = selected;
            }
            break;
        case MotionEvent.ACTION_UP:
            // 把上次的字母单元格重置
            lastSelected = -1;
            listener.onActionUp();
            break;
    }
    invalidate(); // 重绘视图
    return true;
}
</code></pre><p>在<code>ACTION_DOWN</code>和<code>ACTION_MOVE</code>计算出了触摸的y值对应的是索引中的哪个字母，然后回调了监听器；而在<code>ACTION_UP</code>中重置了<code>lastSelected</code>，回调了监听器。</p>
<p>这样，我们就把<code>QuickIndexBar</code>写好了，关于<code>QuickIndexBar</code>使用的代码就不贴出来了，太长了。如果有需要，可以下载下面的Demo，里面都有注释。Demo的效果图如下：</p>
<p><img src="/uploads/20160322/20160322211942.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这里了。have fun!</p>
<p>源码下载：</p>
<p><a href="/uploads/20160322/ContactPicker.rar">ContactPicker.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/ContactPicker" target="_blank" rel="external">ContactPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[夜半一忆]]></title>
    <link href="http://yuqirong.me/2016/03/17/%E5%A4%9C%E5%8D%8A%E4%B8%80%E5%BF%86/"/>
    <id>http://yuqirong.me/2016/03/17/夜半一忆/</id>
    <published>2016-03-17T15:13:58.000Z</published>
    <updated>2016-03-18T05:15:53.169Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈何岁月，流于昨日。雁过一鸣，惊于何人？花开花谢，润土无声。</p>
<p>繁华落尽，只道是人间凄凉。穷极一生，只为还清一世业障。</p>
<p>高山流水，静谧成寂。秋风落叶，随风飘散。</p>
<p>别时易，相逢难，烈酒灼心，忆似水年华。</p>
<p>乍暖还寒，大梦初醒，此夜无眠。</p>
<p>仰天大笑，岂是蓬蒿人？</p>
<p>————记于开题答辩之日</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=1&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/03/08/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/03/08/《Android群英传》笔记(下)/</id>
    <published>2016-03-08T12:22:27.000Z</published>
    <updated>2016-03-31T08:15:54.570Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7" class="headerlink" title="第六章：Android绘图机制与处理技巧"></a>第六章：Android绘图机制与处理技巧</h1><h2 id="6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F"><a href="#6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F" class="headerlink" title="6.1 屏幕的尺寸信息"></a>6.1 屏幕的尺寸信息</h2><p>系统屏幕密度如下</p>
<ul>
<li>ldpi—120—240X320分辨率</li>
<li>mdpi—160—320X480分辨率</li>
<li>hdpi—240—480X800分辨率</li>
<li>xhdpi—320—720X1280分辨率</li>
<li>xxhdpi—480—1080X1920分辨率</li>
</ul>
<p>Android系统使用mdpi即密度值为160的屏幕作为标准，在这屏幕上1px = 1dp。</p>
<p>所以各个分辨率直接的换算比例，即ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12</p>
<p>下面给出单位转换的源码：</p>
<pre><code>public class DisplayUtil {

    /**
     * 把px值转换为dip或dp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2dip(Context context, float pxValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (pxValue / scale + 0.5f);
    }

    /**
     * 把dip值或dp值转换为px值
     *
     * @param context
     * @param dipValue
     * @return
     */
    public static int dip2px(Context context, float dipValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (dipValue * scale + 0.5f);
    }

    /**
     * 将px值转换为sp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2sp(Context context, float pxValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (pxValue / fontScale + 0.5f);
    }

    /**
     * 将sp值转换为px值
     * @param context
     * @param spValue
     * @return
     */
    public static int sp2px(Context context, float spValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (spValue * fontScale + 0.5f);
    }

}
</code></pre><h2 id="6-2_2D_u7ED8_u56FE_u57FA_u7840"><a href="#6-2_2D_u7ED8_u56FE_u57FA_u7840" class="headerlink" title="6.2 2D绘图基础"></a>6.2 2D绘图基础</h2><p>Paint类的一些属性和对应的功能：</p>
<ul>
<li>setAntiAlias(); //设置画笔的锯齿效果</li>
<li>setColor(); //设置画笔的颜色</li>
<li>setARGB(); //设置画笔的A,R,G,B的值</li>
<li>setAlpha(); //设置画笔的Alpha值</li>
<li>setTextSize(); //设置字体的尺寸</li>
<li>setStyle(); //设置画笔的风格（空心或者实心）</li>
<li>setStrokeWidth(); //设置空心边框的宽度</li>
</ul>
<p>Canvas类主要的绘画功能：</p>
<ul>
<li>canvas.drawPoint(x,y,paint); //绘制点</li>
<li>canvas.drawLine(startX,startY,endX,endY,paint); //绘制直线</li>
<li>canvas.drawRect(left,top,right,bottom,paint); //绘制矩形</li>
<li>canvas.drawRoundRect(left,top,right,bottom,radiusX,radiusY,paint); //绘制圆角矩形</li>
<li>canvas.drawCircle(circleX,circleY,radius,paint); //绘制圆</li>
<li>canvas.drawOval(left,top,right,bottom,paint); //通过椭圆的外接矩形来绘制椭圆</li>
<li>canvas.drawText(text,startX,startY,paint); //绘制文字</li>
<li>canvas.drawPosText(text,new float[]{x1,y1,…,xn,yn},paint); //指定位置绘制文本</li>
</ul>
<h2 id="6-3_Android_XML_u7ED8_u56FE"><a href="#6-3_Android_XML_u7ED8_u56FE" class="headerlink" title="6.3 Android XML绘图"></a>6.3 Android XML绘图</h2><ul>
<li><p>Bitmap：</p>
<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:src=&quot;@drawable/ic_launcher&quot;/&gt;
</code></pre><p>  这样就能直接将图片转成bitmap在程序中使用了。</p>
</li>
<li><p>Shape:</p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:shape=&quot;line|oval|ring|rectangle&quot;&gt;
  &lt;!--默认为rectangle--&gt;
  &lt;corners
      android:bottomLeftRadius=&quot;integer&quot;
      android:bottomRightRadius=&quot;integer&quot;
      android:radius=&quot;integer&quot;
      android:topLeftRadius=&quot;integer&quot;
      android:topRightRadius=&quot;integer&quot; /&gt;
  &lt;!--当shape为rectangle时才有，radius默认为1dp--&gt;

  &lt;gradient
      android:angle=&quot;integer&quot;
      android:centerColor=&quot;color&quot;
      android:centerX=&quot;integer&quot;
      android:centerY=&quot;integer&quot;
      android:endColor=&quot;color&quot;
      android:gradientRadius=&quot;integer&quot;
      android:startColor=&quot;color&quot;
      android:type=&quot;linear|radial|sweep&quot;
      android:useLevel=&quot;boolean&quot; /&gt;

  &lt;padding
      android:bottom=&quot;integer&quot;
      android:left=&quot;integer&quot;
      android:right=&quot;integer&quot;
      android:top=&quot;integer&quot; /&gt;

  &lt;size
      android:width=&quot;integer&quot;
      android:height=&quot;integer&quot; /&gt;
  &lt;!--指定大小，一般用在imageview配合scaleType使用--&gt;

  &lt;solid android:color=&quot;color&quot; /&gt;
  &lt;!--填充颜色--&gt;
  &lt;stroke
      android:width=&quot;integer&quot;
      android:color=&quot;color&quot;
      android:dashGap=&quot;integer&quot;
      android:dashWidth=&quot;integer&quot; /&gt;
  &lt;!--边框,dashGap为虚线间隔宽度，dashWidth为虚线宽度--&gt;
&lt;/shape&gt;
</code></pre></li>
<li><p>Layer:实现类似Photoshop中图层的概念。</p>
<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:drawable=&quot;@mipmap/ic_launcher&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;10dp&quot;
      android:top=&quot;10dp&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;20dp&quot;
      android:top=&quot;20dp&quot; /&gt;
&lt;/layer-list&gt;
</code></pre></li>
<li><p>Selector：通常用于view的触摸反馈。</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:state_pressed=&quot;true&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#334444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
  &lt;item android:state_pressed=&quot;false&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#444444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
&lt;/selector&gt;
</code></pre></li>
</ul>
<h2 id="6-4_Android_u7ED8_u56FE_u6280_u5DE7"><a href="#6-4_Android_u7ED8_u56FE_u6280_u5DE7" class="headerlink" title="6.4 Android绘图技巧"></a>6.4 Android绘图技巧</h2><ul>
<li><p>Canvas.save():保存画布。它的作用就是将之前的所有已绘制图像保存起来，让后续的操作就好像在一个新的图层上操作一样。</p>
</li>
<li><p>Canvas.restore():合并图层操作。它的作用就是将我们在save()之后绘制的所有图像与save()之前的图像进行合并。</p>
</li>
<li><p>Canvas.translate():画布平移，可理解为坐标系的平移。如在之前绘制的坐标系原点在(0,0)。在translate(x,y)之后，坐标原点在(x,y)。</p>
</li>
<li><p>Canvas.rotate():画布翻转，可理解为坐标系的翻转。canvas.rotate(30);为按照坐标系的原点顺时针旋转30度。canvas.rotate(30,x,y);为按照坐标系的(x,y)点顺时针旋转30度。</p>
</li>
<li><p>Canvas.saveLayer()、Canvas.saveLayerAlpha():将一个图层入栈。</p>
</li>
<li><p>Canvas.restore()、Canvas.restoreToCount():将一个图层出栈。</p>
</li>
</ul>
<h2 id="6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406"><a href="#6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406" class="headerlink" title="6.5 Android图像处理之色彩特效处理"></a>6.5 Android图像处理之色彩特效处理</h2><ul>
<li><p>色调：<code>setRotate(int axis,float degree)</code>设置颜色的色调。第一个参数，系统分别使用0、1、2来代表Red、Green、Blue三种颜色的处理。而第二个参数就是需要处理的值。</p>
<pre><code>ColorMatrix hueMatrix = new ColorMatrix();
hueMatrix.setRotate(0, hue0);
hueMatrix.setRotate(1, hue1);
hueMatrix.setRotate(2, hue2);
</code></pre></li>
</ul>
<p>通过上面的方法，可以为RGB三种颜色分量分别重新设置了不同的色调值。</p>
<ul>
<li><p>饱和度：<code>setSaturation(float sat)</code>方法来设置颜色的饱和度，参数即代表设置颜色饱和度的值，代码如下所示。当饱和度为0时，图像就变成灰色图像了。</p>
<pre><code>ColorMatrix saturationMatrix = new ColorMatrix();
saturationMatrix.setSaturation(saturation);
</code></pre></li>
<li><p>亮度：当三原色以相同的比例进行混合的时候，就会显示出白色。系统也正是使用这个原理来改变一个图像的亮度的，代码如下所示。当亮度为0时，图像就变成全黑了。</p>
<pre><code>ColorMatrix lumMatrix = new ColorMatrix();
lumMatrix.setScale(lum,lum,lum,1);
</code></pre></li>
<li><p><code>postConcat()</code>方法将矩阵的作用效果混合，从而叠加处理效果，代码如下：</p>
<pre><code>ColorMatrix imageMatrix = new ColorMatrix();
imageMatrix.postConcat(hueMatrix);
imageMatrix.postConcat(saturationMatrix);
imageMatrix.postConcat(lumMatrix);
</code></pre></li>
</ul>
<h2 id="6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406"><a href="#6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h2><ul>
<li>matrix.setRotate()——旋转变换</li>
<li>matrix.setTranslate()——平移变换</li>
<li>matrix.setScale()——缩放变换</li>
<li>matrix.setSkew()——错切变换</li>
<li>pre()和post()——提供矩阵的前乘和后乘运算</li>
</ul>
<h2 id="6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406"><a href="#6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406" class="headerlink" title="6.7 Android图像处理之画笔特效处理"></a>6.7 Android图像处理之画笔特效处理</h2><pre><code>mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
</code></pre><p>可以实现圆形ImageView。</p>
<p>// TODO</p>
<p><strong>Shader</strong></p>
<p>Shader又称之为着色器、渲染器，它用来实现一系列的渐变、渲染效果。在Android中的Shader包括以下几种：</p>
<ul>
<li>BitmapShader 位图Shader</li>
<li>LinearGradient 线性Shader</li>
<li>RadialGradient 光束Shader</li>
<li>SweepGradient 梯度Shader</li>
<li>ComposeShader 混合Shader</li>
</ul>
<p>除第一个Shader以外 其他Shader都实现了名副其实的渐变。BitmapShader产生的是一个位图，它的作用就是通过Paint对画布进行指定Bitmap的填充，填充有以下几种模式可以选择：</p>
<ul>
<li>CLAMP拉伸——拉伸的是图片最后一个像素 不断重复</li>
<li>REPEAT重复——横向纵向不断重复</li>
<li>MIRROR镜像——横向不断翻转重复，纵向不断翻转重复</li>
</ul>
<p><strong>PathEffect</strong></p>
<p>PathEffect是指用各种笔触效果来绘制一个路径。</p>
<ul>
<li>ConrnerPathEffect 就是将拐角变得圆滑，具体圆滑的程度，则由参数决定</li>
<li>DiscretePathEffect 使用这个效果后，线段上就会产生许多杂点。</li>
<li>DashPathEffect 这个效果可以用来绘制虚线，用一个数组来设置各个点之间的间隔。另一个参数phase则用来控制绘制时数组的一个偏移量。通常可以通过设置值来实现路径的动态效果。</li>
<li>PathDashPathEffect 与前面的DashPathEffect类似，只不过它的功能更加强大，可以设置显示点的图形，即方形点的虚线，圆形点的虚线。</li>
<li>ComposePathEffect 组合PathEffect，将任意两种路径特性组合起来形成一种新的效果。</li>
</ul>
<h2 id="6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView"><a href="#6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView" class="headerlink" title="6.8 View之孪生兄弟——SurfaceView"></a>6.8 View之孪生兄弟——SurfaceView</h2><p>SurfaceView与view的区别：  </p>
<ul>
<li>View主要适用于主动更新的情况下，而SurfaceView 主要适用于被动更新，例如频繁的刷新。</li>
<li>View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新。 </li>
<li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了双缓冲。</li>
</ul>
<p>总结成一句话就是，如果你的自定义View需要频繁刷新，或者刷新时数据处理量比较大，那你就可以考虑使用SurfaceView来取代View了。</p>
<p>SurfaceView模版代码：</p>
<pre><code>public class MySurfaceView extends SurfaceView implements Runnable, SurfaceHolder.Callback {
  //SurfaceHolder
  private SurfaceHolder mSurfaceHolder;
  //用于绘图的Canvas
  private Canvas mCanvas;
  //子线程标志位
  private boolean mIsDrawing;

  public MySurfaceView(Context context) {
      super(context);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs) {
      super(context, attrs);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      init();
  }
  private void init() {
      mSurfaceHolder = getHolder();
      mSurfaceHolder.addCallback(this);
      setFocusable(true);
      setFocusableInTouchMode(true);
      this.setKeepScreenOn(true);
      //mSurfaceHolder.setFormat(PixelFormat.OPAQUE);
  }
  @Override
  public void surfaceCreated(SurfaceHolder holder) {
      mIsDrawing = true;
      new Thread(this).start();
  }
  @Override
  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
  }
  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
      mIsDrawing = false;
  }
  @Override
  public void run() {
      while (mIsDrawing) {
          draw();
      }
  }
  private void draw() {
      try {
          //每次获得的canvas对象都是上次的 因此上次的绘画操作都会保存
          mCanvas = mSurfaceHolder.lockCanvas();
          //draw here
      } catch (Exception e) {

      } finally {
          if (mCanvas != null) {
              // 对画布内容进行提交
              mSurfaceHolder.unlockCanvasAndPost(mCanvas);
          }
      }

  }
}
</code></pre><h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第七章：Android动画机制与使用技巧"></a>第七章：Android动画机制与使用技巧</h1><h2 id="7-1_Android_View_u52A8_u753B_u6846_u67B6"><a href="#7-1_Android_View_u52A8_u753B_u6846_u67B6" class="headerlink" title="7.1 Android View动画框架"></a>7.1 Android View动画框架</h2><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，而且控制的是整个View，实现的原理是绘制视图时 View 所在的 ViewGroup 中的 drawChild 函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix()),通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
<ul>
<li>透明度动画：AlphaAnimation</li>
<li>旋转动画：RotateAnimation</li>
<li>位移动画：TranslateAnimation</li>
<li>缩放动画：ScaleAnimation</li>
</ul>
<p>动画集合：AnimationSet</p>
<p>动画监听器：setAnimationListener(new Animation.AnimationListener(){…})</p>
<h2 id="7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790"><a href="#7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790" class="headerlink" title="7.2 Android属性动画分析"></a>7.2 Android属性动画分析</h2><p><strong>ObjectAnimator</strong>：属性动画框架中最重要的实行类。</p>
<p>用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.setDuration(300);
animator.start();
</code></pre><p>注意：操纵的属性(即上面的“translationX”)必须具有get、set方法，不然ObjectAnimator就无法起效。因为内部会通过Java反射机制来调用set函数修改对象属性值。</p>
<p>常用属性值：</p>
<ul>
<li>translationX和translationY</li>
<li>rotation、rotationX和rotationY</li>
<li>scaleX和scaleY</li>
<li>pivotX和pivotY</li>
<li>x和y</li>
<li>alpha</li>
</ul>
<p><strong>PropertyValuesHolder</strong>：类似于视图动画中的AnimationSet。在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</p>
<p>用法：</p>
<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;,300f);
PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0,1f);
PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;,1f,0,1f);
ObjectAnimator.ofPropertyValuesHolder(view,pvh1,pvh2,pvh3).setDuration(1000).start();
</code></pre><p><strong>ValueAnimator</strong>：ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</p>
<p>用法：</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0,100);
animator.setTarget(view);
animator.setDuration(1000).start();
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Float value = (Float) animation.getAnimatedValue();
        // TODO use the value
    }
});
</code></pre><p>在ValueAnimator的AnimatorUpdateListener中监听数值的变换，从而完成动画的变换。</p>
<p><strong>AnimatorListener和AnimatorListenerAdapter</strong>：动画事件的监听。</p>
<p>AnimatorListener用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
});
</code></pre><p>AnimatorListenerAdapter用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><p><strong>AnimatorSet</strong>：AnimatorSet不仅能实现一个属性同时作用多个属性动画效果，同时也能实现更为精确的顺序控制。</p>
<p>用法(实现上面使用PropertyValuesHolder的动画效果)：</p>
<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
    ObjectAnimator animator2 = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1f,0f,1f);
    ObjectAnimator animator3 = ObjectAnimator.ofFloat(view,&quot;scaleY&quot;,1f,0f,1f);
    AnimatorSet set = new AnimatorSet();
    set.setDuration(1000);
    set.playTogether(animator1,animator2,animator3);
    set.start();
</code></pre><p>还有playTogether()、playSequentially()、animSet.play()、with()、before()、after()来协同工作。</p>
<p><strong>在XML中使用属性动画</strong>：在res里新建文件夹animator。</p>
<p>anim_scalex.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:propertyName=&quot;scaleX&quot;
    android:valueFrom=&quot;1.0&quot;
    android:valueTo=&quot;2.0&quot;
    android:valueType=&quot;floatType&quot;&gt;
&lt;/objectAnimator&gt; 
</code></pre><p>在代码中加载xml属性动画：</p>
<pre><code>public void scaleX(View view) {
    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.anim_scalex);  
    anim.setTarget(view);  
    anim.start();
}
</code></pre><p>另附 XML文件中定义两个objectAnimator：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:ordering=&quot;together&quot; &gt;  

    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleX&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  
    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleY&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  

&lt;/set&gt; 
</code></pre><p><strong>View的animate方法</strong>：可以认为是属性动画的一种简写方式。</p>
<p>用法：</p>
<pre><code>view.animate()
    .alpha(0)
    .y(300)
    .setDuration(300)
    .withStartAction(new Runnable() {
        @Override
        public void run() {

        }
    }).withEndAction(new Runnable() {
        @Override
        public void run() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {

                }
            });
        }
    }).start();
</code></pre><h2 id="7-3_Android_u5E03_u5C40_u52A8_u753B"><a href="#7-3_Android_u5E03_u5C40_u52A8_u753B" class="headerlink" title="7.3 Android布局动画"></a>7.3 Android布局动画</h2><p>最简单的布局动画是在ViewGroup的XML中，使用以下打开布局动画。<br><code>android:animateLayoutChanges=&quot;true&quot;</code><br>通过上面的代码，当ViewGroup添加View时，子View会呈现逐渐显示的过渡效果，是Android默认的显示的过渡效果。</p>
<p><strong>LayoutAnimationController</strong></p>
<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);
// 设置过渡动画
ScaleAnimation scaleAnimation = new ScaleAnimation(0,1,0,1);
scaleAnimation.setDuration(2000);
// 设置布局动画的显示属性
LayoutAnimationController lac = new LayoutAnimationController(scaleAnimation,0.5f);
lac.setOrder(LayoutAnimationController.ORDER_NORMAL);
ll.setLayoutAnimation(lac);
</code></pre><p>LayoutAnimationController的第一个参数是作用的动画，第二个参数是每个View显示的delay时间。当delay时间不为0时，可以设置子View显示的顺序，如下所示。</p>
<ul>
<li>LayoutAnimationController.ORDER_NORMAL  顺序</li>
<li>LayoutAnimationController.ORDER_RANDOM  随机</li>
<li>LayoutAnimationController.ORDER_REVERSE 反序</li>
</ul>
<h2 id="7-4_Interpolators_28_u63D2_u503C_u5668_29"><a href="#7-4_Interpolators_28_u63D2_u503C_u5668_29" class="headerlink" title="7.4 Interpolators(插值器)"></a>7.4 Interpolators(插值器)</h2><h2 id="7-5__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#7-5__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="7.5 自定义动画"></a>7.5 自定义动画</h2><p>首先继承Animation类，实现<code>applyTransformation(float interpolatedTime, Transformation t)</code>的逻辑。不过通常情况下，还要覆盖父类的<code>initialize(int width, int height, int parentWidth, int parentHeight)</code>实现一些初始化的工作。</p>
<p><code>applyTransformation(float interpolatedTime, Transformation t)</code>第一个参数是插值器的时间因子，这个因子由动画当前完成的百分比和当前时间所对应的插值所计算得来的，取值为0到1.0。第二个参数是矩阵的封装类，一般使用这个类来获取当前的矩阵对象，代码如下：</p>
<pre><code>final Matrix matrix = t.getMatrix();
</code></pre><p>下面给出电视机关闭效果的动画：</p>
<pre><code>@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    final Matrix matrix = t.getMatrix();
    matrix.preScale(1, 1 - interpolatedTime, mCenterWidth, mCenterHeight);
}
</code></pre><p>//TODO</p>
<h2 id="7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236"><a href="#7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236" class="headerlink" title="7.6 Android 5.X SVG 矢量动画机制"></a>7.6 Android 5.X SVG 矢量动画机制</h2><p>Google在Android 5.X中提供了下面两个新的API来帮助支持SVG：</p>
<ul>
<li>VectorDrawable</li>
<li>AnimatedVectorDrawable</li>
</ul>
<p>下面给出SVG图形：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:width=&quot;200dp&quot;
    android:height=&quot;200dp&quot;
    android:viewportHeight=&quot;100&quot;
    android:viewportWidth=&quot;100&quot;&gt;

    &lt;group
        android:name=&quot;test&quot;
        android:rotation=&quot;0&quot;&gt;
        &lt;path
            android:fillColor=&quot;@android:color/holo_blue_light&quot;
            android:pathData=&quot;M 25 50
            a 25,25 0 1,0 50,0&quot; /&gt;
    &lt;/group&gt;

&lt;/vector&gt;
</code></pre><p> //TODO</p>
<h1 id="u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790"><a href="#u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790" class="headerlink" title="第八章：Activity与Activity调用栈分析"></a>第八章：Activity与Activity调用栈分析</h1><h2 id="8-1_Activity"><a href="#8-1_Activity" class="headerlink" title="8.1 Activity"></a>8.1 Activity</h2><p>Activity的形态：</p>
<ul>
<li><p>Active/Running : 这时候Activity处于Activity栈的最顶层，可见，并与用户进行交互。</p>
</li>
<li><p>Paused : 当Activity失去焦点，被一个新的非全屏的Activity或者一个透明的Activity放置在栈顶时，Activity就转化为Paused形态。但它只是失去了与用户交互的能力，所有状态信息、成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。</p>
</li>
<li><p>Stopped : 如果一个Activity被另一个Activity完全覆盖，那么Activity就会进入Stopped形态，此时，它不再可见，但却依然保持了所有状态信息和成员变量。</p>
</li>
<li><p>Killed : 当Activity被系统回收掉或者Activity从来没有创建过，Activity就处于Killed状态。</p>
</li>
</ul>
<p>Activity启动与销毁过程：</p>
<ul>
<li><p>onCreate() ： 创建基本的UI元素。</p>
</li>
<li><p>onPause()和onStop() ： 清除Activity的资源，避免浪费。</p>
</li>
<li><p>onDestory() ： 因为引用会在Activity销毁的时候销毁，而线程不会，所以清除开启的线程。</p>
</li>
</ul>
<p>Activity的暂停与恢复过程：</p>
<ul>
<li><p>onPause() ： 释放系统资源，如Camera、sensor、receivers。</p>
</li>
<li><p>onResume() ： 需要重新初始化在onPause()中释放资源。</p>
</li>
</ul>
<p>Activity的停止过程：</p>
<ul>
<li><p>由部分不可见到完全不可见 ： onPause() -&gt; onStop()</p>
</li>
<li><p>由部分不可见到可见： onPause() -&gt; onStop() -&gt; onRestart() -&gt; onStart() -&gt; onResume()</p>
</li>
</ul>
<p>Activity的重新创建过程：</p>
<p>如果用户finish()方法结束了Activity，则不会调用onSaveInstanceState()。</p>
<h2 id="8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB"><a href="#8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB" class="headerlink" title="8.2 Android任务栈简介"></a>8.2 Android任务栈简介</h2><p>一个Task中的Activity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</p>
<h2 id="8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F"><a href="#8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.3 AndroidMainifest启动模式"></a>8.3 AndroidMainifest启动模式</h2><ul>
<li><p>standard ： 默认的启动模式，每次都会创建新的实例</p>
</li>
<li><p>singleTop ：   通常适用于接收到消息后显示的界面</p>
</li>
<li><p>singleTask ： 通常可以用来退出整个应用：将主Activity设为singleTask模式，然后在要退出的Activity中转到主Activity，从而将主Activity之上的Activity都清除，然后重写主Activity的onNewIntent()方法，在方法中加上一句finish()，将最后一个Activity结束掉。</p>
</li>
<li><p>singleInstance ： 申明为singleInstance的Activity会出现在一个新的任务栈中，而且该任务栈中只存在这一个Activity。举个例子，如果应用A的任务栈中创建了MainActivity的实例，且启动模式为singleInstance，如果应用B的也要激活MainActivity，则不需要创建，两个应用共享该Activity实例。这种启动模式常用于需要与程序分离的界面。</p>
</li>
</ul>
<p>关于singleTop和singleInstance这两种启动模式还有一点需要特殊说明：如果在一个singleTop或者singleInstance的Activity A中通过startActivityForResult()方法来启动另一个Activity B，那么直接返回Activity.RESULT_CANCELED而不会再去等待返回。这是由于系统在Framework层做了对这两种启动模式的限制，因为Android开发者认为，不同Task之间，默认是不能传递数据的，如果一定要传递，那么只能通过Intent来绑定数据。</p>
<h2 id="8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F"><a href="#8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.4 Intent Flag启动模式"></a>8.4 Intent Flag启动模式</h2><ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于在Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p>
</li>
<li><p>FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>FLAG_ACTIVITY_CLEAR_TOP：使用singleTask模式来启动一个Activity，与指定android:launchMode=”singleTask”效果相同。</p>
</li>
<li><p>FLAG_ACTIVITY_NO_HISTORY：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。例如A-B，B中以这种模式启动C，C再启动D，则当前Activity栈为ABD。</p>
</li>
</ul>
<h2 id="8-5__u6E05_u7A7A_u4EFB_u52A1_u6808"><a href="#8-5__u6E05_u7A7A_u4EFB_u52A1_u6808" class="headerlink" title="8.5 清空任务栈"></a>8.5 清空任务栈</h2><ul>
<li><p>clearTaskOnLaunch：每次返回该Activity时，都将该Activity之上的所有Activity都清除。通过这个属性，可以让这个Task每次在初始化的时候，都只有这一个Activity。</p>
</li>
<li><p>finishOnTaskLaunch：finishOnTaskLaunch属性与clearTaskOnLaunch属性类似，只不过clearTaskOnLaunch作用在别人身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所处的Task，那么用户再返回时，该Activity就会被finish掉。</p>
</li>
<li><p>alwaysRetainTaskState：如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。</p>
</li>
</ul>
<h1 id="u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236"><a href="#u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236" class="headerlink" title="第九章：Android系统信息与安全机制"></a>第九章：Android系统信息与安全机制</h1><h2 id="9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6"><a href="#9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6" class="headerlink" title="9.1 Android系统信息获取"></a>9.1 Android系统信息获取</h2><p>要获取系统的配置信息，通常可以从以下两个方面获取：</p>
<ul>
<li>android.os.Build</li>
<li>SystemProperty</li>
</ul>
<p>下面列举了android.os.Build一些常用的信息：</p>
<ul>
<li>Build.BOARD // 主板</li>
<li>Build.BRAND // Android系统定制商</li>
<li>Build.SUPPORTED_ABIS // CPU指令集</li>
<li>Build.DEVICE // 设备参数</li>
<li>Build.DISPLAY // 显示屏参数</li>
<li>Build.FINGERPRINT // 唯一编号</li>
<li>Build.SERIAL // 硬件序列号</li>
<li>Build.ID // 修订版本列表</li>
<li>Build.MANUFACTURER // 硬件制造商</li>
<li>Build.MODEL // 版本</li>
<li>Build.HARDWARE // 硬件名</li>
<li>Build.PRODUCT // 手机产品名</li>
<li>Build.TAGS // 描述Build的标签</li>
<li>Build.TYPE // Builder类型</li>
<li>Build.VERSION.CODENAME // 当前开发代号</li>
<li>Build.VERSION.INCREMENTAL // 源码控制版本号</li>
<li>Build.VERSION.RELEASE // 版本字符串</li>
<li>Build.VERSION.SDK_INT // 版本号</li>
<li>Build.HOST // Host值</li>
<li>Build.USER // User名</li>
<li>Build.TIME // 编译时间</li>
</ul>
<p>下面列举了SystemProperty常用的信息：</p>
<ul>
<li>os.version // OS版本</li>
<li>os.name // OS名称</li>
<li>os.arch // OS架构</li>
<li>user.home // Home属性</li>
<li>user.name // Name属性</li>
<li>user.dir //Dir属性</li>
<li>user.timezone // 时区</li>
<li>path.separator // 路径分隔符</li>
<li>line.separator // 行分隔符</li>
<li>file.separator // 文件分隔符</li>
<li>java.vendor.url // Java Vendor URL 属性</li>
<li>java.class.path // Java Class 路径</li>
<li>java.class.version Java Class 版本</li>
<li>java.vendor // Java Vendor 属性</li>
<li>java.version // Java 版本</li>
<li>java.home // Java Home 属性</li>
</ul>
<p>我们可以访问到系统的属性值，代码如下所示：</p>
<pre><code>String board = Build.BOARD;
String brand = Build.BRAND;

String os_version = System.getProperty(&quot;os.version&quot;);
String os_name = System.getProperty(&quot;os.name&quot;);
</code></pre><h2 id="9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager"><a href="#9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager" class="headerlink" title="9.2 Android Apk应用信息获取之PackageManager"></a>9.2 Android Apk应用信息获取之PackageManager</h2><p>Android系统提供了PackageManager来负责管理所有已安装的App。其中封装的信息如下：</p>
<ul>
<li>ActivityInfo：Mainfest文件中<activity\></activity\>和<receiver\></receiver\>之间的所有信息，包括name、icon、label、launchmode等。</li>
<li>ServiceInfo：封装了<service\></service\>之间的所有信息。</li>
<li>ApplicationInfo：封装了<application\></application\>之间的信息，不过特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在SDCard上的应用等，通过这些Flag，可以很方便的判断应用类型。</li>
<li>PackageInfo：PackageInfo与前面三个Info类似，都是用于封装Mainfest文件的相关节点信息，而它包含了所以Activity、Service等信息。</li>
<li>ResolveInfo：封装的是包含<intent\>信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含<intent\>的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</intent\></intent\></li>
</ul>
<p>PackageManager常用方法如下：</p>
<ul>
<li>getPackageManager：通过调用这个方法返回一个PackageManager对象。</li>
<li>getApplicationInfo：以ApplicationInfo的形式返回指定包名的ApplicationInfo。</li>
<li>getApplicationIcon：返回指定包名的Icon。</li>
<li>getInstallApplication：以ApplicationInfo的形式返回安装的应用。</li>
<li>getInstalledPackages：以PackageInfo的形式返回安装的应用。</li>
<li>queryIntentActivities：返回指定intent的ResolveInfo对象、Activity集合。</li>
<li>queryIntentServices：返回指定intent的ResolveInfo对象、Service集合。</li>
<li>resolveActivity：返回指定Intent的Activity。</li>
<li>resolveService：返回指定Intent的Service。</li>
</ul>
<p>判断App类型的依据，就是利用ApplicationInfo中的FLAG_SYSTEM来进行判断，代码如下所示：</p>
<pre><code>app.flags &amp; ApplicationInfo.FLAG_SYSTEM
</code></pre><ul>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM != 0</code>则为系统应用；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM &lt;= 0</code>则为第三方应用；</li>
<li>特殊的，当系统应用经过升级后，也将成为第三方应用：<code>flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP != 0</code>；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE != 0</code>则为安装在SDCard上的应用。</li>
</ul>
<h2 id="9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager"><a href="#9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager" class="headerlink" title="9.3 Android Apk应用信息获取之ActivityManager"></a>9.3 Android Apk应用信息获取之ActivityManager</h2><p>ActivityManager可以获得在运行的应用程序信息。其中封装的信息如下：</p>
<ul>
<li>ActivityManager.MemoryInfo：MemoryInfo有几个非常重要的字段，availMem–系统可用内存，totalMem–总内存，threshold–低内存的阈值，即区分是否低内存的临界值，lowMemory–是否处于低内存。</li>
<li>Debug.MemoryInfo：ActivityManager.MemoryInfo用于统计全局的内存信息，而Debug.MemoryInfo用于统计进程下的内存信息。</li>
<li>RunningAppProcessInfo：进程相关的信息，processName–进程名，pid–进程pid，uid–进程uid，pkgList–该进程下的所有包。</li>
<li>RunningServiceInfo：用于封装运行的服务信息，在它里面包含一些服务进程的信息，同时还有一些其他信息。activeSince–第一次被激活的时间、方式，foreground–服务是否在后台执行。</li>
</ul>
<h2 id="9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F"><a href="#9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F" class="headerlink" title="9.4 解析Packages.xml获取系统信息"></a>9.4 解析Packages.xml获取系统信息</h2><p>packages.xml在 data/system/目录下。</p>
<h2 id="9-5_Android_u5B89_u5168_u673A_u5236"><a href="#9-5_Android_u5B89_u5168_u673A_u5236" class="headerlink" title="9.5 Android安全机制"></a>9.5 Android安全机制</h2><p>反编译：</p>
<ul>
<li>apktool(反编译XML) ： <code>apktool_2.1.0.jar d test.apk</code></li>
<li>apktool(重新打包) ： <code>apktool_2.1.0.jar b test</code></li>
<li>Dex2jar、jd-gui ：<code>d2j-dex2jar.bat classes.dex</code></li>
</ul>
<p>Android Apk 加密：</p>
<p>打开build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能，proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><h1 id="u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十章：Android性能优化"></a>第十章：Android性能优化</h1><h2 id="10-1__u5E03_u5C40_u4F18_u5316"><a href="#10-1__u5E03_u5C40_u4F18_u5316" class="headerlink" title="10.1 布局优化"></a>10.1 布局优化</h2><ul>
<li><p>Android UI渲染机制</p>
<p>  在Android中，系统通过VSYNC信号出发对UI的渲染、重绘，其间隔时间是16ms。这个16ms其实就是1000ms中显示60帧画面的单位时间（玩游戏的就该知道，大于等于60帧就感觉不到卡顿）。Android系统提供了检测UI渲染时间的工具，打开“开发者选项”，选择“Profile GPU Rendering”（我的手机是“GPU呈现模式分析”），选中“On screen as bars”（我的为“在屏幕上显示为条形图”）。每一条柱状线都包括三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间，中间绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。</p>
</li>
<li><p>避免Overdraw</p>
<p>  过渡绘制会浪费很多CPU、GPU资源，例如系统默认会绘制Activity的背景，而如果再给布局绘制了重叠的背景，那么默认Activity的背景就属于无效的过渡绘制。Android系统在开发者选项中提供了这样一个检测工具–“Enable GPU Overdraw”。借助它可以判断Overdraw的次数。尽量增大蓝色的区域，减少红色的区域。</p>
</li>
<li><p>优化布局层级</p>
<p>  在Android中系统对View的测量、布局和绘制都是通过遍历View树来进行的，如果View树太高，就会影响其速度，Google也建议View树的高度不宜超过10层。</p>
</li>
<li><p>避免嵌套过多无用布局</p>
<ul>
<li>使用<include\>标签重用Layout</include\></li>
<li><p>使用<viewstub\>实现View的延迟加载</viewstub\></p>
<p><viewstub\>是个非常轻量级的组件，不仅不可视而且大小为0。这个布局在初始化时不需要显示，只有在某些情况下才显示出来。下面是实例代码：</viewstub\></p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;TextView
      android:id=&quot;@+id/tv&quot;
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:text=&quot;not often use&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>使用<viewstub\>：</viewstub\></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;ViewStub
      android:id=&quot;@+id/view_stub&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerInParent=&quot;true&quot;
      android:layout=&quot;@layout/test&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>在<code>onCreate(Bundle savedInstanceState)</code>中：</p>
<pre><code>ViewStub viewStub= (ViewStub) findViewById(R.id.view_stub);
//下面两个方法都是用来实现延迟加载的，区别是inflate()方法会返回引用的布局。
viewStub.setVisibility(View.VISIBLE); // 第一种方法

View view=viewStub.inflate(); // 第二种方法
TextView tv= (TextView) view.findViewById(R.id.tv);
</code></pre><p><viewstub\>标签与设置View.GONE这种方式的区别在于<viewstub\>标签只在显示时渲染整个布局，而设置View.GONE这种方式在初始化布局树时就已经添加在布局树上了，所以相比之下<viewstub>更有效率。</viewstub></viewstub\></viewstub\></p>
</li>
</ul>
</li>
<li><p>Hierarchy Viewer</p>
</li>
</ul>
<p>这是个用来测试布局冗余的工具。<a href="http://blog.csdn.net/xyz_lmn/article/details/14222975" target="_blank" rel="external">可点击此处</a></p>
<h2 id="10-2__u5185_u5B58_u4F18_u5316"><a href="#10-2__u5185_u5B58_u4F18_u5316" class="headerlink" title="10.2 内存优化"></a>10.2 内存优化</h2><ul>
<li><p>什么是内存</p>
<ul>
<li>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制。</li>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。</li>
<li>堆：堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器(GC)来管理。</li>
<li>静态存储区域：是指在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量。</li>
<li><p>常量池：就是该类型所用到常量的一个有序集合，包括直接常量（基本类型，String）和对其他类型、字段和方法的符号引用。</p>
<p>在程序中，可以使用如下所示的代码来获得堆的大小，所谓的内存分析，正是分析Heap中的内存状态</p>
<pre><code>ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)；
int heapSize = manager.getLargeMemoryClass();
</code></pre></li>
</ul>
</li>
<li><p>获取Android系统内存信息</p>
<ul>
<li><p>进程状态</p>
<pre><code>adb shell dumpsys procstats
</code></pre></li>
<li><p>内存信息</p>
<pre><code>adb shell dumpsys meminfo
</code></pre></li>
</ul>
</li>
<li><p>内存优化实例</p>
<ul>
<li><p>Bitmap优化</p>
<p>Bitmap是造成内存占用过高甚至是OOM的最大威胁，可以通过以下技巧进行优化</p>
<p>① 使用适当分辨率和大小的图片：例如在图片列表界面可以使用图片的缩略图thumbnails，而在显示详细图片的时候再显示原图；或者在对图像要求不高的地方，尽量降低图片的精度。</p>
<p>② 及时回收内存：一旦使用完Bitmap后，一定要及时使用bitmap.recycle()方法释放内存资源。自Android3.0后，由于Bitmap被放到了堆中，其内存由GC管理，就不需要释放了。</p>
<p>③ 通过内存缓存LruCache和DiskLruCache可以更好地使用Bitmap。</p>
</li>
<li><p>代码优化</p>
<p>任何Java类都将占用大约500字节的内存空间，创建一个类的实例会消耗大约15字节内存。从代码的实现上，也可以对内存进行优化。</p>
<p>① 对常量使用static修饰符。</p>
<p>② 使用静态方法，静态方法会比普通方法提高15%左右的访问速度。</p>
<p>③ 减少不必要的成员变量，这点在Android Lint工具上已经集成检测了。</p>
<p>④ 减少不必要对象，使用基础类型会比使用对象更加节省资源，同时更应该避免频繁创建短作用域的变量。</p>
<p>⑤ 尽量不要使用枚举、少用迭代器。</p>
<p>⑥ 对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收和注册、反注册。</p>
<p>⑦ 避免使用IOC框架，IOC通常使用注解、反射来进行实现，大量使用反射会带来性能的下降。</p>
<p>⑧ 使用RenderScript、OpenGL来进行非常复杂的绘图操作。</p>
<p>⑨ 使用SurfaceView来代替View进行大量、频繁的绘图操作。</p>
<p>⑩ 尽量使用视图缓存，而不是每次都执行inflate()解析视图。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-3_Lint_u5DE5_u5177"><a href="#10-3_Lint_u5DE5_u5177" class="headerlink" title="10.3 Lint工具"></a>10.3 Lint工具</h2><h2 id="10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177"><a href="#10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177" class="headerlink" title="10.4 使用Android Studio的Memory Monitor工具"></a>10.4 使用Android Studio的Memory Monitor工具</h2><h2 id="10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD"><a href="#10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD" class="headerlink" title="10.5 使用TraceView工具优化App性能"></a>10.5 使用TraceView工具优化App性能</h2><h2 id="10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001"><a href="#10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001" class="headerlink" title="10.6 使用MAT工具分析App内存状态"></a>10.6 使用MAT工具分析App内存状态</h2><h2 id="10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001"><a href="#10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001" class="headerlink" title="10.7 使用Dumpsys命令分析系统状态"></a>10.7 使用Dumpsys命令分析系统状态</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现WebView中JS和App之间的交互]]></title>
    <link href="http://yuqirong.me/2016/03/07/%E5%AE%9E%E7%8E%B0WebView%E4%B8%ADJS%E5%92%8CApp%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yuqirong.me/2016/03/07/实现WebView中JS和App之间的交互/</id>
    <published>2016-03-07T11:53:12.000Z</published>
    <updated>2016-03-07T15:04:30.507Z</updated>
    <content type="html"><![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img src="/uploads/20160307/20160307200816.png" alt="这里写图片的描述"></p>
<p>之后在脑海中回想到 WebView 中的JS可以和app产生交互，于是搜索了一下，果然网上有类似的实现效果。看了一下，在这里就做一个简单的笔记了以便之后查看。</p>
<p>在 WebView 中想要JS和app产生交互，就不得不提一个方法，那就是<code>addJavascriptInterface(Object object, String name)</code>：</p>
<ul>
<li>第一个参数：绑定到 JavaScript 的类实例。</li>
<li>第二个参数：用来显示 JavaScript 中的实例的名称。</li>
</ul>
<p>这里只是给出了参数的解释，如果你没看懂，那接下来就告诉你答案。</p>
<p>那就开始吧，在创建新的 project 之前，我们先把要加载的 test.html 写好，放在 assets 目录下：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebView Test&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
        function btnShowToast(){
            window.testJS.showToast();
        }

        function btnGoActivity(){
            window.testJS.goActivity();
        }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;This is a website&lt;/p&gt;
        &lt;br&gt;
        &lt;button onclick=&apos;btnShowToast();&apos;&gt;show Toast&lt;/button&gt;
        &lt;button onclick=&apos;btnGoActivity();&apos;&gt;go Activity&lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>上面的 html 很简单，相信有点基础的同学都能看得懂。要注意的是在JS函数中的 testJS 是要和 WebView 约定好的，这里就取名叫 testJS 吧，在下面会用到。还有<code>showToast()</code>和<code>goActivity()</code>也是约定好的函数名。我们预期的效果是点击 show Toast 按钮会显示Toast，而点击 go Activity 按钮会跳转到另外一个 Activity 上。</p>
<p>下面创建了一个 project ，名叫 WebViewDemo ，工程中 MainActivity 的 layout.xml 就只有一个 WebView 了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.yuqirong.webviewdemo.MainActivity&quot;&gt;

    &lt;WebView
        android:id=&quot;@+id/mWebView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>MainActivity 的代码很短，就直接贴出来了：</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mWebView = (WebView) findViewById(R.id.mWebView);
        // 设置支持JS
        mWebView.getSettings().setJavaScriptEnabled(true);
        // 增加JS交互的接口
        mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);
        mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                return false;
            }
        });
        String url = &quot;file:///android_asset/test.html&quot;;
        mWebView.loadUrl(url);
    }
}
</code></pre><p>我们可以看到，如果想要和JS交互，那么<code>mWebView.getSettings().setJavaScriptEnabled(true);</code>这句是必不可少的，再看到下面一行代码：<code>mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);</code>，这里注意一下第二个参数，没错，就是在 html 中的 testJS ！</p>
<p>再看回第一个参数，发现 new 了一个 AndroidJSInterface 类，下面就是 AndroidJSInterface 的代码：</p>
<pre><code>public class AndroidJSInterface {

    private Context context;

    public AndroidJSInterface(Context context) {
        this.context = context;
    }

    @JavascriptInterface
    public void goActivity() {
        context.startActivity(new Intent(context, SecondActivity.class));
    }

    @JavascriptInterface
    public void showToast() {
        Toast.makeText(context, &quot;hello js&quot;, Toast.LENGTH_SHORT).show();
    }

}
</code></pre><p>我们可以看到上面的<code>showToast()</code>和<code>goActivity()</code>方法名和 html 里面的一定要一样，不然无法触发了。然后在方法的内部实现你想要的逻辑。</p>
<p>经过上面的步骤，就可以实现和JS交互了，一起来看看效果吧：</p>
<p><img src="/uploads/20160307/20160307225743.gif" alt="这里写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160307/WebViewDemo.rar">WebViewDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="WebView" scheme="http://yuqirong.me/tags/WebView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/02/28/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/02/28/《Android群英传》笔记(上)/</id>
    <published>2016-02-28T12:20:04.000Z</published>
    <updated>2016-03-31T06:28:41.641Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3" class="headerlink" title="第三章：Android控件架构与自定义控件详解"></a>第三章：Android控件架构与自定义控件详解</h1><h2 id="3-1_Android_u63A7_u4EF6_u67B6_u6784"><a href="#3-1_Android_u63A7_u4EF6_u67B6_u6784" class="headerlink" title="3.1 Android控件架构"></a>3.1 Android控件架构</h2><p>控件分为两类：View和ViewGroup，通过ViewGroup整个界面形成一个树形结构，并且ViewGroup负责对子View的测量与绘制以及传递交互事件。通常在Activity中使用的findViewById()方法，就是在控件树中以树的深度优先遍历来查找对应元素。在每颗控件树的顶部，都有一个ViewParent对象，这就是整棵树的控制核心，所有的交互管理事件都由它来统一调度和分配。</p>
<p><img src="/uploads/20160228/20160228230641.png" alt="这里写图片描述"></p>
<p>如上图所示，每个Activity都包含一个Window对象，在Android中Window对象通常由PhoneWindow来实现。PhoneWindow对象又将一个DecorView设置为整个应用的根View。DecorView作为了窗口界面的顶层视图，封装了一些窗口操作的通用方法。可以说，DecorView将要显示的具体内容呈现在了PhoneWindow上，这里所有View的监听事件，都通过WindowManagerService来接收，并通过Activity对象来回调onClickListener。DecorView在显示上分为TitleView和ContentView两部分。ContentView是一个ID为content的FrameLayout，activity_main.xml就是设置在这样一个FrameLayout里。可以通过如下代码获得ContentView：</p>
<pre><code>FrameLayout content = (FrameLayout)findViewById(android.R.id.content);
</code></pre><p><img src="/uploads/20160228/20160228232837.png" alt="这里写图片描述"></p>
<p>而在代码中，当程序在onCreate()方法中调用setContentView()方法后，ActivityManagerService会回调onResume()方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p>
<h2 id="3-2_View_u7684_u6D4B_u91CF"><a href="#3-2_View_u7684_u6D4B_u91CF" class="headerlink" title="3.2 View的测量"></a>3.2 View的测量</h2><p>View的测量在onMeasure中进行，系统提供了MeasureSpec类，是一个32位的int值，其高2位为测量模式，低30位为测量的大小。测量模式有以下三种：</p>
<ul>
<li><p>EXACTLY：精确模式，当控件指定精确值（例如android:layout_width=”50dp”）或者指定为match_parent属性时系统使用该模式。</p>
</li>
<li><p>AT_MOST：最大值模式，指定wrap_content时系统使用该属性。控件大小一般随着控件的子空间或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。View类默认只支持EXACTLY，如果想使用wrap_content需自己在onMeasure中实现。</p>
</li>
<li><p>UNSPECIFIED：自定义模式，View想多大就多大，通常在绘制自定义View的时候才使用。</p>
</li>
</ul>
<p>下面是onMeasure的示例代码：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);// 获取宽度模式
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);// 获取宽度值
    int width = 0;
    if (widthMode == MeasureSpec.EXACTLY) {
        width = widthSize;
    } else {
        width = 200;// 自定义的默认wrap_content值
        if (widthMode == MeasureSpec.AT_MOST) {
                width = Math.min(widthSize, width);
        }

    }
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);// 获取高度模式
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);// 获取高度值
    int height = 0;
    if (heightMode == MeasureSpec.EXACTLY) {
        height = heightSize;
    } else {
        height = 200;// 自定义的默认wrap_content值
        if (heightMode == MeasureSpec.AT_MOST) {
            height = Math.min(heightSize, height);
        }
    }
    setMeasuredDimension(width, height);// 最终将测量的值传入该方法完成测量
}
</code></pre><h2 id="3-3_View_u7684_u7ED8_u5236"><a href="#3-3_View_u7684_u7ED8_u5236" class="headerlink" title="3.3 View的绘制"></a>3.3 View的绘制</h2><p>View的绘制是通过onDraw()方法实现的，具体是通过对onDraw()方法中Canvas参数操作执行绘图。在其他地方，则需要自己创建Canvas对象，创建时需传入一个bitmap对象，这个过程我们称之为装载画布。bitmap是用来存储所有绘制在Canvas上的像素信息，当你通过这种方式创建了Canvas对象后，后面调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p>
<h2 id="3-4_ViewGroup_u7684_u6D4B_u91CF"><a href="#3-4_ViewGroup_u7684_u6D4B_u91CF" class="headerlink" title="3.4 ViewGroup的测量"></a>3.4 ViewGroup的测量</h2><p>当ViewGroup的大小为wrap_content时，它就会遍历所有子View，以便获得所有子View的大小，从而来决定自身的大小，而在其他模式下则通过指定值来设置自身的大小。</p>
<p>然后当子View测量完毕以后，ViewGroup会执行它的Layout方法，同样是遍历子View并调用其Layout方法来确定布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout()方法来控制子View显示位置，若需支持wrap_content还需重写onMeasure()方法，这点与View是相同的。</p>
<h2 id="3-5_ViewGroup_u7684_u7ED8_u5236"><a href="#3-5_ViewGroup_u7684_u7ED8_u5236" class="headerlink" title="3.5 ViewGroup的绘制"></a>3.5 ViewGroup的绘制</h2><p>ViewGroup通常情况下不需要绘制，如果不是指定了ViewGroup的背景颜色，那么ViewGroup的onDraw()方法都不会被调用。但是ViewGroup会调用dispatchDraw()方法来绘制其子View，过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
<h2 id="3-6__u81EA_u5B9A_u4E49View"><a href="#3-6__u81EA_u5B9A_u4E49View" class="headerlink" title="3.6 自定义View"></a>3.6 自定义View</h2><p>自定义View时有一些比较重要的回调方法如下：</p>
<ul>
<li>onFinishInflate();//从xml加载组件后回调</li>
<li>onSizeChanged();//组件大小改变时回调</li>
<li>onMeasure();//回调该方法进行测量</li>
<li>onLayout();//回调该方法来确定显示的位置</li>
<li>onTouchEvent();//监听到触摸事件回调</li>
</ul>
<p>通常情况下，有以下三种方法来实现自定义的控件：</p>
<ul>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写View来实现全新的控件</li>
</ul>
<p>PS ： LinearGradient也称作线性渲染，LinearGradient的作用是实现某一区域内颜色的线性渐变效果。构造函数有两个，分别如下：</p>
<p><code>public LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标　；color0表示渐变开始颜色；color1表示渐变结束颜色；参数tile表示平铺方式。</p>
<p>Shader.TileMode有3种参数可供选择，分别为CLAMP、REPEAT和MIRROR：</p>
<ul>
<li><p>CLAMP的作用是如果渲染器超出原始边界范围，则会复制边缘颜色对超出范围的区域进行着色</p>
</li>
<li><p>REPEAT的作用是在横向和纵向上以平铺的形式重复渲染位图</p>
</li>
<li><p>MIRROR的作用是在横向和纵向上以镜像的方式重复渲染位图</p>
</li>
</ul>
<p><code>public LinearGradient (float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标；参数colors表示渐变的颜色数组；参数positions用来定义每个颜色处于的渐变相对位置；参数tile表示平铺方式。通常，参数positions设为null，表示颜色数组按顺序均匀的分布。</p>
<h2 id="3-7__u81EA_u5B9A_u4E49ViewGroup"><a href="#3-7__u81EA_u5B9A_u4E49ViewGroup" class="headerlink" title="3.7 自定义ViewGroup"></a>3.7 自定义ViewGroup</h2><p>自定义ViewGroup通常需要重写onMeasure()方法来对子View进行测量，重写onLayout()方法来确定子View的位置，重写onTouchEvent()方法增加响应事件。</p>
<p><code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int count = getChildCount();
    for (int i = 0; i &lt; count; i++) {
        measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><h2 id="3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790"><a href="#3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790" class="headerlink" title="3.8 事件拦截机制分析"></a>3.8 事件拦截机制分析</h2><p>本章较为浅显的分析了下事件传递的机制。当ViewGroup接收到事件，通过调用dispatchTouchEvent()，由这个方法再调用onInterceptTouchEvent()方法来判断是否要拦截事件，如果返回true则拦截将事件交给自己的onTouchEvent处理，返回false则继续向下传递。当View在接受到事件时，通过调用dispatchTouchEvent()，由此方法再调用onTouchEvent方法，如果返回true则拦截事件自己处理，如果返回false则将事件向上传递回ViewGroup并且调用其onTouchEvent方法继续做判断。</p>
<h1 id="u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第四章：ListView使用技巧"></a>第四章：ListView使用技巧</h1><h2 id="4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7"><a href="#4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7" class="headerlink" title="4.1 ListView常用优化技巧"></a>4.1 ListView常用优化技巧</h2><ul>
<li>使用ViewHolder模式提高效率</li>
<li><p>设置项目间分隔线：</p>
<pre><code>android:divider=&quot;@android:color/darker_gray&quot;
android:dividerHeight=&quot;10dp&quot;
</code></pre><p>   特殊情况下，以下代码可以设置分割线为透明：</p>
<pre><code>android:divider=&quot;@null&quot;
</code></pre></li>
<li><p>隐藏ListView的滚动条：</p>
<pre><code>android:scrollbars=&quot;none&quot;
</code></pre></li>
<li><p>取消ListView的点击效果：</p>
<pre><code>android:listSelector=&quot;#00000000&quot;
</code></pre><p>  也可以用Android自带的透明色来实现这个效果：</p>
<pre><code>android:listSelector=&quot;@android:color/transparent&quot;
</code></pre></li>
<li><p>设置ListView需要显示在第几项：</p>
<pre><code>listView.setSelection(N);
</code></pre><p>  其中N就是需要显示的第N个Item。</p>
<p>  除此之外，还可以使用如下代码来实现平滑移动：</p>
<pre><code>mListView.smoothScrollBy(distance,duration);
mListView.smoothScrollByOffset(offset);
mListView.smoothScrollToPosition(index);
</code></pre></li>
<li><p>动态修改ListView：</p>
<pre><code>mAdapter.notifyDataSetChanged();
</code></pre></li>
<li><p>遍历ListView中的所有Item：</p>
<pre><code>for(int i=0;i&lt;mListView.getChildCount();i++){
    View view = mListView.getChildAt(i);
}
</code></pre></li>
<li><p>处理空ListView：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;ListView
    android:id=&quot;@+id/listView&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;ImageView
        android:id=&quot;@+id/imageView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:src=&quot;@drawable/empty_view&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>  在代码中，我们通过以下方式给ListView设置空数据时要显示的布局，代码如下：</p>
<pre><code>ListView listView = (ListView)findViewById(R.id.listView);
listView.setEmptyView(findViewById(R.id.imageView));
</code></pre></li>
<li><p>ListView滑动监听：一种是通过OnTouchListener来实现监听，另外一种是使用OnScrollListener来实现监听。</p>
<p>  OnScrollListener中有两个回调方法——onScrollStateChanged()和onScroll()</p>
<pre><code> @Override
public void onScrollStateChanged(AbsListView view, int scrollState) {
    switch(scrollState){
        case SCROLL_STATE_FLING:
          // TODO    
        break;
        case SCROLL_STATE_IDLE:
        // TODO 
        break;
        case SCROLL_STATE_TOUCH_SCROLL:
        // TODO 
        break;
    }
}
</code></pre><p>  scrollState有以下三种模式：</p>
<ul>
<li>OnScrollListener.SCROLL_STATE_IDLE ： 滚动停止时；</li>
<li>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL ： 正在滚动时；</li>
<li><p>OnScrollListener.SCROLL_STATE_FLING ： 手指抛动时，即手指用力滑动，在离开后ListView由于惯性继续滑动的状态；</p>
<p>当手指没有做手指抛动的状态时，这个方法只会回调2次，否则会回调3次。</p>
<pre><code>@Override
public void onScroll(AbsListView view, int firstVisibleItem,
        int visibleItemCount, int totalItemCount) {
    // TODO Auto-generated method stub
}
</code></pre></li>
<li><p>firstVisibleItem ： 当前能看见的第一个Item的ID（从0开始）</p>
</li>
<li><p>visibleItemCount ： 当前能看见的Item的总数</p>
</li>
<li><p>totalItemCount ： 整个ListView的Item总数</p>
<p>判断是否滚动到最后一行：</p>
<pre><code>if(firstVisibleItem + visibleItemCount == totalItemCount &amp;&amp; totalItemCount &gt; 0){
    // 滚动到最后一行
} 
</code></pre><p>再比如，可以通过如下代码来判断滚动的方向：</p>
<pre><code>if(firstVisibleItem &gt; lastVisibleItemPosition){
    // 上滑
}else if(firstVisibleItem &lt; lastVisibleItemPosition){
    // 下滑
}
lastVisibleItemPosition = firstVisibleItem;
</code></pre><p>当然，ListView也给我们提供了一些封装的方法来获得当前可视的Item的位置等信息：</p>
<pre><code>// 获取可视区域内最后一个Item的id
mListView.getLastVisiblePosition()；
// 获取可视区域内第一个Item的id
mListView。getFirstVisiblePosition();
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="4-2_ListView_u5E38_u7528_u62D3_u5C55"><a href="#4-2_ListView_u5E38_u7528_u62D3_u5C55" class="headerlink" title="4.2 ListView常用拓展"></a>4.2 ListView常用拓展</h2><ol>
<li><p>具有弹性的ListView：</p>
<pre><code>@Override
protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
    return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
}
</code></pre><p> 其中的maxOverScrollY，默认值为0。所以只要修改它的值，就可以让ListView具有弹性了。</p>
</li>
</ol>
<h1 id="u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790"><a href="#u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790" class="headerlink" title="第五章：Android Scroll分析"></a>第五章：Android Scroll分析</h1><h2 id="5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684"><a href="#5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684" class="headerlink" title="5.1 滑动效果是如何产生的"></a>5.1 滑动效果是如何产生的</h2><p>滑动一个View，本质上来说就是移动一个View。改变其当前所处的位置，它的原理与动画效果的实现非常相似，都是通过不断地改变View的坐标来实现这一效果。所以，要实现View的滑动，就必须监听用户触摸的事件，并根据事件传入的坐标，动态且不断地改变View的坐标，从而实现View跟随用户触摸的滑动而滑动。</p>
<p><strong>Android坐标系</strong></p>
<p>Android的坐标系是以屏幕最左上角为顶点，向右为x轴正方向，向下是y轴正方向。在触控事件中通过<code>getRawX()</code>和<code>getRawY()</code>获取Android坐标系中的坐标。在View中通过<code>getLocationOnScreen(int[] location)</code>获取。</p>
<p><strong>视图坐标系</strong></p>
<p>描述的是子视图在父视图中的位置关系，原点为父视图的左上角，x、y轴方向与Android坐标系一致。触控事件中通过<code>getX()</code>,<code>getY()</code>获取视图坐标系的坐标。</p>
<p><strong>触控事件——MotionEvent</strong></p>
<pre><code>// 单点触摸按下动作
public static final int MotionEvent.ACTION_DOWN = 0;
// 单点触摸离开动作
public static final int MotionEvent.ACTION_UP = 1;
// 触摸点移动动作
public static final int MotionEvent.ACTION_MOVE = 2;
// 触摸动作取消
public static final int MotionEvent.ACTION_CANCEL = 3;
// 触摸动作超出边界
public static final int MotionEvent.ACTION_OUTSIDE = 4;
// 多点触摸按下动作
public static final int MotionEvent.ACTION_POINTER_DOWN = 5;
// 多点离开动作
public static final int MotionEvent.ACTION_POINTER_UP = 6;
</code></pre><p><strong>View提供的获取坐标方法</strong></p>
<ul>
<li>getTop()：获取到的是View自身的顶边到其父布局顶边的距离</li>
<li>getLeft()：获取到的是View自身的左边到其父布局左边的距离</li>
<li>getRight()：获取到的是View自身的右边到其父布局右边的距离</li>
<li>getBottom()：获取到的是View自身的底边到其父布局底边的距离</li>
</ul>
<p><strong>MotionEvent提供的方法</strong></p>
<ul>
<li>getX()：获取点击事件距离控件左边的距离，即视图坐标</li>
<li>getY()：获取点击事件距离控件顶边的距离，即视图坐标</li>
<li>getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标</li>
<li>getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标</li>
</ul>
<h2 id="5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5"><a href="#5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5" class="headerlink" title="5.2 实现滑动的七种方法"></a>5.2 实现滑动的七种方法</h2><ul>
<li><p>layout()方法</p>
<pre><code>private int lastX;
private int lastY;
private int offsetX;
private int offsetY;

@Override
public boolean onTouchEvent(MotionEvent event) {
  int x = (int) event.getRawX();
  int y = (int) event.getRawY();

  switch (event.getAction()) {
  case MotionEvent.ACTION_DOWN:
      lastX = x;
      lastY = y;
      break;
  case MotionEvent.ACTION_MOVE:
      offsetX = x - lastX;
      offsetY = y - lastY;

      layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY);

      lastX = x;
      lastY = y;
      break;
  }
  return true;
}
</code></pre></li>
<li><p>offsetLeftAndRight()与offsetTopAndBottom()</p>
<pre><code>// 同时对left和right进行偏移
offsetLeftAndRight(offsetX);
// 同时对top和bottom进行偏移
offsetTopAndBottom(offsetY);
</code></pre></li>
<li><p>LayoutParams</p>
<pre><code>LinearLayout.MarginLayoutParams layoutParams=(LinearLayout.LayoutParams)getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre><p>  或者</p>
<pre><code>ViewGroup.MarginLayoutParams layoutParams=(MarginLayoutParams) getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre></li>
<li><p>scrollTo()和scrollBy()</p>
<pre><code>//scrollTo和scrollBy移动的是view的内容而不是view本身
//如果在viewgroup中使用就是移动所有子view。
View view=(View) getParent();
//scrollTo和scrollBy参考的坐标系正好与视图坐标系相反，所以offset需为负
view.scrollBy(-offsetX, -offsetY);
</code></pre></li>
<li><p>Scroller</p>
<p>  scrollTo()和scrollBy()都是使View的平移瞬间发生的，这样的效果会让人感觉很突兀，而Scroller可以实现平滑移动的效果，而不是瞬间完成的移动。</p>
<p>  使用Scroller主要有三个步骤：</p>
<ol>
<li><p>初始化Scroller对象，一般在view初始化的时候同时初始化scroller，代码如下：<br><code>mScroller=new Scroller(context);</code></p>
</li>
<li><p>重写view的computeScroll()方法，实现模拟滑动。computeScroll()的模版代码如下：</p>
<pre><code>@Override
public void computeScroll() {
  super.computeScroll();
  // 判断Scroller是否执行完毕
  if (mScroller.computeScrollOffset()) {
      ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
      // 通过重绘来不断调用computeScroll
      invalidate();
  }
}
</code></pre><p> Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动，同时也提供了getCurrX()和getCurrY()方法来获得当前的滑动坐标。computeScroll()方法是不会自动调用的，只能通过invalidate()-&gt;draw()-&gt;computeScroll()来间接调用，实现循环获取scrollX和scrollY的目的，当移动过程结束之后，Scroller.computeScrollOffset方法会返回false，从而中断循环,完成整个平滑移动过程；</p>
</li>
<li><p>startScroll开启模拟过程。调用Scroller.startScroll()方法，将起始位置、偏移量以及移动时间(可选)作为参数传递给startScroll()方法。在获取坐标时，通常可以使用getScrollX()和getScrollY()方法来获取父视图中content所滑动到的点的坐标，不过要注意的是这个值的正负，它与在scrollBy()、scrollTo()中讲解是一样的。另外，在startScroll()之后，还要invalidate()方法来通知View进行重绘，从而来调用computeScroll()的模拟过程。当然，可以给startScroll()方法增加一个duration的参数来设置滑动的持续时长。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>属性动画</p>
</li>
<li><p>ViewDragHelper</p>
<p>  ViewDragHelper基本可以实现各种不同滑动需求，但使用稍微复杂。</p>
<p>  示例代码：</p>
<pre><code>public class DragViewGroup extends FrameLayout {

  private ViewDragHelper mViewDragHelper;
  private View mMenuView, mMainView;
  private int mWidth;

  public DragViewGroup(Context context) {
      super(context);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs) {
      super(context, attrs);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      initView();
  }

  @Override
  protected void onFinishInflate() {
      super.onFinishInflate();
      mMenuView = getChildAt(0);
      mMainView = getChildAt(1);
  }

  @Override
  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
      super.onSizeChanged(w, h, oldw, oldh);
      mWidth = mMenuView.getMeasuredWidth();
  }

  @Override
  public boolean onInterceptTouchEvent(MotionEvent ev) {
      return mViewDragHelper.shouldInterceptTouchEvent(ev);
  }

  @Override
  public boolean onTouchEvent(MotionEvent event) {
      //将触摸事件传递给ViewDragHelper,此操作必不可少
      mViewDragHelper.processTouchEvent(event);
      return true;
  }

  private void initView() {
      mViewDragHelper = ViewDragHelper.create(this, callback);
  }

  private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {

      // 何时开始检测触摸事件
      @Override
      public boolean tryCaptureView(View child, int pointerId) {
          //如果当前触摸的child是mMainView时开始检测
          return mMainView == child;
      }

      // 触摸到View后回调
      @Override
      public void onViewCaptured(View capturedChild, int activePointerId) {
          super.onViewCaptured(capturedChild, activePointerId);
      }

      // 当拖拽状态改变，比如idle，dragging
      @Override
      public void onViewDragStateChanged(int state) {
          super.onViewDragStateChanged(state);
      }

      // 当位置改变的时候调用,常用与滑动时更改scale等
      @Override
      public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
          super.onViewPositionChanged(changedView, left, top, dx, dy);
      }

      // 处理垂直滑动
      @Override
      public int clampViewPositionVertical(View child, int top, int dy) {
          return 0;
      }

      // 处理水平滑动
      @Override
      public int clampViewPositionHorizontal(View child, int left, int dx) {
          return left;
      }

      // 拖动结束后调用
      @Override
      public void onViewReleased(View releasedChild, float xvel, float yvel) {
          super.onViewReleased(releasedChild, xvel, yvel);
          //手指抬起后缓慢移动到指定位置
          if (mMainView.getLeft() &lt; 500) {
              //关闭菜单，相当于Scroller的startScroll方法
              mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          } else {
              //打开菜单
              mViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          }
      }
  };

  @Override
  public void computeScroll() {
      if (mViewDragHelper.continueSettling(true)) {
          ViewCompat.postInvalidateOnAnimation(this);
      }
  }
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用RecyclerView实现仿喵街效果]]></title>
    <link href="http://yuqirong.me/2016/02/26/%E4%BD%BF%E7%94%A8RecyclerView%E5%AE%9E%E7%8E%B0%E4%BB%BF%E5%96%B5%E8%A1%97%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/02/26/使用RecyclerView实现仿喵街效果/</id>
    <published>2016-02-26T11:50:18.000Z</published>
    <updated>2016-03-05T09:45:43.291Z</updated>
    <content type="html"><![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></p>
<p>值得一提的是，这是旧版本的特效，新版本的喵街已经去掉了这种效果。</p>
<p>看完了效果，接下来就是动手的时间了。</p>
<p>我们先来分析一下思路：我们先给RecyclerView添加一个OnScrollListener，然后分别去获得firstVisiblePosition和firstCompletelyVisiblePosition。这里要注意一下，firstVisiblePosition是第一个在屏幕中<strong>可见</strong>的itemView对应的position，而firstCompletelyVisiblePosition是是第一个在屏幕中<strong>完全可见</strong>的itemView对应的position。之后在滚动中去动态地设置itemView的高度。整体的思路就这样了，下面我们直接来看代码。</p>
<p>创建几个自定义的属性，以便后面备用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ExpandRecyclerView&quot;&gt;
        &lt;!-- item最大的高度 --&gt;
        &lt;attr name=&quot;max_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- item普通的高度 --&gt;
        &lt;attr name=&quot;normal_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们新建一个类继承自RecyclerView，类名就叫ExpandRecyclerView。</p>
<pre><code>//最大item的高度
private float maxItemHeight;
//普通item的高度
private float normalItemHeight;
// 默认最大的item高度
private float defaultMaxItemHeight;
// 默认普通的item高度
private float defaultNormalItemHeight;

public ExpandRecyclerView(Context context) {
    this(context, null);
}

public ExpandRecyclerView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public ExpandRecyclerView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ExpandRecyclerView);
    defaultMaxItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 256, context.getResources().getDisplayMetrics());
    defaultNormalItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 120, context.getResources().getDisplayMetrics());
    maxItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_max_item_height, defaultMaxItemHeight);
    normalItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_normal_item_height, defaultNormalItemHeight);
    a.recycle();

    setHasFixedSize(true);
    setLayoutManager(new LinearLayoutManager(context));
    setItemAnimator(new DefaultItemAnimator());
    this.addOnScrollListener(listener);
}
</code></pre><p>在构造器中我们得到了<code>maxItemHeight</code>和<code>normalItemHeight</code>，之后设置了OnScrollListener。</p>
<pre><code>OnScrollListener listener = new RecyclerView.OnScrollListener() {

    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        Log.i(TAG,&quot;dy : &quot; + dy);
        LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
        // 在屏幕中第一个可见的position
        int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();
        // 得到第一个可见的ViewHolder
        RecyclerView.ViewHolder firstVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstVisiblePosition);
        // 在屏幕中第一个完全可见的position
        int firstCompletelyVisiblePosition = mLinearLayoutManager.findFirstCompletelyVisibleItemPosition();
        // 得到第一个完全可见的ViewHolder
        RecyclerView.ViewHolder firstCompletelyVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstCompletelyVisiblePosition);

        Log.i(TAG, &quot;firstVisiblePosition : &quot; + firstVisiblePosition + &quot; , firstCompletelyVisiblePosition : &quot; + firstCompletelyVisiblePosition);
        // 当firstVisibleViewHolder被滑出屏幕时
        if (firstVisibleViewHolder.itemView.getLayoutParams().height - dy &lt; maxItemHeight
                &amp;&amp; firstVisibleViewHolder.itemView.getLayoutParams().height - dy &gt;= normalItemHeight) {
            // 高度减小
            firstVisibleViewHolder.itemView.getLayoutParams().height -= dy;
            firstVisibleViewHolder.itemView.setLayoutParams(firstVisibleViewHolder.itemView.getLayoutParams());
        }
        // 当firstCompletelyVisibleViewHolder慢慢滑到屏幕顶部时
        if (firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &lt;= maxItemHeight
                &amp;&amp; firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &gt;= normalItemHeight) {
            // 高度增加
            firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height += dy;
            firstCompletelyVisibleViewHolder.itemView.setLayoutParams(firstCompletelyVisibleViewHolder.itemView.getLayoutParams());
        }

    }

};
</code></pre><p>在<code>onScrolled(RecyclerView recyclerView, int dx, int dy)</code>里大部分的代码都加上注释了，就是根据<code>dy</code>去动态地改变了<code>firstVisibleViewHolder</code>和<code>firstCompletelyVisibleViewHolder</code>的高度。</p>
<p>上面的搞定了之后，别忘了要在Adapter里去初始化设置Item的高度。</p>
<pre><code>/**
 * 设置适配器
 *
 * @param adapter
 */
@Override
public void setAdapter(Adapter adapter) {
    super.setAdapter(adapter);
    if (adapter instanceof ExpandRecyclerViewAdapter) {
        ExpandRecyclerViewAdapter mAdapter = (ExpandRecyclerViewAdapter) adapter;
        //设置最大的item高度
        mAdapter.setMaxItemHeight(maxItemHeight);
        //设置普通的item高度
        mAdapter.setNormalItemHeight(normalItemHeight);
    }
}
</code></pre><p>ExpandRecyclerViewAdapter的代码，重写<code>onBindViewHolder(RecyclerView.ViewHolder holder, int position)</code>：</p>
<pre><code>@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if(position == 0){
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) maxItemHeight));
        }else{
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) normalItemHeight));
        }
        bindCustomViewHolder(holder, position);
}

public abstract void bindCustomViewHolder(RecyclerView.ViewHolder holder, int position);
</code></pre><p>好了，整体的代码就这些了，下面贴出运行效果：</p>
<p><img src="/uploads/20160226/20160226210235.gif" alt="这里写图片描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160226/ExpandRecyclerView.rar">ExpandRecyclerView.rar</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.jianshu.com/p/a2c3c21e3b99" target="_blank" rel="external">android版高仿喵街主页滑动效果</a></p>
<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><ul>
<li><a href="https://github.com/dongjunkun/miaojiedemo" target="_blank" rel="external">miaojiedemo</a> created by <a href="https://github.com/dongjunkun" target="_blank" rel="external">dongjunkun</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[九大基本排序算法]]></title>
    <link href="http://yuqirong.me/2016/02/18/%E4%B9%9D%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yuqirong.me/2016/02/18/九大基本排序算法/</id>
    <published>2016-02-18T13:56:06.000Z</published>
    <updated>2016-03-23T08:13:50.130Z</updated>
    <content type="html"><![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O(N),最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] bubbleSort(int[] A, int n) {
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (A[j] &gt; A[j + 1]) {
                temp = A[j + 1];
                A[j + 1] = A[j];
                A[j] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u9009_u62E9_u6392_u5E8F"><a href="#u9009_u62E9_u6392_u5E8F" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序时间复杂度 O(N^2)，最坏的情况O(N^2);空间复杂度O(1)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] selectionSort(int[] A, int n) {
    int minPos = 0;
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (A[j] &lt; A[minPos]) {
                minPos = j;
            }
        }
        temp = A[minPos];
        A[minPos] = A[i];
        A[i] = temp;
        minPos = i + 1;
    }
    return A;
}
</code></pre><h1 id="u63D2_u5165_u6392_u5E8F"><a href="#u63D2_u5165_u6392_u5E8F" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的平均复杂度是O(N^2)，最好的情况O(N)，最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] insertionSort(int[] A, int n) {
    int temp;
    for (int i = 2; i &lt; n; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (A[i] &lt; A[j]) {
                temp = A[j];
                A[j] = A[i];
                A[i] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u5F52_u5E76_u6392_u5E8F"><a href="#u5F52_u5E76_u6392_u5E8F" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序时间复杂度O(N*logN),最好的情况O(N*logN)，最坏的情况O(N*logN)；空间复杂度O(N)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] mergeSort(int[] A, int n) {
    if (n &gt; 1) {
        int k = n / 2;
        int[] temp1 = new int[k];
        int[] temp2 = new int[n - k];

        for (int i = 0; i &lt; k; i++) {
            temp1[i] = A[i];
        }
        for (int i = k; i &lt; n; i++) {
            temp2[i - k] = A[i];
        }
        temp1 = mergeSort(temp1, k);
        temp2 = mergeSort(temp2, n - k);

        int i = 0;
        int j = 0;
        int x = 0;
        int[] temp = new int[n];

        while (i &lt; k &amp;&amp; j &lt; n - k) {
            if (temp1[i] &lt;= temp2[j]) {
                temp[x] = temp1[i];
                x++;
                i++;
            } else {
                temp[x] = temp2[j];
                x++;
                j++;
            }
        }

        while (i &lt; k) {
            temp[x] = temp1[i];
            x++;
            i++;
        }

        while (j &lt; n - k) {
            temp[x] = temp2[j];
            x++;
            j++;
        }
        return temp;
    }
    return A;
}
</code></pre><h1 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的平均复杂度是O(N*logN)，最好的情况O(N*logN)，最坏的情况O(N^2);空间复杂度O(logN)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] quickSort(int[] A, int n) {
    qSort(A, 0, n - 1);
    return A;
}

/**
 * 
 * @param A
 *            数组
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void qSort(int[] A, int start, int end) {
    if (start &lt; end) {
        Random random = new Random();
        // 产生一个随机数
        int nextInt = random.nextInt(end - start + 1) + start;
        // 把随机位和数组最后一位交换
        int temp = A[end];
        A[end] = A[nextInt];
        A[nextInt] = temp;
        // 比A[nextInt]小的数的个数
        int lt = 0;

        for (int i = start; i &lt; end; i++) {
            if (A[i] &lt;= A[end]) {
                int temp1 = A[lt + start];
                A[lt + start] = A[i];
                A[i] = temp1;
                lt++;
            }
        }
        // 把数组最后一位和A[start + lt]交换
        int temp2 = A[start + lt];
        A[lt + start] = A[end];
        A[end] = temp2;
        // 递归
        qSort(A, start, lt + start - 1);
        qSort(A, lt + start + 1, end);
    }
}
</code></pre><h1 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h1><p>时间复杂度 O(N*logN),最坏O(N*logN);不稳定算法</p>
<pre><code>/**
 * 从堆顶中取值，再重新建堆
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] heapSort(int[] A, int n) {
    while (n &gt; 0) {
        sift(A, n);
        int temp = A[n - 1];
        A[n - 1] = A[0];
        A[0] = temp;
        n--;
        sift(A, n);
    }
    return A;
}

/**
 * 建堆
 * 
 * @param A
 * @param n
 */
public static void sift(int[] A, int n) {
    // 最后一个非终端节点
    int temp = n / 2;

    while (temp &gt; 0) {
        int tt = 2 * temp - 1;
        if (2 * temp &lt;= n - 1) {
            if (A[2 * temp] &lt; A[2 * temp - 1]) {
                tt = 2 * temp - 1;
            } else {
                tt = 2 * temp;
            }
        }
        // 如果子节点大于父节点
        if (A[temp - 1] &lt; A[tt]) {
            int t = A[temp - 1];
            A[temp - 1] = A[tt];
            A[tt] = t;
        }

        // 保证下面的堆为大顶堆
        for (int i = (tt + 1); i &lt;= n; i = 2 * i) {
            int k = 2 * i - 1;
            if (k &lt; n) {
                if (i * 2 + 1 &lt;= n) {
                    if (A[2 * i] &gt; A[2 * i - 1]) {
                        k = 2 * i;
                    }
                }
                if (A[i - 1] &lt; A[k]) {
                    int t = A[i - 1];
                    A[i - 1] = A[k];
                    A[k] = t;
                }
            }
        }
        // 节点自减
        temp--;
    }
}
</code></pre><h1 id="u5E0C_u5C14_u6392_u5E8F"><a href="#u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的平均复杂度是O(N*logN)~O(N^2)，最好的情况O(N^1.3)，最坏的情况O(N^2)；空间复杂度O(1);不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] shellSort(int[] A, int n) {
    Random random = new Random();
    // 步长
    int step = random.nextInt(n);
    sSort(A,step);
    return A;
}

/**
 * 
 * @param A
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void sSort(int[] A, int step) {
    // 当步长大于0时循环
    while (step &gt; 0) {
        for (int i = step; i &lt; A.length; i++) {
            int k = i;
            int temp = k - step;
            while (temp &gt;= 0) {
                if (A[k] &lt; A[temp]) {
                    int temp2 = A[k];
                    A[k] = A[temp];
                    A[temp] = temp2;
                    k = temp;
                }
                temp -= step;
            }
        }
        // 步长自减
        step--;
    }
}
</code></pre><h1 id="u8BA1_u6570_u6392_u5E8F"><a href="#u8BA1_u6570_u6392_u5E8F" class="headerlink" title="计数排序"></a>计数排序</h1><p>时间复杂度 O(N)；</p>
<pre><code>/**
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] countingSort(int[] A, int n) {
    int temp = A[0];
    for (int i = 1;i&lt;n ;i++) {
        if(A[i]&gt;temp){
            temp = A[i];
        }
    }

    int[] count = new int[temp+1];

    for (int i = 0; i &lt; n; i++) {
        count[A[i]]++;
    }
    int[] result = new int[n];
    int length = 0;
    for (int i = 0; i &lt; count.length; i++) {
        while(count[i]&gt;0){
            result[length] = i;
            count[i]--;
            length++;
        }
    }
    return result;
}
</code></pre><h1 id="u57FA_u6570_u6392_u5E8F"><a href="#u57FA_u6570_u6392_u5E8F" class="headerlink" title="基数排序"></a>基数排序</h1><p>时间复杂度 O (nlog(r)m)，其中r为所采取的基数，而m为堆数;空间复杂度O(N)；稳定算法</p>
<pre><code>public static int[] radixSort(int[] A, int n) {

    int index = 0;
    for (int i = 1; i &lt; n; i++) {
        if (A[i] &gt; A[index]) {
            index = i;
        }
    }

    int temp = A[index];
    int count = 0;
    while (temp / 10 &gt; 0) {
        count++;
        temp /= 10;
    }
    count++;

    int[][] bucket = new int[10][n + 1];

    int temp1 = count;
    while (count &gt; 0) {

        for (int i = 0; i &lt; bucket.length; i++) {
            bucket[i][0] = 0;
        }

        for (int i = 0; i &lt; n; i++) {
            int num;
            if (temp1 - count == 0) {
                num = A[i] % 10;
            } else {
                int tt = (int) Math.pow(10, temp1 - count);
                num = (int) A[i] / tt % 10;
            }
            int length = bucket[num][0];
            bucket[num][length + 1] = A[i];
            length++;
            bucket[num][0] = length;
        }
        int length = 0;
        for (int i = 0; i &lt; 10; i++) {
            for (int j = 0; j &lt; bucket[i][0]; j++) {
                A[length] = bucket[i][j + 1];
                length++;
            }
        }
        count--;
    }
    return A;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O]]>
    </summary>
    
      <category term="算法" scheme="http://yuqirong.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://yuqirong.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你一步步实现可拖拽的GridView控件]]></title>
    <link href="http://yuqirong.me/2016/02/15/%E5%B8%A6%E4%BD%A0%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84GridView%E6%8E%A7%E4%BB%B6/"/>
    <id>http://yuqirong.me/2016/02/15/带你一步步实现可拖拽的GridView控件/</id>
    <published>2016-02-15T12:46:17.000Z</published>
    <updated>2016-03-03T04:52:45.299Z</updated>
    <content type="html"><![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述"></p>
<p>是不是也想自己也想实现出相同的效果呢？那就一起来往下看吧。</p>
<p>首先我们来梳理一下思路：</p>
<ol>
<li>当用户长按选择一个item时，将该item隐藏，然后用WindowManager添加一个新的window，该window与所选择item一模一样，并且跟随用户手指滑动而不断改变位置。</li>
<li>当window的位置坐标在GridView里面时，使用<code>pointToPosition (int x, int y)</code>方法来判断对应的应该是哪个item，在adapter中作出数据集相应的变化，然后做出平移的动画。</li>
<li>当用户手指抬起时，把window移除，使用<code>notifyDataSetChanged()</code>做出GridView更新。</li>
</ol>
<p>讲完了思路后，我们就来实践一下吧，把这个控件取名为DragGridView。</p>
<pre><code>public DragGridView(Context context) {
    this(context, null);
}

public DragGridView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public DragGridView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    setOnItemLongClickListener(this);
}
</code></pre><h1 id="u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6"><a href="#u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6" class="headerlink" title="手指在Item上长按时"></a>手指在Item上长按时</h1><p>首先在构造器中得到WindowManager对象以及设置长按监听器，所以只有长按item才能拖拽。</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mWindowX = ev.getRawX();
            mWindowY = ev.getRawY();
            break;
        case MotionEvent.ACTION_MOVE:
            break;
        case MotionEvent.ACTION_UP:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre><p>然后在<code>onInterceptTouchEvent(MotionEvent ev)</code>中得到手指下落时的<code>ev.getRawX()</code>和<code>ev.getRawY()</code>，以备后面的计算使用。至于<code>getRawX()</code>和<code>getX()</code>的区别这里就不再讲述了，如果有不懂的可以自行百度。</p>
<p>下面就是<code>onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id)</code>方法了，我们在DragGridView中定义了两种模式：<code>MODE_DRAG</code>和<code>MODE_NORMAL</code>，分别对应着item拖拽和item不拖拽：</p>
<pre><code>@Override
public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
    if (mode == MODE_DRAG) {
        return false;
    }
    this.view = view;
    this.position = position;
    this.tempPosition = position;
    mX = mWindowX - view.getLeft() - this.getLeft();
    mY = mWindowY - view.getTop() - this.getTop();
    initWindow();
    return true;
}
</code></pre><p>在onItemLongClick()中先判断了一下模式，只有在<code>MODE_NORMAL</code>的情况下才会添加window。然后计算出mX和mY。可能有些童鞋在mX和mY的计算上看不懂，我给出了一个图示：</p>
<p><img src="/uploads/20160215/20160215210800.png" alt="这里写图片描述"></p>
<p>其中红点是手指按下的坐标，也就是(mWindowX,mWindowY)这个点；绿边框为DragGridView，因为DragGridView有可能会有margin值；所以this.getLeft()就是绿边框到屏幕的距离，而view.getLeft()就是长按的Item的左边到绿边框的距离。这几个值相减就得到了mX。同理，mY也是这样得到的。</p>
<p>然后来看看<code>initWindow();</code>这个方法：</p>
<pre><code>/**
 * 初始化window
 */
private void initWindow() {
    if (dragView == null) {
        dragView = View.inflate(getContext(), R.layout.drag_item, null);
        TextView tv_text = (TextView) dragView.findViewById(R.id.tv_text);
        tv_text.setText(((TextView) view.findViewById(R.id.tv_text)).getText());
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.width = view.getWidth();
        layoutParams.height = view.getHeight();
        layoutParams.x = view.getLeft() + this.getLeft();  //悬浮窗X的位置
        layoutParams.y = view.getTop() + this.getTop();  //悬浮窗Y的位置
        view.setVisibility(INVISIBLE);
    }

    mWindowManager.addView(dragView, layoutParams);
    mode = MODE_DRAG;
}
</code></pre><p>在<code>initWindow()</code>中，我们先创建了一个dragView，而dragView里面的内容与长按的Item的内容完全一致。然后创建<code>WindowManager.LayoutParams</code>的对象，把dragView添加到window上去。同时，也要把长按的Item隐藏了。在这里别忘了需要申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;
</code></pre><h1 id="u624B_u6307_u6ED1_u52A8_u65F6"><a href="#u624B_u6307_u6ED1_u52A8_u65F6" class="headerlink" title="手指滑动时"></a>手指滑动时</h1><p>在<code>initWindow()</code>之后，我们就要考虑当手指滑动时window也要跟着动了，我们重写<code>onTouchEvent(MotionEvent ev)</code>来监听滑动事件，可以看到下面的<code>updateWindow(ev)</code>方法。</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            break;
        case MotionEvent.ACTION_MOVE:
            if (mode == MODE_DRAG) {
                updateWindow(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mode == MODE_DRAG) {
                closeWindow(ev.getX(), ev.getY());
            }
            break;
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>这里贴出<code>updateWindow(ev)</code>方法：</p>
<pre><code>/**
 * 触摸移动时，window更新
 *
 * @param ev
 */
private void updateWindow(MotionEvent ev) {
    if (mode == MODE_DRAG) {
        float x = ev.getRawX() - mX;
        float y = ev.getRawY() - mY;
        if (layoutParams != null) {
            layoutParams.x = (int) x;
            layoutParams.y = (int) y;
            mWindowManager.updateViewLayout(dragView, layoutParams);
        }
        float mx = ev.getX();
        float my = ev.getY();
        int dropPosition = pointToPosition((int) mx, (int) my);
        Log.i(TAG, &quot;dropPosition : &quot; + dropPosition + &quot; , tempPosition : &quot; + tempPosition);
        if (dropPosition == tempPosition || dropPosition == GridView.INVALID_POSITION) {
            return;
        }
        itemMove(dropPosition);
    }
}
</code></pre><p>在这里，mX和mY就派上用场了。根据<code>ev.getRawX()</code>和<code>ev.getRawY()</code>分别减去<code>mX</code>和<code>mY</code>就得到了移动中layoutParams.x和layoutParams.y。再调用<code>updateViewLayout (View view, ViewGroup.LayoutParams params)</code>就出现了window跟随手指滑动而滑动的效果。最后根据 <code>pointToPosition(int x, int y)</code>返回的值来执行<code>itemMove(dropPosition);</code>。</p>
<pre><code>/**
 * 判断item移动，作出移动动画
 *
 * @param dropPosition
 */
private void itemMove(int dropPosition) {
    TranslateAnimation translateAnimation;
    // 移动的位置在原位置前面时
    if (dropPosition &lt; tempPosition) {
        for (int i = dropPosition; i &lt; tempPosition; i++) {
            View view = getChildAt(i);
            View nextView = getChildAt(i + 1);
            float xValue = (nextView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (nextView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == tempPosition - 1) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    } else {
        // 移动的位置在原位置后面时
        for (int i = tempPosition + 1; i &lt;= dropPosition; i++) {
            View view = getChildAt(i);
            View prevView = getChildAt(i - 1);
            float xValue = (prevView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (prevView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == dropPosition) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    }
    tempPosition = dropPosition;
}

/**
 * 动画监听器
 */
Animation.AnimationListener animationListener = new Animation.AnimationListener() {
    @Override
    public void onAnimationStart(Animation animation) {

    }

    @Override
    public void onAnimationEnd(Animation animation) {
        // 在动画完成时将adapter里的数据交换位置
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, true);
        }
        position = tempPosition;
    }

    @Override
    public void onAnimationRepeat(Animation animation) {

    }
};
</code></pre><p>上面的代码主要是根据dropPosition使要改变位置的Item来做出平移动画，当最后一个要改变位置的Item平移动画完成之后，在adapter中完成数据集的交换。</p>
<pre><code>/**
 * 给item交换位置
 *
 * @param originalPosition item原先位置
 * @param nowPosition      item现在位置
 */
public void exchangePosition(int originalPosition, int nowPosition, boolean isMove) {
    T t = list.get(originalPosition);
    list.remove(originalPosition);
    list.add(nowPosition, t);
    movePosition = nowPosition;
    this.isMove = isMove;
    notifyDataSetChanged();
}

@Override
public View getView(int position, View convertView, ViewGroup parent) {
    Log.i(TAG, &quot;-------------------------------&quot;);
    for (T t : list){
        Log.i(TAG, t.toString());
    }
    View view = getItemView(position, convertView, parent);
    if (position == movePosition &amp;&amp; isMove) {
        view.setVisibility(View.INVISIBLE);
    }
    return view;
}
</code></pre><h1 id="u624B_u6307_u62AC_u8D77_u65F6"><a href="#u624B_u6307_u62AC_u8D77_u65F6" class="headerlink" title="手指抬起时"></a>手指抬起时</h1><p>在上面<code>onTouchEvent(MotionEvent ev)</code>方法中，可以看到手指抬起时调用了<code>closeWindow(ev.getX(), ev.getY());</code>，那就一起来看看：</p>
<pre><code> /**
 * 关闭window
 *
 * @param x
 * @param y
 */
private void closeWindow(float x, float y) {
    if (dragView != null) {
        mWindowManager.removeView(dragView);
        dragView = null;
        layoutParams = null;
    }
    itemDrop();
    mode = MODE_NORMAL;
}

/**
 * 手指抬起时，item下落
 */
private void itemDrop() {
    if (tempPosition == position || tempPosition == GridView.INVALID_POSITION) {
        getChildAt(position).setVisibility(VISIBLE);
    } else {
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, false);
        }
    }
}
</code></pre><p>可以看出主要做的事情就是移除了window，并且也是调用了<code>exchangePosition(int originalPosition, int nowPosition, boolean isMove)</code>，不同的是第三个参数isMove传入了false，这样所有的Item都显示出来了。</p>
<p>讲了这么多，来看看最后的效果吧：</p>
<p><img src="/uploads/20160215/20160215212234.gif" alt="这里写图片描述"></p>
<p>和网易新闻的效果不相上下吧，完整的源码太长就不贴出了，下面提供源码下载：</p>
<p><a href="/uploads/20160215/DragGridView-master.rar">DragGridView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述">]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在AlertDialog中EditText无法弹出键盘的解决方案]]></title>
    <link href="http://yuqirong.me/2016/02/06/%E5%9C%A8AlertDialog%E4%B8%ADEditText%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yuqirong.me/2016/02/06/在AlertDialog中EditText无法弹出键盘的解决方案/</id>
    <published>2016-02-06T06:54:11.000Z</published>
    <updated>2016-03-02T11:34:38.470Z</updated>
    <content type="html"><![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这个问题。这次算是填了一个隐藏的坑。</p>
<p>例如下面给出了一个例子，首先贴上AlertDialog的<code>layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;200dp&quot;
    android:background=&quot;@android:color/white&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello friend!&quot;/&gt;

    &lt;EditText
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:hint=&quot;input content&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;submit&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>AlertDialog的效果图是这样的：</p>
<p><img src="/uploads/20160206/20160206160310.png" alt="这里填写图片的描述"></p>
<p>我们会发现无论怎么点击EditText也无法弹出键盘，其实我们只要加上<code>alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</code>这一句，就可以让键盘弹出了。</p>
<p><img src="/uploads/20160206/20160206161311.png" alt="这里填写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160206/AlertDialogDemo.rar">AlertDialogDemo.rar</a></p>
<p>StackOverFlow：</p>
<p><a href="http://stackoverflow.com/questions/9102074/android-edittext-in-dialog-doesnt-pull-up-soft-keyboard" target="_blank" rel="external">Android: EditText in Dialog doesn’t pull up soft keyboard</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对LayoutInflater的深入解析]]></title>
    <link href="http://yuqirong.me/2016/02/03/%E5%AF%B9LayoutInflater%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/02/03/对LayoutInflater的深入解析/</id>
    <published>2016-02-03T11:19:12.000Z</published>
    <updated>2016-03-02T11:28:20.568Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身影。比如说在Fragment的<code>onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</code>方法里，就需要我们返回Fragment的View。这时就可以用<code>inflater.inflate(R.layout.fragment_view, container, false)</code>来加载视图。那么下面就来探究一下LayoutInflater的真面目吧。</p>
<h1 id="from_28Context_context_29"><a href="#from_28Context_context_29" class="headerlink" title="from(Context context)"></a>from(Context context)</h1><p>首先我们在使用LayoutInflater时，通常用<code>LayoutInflater.from(Context context)</code>这个方法来得到其对象：</p>
<pre><code>/**
 * Obtains the LayoutInflater from the given context.
 */
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre><p>我们可以看到原来<code>from(Context context)</code>这个方法只不过把<code>context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</code>进行简单地封装了一下，方便开发者调用。相信大家都看得懂。</p>
<h1 id="inflate_28_u2026_29"><a href="#inflate_28_u2026_29" class="headerlink" title="inflate(…)"></a>inflate(…)</h1><p>在得到了LayoutInflater的对象之后，我们就要使用它的inflate()方法了。</p>
<p><img src="/uploads/20160203/20160203183605.png" alt="这里填写图片的描述"></p>
<p>可以看到inflate()有四个重载的方法。我们先来看看前三个的源码：</p>
<pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
    return inflate(resource, root, root != null);
}

public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}

public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre><p>看到这里，我们都明白了，前三个inflate()方法到最后都是调用了<code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>这个方法。原来第四个inflate()方法才是“幕后黑手”。那让我们来揭开它的黑纱吧：</p>
<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }

            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription()
                        + &quot;: No start tag found!&quot;);
            }

            final String name = parser.getName();

            if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot;
                        + name);
                System.out.println(&quot;**************************&quot;);
            }

            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                            + &quot;ViewGroup root and attachToRoot=true&quot;);
                }

                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(
                    parser.getPositionDescription()
                            + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don&apos;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return result;
    }
}
</code></pre><p>这段代码有点长，不过别担心，我们慢慢来看。首先把传入的<code>parser</code>进行解析，创建视图。其中我们可以注意到在Android的源码中是用Pull方式来解析xml得到视图的。接下来判断了传入的<code>root</code>是否为null，如果<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，<code>temp.setLayoutParams(params);</code>。也就是说把创建出来的视图的LayoutParams设置为params。那么params又是从哪里来的呢？可以在上面一行可以找到<code>params = root.generateLayoutParams(attrs);</code>我们来看看源码：</p>
<pre><code> public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new LayoutParams(getContext(), attrs);
}
</code></pre><p>也就是说，在<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，把<code>root</code>的LayoutParams设置给了新创建出来的View。</p>
<p>好了，再往下看，我们注意到了<code>root</code>不为null并且<code>attachToRoot</code>为true的情况。调用了<code>root.addView(temp, params);</code>，在其内部就是将temp添加进了root中。即最后得到的View的父布局就是root。</p>
<p>最后一个情况就是<code>(root == null || !attachToRoot)</code>时，直接返回了temp。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>到这里，关于LayoutInflater的讲解就差不多了，最后我们就来总结一下：</p>
<ul>
<li>在root!=null并且attachToRoot为false：将root的LayoutParams设置给了View。</li>
<li>在root!=null并且attachToRoot为true：把root作为View的父布局。</li>
<li>在root==null时：直接返回View，无视attachToRoot的状态。</li>
</ul>
<p>今天就到这，如有问题可以在下面留言。</p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义ViewGroup打造流式布局]]></title>
    <link href="http://yuqirong.me/2016/01/22/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%89%93%E9%80%A0%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yuqirong.me/2016/01/22/自定义ViewGroup打造流式布局/</id>
    <published>2016-01-22T12:31:37.000Z</published>
    <updated>2016-02-24T14:15:31.817Z</updated>
    <content type="html"><![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/38352503" target="_blank" rel="external">《Android 自定义ViewGroup 实战篇 -&gt; 实现FlowLayout》</a>，觉得文中的FlowLayout很多地方都可以用到。于是自己按照思路实现了一遍，这就是本片博文诞生的原因了。</p>
<p>首先流式布局相信大家都见到过，比如说下图中的京东热搜就是流式布局的应用。还有更多应用的地方在这里就不一一举例了。</p>
<p><img src="/uploads/20160222/20160222205447.png" alt="这里写图片描述"></p>
<p>下面我们就来看看是如何实现的。首先新建一个class，继承自ViewGroup。在<code>generateLayoutParams(AttributeSet attrs)</code>里直接返回MarginLayoutParams就行了。</p>
<pre><code> @Override
public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new MarginLayoutParams(getContext(), attrs);
}
</code></pre><p>然后就是<code>onLayout(boolean changed, int l, int t, int r, int b)</code>了，大部分的代码都添加了注释，相信大家都能看懂。</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int count = getChildCount();
    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    // 用来统计总宽度，初始值设为paddingLeft
    int lastWidth = getPaddingLeft();
    int lastHeight = getPaddingTop();

    for (int i = 0; i &lt; count; i++) {
        // 得到当前View
        View childView = getChildAt(i);
        // 测量得到当前View的宽度
        cWidth = childView.getMeasuredWidth();
        // 测量得到当前View的高度
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();
        // 宽度加上margin
        int width = cWidth + params.leftMargin + params.rightMargin;
        // 高度加上margin
        int height = cHeight + params.topMargin + params.bottomMargin;
        // 判断流式布局里的item总长度是否超过FlowLayout的宽度，如果是则需要换行  
        if (width + lastWidth &gt; r - getPaddingRight()) {
            // 如果超过，重置lastWidth
            lastWidth = getPaddingLeft();
            // lastHeight加上一个item的高度
            lastHeight += height;
        }
        // 给View布局
        childView.layout(lastWidth, lastHeight, lastWidth + cWidth, lastHeight + cHeight);
        //累加总宽度
        lastWidth += width;
    }
}
</code></pre><p>之后就是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);

    int totalWidth = getPaddingLeft() + getPaddingRight();
    int maxWidth = getPaddingLeft() + getPaddingRight();
    int maxHeight = getPaddingBottom() + getPaddingTop();
    int count = getChildCount();
    // 测量子view
    measureChildren(widthMeasureSpec, heightMeasureSpec);

    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    int width;
    int height;
    for (int i = 0; i &lt; count; i++) {
        View childView = getChildAt(i);
        cWidth = childView.getMeasuredWidth();
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();

        width = cWidth + params.leftMargin + params.rightMargin;
        height = cHeight + params.topMargin + params.bottomMargin;

        if (i == 0) {
            // 第一行时最大高度设为height
            maxHeight += height;
        }

        // 如果需要换行
        if (width + totalWidth &gt; widthSize) {
            // 得到最大的值作为setMeasuredDimension()的宽度
            maxWidth = Math.max(maxWidth, totalWidth);
            totalWidth = getPaddingLeft() + getPaddingRight();
            totalWidth += width;
            // 高度就是累加到最后
            maxHeight += height;
        } else {
            // 不换行就总长度累加
            totalWidth += width;
        }
        Log.i(TAG, &quot;i = &quot; + i + &quot;, width = &quot; + width + &quot;, totalWidth = &quot; + totalWidth + &quot;, widthSize = &quot; + widthSize + ((TextView) childView).getText());
        Log.i(TAG, &quot;height = &quot; + height);
        Log.i(TAG, &quot;i = &quot; + i + &quot;, maxHeight = &quot; + maxHeight);

    }
    // 设置宽高度
    setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? widthSize : maxWidth,
            heightMode == MeasureSpec.EXACTLY ? heightSize : maxHeight);

}
</code></pre><p>在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>中，如果测量模式是MeasureSpec.EXACTLY，则直接设置测量出来的宽和高；否则需要测量每个子View，根据item的行数来得到宽和高。</p>
<p>这样，FlowLayout就写好了，那就让我们来看看效果吧。当<code>android:layout_width=&quot;wrap_content&quot;</code>时</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220305.png" alt="这里写图片描述"></p>
<p>当<code>android:layout_width=&quot;300dp&quot;</code>时：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;哈尔滨&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;呼和浩特&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220718.png" alt="这里写图片描述"></p>
<p>最后，提供源码下载：</p>
<p><a href="/uploads/20160222/FlowLayout.rar">FlowLayout.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现导航Tab栏悬浮功能之改进版]]></title>
    <link href="http://yuqirong.me/2016/01/14/%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>http://yuqirong.me/2016/01/14/实现导航Tab栏悬浮功能之改进版/</id>
    <published>2016-01-14T12:34:25.000Z</published>
    <updated>2016-02-24T14:16:17.719Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/">《轻松实现app中的导航Tab栏悬浮功能》</a>。</p>
<p>当然，用WindowManager来实现由一个缺点就是当没有显示悬浮窗的权限时，该功能就无法体现出来。而在本篇博文中，我们用第二种方法，也就是不断地重新设置Tab栏的布局位置来实现悬浮功能，弥补了第一种方法的缺点。效果图这里就不放了，相信大家都看过啦。</p>
<p>不废话了，直接上代码。</p>
<p>activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;55dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>我们发现在activity_main.xml里Tab栏悬浮窗的布局放在了最后，这是因为当悬浮窗悬浮在顶部时，应该在所有的UI控件上方，所以在xml里放在了最后。</p>
<p>接下来看看MainActivity：</p>
<pre><code>public class MainActivity extends AppCompatActivity implements MyScrollView.OnScrollListener {

    private static final String TAG = &quot;MainActivity&quot;;
    private MyScrollView mScrollView;
    private LinearLayout ll_tab;
    private ImageView iv_pic;
    private int picBottom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getSupportActionBar().hide();
        mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
        mScrollView.setOnScrollListener(this);
        ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
        iv_pic = (ImageView) findViewById(R.id.iv_pic);
        findViewById(R.id.ll_main).getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                onScroll(mScrollView.getScrollY());
            }
        });
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            picBottom = iv_pic.getBottom();
        }
    }

    @Override
    public void onScroll(int scrollY) {
        int top = Math.max(scrollY, picBottom);
        ll_tab.layout(0, top, ll_tab.getWidth(), top + ll_tab.getHeight());
    }

}
</code></pre><p>我们惊奇地发现在Activity里的代码竟然这么短！但是这是这么短，实现了一模一样的功能。</p>
<p>首先在父布局中添加了OnGlobalLayoutListener，以便当布局的状态或者控件的可见性改变时去重新设置Tab栏的布局。之后在<code>onWindowFocusChanged(boolean hasFocus)</code>里得到<code>iv_pic.getBottom()</code>的值，也就是<code>iv_pic</code>的高度。也就是说你一开始想把<code>ll_tab</code>布局在<code>iv_pic</code>的下面。因此可以当作Tab栏距离ScrollView顶部的距离。</p>
<p>最后在<code>onScroll(int scrollY)</code>中比较scrollY，picBottom的最大值。当<code>scrollY&lt;picBottom</code>时，<code>ll_tab</code>会跟随ScrollView的滑动而滑动；当<code>scrollY&gt;picBottom</code>时，<code>ll_tab</code>布局的顶部的坐标始终是ScrollView的滑动距离，这样就造成了<code>ll_tab</code>悬浮在顶部的“假象”。</p>
<p>好了，一起来看看效果吧：</p>
<p><img src="/uploads/20160114/20160114223247.gif" alt="这里填写图片的描述"></p>
<p>是不是和第一种方法的效果一样呢，相信大家都学会了。如果有问题可以在下面留言。</p>
<p>最后，放出源码：</p>
<p><a href="/uploads/20160114/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻松实现app中的导航Tab栏悬浮功能]]></title>
    <link href="http://yuqirong.me/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/"/>
    <id>http://yuqirong.me/2016/01/12/轻松实现app中的导航Tab栏悬浮功能/</id>
    <published>2016-01-12T13:59:29.000Z</published>
    <updated>2016-02-22T12:45:22.651Z</updated>
    <content type="html"><![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160112/20160112210653.gif" alt="这里填写图片的描述"></p>
<p>可以看到上图中的“分类”、“排序”、“筛选”会悬浮在app的顶部，状态随着ScrollView(也可能不是ScrollView，在这里姑且把这滑动的UI控件当作ScrollView吧)的滚动而变化。像这种导航Tab栏悬浮的作用相信大家都能体会到，Tab栏不会随着ScrollView等的滚动而被滑出屏幕外，增加了与用户之间的交互性和方便性。</p>
<p>看到上面的效果，相信大家都跃跃欲试了，那就让我们开始吧。</p>
<p>首先大家要明白一点：Tab栏的状态变化是要监听ScrollView滑动距离的。至于如何得到ScrollView的滑动距离？可以看看我的一篇Tip：<a href="/2015/10/19/给你的ScrollView设置滑动距离监听器/">《给你的ScrollView设置滑动距离监听器》</a>，这里就不过多叙述了。</p>
<p>好了，根据上面的就得到了对ScrollView滑动的监听了。接下来要思考的问题就是如何让Tab栏实现悬浮的效果呢？这里给出的方法有两种，第一种就是使用WindowManager来动态地添加一个View悬浮在顶部；第二种就是随着ScrollView的滑动不断重新设置Tab栏的布局位置。</p>
<p>我们先来看看第一种实现方法，首先是xml布局了。</p>
<p>Activity的布局，activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>Tab栏的布局，tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面布局中的很多空白LinearLayout主要是拉长ScrollView，效果图就是这样的：</p>
<p><img src="/uploads/20160112/20160112201753.png" alt="这里填写图片的描述"></p>
<p>然后我们来看看<code>onCreate(Bundle savedInstanceState)</code>：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    setContentView(R.layout.activity_main);
    mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
    mScrollView.setOnScrollListener(this);
    ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
    windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
}
</code></pre><p>我们先在<code>onCreate(Bundle savedInstanceState)</code>中给ScrollView添加了滑动距离监听器以及得到了一个windowManager的对象。还有一点需要注意的是：我们调用了<code>getSupportActionBar().hide();</code>去掉了标题栏(MainActivity继承了AppCompatActivity)。这是因为标题栏的存在导致了在计算悬浮窗y轴的值时要额外加上标题栏的高度(当然你也可以保留标题栏，然后计算时再加上标题栏的高度^_^!)。</p>
<p>然后在onWindowFocusChanged(boolean hasFocus)得到Tab栏的高度、getTop()值等，以便下面备用。如果你对getLeft()、getTop()、getRight()和getBottom()还不了解的话，可以看看我的另一篇Tip： <a href="/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/">《对view的getLeft()、getTop()等的笔记》</a>。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        tabHeight = ll_tab.getHeight();
        tabTop = ll_tab.getTop();
        scrollTop = mScrollView.getTop();
    }
}
</code></pre><p>之后在滑动监听器的回调方法<code>onScroll(int scrollY)</code>中来控制显示还是隐藏悬浮窗。</p>
<pre><code> @Override
public void onScroll(int scrollY) {
    Log.i(TAG, &quot;scrollY = &quot; + scrollY + &quot;, tabTop = &quot; + tabTop);
    if (scrollY &gt; tabTop) {
        // 如果没显示
        if (!isShowWindow) {
            showWindow();
        }
    } else {
        // 如果显示了
        if (isShowWindow) {
            removeWindow();
        }
    }
}
</code></pre><p>上面的代码比较简单，不用我过多叙述了。下面是removeWindow()、showWindow()两个方法：</p>
<pre><code>// 显示window
private void removeWindow() {
    if (ll_tab_temp != null)
        windowManager.removeView(ll_tab_temp);
    isShowWindow = false;
}

// 移除window
private void showWindow() {
    if (ll_tab_temp == null) {
        ll_tab_temp = LayoutInflater.from(this).inflate(R.layout.tab_layout, null);
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE; //悬浮窗的类型，一般设为2002，表示在所有应用程序之上，但在状态栏之下
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.gravity = Gravity.TOP;  //悬浮窗的对齐方式
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.height = tabHeight;
        layoutParams.x = 0;  //悬浮窗X的位置
        layoutParams.y = scrollTop;  //悬浮窗Y的位置
    }
    windowManager.addView(ll_tab_temp, layoutParams);
    isShowWindow = true;
}
</code></pre><p>这两个方法也很简单，而且有注释，相信大家可以看懂。</p>
<p>最后，不要忘了在AndroidManifest.xml里申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
</code></pre><p>到这里，整体的代码就这些了。一起来看看效果吧：</p>
<p><img src="/uploads/20160112/20160112204356.gif" alt="这里填写图片的描述"></p>
<p>但是用这种方法来实现Tab栏悬浮功能有一个缺点，那就是如果该app没有被赋予显示悬浮窗的权限，那么该功能就变成鸡肋了。当然还有第二种方法来实现，不过只能等到下一篇博文再讲了。</p>
<p>本Demo源码下载：</p>
<p><a href="/uploads/20160112/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对view的getLeft()、getTop()等的笔记]]></title>
    <link href="http://yuqirong.me/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/01/05/对view的getLeft()、getTop()等的笔记/</id>
    <published>2016-01-05T12:01:48.000Z</published>
    <updated>2016-02-19T14:24:47.890Z</updated>
    <content type="html"><![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;


    &lt;LinearLayout
        android:id=&quot;@+id/ll_01&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_green_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_01&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第一行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/ll_02&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_blue_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_02&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第二行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面是一个很简单的布局，UI效果图如下：</p>
<p><img src="/uploads/20160105/20160105202531.png" alt="这里填写图片的描述"></p>
<p>当我们用<code>tv_01.getTop()</code>的时候，得到的返回值是0，符合我的想象。但是用<code>tv_02.getTop()</code>，得到的值也为0。而我原以为<code>tv_02.getTop()</code>的值为<code>ll_01</code>的高度，也就是<code>tv_02</code>距离屏幕顶部的长度。但是结果和我的想象不一致。</p>
<p>后来我才知道原来<code>getTop()</code>方法返回的是该view距离<strong>父容器顶部</strong>的距离，所以理所应当<code>tv_02.getTop()</code>距离<code>ll_02</code>顶部的距离也为0了，同样的<code>getLeft()</code>、<code>getBottom()</code>、<code>getRight()</code>也是一个道理，以此类推。</p>
<p>那么问题来了，如何按我之前的想法一样，得到<code>tv_02</code>距离<strong>屏幕顶部</strong>的值呢？很简单，我们只要<code>tv_02.getTop() + ll_02.getTop()</code>就好了。相信聪明的你已经懂了。</p>
<p>看来在开发中还有不少的细节需要我们注意，特此一记。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml versi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见2015，你好2016]]></title>
    <link href="http://yuqirong.me/2016/01/01/%E5%86%8D%E8%A7%812015%EF%BC%8C%E4%BD%A0%E5%A5%BD2016/"/>
    <id>http://yuqirong.me/2016/01/01/再见2015，你好2016/</id>
    <published>2016-01-01T12:54:54.000Z</published>
    <updated>2016-02-19T14:15:29.787Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>转眼间2015年悄然流走，而2016年已经来临。蓦然回首，在2015年里经历了太多。</p>
<p>在这短短的一年里，得到了很多，同时也失去了很多。</p>
<h1 id="u518D_u89C12015"><a href="#u518D_u89C12015" class="headerlink" title="再见2015"></a>再见2015</h1><p>2015，完成了我从大三到大四的转变，同时也是抉择人生道路的重要时刻。和其他人一样，在考研和就业的分叉路上也纠结了很久。但是在2015年里，努力地学习编程，幻想着有一天能够成为大牛，这似乎离考研的路越走越远。</p>
<p>细细回想似乎写程序也已经满一年多了，从一开始的Java到现在的Android，这中间也弯弯曲曲地走了不少的弯路。还记得刚开始学习Android时，对于一切知识都急于求成，但却似乎忘了基础；以为自己什么都懂，其实只是一只“纸老虎”。最关键的是，把心慢下来，一点一滴积累才是正道，学习的路上没有捷径。</p>
<h1 id="u4F60_u597D2016"><a href="#u4F60_u597D2016" class="headerlink" title="你好2016"></a>你好2016</h1><p>至于2016的到来，真的是“手足无措”。时间总是在不经意间流逝，而当你幡然醒悟时，只能扼腕叹息。其实更重要的是，在2016年的6月，我们要毕业了。离开同学，离开老师，离开校园。这其中纵然有千万缕不舍，但是人终究要面临着成长。之前从没想象过毕业，总以为离我们很遥远，但其实却很近。我们都已经习惯了在校园里慵懒的生活，闲暇之余可以和同学之间玩玩游戏，在草地上晒晒太阳，在图书馆安静地看看书。而这一切在2016都要发生重大的转变，这似乎就是我不愿意2016到来的原因了。</p>
<p>人们总是在展望未来，却忘了把握当下。最无厘头的一句话“我在2016年的新年目标就是完成2015年那些本该在2014年完成的我在2013年就信誓旦旦要完成的2012年制定的目标…”。当然希望每个人都要脚踏实地，认认真真地完成自己订下的目标。也希望自己在新的一年里积累更多的知识，技术节节高升，早日走向人生的巅峰。</p>
<p>最后，献上一首《同学的你》，纪念即将告别的校园生活。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28387594&auto=1&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" ti]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现水波纹动画，让你的app不再单调]]></title>
    <link href="http://yuqirong.me/2015/12/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%B0%B4%E6%B3%A2%E7%BA%B9%E5%8A%A8%E7%94%BB%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84app%E4%B8%8D%E5%86%8D%E5%8D%95%E8%B0%83/"/>
    <id>http://yuqirong.me/2015/12/27/自定义实现水波纹动画，让你的app不再单调/</id>
    <published>2015-12-27T15:05:17.000Z</published>
    <updated>2016-02-21T14:21:00.308Z</updated>
    <content type="html"><![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效果怎样，我们一起来看看：</p>
<p><img src="/uploads/20151227/20151227231546.gif" alt="这里填写图片描述"></p>
<p>是不是觉得有新意多了呢？那就一起来看看吧，先简单讲述一下思路：首先波浪的形状主要是根据三角函数决定的。三角函数相信大家在中学的课程中学习过吧。通用公式就是f(x)=Asin(ωx+φ) + b。其中A就是波浪的振幅，ω与时间周期有关，x就是屏幕宽度的像素点，φ是初相，可以让波浪产生偏移，最后的b就是水位的高度了。最后根据这公式算出y坐标，用<code>canvas.drawLine(startX, startY, stopX, stopY, paint);</code>来画出竖直的线条，这样就形成了波浪。</p>
<p>整体的思路就如下面示意图所示，当红色的线条间距越来越小，密度越来越大时就形成了波浪：</p>
<p><img src="/uploads/20151227/20151227230103.png" alt="这里填写图片描述"></p>
<p>讲完了思路，那下面我们就来分析一下代码吧。</p>
<p>首先看一下“自定义View三部曲”中的第一部，自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

    &lt;declare-styleable name=&quot;WaveView&quot;&gt;
        &lt;attr name=&quot;waveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;secondWaveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;waveHeight&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;

&lt;/resources&gt;
</code></pre><p>我们先定义了三个属性，分别是前波浪颜色、后波浪颜色以及波浪的振幅高度。</p>
<p>然后就是在构造器中初始化自定义的属性。</p>
<pre><code>public WaveView(Context context) {
    this(context, null);
}

public WaveView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public WaveView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.WaveView);
    defaultWaveColor = getResources().getColor(R.color.indigo_color);
    waveColor = a.getColor(R.styleable.WaveView_waveColor, defaultWaveColor);
    defaultSecondWaveColor = getResources().getColor(R.color.second_indigo_color);
    secondWaveColor = a.getColor(R.styleable.WaveView_secondWaveColor, defaultSecondWaveColor);
    defaultWaveHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, getResources().getDisplayMetrics());
    waveHeight = a.getDimension(R.styleable.WaveView_waveHeight, defaultWaveHeight);
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
}
</code></pre><p>前面的代码很简单，接下来要重写<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>:</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    this.w = (float) (Math.PI * 2 / w);
}
</code></pre><p>这里的w就是上面f(x)=Asin(ωx+φ) + b公式中的ω，而ω=2π/T。也就是说周期就是屏幕宽度。所以在一个屏幕内正好可以显示出正弦函数的一个周期。</p>
<p>下面就是三部曲的第二部：重写<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 200;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 200;
    }
    setMeasuredDimension(mWidth, mHeight);
}
</code></pre><p>onMeasure()中就是测量了View的宽高度，如果不是MeasureSpec.EXACTLY的模式就直接赋值200(这里没有把200px转化为200dp,偷懒了ㄟ(▔ ,▔)ㄏ)。相信大家都会了。</p>
<p>最后就是<code>onDraw(Canvas canvas)</code>，也就是三部曲中的最后一部：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 水位的高度
    waterHeight = waterHeight + 10;
    // 正弦函数y的坐标
    float startY;
    canvas.save();

    if (System.currentTimeMillis() - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    double temp = Math.toDegrees(speed);
    speed++;

    // 先绘制第二条波浪
    mPaint.setColor(secondWaveColor);
    // 遍历每个像素点，并在竖直上画线
    for (int i = 0; i &lt; mWidth; i++) {
        // 和第一条波浪相比产生的偏移量为8,至于偏移量大小可以自己决定
        startY = (float) (waveHeight * Math.sin(w * i + temp + 8) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }

    // 再绘制第一条波浪
    mPaint.setColor(waveColor);
    for (int i = 0; i &lt; mWidth; i++) {
        startY = (float) (waveHeight * Math.sin(w * i + temp) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }
    Log.i(TAG, &quot;waterHeight : &quot; + waterHeight);
    canvas.restore();
    // 不断重绘
    invalidate();
    startTime = System.currentTimeMillis();
}
</code></pre><p>在<code>onDraw(Canvas canvas)</code>的一开始waterHeight不断自增，以此来实现水位不断上涨的效果，然后就是线程的休眠来控制绘制的频率。之后在绘制第二条波浪时初相加上一个偏移量，这样就可以与第一条波浪形成交错的效果。整体代码并不复杂，主要是坐标上的计算。</p>
<p>到这里基本就讲得差不多了，以下是本案例的源码：</p>
<p><a href="/uploads/20151227/WaveView.rar">WaveView.rar</a></p>
<p>最后，预祝大家元旦快乐！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让你的ListView更炫酷，实现侧滑删除效果]]></title>
    <link href="http://yuqirong.me/2015/12/13/%E8%AE%A9%E4%BD%A0%E7%9A%84ListView%E6%9B%B4%E7%82%AB%E9%85%B7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2015/12/13/让你的ListView更炫酷，实现侧滑删除效果/</id>
    <published>2015-12-13T15:54:48.000Z</published>
    <updated>2016-03-02T08:51:02.245Z</updated>
    <content type="html"><![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接一下之前写的博文使用ViewDragHelper来实现侧滑菜单的，<a href="/2015/11/04/史上最简单粗暴实现侧滑菜单/">点击此处跳转</a>。如果你对ViewDragHelper不熟悉，你可以去看看<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">《Android ViewDragHelper完全解析 自定义ViewGroup神器》</a>。</p>
<p>好了，话说的那么多，先来看看我们实现的效果图吧：</p>
<p><img src="/uploads/20151213/20151213140251.gif" alt="这里填写图片描述"></p>
<p>可以看出来，我们实现的和QQ的效果相差无几。下面就是源码时间了。</p>
<p>先来看一下ListView的item的<code>slip_item_layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.swipelistview.view.SwipeListLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/sll_main&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;TextView
            android:id=&quot;@+id/tv_top&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#66ff0000&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;置顶&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_delete&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#330000ff&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;删除&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:background=&quot;#66ffffff&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;ImageView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_margin=&quot;10dp&quot;
            android:src=&quot;@drawable/head_1&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_name&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:gravity=&quot;center_vertical&quot;
            android:text=&quot;hello&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/com.yuqirong.swipelistview.view.SwipeListLayout&gt;
</code></pre><p>我们可以看出，要先把侧滑出的按钮布局放在SwipeListLayout的第一层，而item的布局放在第二层。还有一点要注意的是，侧滑出的按钮如果有两个或两个以上，那么必须用ViewGroup作为父布局。要整体保持SwipeListLayout的直接子View为2个。</p>
<p>而activity的布局文件里就是一个ListView，这里就不再给出了。</p>
<p>下面我们直接来看看SwipeListLayout的内容：</p>
<pre><code>public SwipeListLayout(Context context) {
    this(context, null);
}

public SwipeListLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
    mDragHelper = ViewDragHelper.create(this, callback);
}

// ViewDragHelper的回调
Callback callback = new Callback() {

    @Override
    public boolean tryCaptureView(View view, int arg1) {
        return view == itemView;
    }

    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == itemView) {
            if (left &gt; 0) {
                return 0;
            } else {
                left = Math.max(left, -hiddenViewWidth);
                return left;
            }
        }
        return 0;
    }

    @Override
    public int getViewHorizontalDragRange(View child) {
        return hiddenViewWidth;
    }

    @Override
    public void onViewPositionChanged(View changedView, int left, int top,
            int dx, int dy) {
        if (itemView == changedView) {
            hiddenView.offsetLeftAndRight(dx);
        }
        // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
        // 为了确保绘制成功 调用 invalidate
        invalidate();
    }

    public void onViewReleased(View releasedChild, float xvel, float yvel) {
        // 向右滑xvel为正 向左滑xvel为负
        if (releasedChild == itemView) {
            if (xvel == 0
                    &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                open(smooth);
            } else if (xvel &lt; 0) {
                open(smooth);
            } else {
                close(smooth);
            }
        }
    }

};
</code></pre><p>我们主要来看callback，首先在<code>tryCaptureView(View view, int arg1)</code>里设置了只有是itemView的时候才能被捕获，也就是说当你去滑动“删除”、“置顶”等按钮的时候，侧滑按钮是不会被关闭的，因为根本就没捕获。(当然你也可以设置都捕获，那样的话下面的逻辑要调整了)，剩余的几个函数中的逻辑较为简单，在<code>onView
Released(View releasedChild, float xvel, float yvel)</code>也是判断了当手指抬起时itemView所处的位置。如果向左滑或者停止滑动时按钮已经显示出1/2的宽度，则打开；其余情况下都将关闭按钮。</p>
<p>以下分别是close()和open()的方法：</p>
<pre><code>/**
 * 侧滑关闭
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void close(boolean smooth) {
    preStatus = status;
    status = Status.Close;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start close animation&quot;);
                listener.onStartCloseAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Open) {
        Log.i(TAG, &quot;close&quot;);
        listener.onStatusChanged(status);
    }
}

/**
 * 侧滑打开
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void open(boolean smooth) {
    preStatus = status;
    status = Status.Open;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start open animation&quot;);
                listener.onStartOpenAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Close) {
        Log.i(TAG, &quot;open&quot;);
        listener.onStatusChanged(status);
    }
}
</code></pre><p>SwipeListLayout大致的代码就这些，相信对于熟悉ViewDragHelper的同学们来说应该是不成问题的。其实整体的逻辑和之前用ViewDragHelper来实现侧滑菜单大同小异。</p>
<p>顺便下面贴出SwipeListLayout的全部代码：</p>
<pre><code>/**
 * 侧滑Layout
 */
public class SwipeListLayout extends FrameLayout {

    private View hiddenView;
    private View itemView;
    private int hiddenViewWidth;
    private ViewDragHelper mDragHelper;
    private int hiddenViewHeight;
    private int itemWidth;
    private int itemHeight;
    private OnSwipeStatusListener listener;
    private Status status = Status.Close;
    private boolean smooth = true;

    public static final String TAG = &quot;SlipListLayout&quot;;

    // 状态
    public enum Status {
        Open, Close
    }

    /**
     * 设置侧滑状态
     * 
     * @param status
     *            状态 Open or Close
     * @param smooth
     *            若为true则有过渡动画，否则没有
     */
    public void setStatus(Status status, boolean smooth) {
        this.status = status;
        if (status == Status.Open) {
            open(smooth);
        } else {
            close(smooth);
        }
    }

    public void setOnSwipeStatusListener(OnSwipeStatusListener listener) {
        this.listener = listener;
    }

    /**
     * 是否设置过渡动画
     * 
     * @param smooth
     */
    public void setSmooth(boolean smooth) {
        this.smooth = smooth;
    }

    public interface OnSwipeStatusListener {

        /**
         * 当状态改变时回调
         * 
         * @param status
         */
        void onStatusChanged(Status status);

        /**
         * 开始执行Open动画
         */
        void onStartCloseAnimation();

        /**
         * 开始执行Close动画
         */
        void onStartOpenAnimation();

    }

    public SwipeListLayout(Context context) {
        this(context, null);
    }

    public SwipeListLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDragHelper = ViewDragHelper.create(this, callback);
    }

    // ViewDragHelper的回调
    Callback callback = new Callback() {

        @Override
        public boolean tryCaptureView(View view, int arg1) {
            return view == itemView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            if (child == itemView) {
                if (left &gt; 0) {
                    return 0;
                } else {
                    left = Math.max(left, -hiddenViewWidth);
                    return left;
                }
            }
            return 0;
        }

        @Override
        public int getViewHorizontalDragRange(View child) {
            return hiddenViewWidth;
        }

        @Override
        public void onViewPositionChanged(View changedView, int left, int top,
                int dx, int dy) {
            if (itemView == changedView) {
                hiddenView.offsetLeftAndRight(dx);
            }
            // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
            // 为了确保绘制成功 调用 invalidate
            invalidate();
        }

        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            // 向右滑xvel为正 向左滑xvel为负
            if (releasedChild == itemView) {
                if (xvel == 0
                        &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                    open(smooth);
                } else if (xvel &lt; 0) {
                    open(smooth);
                } else {
                    close(smooth);
                }
            }
        }

    };
    private Status preStatus = Status.Close;

    /**
     * 侧滑关闭
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void close(boolean smooth) {
        preStatus = status;
        status = Status.Close;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start close animation&quot;);
                    listener.onStartCloseAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Open) {
            Log.i(TAG, &quot;close&quot;);
            listener.onStatusChanged(status);
        }
    }

    /**
     * 
     * @param status
     */
    private void layout(Status status) {
        if (status == Status.Close) {
            hiddenView.layout(itemWidth, 0, itemWidth + hiddenViewWidth,
                    itemHeight);
            itemView.layout(0, 0, itemWidth, itemHeight);
        } else {
            hiddenView.layout(itemWidth - hiddenViewWidth, 0, itemWidth,
                    itemHeight);
            itemView.layout(-hiddenViewWidth, 0, itemWidth - hiddenViewWidth,
                    itemHeight);
        }
    }

    /**
     * 侧滑打开
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void open(boolean smooth) {
        preStatus = status;
        status = Status.Open;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start open animation&quot;);
                    listener.onStartOpenAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Close) {
            Log.i(TAG, &quot;open&quot;);
            listener.onStatusChanged(status);
        }
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        // 开始执行动画
        if (mDragHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        final int action = ev.getAction();
        if (action == MotionEvent.ACTION_CANCEL) {
            mDragHelper.cancel();
            return false;
        }
        return mDragHelper.shouldInterceptTouchEvent(ev);
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onTouchEvent(MotionEvent event) {
        mDragHelper.processTouchEvent(event);
        return true;
    };

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        hiddenView = getChildAt(0); // 得到隐藏按钮的linearlayout
        itemView = getChildAt(1); // 得到最上层的linearlayout
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        // 测量子View的长和宽
        itemWidth = itemView.getMeasuredWidth();
        itemHeight = itemView.getMeasuredHeight();
        hiddenViewWidth = hiddenView.getMeasuredWidth();
        hiddenViewHeight = hiddenView.getMeasuredHeight();
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right,
            int bottom) {
        layout(Status.Close);
    }

}
</code></pre><p>最后，提供SwipeListLayout的源码下载：</p>
<p><a href="/uploads/20151213/SwipeListView.rar">SwipeListView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/SwipeListView" target="_blank" rel="external">SwipeListView</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现炫酷的CheckBox，就这么简单]]></title>
    <link href="http://yuqirong.me/2015/12/05/%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84CheckBox%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://yuqirong.me/2015/12/05/实现炫酷的CheckBox，就这么简单/</id>
    <published>2015-12-05T15:10:32.000Z</published>
    <updated>2016-03-02T08:52:24.219Z</updated>
    <content type="html"><![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andyxialm/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a>，它的效果预览触动到我了，于是趁着今天有空就试着自己写一写。尽管效果可能不如SmoothCheckBox那样动感，但是基本的效果还是实现了。按照惯例，下面就贴出我写的CheckBox的gif： </p>
<p><img src="/uploads/20151205/20151205234652.gif" alt="这里写图片描述"></p>
<p>gif的效果可能有点过快，在真机上运行的效果会更好一些。我们主要的思路就是利用属性动画来动态地画出选中状态以及对勾的绘制过程。看到上面的效果图，相信大家都迫不及待地要跃跃欲试了，那就让我们开始吧。</p>
<p>自定义View的第一步：自定义属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;SmoothCheckBox&quot;&gt;
        &lt;!-- 动画持续时间 --&gt;
        &lt;attr name=&quot;duration&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框宽度 --&gt;
        &lt;attr name=&quot;strikeWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框颜色 --&gt;
        &lt;attr name=&quot;borderColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 选中状态的颜色 --&gt;
        &lt;attr name=&quot;trimColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾颜色 --&gt;
        &lt;attr name=&quot;tickColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾宽度 --&gt;
        &lt;attr name=&quot;tickWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>我们把CheckBox取名为SmoothCheckBox(没办法(⊙﹏⊙)，这名字挺好听的)，定义了几个等等要用到的属性。这一步很简单，相信大家都熟练了。</p>
<p>接下来看一看<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>:</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 40;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 40;
    }
    setMeasuredDimension(mWidth, mHeight);
    int size = Math.min(mWidth, mHeight);
    center = size / 2;
    mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
    startPoint.set(center * 14 / 30, center * 28 / 30);
    breakPoint.set(center * 26 / 30, center * 40 / 30);
    endPoint.set(center * 44 / 30, center * 20 / 30);

    downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
    upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
    totalLength = downLength + upLength;
}
</code></pre><p>一开始是测量了SmoothCheckBox的宽、高度，默认的宽高度随便定义了一个，当然你们可以自己去修改和完善它。然后就是设置半径之类的，最后的startPoint、breakPoint、endPoint分别对应着选中时对勾的三个点(至于为何是这几个数字，那完全是经验值);downLength就是startPoint和breakPoint的距离，而相对应的upLength就是breakPoint和endPoint的距离。即以下图示：</p>
<p><img src="/uploads/20151205/20151205000130.png" alt="这里写图片描述"></p>
<p>在看<code>onDraw(Canvas canvas)</code>之前我们先来看两组动画，分别是选中状态时的动画以及未选中状态的动画：</p>
<pre><code> // 由未选中到选中的动画
private void checkedAnimation() {
    animatedValue = 0f;
    tickValue = 0f;
    // 选中时底色的动画
    mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    // 对勾的动画
    mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
    mTickValueAnimator.setInterpolator(new LinearInterpolator());
    mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            tickValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            //当底色的动画完成后再开始对勾的动画
            mTickValueAnimator.start();
            Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
        }
    });
    mValueAnimator.start();
}

// 由选中到未选中的动画
private void uncheckedAnimation() {
    animatedValue = 0f;
    mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateInterpolator());
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.start();
}
</code></pre><p>这两组动画在点击SmoothCheckBox的时候会调用。相似的，都是在动画执行中得到动画执行的进度，再来调用<code>postInvalidate();</code>让SmoothCheckBox重绘。看完这个之后就是终极大招<code>onDraw(Canvas canvas)</code>了:</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    drawBorder(canvas);
    drawTrim(canvas);
    if (isChecked) {
        drawTick(canvas);
    }
    canvas.restore();
}

// 画对勾
private void drawTick(Canvas canvas) {
    // 得到画对勾的进度
    float temp = tickValue * totalLength;
    Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
    //判断是否是刚开始画对勾的时候,即等于startPoint
    if (Float.compare(tickValue, 0f) == 0) {
        Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
        path.reset();
        path.moveTo(startPoint.x, startPoint.y);
    }
    // 如果画对勾的进度已经超过breakPoint的时候,即(breakPoint,endPoint]
    if (temp &gt; downLength) {
        path.moveTo(startPoint.x, startPoint.y);
        path.lineTo(breakPoint.x, breakPoint.y);
        Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
        path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
    } else {
        //画对勾的进度介于startPoinit和breakPoint之间，即(startPoint,breakPoint]
        Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
        path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
    }
    canvas.drawPath(path, tickPaint);
}

// 画边框
private void drawBorder(Canvas canvas) {
    float temp;
    // 通过animatedValue让边框产生一个“OverShooting”的动画
    if (animatedValue &gt; 1f) {
        temp = animatedValue * mRadius;
    } else {
        temp = mRadius;
    }
    canvas.drawCircle(center, center, temp, borderPaint);
}

// 画checkbox内部
private void drawTrim(Canvas canvas) {
    canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
}
</code></pre><p><code>onDraw(Canvas canvas)</code>代码中的逻辑基本都加了注释，主要就是原理搞懂了就比较简单了。在绘制对勾时要区分当前处于绘制对勾的哪种状态，然后对应做处理画出线条，剩下的就简单了。关于SmoothCheckBox的讲解到这里就差不多了。</p>
<p>下面就贴出SmoothCheckBox的完整代码：</p>
<pre><code>public class SmoothCheckBox extends View implements View.OnClickListener {

    // 动画持续时间
    private long duration;
    // 边框宽度
    private float mStrokeWidth;
    // 对勾宽度
    private float mTickWidth;
    // 内饰画笔
    private Paint trimPaint;
    // 边框画笔
    private Paint borderPaint;
    // 对勾画笔
    private Paint tickPaint;
    // 默认边框宽度
    private float defaultStrikeWidth;
    // 默认对勾宽度
    private float defaultTickWidth;
    // 宽度
    private int mWidth;
    // 高度
    private int mHeight;
    // 边框颜色
    private int borderColor;
    // 内饰颜色
    private int trimColor;
    // 对勾颜色
    private int tickColor;
    // 半径
    private int mRadius;
    // 中心点
    private int center;
    // 是否是选中
    private boolean isChecked;
    //对勾向下的长度
    private float downLength;
    //对勾向上的长度
    private float upLength;
    // 对勾的总长度
    private float totalLength;
    // 监听器
    private OnCheckedChangeListener listener;

    private ValueAnimator mValueAnimator;

    private ValueAnimator mTickValueAnimator;

    private float animatedValue;

    private float tickValue;
    // 对勾开始点
    private Point startPoint = new Point();
    // 对勾转折点
    private Point breakPoint = new Point();
    // 对勾结束点
    private Point endPoint = new Point();

    private static final String TAG = &quot;SmoothCheckBox&quot;;

    private static final String KEY_INSTANCE_STATE = &quot;InstanceState&quot;;

    private Path path = new Path();

    public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
        this.listener = listener;
    }

    public SmoothCheckBox(Context context) {
        this(context, null);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.SmoothCheckBox);
        duration = a.getInt(R.styleable.SmoothCheckBox_duration, 600);

        defaultStrikeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, getResources().getDisplayMetrics());
        mStrokeWidth = a.getDimension(R.styleable.SmoothCheckBox_strikeWidth, defaultStrikeWidth);
        defaultTickWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
        mTickWidth = a.getDimension(R.styleable.SmoothCheckBox_tickWidth, defaultTickWidth);
        borderColor = a.getColor(R.styleable.SmoothCheckBox_borderColor, getResources().getColor(android.R.color.darker_gray));
        trimColor = a.getColor(R.styleable.SmoothCheckBox_trimColor, getResources().getColor(android.R.color.holo_green_light));
        tickColor = a.getColor(R.styleable.SmoothCheckBox_tickColor, getResources().getColor(android.R.color.white));
        a.recycle();

        trimPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        trimPaint.setStyle(Paint.Style.FILL);
        trimPaint.setColor(trimColor);

        borderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        borderPaint.setStrokeWidth(mStrokeWidth);
        borderPaint.setColor(borderColor);
        borderPaint.setStyle(Paint.Style.STROKE);

        tickPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        tickPaint.setColor(tickColor);
        tickPaint.setStyle(Paint.Style.STROKE);
        tickPaint.setStrokeCap(Paint.Cap.ROUND);
        tickPaint.setStrokeWidth(mTickWidth);

        setOnClickListener(this);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = 40;
        }

        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = 40;
        }
        setMeasuredDimension(mWidth, mHeight);
        int size = Math.min(mWidth, mHeight);
        center = size / 2;
        mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
        startPoint.set(center * 14 / 30, center * 28 / 30);
        breakPoint.set(center * 26 / 30, center * 40 / 30);
        endPoint.set(center * 44 / 30, center * 20 / 30);

        downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
        upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
        totalLength = downLength + upLength;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        drawBorder(canvas);
        drawTrim(canvas);
        if (isChecked) {
            drawTick(canvas);
        }
        canvas.restore();
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INSTANCE_STATE, super.onSaveInstanceState());
        bundle.putBoolean(KEY_INSTANCE_STATE, isChecked);
        return bundle;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            Bundle bundle = (Bundle) state;
            boolean isChecked = bundle.getBoolean(KEY_INSTANCE_STATE);
            setChecked(isChecked);
            super.onRestoreInstanceState(bundle.getParcelable(KEY_INSTANCE_STATE));
            return;
        }
        super.onRestoreInstanceState(state);
    }

    // 切换状态
    private void toggle() {
        isChecked = !isChecked;
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
        if (isChecked) {
            checkedAnimation();
        } else {
            uncheckedAnimation();
        }
    }

    // 由未选中到选中的动画
    private void checkedAnimation() {
        animatedValue = 0f;
        tickValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
        mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
        mTickValueAnimator.setInterpolator(new LinearInterpolator());
        mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                tickValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                mTickValueAnimator.start();
                Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
            }
        });
        mValueAnimator.start();
    }

    // 由选中到未选中的动画
    private void uncheckedAnimation() {
        animatedValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateInterpolator());
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.start();
    }

    // 画对勾
    private void drawTick(Canvas canvas) {
        float temp = tickValue * totalLength;
        Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
        if (Float.compare(tickValue, 0f) == 0) {
            Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
            path.reset();
            path.moveTo(startPoint.x, startPoint.y);
        }
        if (temp &gt; downLength) {
            path.moveTo(startPoint.x, startPoint.y);
            path.lineTo(breakPoint.x, breakPoint.y);
            Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
            path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
        } else {
            Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
            path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
        }
        canvas.drawPath(path, tickPaint);
    }

    // 画边框
    private void drawBorder(Canvas canvas) {
        float temp;
        if (animatedValue &gt; 1f) {
            temp = animatedValue * mRadius;
        } else {
            temp = mRadius;
        }
        canvas.drawCircle(center, center, temp, borderPaint);
    }

    // 画checkbox内部
    private void drawTrim(Canvas canvas) {
        canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
    }

    @Override
    public void onClick(View view) {
        toggle();
    }

    /**
     * 判断checkbox是否选中状态
     *
     * @return
     */
    public boolean isChecked() {
        return isChecked;
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked 是否选中
     */
    public void setChecked(boolean isChecked) {
        this.setChecked(isChecked, false);
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked   是否选中
     * @param isAnimation 切换时是否有动画
     */
    public void setChecked(boolean isChecked, boolean isAnimation) {
        this.isChecked = isChecked;
        if (isAnimation) {
            if (isChecked) {
                checkedAnimation();
            } else {
                uncheckedAnimation();
            }
        } else {
            animatedValue = isChecked ? 1f : 0f;
            tickValue = 1f;
            invalidate();
        }
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
    }

    public interface OnCheckedChangeListener {
        void onCheckedChanged(SmoothCheckBox smoothCheckBox, boolean isChecked);
    }
}
</code></pre><p>下面是SmoothCheckBox的源码下载，如果有问题可以在下面留言来交流：</p>
<p><a href="/uploads/20151205/SmoothCheckBox.rar">SmoothCheckBox.rar</a></p>
<p>GitHub:</p>
<p><a href="https://github.com/yuqirong/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探Android ORM框架之greenDAO]]></title>
    <link href="http://yuqirong.me/2015/11/24/%E5%88%9D%E6%8E%A2Android%20ORM%E6%A1%86%E6%9E%B6%E4%B9%8BgreenDAO/"/>
    <id>http://yuqirong.me/2015/11/24/初探Android ORM框架之greenDAO/</id>
    <published>2015-11-24T13:14:30.000Z</published>
    <updated>2016-02-21T14:20:16.913Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许多ORM (对象关系映射 英语：Object Relational Mapping) 的第三方框架，比如greenDAO、ActiveAndroid、ormlite等。说到ORM，相信有过J2EE开发经验的童鞋对此并不陌生，在web开发中就有Hibernate、MyBatis等框架提供使用。那么今天就来介绍一下主角：greenDAO。</p>
<p>根据 <a href="http://greenrobot.org/" target="_blank" rel="external">greenrobot</a> 官方的介绍，greenDAO是一款轻量，快速，适用于Android数据库的ORM框架。具有很高的性能以及消耗很少的内存。其他的优点和特性就不在这里一一介绍了，想要了解的同学可以去访问它的项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a>。</p>
<p>说了这么多，下面就开始我们的正题吧。</p>
<p>在使用greenDAO之前，我们有一件事情不得不做，那就是用代码生成器生成数据模型以及xxxDao等</p>
<p>新建一个java module，取名greendaogeneration(名字随意取，不要在意细节↖(^ω^)↗)，然后在build.gradle(Module:greendaogeneration)中添加依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao-generator:2.0.0&#39;</code></p>
<p>在 src/main 目录下新建一个与 java 同层级的 java-gen 目录，然后配置 Android 工程的 build.gradle(Module:app)，分别添加如下sourceSets。</p>
<pre><code>android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.yuqirong.greendaodemo&quot;
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
    sourceSets {
        main {
            java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/java-gen&apos;]
        }
    }
}
</code></pre><p>然后在greendaogeneration中创建一个GreenDaoGeneration类，用于生成代码：</p>
<pre><code>public class GreenDaoGeneration {

    public static void main(String[] arg0) {

        try {
            Schema schema = new Schema(1, &quot;com.yuqirong.greendao&quot;);
            addLocation(schema);
            new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void addLocation(Schema schema){
        Entity location= schema.addEntity(&quot;Location&quot;);
        location.addIdProperty();
        location.addDoubleProperty(&quot;lon&quot;);
        location.addIntProperty(&quot;level&quot;);
        location.addStringProperty(&quot;address&quot;);
        location.addStringProperty(&quot;city_name&quot;);
        location.addIntProperty(&quot;alevel&quot;);
        location.addDoubleProperty(&quot;lat&quot;);
    }
}
</code></pre><p>其中在创建Schema对象的参数中，第一个表示数据库的版本号，我们传入了“1”，第二个参数是生成代码的包名，我们传入了”com.yuqirong.greendao”，那么生成的代码就自动在”com.yuqirong.greendao”包下了。</p>
<p>在addLocatiion方法中，我们打算把“Location”这个类(其实到现在为止，Location实体类还未生成)保存在数据库中，<code>schema.addEntity(&quot;Location&quot;)</code>传入的Location，那么该表的表名就叫Location，然后我们又定义了在Location表中会有lon、lat、city_name三个字段。所以如果你想创建多张表，那么就要像addLocation()这样的方法多写几个。好了，该做的差不多都做了，最后再<code>new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);</code>把之前的schema传入，第二个参数传的是之前创建的java-gen的路径(建议传入绝对路径，之前在这里被坑了好久↖(~^~)↗)。代码运行之后再到”com.yuqirong.greendao”路径下去看，发现会有许多类生成：</p>
<p><img src="/uploads/20151124/20151124235609.png" alt="这里写图片描述"></p>
<p>至于这些类的作用，我们到下面再说。</p>
<p>第二步在Android Studio的build.gradle(Module:app)中添加以下依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao:2.0.0&#39;</code>  </p>
<p>这样我们就可以在项目中使用greenDAO了。</p>
<p>在正式使用greenDAO前我们需要了解几个greenDAO中的类(也就是上面代码生成的几个类)：</p>
<ul>
<li><p>DaoMaster ：一看这个类名我们就知道这个类肯定是大总管级别的，DaoMaster继承自AbstractDaoMaster。在AbstractDaoMaster中保存了sqlitedatebase对象以及以Map的形式保存了各种操作DAO。DaoMaster还提供了一些创建和删除table的静态方法。另外在DaoMaster类里面有一个静态内部类DevOpenHelper，DevOpenHelper间接继承了SQLiteOpenHelper，通常我们会用<code>new DaoMaster.DevOpenHelper(this, &quot;notes-db&quot;, null)</code>来得到一个DevOpenHelper对象，第一个参数是Context，第二个参数是数据库名，第三个参数是CursorFactory，通常我们传入null。就上面这样简单的一句话你就实际上创建了一个SQLiteOpenHelper对象，而不需要输入<code>&quot;CREATE TABLE...&quot;</code> SQL语句，greenDAO已经帮你做好了一切。</p>
</li>
<li><p>DaoSession：会话层。主要功能就是操作具体的DAO对象，比如各种getXXXDao()方法。</p>
</li>
<li><p>XXXDao：实际生成的DAO类(即生成的LocationDao)，主要对应于某张表的CRUD，比如说LocationDao，那相对应就是对Location表的操作。</p>
</li>
<li><p>XXXEntity：主要是各个实体类(也就是上面生成的Location)，里面的属性与表中的字段相对应。比如上面的LocationDao，那么实体类就是Location，Location实体类中有lon，lat，city_name,alevel,level,address六个属性，那么在Location表中就有lon，lat，city_name,alevel,level,address六个字段。</p>
</li>
</ul>
<p>通过上面几个类作用的介绍，相信大家对greenDAO有了一个初步的印象，下面我们就要真枪实弹了，一起来看一个简单的Demo吧：</p>
<pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(context, &quot;location&quot;, null);
SQLiteDatabase writableDB = devOpenHelper.getWritableDatabase();
DaoMaster daoMaster = new DaoMaster(writableDB);
DaoSession daoSession = daoMaster.newSession();
</code></pre><p>上面的代码很简单，我们创建了一个名叫“location”的数据库，然后通过daoMaster得到了daoSession，有了daoSession，我们就可以得到各种xxxDao，之后的CRUD都是通过xxxDao来操作。</p>
<pre><code>LocationDao locationDao = daoSession.getLocationDao();
Location local = new Location(null,120.15507,2,&quot;&quot;,&quot;杭州市&quot;,4,30.27408);
locationDao.insert(local);
</code></pre><p>我们创建了一个Location的对象，然后调用<code>locationDao.insert()</code>方法就把local的数据插入到location的表中，是不是简单到难以让人置信?!只需要三行代码，而不再需要原生的ContentValues了。不得不感叹greenDAO太方便了。</p>
<p>除了添加数据的，greenDAO还提供删除数据的方法：<code>locationDao.deleteByKey(id);</code>id为当前要删除的那行的主键。</p>
<p>更新数据的方法：<code>locationDao.update(local);</code>local为新的数据。</p>
<p>查询数据的方法： </p>
<ul>
<li><code>locationDao.queryRaw(String where, String...selectionArg)</code>,可以看到greenDAO支持sql语句查询。</li>
<li><p>greenDAO还支持一种更为简单的查询方式，不再需要你去写sql语句(查询Location的lon大于120度和lat大于30度)： </p>
<pre><code>List&lt;Location&gt; list = locationDao.queryBuilder()
                        .where(LocationDao.Properties.Lat.gt(30d), LocationDao.Properties.Lon.gt(120d))
                        .build()
                        .list();
</code></pre></li>
</ul>
<p>好了，关于greenDAO的简单使用就先到这里，至于深入使用我们有机会再讲吧！</p>
<p>依据惯例，下面提供本Demo的源码:</p>
<p><a href="/uploads/20151124/GreenDaoDemo.rar">GreenDaoDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许]]>
    </summary>
    
      <category term="greenDAO" scheme="http://yuqirong.me/tags/greenDAO/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
