<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[俞其荣的博客 | Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2019-03-18T15:51:43.149Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Apk安全之校验签名]]></title>
    <link href="http://yuqirong.me/2019/03/18/Apk%E5%AE%89%E5%85%A8%E4%B9%8B%E6%A0%A1%E9%AA%8C%E7%AD%BE%E5%90%8D/"/>
    <id>http://yuqirong.me/2019/03/18/Apk安全之校验签名/</id>
    <published>2019-03-18T15:17:31.000Z</published>
    <updated>2019-03-18T15:51:43.149Z</updated>
    <content type="html"><![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防护，比如代码混淆、加固等。</p>
<p>今天就来讲讲其中的一项：校验签名。</p>
<p>校验签名可以有效的防止二次打包，避免你的 app 被植入广告甚至破解等。而今天就从两个角度来讲签名的具体校验：</p>
<ul>
<li>Java 层</li>
<li>C/C++ 层</li>
</ul>
<p>那么就先开始讲 java 层好了。</p>
<h1 id="Java__u5C42"><a href="#Java__u5C42" class="headerlink" title="Java 层"></a>Java 层</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">validateAppSignature</span><span class="params">(Context context, String apkSignature)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        PackageManager packageManager = context.getApplicationContext().getPackageManager();</span><br><span class="line">        PackageInfo packageInfo = packageManager.getPackageInfo(context.getPackageName(), PackageManager.GET_SIGNATURES);</span><br><span class="line">        <span class="keyword">for</span> (Signature signature : packageInfo.signatures) &#123;</span><br><span class="line">            String lowerCaseSignature = signature.toCharsString().toLowerCase();</span><br><span class="line">            <span class="keyword">if</span> (lowerCaseSignature.equals(apkSignature)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PackageManager.NameNotFoundException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Java 层的签名校验核心代码就这些，传入的两个参数 ：</p>
<ul>
<li>Context context : 一般都是 Application</li>
<li>String apkSignature : 你的 apk 的正式签名</li>
</ul>
<p>Java 层的签名校验比较容易被攻破，因为别人可以反编译一下，然后在 smali 中把 validateAppSignature 方法的返回值改成 true 就大功告成了。</p>
<p>也正因为如此，所以需要在 C/C++ 层中也加入签名校验。</p>
<h1 id="C/C++__u5C42"><a href="#C/C++__u5C42" class="headerlink" title="C/C++ 层"></a>C/C++ 层</h1><p>在 so 文件加载的时候，会去调用 JNI_OnLoad 函数，所以我们可以在这里做签名校验。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JNIEXPORT jint <span class="title">JNI_OnLoad</span><span class="params">(JavaVM *vm, <span class="keyword">void</span> *reserved)</span> </span>&#123;</span><br><span class="line">    JNIEnv *env = <span class="literal">NULL</span>;</span><br><span class="line">    jint result = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> ((*vm)-&gt;GetEnv(vm, (<span class="keyword">void</span> **) &amp;env, JNI_VERSION_1_6) != JNI_OK) &#123;</span><br><span class="line">        LOGE(<span class="string">"no jni version 1.6"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (checkAppSignature(env) != JNI_TRUE) &#123;</span><br><span class="line">        LOGE(<span class="string">"the signature of apk is invalid"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> JNI_VERSION_1_6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>签名校验的代码主要在 checkAppSignature 函数中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">checkAppSignature</span><span class="params">(JNIEnv *env)</span> </span>&#123;</span><br><span class="line">    jclass classNativeContext = (*env)-&gt;FindClass(env, <span class="string">"me/yuqirong/security/Security"</span>);</span><br><span class="line">    jmethodID midGetAppContext = (*env)-&gt;GetStaticMethodID(env, classNativeContext,</span><br><span class="line">                                                        <span class="string">"getContext"</span>,</span><br><span class="line">                                                        <span class="string">"()Landroid/content/Context;"</span>);</span><br><span class="line">    jobject appContext = (*env)-&gt;CallStaticObjectMethod(env, classNativeContext, midGetAppContext);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (appContext != NULL) &#123;</span><br><span class="line">        jboolean signatureValid = Android_checkSignature(env, NULL, appContext);</span><br><span class="line">        <span class="keyword">return</span> signatureValid;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        LOGE(<span class="string">"app context is null, please check the context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> JNI_FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出来，checkAppSignature 主要是通过 C 的代码反射来获取 Context 。</p>
<p>对应的 Java 层代码如下，一般来说， <code>Security.setContext(application)</code> 会在 Application.onCreate 方法中调用 :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Security</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> Application application;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Context <span class="title">getContext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> application;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(Application context)</span> </span>&#123;</span><br><span class="line">	    application = context;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取到 Context 之后，就可以来比较签名了 ：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* APP_SIGNATURE = <span class="string">"input your signature of apk"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> jboolean <span class="title">Android_checkSignature</span><span class="params">(</span><br><span class="line">        JNIEnv *env, jclass clazz, jobject context)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    jstring appSignature = loadSignature(env, context);</span><br><span class="line">    jstring releaseSignature = (*env)-&gt;NewStringUTF(env, APP_SIGNATURE);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charAppSignature = (*env)-&gt;GetStringUTFChars(env, appSignature, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *charReleaseSignature = (*env)-&gt;GetStringUTFChars(env, releaseSignature, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    jboolean result = JNI_FALSE;</span><br><span class="line">    <span class="keyword">if</span> (charAppSignature != <span class="literal">NULL</span> &amp;&amp; charReleaseSignature != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(charAppSignature, charReleaseSignature) == <span class="number">0</span>) &#123;</span><br><span class="line">            LOGI(<span class="string">"the signature of apk is valid, so pass it"</span>);</span><br><span class="line">            result = JNI_TRUE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, appSignature, charAppSignature);</span><br><span class="line">    (*env)-&gt;ReleaseStringUTFChars(env, releaseSignature, charReleaseSignature);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 APP_SIGNATURE 就是正式版的签名字符串，而 loadSignature 函数需要反射安卓系统的 API 才能获得。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> jstring <span class="title">loadSignature</span><span class="params">(JNIEnv *env, jobject context)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得Context类</span></span><br><span class="line">    jclass cls = (*env)-&gt;GetObjectClass(env, context);</span><br><span class="line">    <span class="comment">// 得到getPackageManager方法的ID</span></span><br><span class="line">    jmethodID mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageManager"</span>, <span class="string">"()Landroid/content/pm/PackageManager;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得应用包的管理器</span></span><br><span class="line">    jobject pm = (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到getPackageName方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageName"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 获得当前应用包名</span></span><br><span class="line">    jstring packageName = (jstring) (*env)-&gt;CallObjectMethod(env, context, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得PackageManager类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, pm);</span><br><span class="line">    <span class="comment">// 得到getPackageInfo方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"getPackageInfo"</span>, <span class="string">"(Ljava/lang/String;I)Landroid/content/pm/PackageInfo;"</span>);</span><br><span class="line">    <span class="comment">// 获得应用包的信息</span></span><br><span class="line">    jobject packageInfo = (*env)-&gt;CallObjectMethod(env, pm, mid, packageName, <span class="number">0x40</span>); <span class="comment">//GET_SIGNATURES = 64;</span></span><br><span class="line">    <span class="comment">// 获得PackageInfo 类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, packageInfo);</span><br><span class="line">    <span class="comment">// 获得签名数组属性的ID</span></span><br><span class="line">    jfieldID fid = (*env)-&gt;GetFieldID(env, cls, <span class="string">"signatures"</span>, <span class="string">"[Landroid/content/pm/Signature;"</span>);</span><br><span class="line">    <span class="comment">// 得到签名数组</span></span><br><span class="line">    jobjectArray signatures = (jobjectArray) (*env)-&gt;GetObjectField(env, packageInfo, fid);</span><br><span class="line">    <span class="comment">// 得到签名</span></span><br><span class="line">    jobject signature = (*env)-&gt;GetObjectArrayElement(env, signatures, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获得Signature类</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signature);</span><br><span class="line">    <span class="comment">// 得到toCharsString方法的ID</span></span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toCharsString"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    <span class="comment">// 返回当前应用签名信息</span></span><br><span class="line">    jstring signatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signature, mid);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// toLowerCase</span></span><br><span class="line">    cls = (*env)-&gt;GetObjectClass(env, signatureString);</span><br><span class="line">    mid = (*env)-&gt;GetMethodID(env, cls, <span class="string">"toLowerCase"</span>, <span class="string">"()Ljava/lang/String;"</span>);</span><br><span class="line">    jstring lowerCaseSignatureString = (jstring) (*env)-&gt;CallObjectMethod(env, signatureString, mid);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> lowerCaseSignatureString;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>loadSignature 函数可以说就是用 C 语言把上面 Java 的那段代码实现了一遍，并没有什么差别。</p>
<p>至此，有了 Java 和 C/C++ 的双重保护，app 的安全性又提升了一级。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u6821_u9A8C_u7B7E_u540D"><a href="#u6821_u9A8C_u7B7E_u540D" class="headerlink" title="校验签名"></a>校验签名</h1><p>一般绝大多数的 app 在上线前都会做一层安全防]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(六):补丁合成流程]]></title>
    <link href="http://yuqirong.me/2019/03/14/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%85%AD)/"/>
    <id>http://yuqirong.me/2019/03/14/Tinker源码分析(六)/</id>
    <published>2019-03-14T15:05:56.000Z</published>
    <updated>2019-03-14T15:41:53.172Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="headerlink" title="补丁合成流程"></a>补丁合成流程</h1><p>下发的补丁包其实并不能直接加载，因为补丁包只是差异包，需要和本地的 dex 、资源等进行合成后，得到全量的 dex 才能被完整地使用。这样也就避免了热修复中 dex 的 pre-verify 问题，也减少了补丁包的体积，方便用户下载。</p>
<p>补丁合成的入口在 TinkerInstaller.onReceiveUpgradePatch 方法</p>
<h1 id="TinkerInstaller-onReceiveUpgradePatch"><a href="#TinkerInstaller-onReceiveUpgradePatch" class="headerlink" title="TinkerInstaller.onReceiveUpgradePatch"></a>TinkerInstaller.onReceiveUpgradePatch</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">onReceiveUpgradePatch</span><span class="params">(Context context, String patchLocation)</span> </span>&#123;</span><br><span class="line">    Tinker.with(context).getPatchListener().onPatchReceived(patchLocation);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 PatchListener 有默认实现类，即 DefaultPatchListener 。</p>
<h1 id="DefaultPatchListener-onPatchReceived"><a href="#DefaultPatchListener-onPatchReceived" class="headerlink" title="DefaultPatchListener.onPatchReceived"></a>DefaultPatchListener.onPatchReceived</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onPatchReceived</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line">    <span class="comment">// 对补丁进行校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = patchCheck(path, SharePatchFileUtil.getMD5(patchFile));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PATCH_OK) &#123;</span><br><span class="line">        <span class="comment">// 通过的话就启动 :process 进程进行补丁合成    </span></span><br><span class="line">        TinkerPatchService.runPatchService(context, path);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 校验失败就回调 onLoadPatchListenerReceiveFail</span></span><br><span class="line">        Tinker.with(context).getLoadReporter().onLoadPatchListenerReceiveFail(<span class="keyword">new</span> File(path), returnCode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们直接来看 TinkerPatchService.runPatchService 方法</p>
<h1 id="TinkerPatchService-runPatchService"><a href="#TinkerPatchService-runPatchService" class="headerlink" title="TinkerPatchService.runPatchService"></a>TinkerPatchService.runPatchService</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runPatchService</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> String path)</span> </span>&#123;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"run patch service..."</span>);</span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(context, TinkerPatchService.class);</span><br><span class="line">    <span class="comment">// path 就是补丁的路径</span></span><br><span class="line">    intent.putExtra(PATCH_PATH_EXTRA, path);</span><br><span class="line">    <span class="comment">// RESULT_CLASS_EXTRA 一般默认就是 DefaultTinkerResultService</span></span><br><span class="line">    intent.putExtra(RESULT_CLASS_EXTRA, resultServiceClass.getName());</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        enqueueWork(context, TinkerPatchService.class, JOB_ID, intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"run patch service fail, exception:"</span> + thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 runPatchService 中去启动了 TinkerPatchService 。TinkerPatchService 是跑在 :patch<br> 进程中的。</p>
<p>TinkerPatchService 主要做的事情都在 onHandleWork 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onHandleWork</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 提高优先级</span></span><br><span class="line">    increasingPriority();</span><br><span class="line">    <span class="comment">// 合成补丁</span></span><br><span class="line">    doApplyPatch(<span class="keyword">this</span>, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先是 increasingPriority 方法，目的就是提高 service 的优先级，具体的方案就是设置为前台服务</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">increasingPriority</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">26</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for system version &gt;= Android O, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash or toasts."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"ZUK"</span>.equals(Build.MANUFACTURER)) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"for ZUK device, we just ignore increasingPriority "</span></span><br><span class="line">                + <span class="string">"job to avoid crash."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"try to increase patch process priority"</span>);</span><br><span class="line">    <span class="comment">// 设置为前台服务，提高优先级</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Notification notification = <span class="keyword">new</span> Notification();</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startForeground(notificationId, notification);</span><br><span class="line">            <span class="comment">// start InnerService</span></span><br><span class="line">            startService(<span class="keyword">new</span> Intent(<span class="keyword">this</span>, InnerService.class));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"try to increase patch process priority error:"</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着是 doApplyPatch 方法，在这里做补丁合成的事</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">doApplyPatch</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Since we may retry with IntentService, we should prevent</span></span><br><span class="line">    <span class="comment">// racing here again.</span></span><br><span class="line">    <span class="keyword">if</span> (!sIsPatchApplying.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">        TinkerLog.w(TAG, <span class="string">"TinkerPatchService doApplyPatch is running by another runner."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    tinker.getPatchReporter().onPatchServiceStart(intent);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService received a null intent, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取补丁文件的路径</span></span><br><span class="line">    String path = getPatchPathExtra(intent);</span><br><span class="line">    <span class="keyword">if</span> (path == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"TinkerPatchService can't get the path extra, ignoring."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    File patchFile = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    <span class="keyword">boolean</span> result;</span><br><span class="line">    <span class="keyword">long</span> cost;</span><br><span class="line">    Throwable e = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    PatchResult patchResult = <span class="keyword">new</span> PatchResult();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (upgradePatchProcessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"upgradePatchProcessor is null."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 处理补丁合成</span></span><br><span class="line">        result = upgradePatchProcessor.tryPatch(context, path, patchResult);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        e = throwable;</span><br><span class="line">        result = <span class="keyword">false</span>;</span><br><span class="line">        tinker.getPatchReporter().onPatchException(patchFile, e);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    tinker.getPatchReporter().</span><br><span class="line">        onPatchResult(patchFile, result, cost);</span><br><span class="line"></span><br><span class="line">    patchResult.isSuccess = result;</span><br><span class="line">    patchResult.rawPatchFilePath = path;</span><br><span class="line">    patchResult.costTime = cost;</span><br><span class="line">    patchResult.e = e;</span><br><span class="line">    <span class="comment">// 补丁合成的结果回调给 DefaultResultService</span></span><br><span class="line">    AbstractResultService.runResultService(context, patchResult, getPatchResultExtra(intent));</span><br><span class="line"></span><br><span class="line">    sIsPatchApplying.set(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>upgradePatchProcessor 是一个接口，具体的实现类是 UpgradePatch 。</p>
<h1 id="UpgradePatch-tryPatch"><a href="#UpgradePatch-tryPatch" class="headerlink" title="UpgradePatch.tryPatch"></a>UpgradePatch.tryPatch</h1><p>那么来看看 UpgradePatch.tryPatch ，方法比较长，分段来看吧。</p>
<p>首先是对 Tinker 自身开关的校验，然后对补丁文件的合法性进行校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryPatch</span><span class="params">(Context context, String tempPatchPath, PatchResult patchResult)</span> </span>&#123;</span><br><span class="line">    Tinker manager = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> File patchFile = <span class="keyword">new</span> File(tempPatchPath);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!manager.isTinkerEnabled() || !ShareTinkerInternals.isTinkerEnableWithSharedPreferences(context)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch is disabled, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchFile)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch file is not found, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>然后检查补丁包的签名以及 tinkerId , 这里的操作和加载补丁是一样的。</p>
<p>然后就是获取补丁文件的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check the signature, we should create a new checker</span></span><br><span class="line">ShareSecurityCheck signatureCheck = <span class="keyword">new</span> ShareSecurityCheck(context);</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(context, manager.getTinkerFlags(), patchFile, signatureCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchPackageCheckFail"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchPackageCheckFail(patchFile, returnCode);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取补丁文件的 md5</span></span><br><span class="line">String patchMd5 = SharePatchFileUtil.getMD5(patchFile);</span><br><span class="line"><span class="keyword">if</span> (patchMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:patch md5 is null, just return"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//use md5 as version</span></span><br><span class="line"><span class="comment">// 用 md5 做版本号</span></span><br><span class="line">patchResult.patchVersion = patchMd5;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchMd5:%s"</span>, patchMd5);</span><br></pre></td></tr></table></figure>
<p>接着，校验完成后，我们就来构造一个新的 patch.info 文件了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check ok, we can real recover a new patch</span></span><br><span class="line"><span class="keyword">final</span> String patchDirectory = manager.getPatchDirectory().getAbsolutePath();</span><br><span class="line"></span><br><span class="line"><span class="comment">// info.lock 文件</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectory);</span><br><span class="line"><span class="comment">// patch.info 文件</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 读取出老的 patch.info 文件，可能存在 可能不存在</span></span><br><span class="line">SharePatchInfo oldInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"></span><br><span class="line"><span class="comment">//it is a new patch, so we should not find a exist</span></span><br><span class="line">SharePatchInfo newInfo;</span><br><span class="line"></span><br><span class="line"><span class="comment">//如果有老的 patch.info 文件</span></span><br><span class="line"><span class="keyword">if</span> (oldInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (oldInfo.oldVersion == <span class="keyword">null</span> || oldInfo.newVersion == <span class="keyword">null</span> || oldInfo.oatDir == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchInfoCorrupted"</span>);</span><br><span class="line">        manager.getPatchReporter().onPatchInfoCorrupted(patchFile, oldInfo.oldVersion, oldInfo.newVersion);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkIfMd5Valid(patchMd5)) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:onPatchVersionCheckFail md5 %s is valid"</span>, patchMd5);</span><br><span class="line">        manager.getPatchReporter().onPatchVersionCheckFail(patchFile, oldInfo, patchMd5);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// if it is interpret now, use changing flag to wait main process</span></span><br><span class="line">    <span class="keyword">final</span> String finalOatDir = oldInfo.oatDir.equals(ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH)</span><br><span class="line">        ? ShareConstants.CHANING_DEX_OPTIMIZE_PATH : oldInfo.oatDir;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(oldInfo.oldVersion, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, finalOatDir);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 构造新的 patch.info </span></span><br><span class="line">    newInfo = <span class="keyword">new</span> SharePatchInfo(<span class="string">""</span>, patchMd5, <span class="keyword">false</span>, Build.FINGERPRINT, ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再接下来，就是把补丁包复制到私有目录中</p>
<p>具体的路径也就是之前在加载补丁中遇到的 /data/data/应用包名/tinker/patch-xxxxxx/patch-xxxxxx.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//it is a new patch, we first delete if there is any files</span></span><br><span class="line"><span class="comment">//don't delete dir for faster retry</span></span><br><span class="line"><span class="comment">//        SharePatchFileUtil.deleteDir(patchVersionDirectory);</span></span><br><span class="line"><span class="keyword">final</span> String patchName = SharePatchFileUtil.getPatchVersionDirectory(patchMd5);</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> String patchVersionDirectory = patchDirectory + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">TinkerLog.i(TAG, <span class="string">"UpgradePatch tryPatch:patchVersionDirectory:%s"</span>, patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="comment">//copy file</span></span><br><span class="line">File destPatchFile = <span class="keyword">new</span> File(patchVersionDirectory + <span class="string">"/"</span> + SharePatchFileUtil.getPatchVersionFile(patchMd5));</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">// check md5 first</span></span><br><span class="line">  <span class="keyword">if</span> (!patchMd5.equals(SharePatchFileUtil.getMD5(destPatchFile))) &#123;</span><br><span class="line">      <span class="comment">// 复制补丁包到 /data/data/ 中</span></span><br><span class="line">      SharePatchFileUtil.copyFileUsingStream(patchFile, destPatchFile);</span><br><span class="line">      TinkerLog.w(TAG, <span class="string">"UpgradePatch copy patch file, src file: %s size: %d, dest file: %s size:%d"</span>, patchFile.getAbsolutePath(), patchFile.length(),</span><br><span class="line">          destPatchFile.getAbsolutePath(), destPatchFile.length());</span><br><span class="line">  &#125;</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">  TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:copy patch file fail from %s to %s"</span>, patchFile.getPath(), destPatchFile.getPath());</span><br><span class="line">  manager.getPatchReporter().onPatchTypeExtractFail(patchFile, destPatchFile, patchFile.getName(), ShareConstants.TYPE_PATCH_FILE);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制好之后，就是把补丁包和基准包进行整合了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//we use destPatchFile instead of patchFile, because patchFile may be deleted during the patch process</span></span><br><span class="line"><span class="comment">// 合成 dex</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.tryRecoverDexFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch dex failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成 so 文件</span></span><br><span class="line"><span class="keyword">if</span> (!BsDiffPatchInternal.tryRecoverLibraryFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch library failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 合成资源文件</span></span><br><span class="line"><span class="keyword">if</span> (!ResDiffPatchInternal.tryRecoverResourceFiles(manager, signatureCheck, context, patchVersionDirectory, destPatchFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, try patch resource failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里面的三个合成代码我们到后面的章节再分析，这里先跳过了。</p>
<p>合成完后，还要对 dex 进行opt优化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// check dex opt file at last, some phone such as VIVO/OPPO like to change dex2oat to interpreted</span></span><br><span class="line"><span class="keyword">if</span> (!DexDiffPatchInternal.waitAndCheckDexOptFile(patchFile, manager)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, check dex opt file failed"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是把结果重新写入到 patch.info ，这样在加载补丁的流程中就能加载新补丁了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, newInfo, patchInfoLockFile)) &#123;</span><br><span class="line">    TinkerLog.e(TAG, <span class="string">"UpgradePatch tryPatch:new patch recover, rewrite patch info failed"</span>);</span><br><span class="line">    manager.getPatchReporter().onPatchInfoCorrupted(patchFile, newInfo.oldVersion, newInfo.newVersion);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TinkerLog.w(TAG, <span class="string">"UpgradePatch tryPatch: done, it is ok"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>over ，整个合成补丁的流程讲完了，这里还留了三个坑：</p>
<ul>
<li>dex 文件的合成</li>
<li>so 文件的合成</li>
<li>资源文件的合成</li>
</ul>
<p>到后面再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u8865_u4E01_u5408_u6210_u6D41_u7A0B"><a href="#u8865_u4E01_u5408_u6210_u6D41_u7A0B" class="h]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(五):加载so补丁流程]]></title>
    <link href="http://yuqirong.me/2019/03/10/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%94)/"/>
    <id>http://yuqirong.me/2019/03/10/Tinker源码分析(五)/</id>
    <published>2019-03-10T14:50:22.000Z</published>
    <updated>2019-03-10T16:33:02.144Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="校验so补丁流程"></a>校验so补丁流程</h1><p>与加载资源补丁类似，加载so补丁也要先从校验开始看起。</p>
<p>其实总体来说，Tinker 中加载 so 补丁文件的关键代码就一句：</p>
<p>System.load(String filePath)</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>从 assets/so_meta.txt 中读取 so 补丁信息，每一条 so 补丁信息都会被封装成一个 ShareBsDiffPatchInfo 对象，然后放入 libraryList 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String meta = securityCheck.getMetaContentMap().get(SO_MEAT_FILE);</span><br><span class="line"><span class="comment">//not found lib</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">ArrayList&lt;ShareBsDiffPatchInfo&gt; libraryList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">ShareBsDiffPatchInfo.parseDiffPatchInfo(meta, libraryList);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (libraryList.isEmpty()) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后遍历 libraryList ，去校验里面的 ShareBsDiffPatchInfo 对象中 md5 和 name 值是否合法。合法的 ShareBsDiffPatchInfo 对象再放入 libs 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker//patch-641e634c/lib</span></span><br><span class="line">String libraryPath = directory + <span class="string">"/"</span> + SO_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">HashMap&lt;String, String&gt; libs = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareBsDiffPatchInfo info : libraryList) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!ShareBsDiffPatchInfo.checkDiffPatchInfo(info)) &#123;</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_LIB_META_CORRUPTED);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    String middle = info.path + <span class="string">"/"</span> + info.name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unlike dex, keep the original structure</span></span><br><span class="line">    libs.put(middle, info.md5);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着会校验 so 补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">File libraryDir = <span class="keyword">new</span> File(libraryPath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!libraryDir.exists() || !libraryDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再校验上面的从 so_meta.txt 中获取到的 so 补丁文件路径是否真的存在并且 so 文件是可读的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//fast check whether there is any dex files missing</span></span><br><span class="line"><span class="keyword">for</span> (String relative : libs.keySet()) &#123;</span><br><span class="line">    File libFile = <span class="keyword">new</span> File(libraryPath + relative);</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(libFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_LIB_FILE_NOT_EXIST);</span><br><span class="line">        intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISSING_LIB_PATH, libFile.getAbsolutePath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>都没问题的话，就通过校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//if is ok, add to result intent</span></span><br><span class="line">intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_LIBS_PATH, libs);</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h1 id="u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Dso_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载so补丁流程"></a>加载so补丁流程</h1><p>加载so补丁的入口：TinkerLoadLibrary.loadArmLibrary / TinkerLoadLibrary.loadArmV7Library ，区别就是前者用来加载 armeabi 平台的，后者是用来加载 armeabi-v7a 平台的。我们就来看 loadArmLibrary 方法吧。</p>
<h2 id="loadArmLibrary"><a href="#loadArmLibrary" class="headerlink" title="loadArmLibrary"></a>loadArmLibrary</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadArmLibrary</span><span class="params">(Context context, String libName)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 校验 libName 和 context 参数</span></span><br><span class="line">    <span class="keyword">if</span> (libName == <span class="keyword">null</span> || libName.isEmpty() || context == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"libName or context is null!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 这里需要保证已经调用了 Tinker.install 方法 不然 Tinker 没安装的话会抛出异常</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 tinker 支持 so 补丁，就加载外部的 so 文件</span></span><br><span class="line">    <span class="keyword">if</span> (tinker.isEnabledForNativeLib()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (TinkerLoadLibrary.loadLibraryFromTinker(context, <span class="string">"lib/armeabi"</span>, libName)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 tinker 不支持 so 补丁，就调用系统的加载方法</span></span><br><span class="line">    System.loadLibrary(libName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadLibraryFromTinker"><a href="#loadLibraryFromTinker" class="headerlink" title="loadLibraryFromTinker"></a>loadLibraryFromTinker</h2><p>loadLibraryFromTinker 一开始校验了 libName 的名字是否是 lib 开头、 .so 结尾的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">final</span> Tinker tinker = Tinker.with(context);</span><br><span class="line"></span><br><span class="line">    libName = libName.startsWith(<span class="string">"lib"</span>) ? libName : <span class="string">"lib"</span> + libName;</span><br><span class="line">    libName = libName.endsWith(<span class="string">".so"</span>) ? libName : libName + <span class="string">".so"</span>;</span><br><span class="line">    String relativeLibPath = relativePath + <span class="string">"/"</span> + libName;</span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">然后就是用 relativeLibPath 去和之前 so 校验得到的 libs 去一一匹配。</span><br><span class="line"></span><br><span class="line">如果匹配上了，就说明要加载的就是这个 so 文件，调用 System.load ，传入文件路径即可。</span><br><span class="line"></span><br><span class="line">``` java</span><br><span class="line"><span class="comment">//TODO we should add cpu abi, and the real path later</span></span><br><span class="line"><span class="comment">// tinker 支持 so 补丁并且 tinker 完成加载补丁</span></span><br><span class="line"><span class="keyword">if</span> (tinker.isEnabledForNativeLib() &amp;&amp; tinker.isTinkerLoaded()) &#123;</span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="comment">// 获取上面校验得到的 libs</span></span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (String name : loadResult.libs.keySet()) &#123;</span><br><span class="line">            <span class="comment">// 如果名字对上了，就说明要加载的就是这个外部的so补丁</span></span><br><span class="line">            <span class="keyword">if</span> (name.equals(relativeLibPath)) &#123;</span><br><span class="line">                String patchLibraryPath = loadResult.libraryDirectory + <span class="string">"/"</span> + name;</span><br><span class="line">                File library = <span class="keyword">new</span> File(patchLibraryPath);</span><br><span class="line">                <span class="comment">// 确认 so 补丁文件存在</span></span><br><span class="line">                <span class="keyword">if</span> (library.exists()) &#123;</span><br><span class="line">                    <span class="comment">//whether we check md5 when load</span></span><br><span class="line">                    <span class="keyword">boolean</span> verifyMd5 = tinker.isTinkerLoadVerify();</span><br><span class="line">                    <span class="comment">// 如果需要校验md5值但是校验失败了，就回调 onLoadFileMd5Mismatch 方法</span></span><br><span class="line">                    <span class="keyword">if</span> (verifyMd5 &amp;&amp; !SharePatchFileUtil.verifyFileMd5(library, loadResult.libs.get(name))) &#123;</span><br><span class="line">                        tinker.getLoadReporter().onLoadFileMd5Mismatch(library, ShareConstants.TYPE_LIBRARY);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// 否则就调用 System.load 方法，传入 so 补丁文件的路径即可</span></span><br><span class="line">                        System.load(patchLibraryPath);</span><br><span class="line">                        TinkerLog.i(TAG, <span class="string">"loadLibraryFromTinker success:"</span> + patchLibraryPath);</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，Tinker 中关于 so 补丁加载的流程就讲完了。</p>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>大家有没有发现，一个个单独去调用 TinkerLoadLibrary.loadArmLibrary 会很麻烦，因为如果我的 so 补丁文件有很多个，就需要调用很多次。所以从 Tinker v1.7.7 之后，提供了一键反射的方案来加载 so 补丁文件。</p>
<p>具体方法 TinkerLoadLibrary.installNavitveLibraryABI</p>
<h2 id="installNavitveLibraryABI"><a href="#installNavitveLibraryABI" class="headerlink" title="installNavitveLibraryABI"></a>installNavitveLibraryABI</h2><p>来看一下具体的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">installNavitveLibraryABI</span><span class="params">(Context context, String currentABI)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查 tinker 有没有安装</span></span><br><span class="line">    Tinker tinker = Tinker.with(context);</span><br><span class="line">    <span class="keyword">if</span> (!tinker.isTinkerLoaded()) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker is not loaded, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查 tinker 加载的结果</span></span><br><span class="line">    TinkerLoadResult loadResult = tinker.getTinkerLoadResultIfPresent();</span><br><span class="line">    <span class="keyword">if</span> (loadResult.libs == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"tinker libs is null, just return"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查当前 ABI 的 so 文件夹是否存在</span></span><br><span class="line">    File soDir = <span class="keyword">new</span> File(loadResult.libraryDirectory, <span class="string">"lib/"</span> + currentABI);</span><br><span class="line">    <span class="keyword">if</span> (!soDir.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"current libraryABI folder is not exist, path: %s"</span>, soDir.getPath());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 获取 classloader</span></span><br><span class="line">    ClassLoader classLoader = context.getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader == <span class="keyword">null</span>) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    TinkerLog.i(TAG, <span class="string">"before hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    <span class="comment">// 加载当前 ABI 的所有 so 补丁文件</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        installNativeLibraryPath(classLoader, soDir);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath fail:"</span> + throwable);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        TinkerLog.i(TAG, <span class="string">"after hack classloader:"</span> + classLoader.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在做了一堆的检查之后，具体 so 文件加载是在 installNativeLibraryPath 方法中。</p>
<h2 id="installNativeLibraryPath"><a href="#installNativeLibraryPath" class="headerlink" title="installNativeLibraryPath"></a>installNativeLibraryPath</h2><p>installNativeLibraryPath 中做的事情主要有两点：</p>
<ul>
<li>如果 classloader 中没有注入 so 补丁文件夹的路径的话，就执行注入；</li>
<li>如果 classloader 中已经有 so 补丁文件夹的路径了，就先删除，再进行注入；</li>
</ul>
<p>具体 hook 的代码根据 SDK 版本而定，这里就不展开讲了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installNativeLibraryPath</span><span class="params">(ClassLoader classLoader, File folder)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (folder == <span class="keyword">null</span> || !folder.exists()) &#123;</span><br><span class="line">        TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, folder %s is illegal"</span>, folder);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// android o sdk_int 26</span></span><br><span class="line">    <span class="comment">// for android o preview sdk_int 25</span></span><br><span class="line">    <span class="keyword">if</span> ((Build.VERSION.SDK_INT == <span class="number">25</span> &amp;&amp; Build.VERSION.PREVIEW_SDK_INT != <span class="number">0</span>)</span><br><span class="line">        || Build.VERSION.SDK_INT &gt; <span class="number">25</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V25.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v23</span></span><br><span class="line">            <span class="comment">// some preview N version may go here</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v25 fail, sdk: %d, error: %s, try to fallback to V23"</span>,</span><br><span class="line">                    Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            V23.install(classLoader, folder);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">            <span class="comment">// install fail, try to treat it as v14</span></span><br><span class="line">            TinkerLog.e(TAG, <span class="string">"installNativeLibraryPath, v23 fail, sdk: %d, error: %s, try to fallback to V14"</span>,</span><br><span class="line">                Build.VERSION.SDK_INT, throwable.getMessage());</span><br><span class="line"></span><br><span class="line">            V14.install(classLoader, folder);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        V14.install(classLoader, folder);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        V4.install(classLoader, folder);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>综上所述，有了 TinkerLoadLibrary.installNavitveLibraryABI 之后，你就只需要传入当前手机系统的 ABI ，就无需再对 so 的加载做任何的介入。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B"><a href="#u6821_u9A8Cso_u8865_u4E01_u6D41_u7A0B" clas]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(四):加载资源补丁流程]]></title>
    <link href="http://yuqirong.me/2019/03/05/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E5%9B%9B)/"/>
    <id>http://yuqirong.me/2019/03/05/Tinker源码分析(四)/</id>
    <published>2019-03-05T15:54:26.000Z</published>
    <updated>2019-03-09T17:25:07.915Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载资源补丁流程"></a>加载资源补丁流程</h1><p>将到资源补丁的加载，首先还要回过头来先看资源补丁的校验和检查。</p>
<p>我们回到 TinkerLoader.tryLoadPatchFilesInternal 方法中来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体的校验是在 TinkerResourceLoader.checkComplete 中完成的。这里为了校验的速度，所以只会校验资源补丁存不存在。</p>
<h2 id="checkComplete"><a href="#checkComplete" class="headerlink" title="checkComplete"></a>checkComplete</h2><p>checkComplete 方法我们分段来看吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 读取 assets/res_meta.txt </span></span><br><span class="line">String meta = securityCheck.getMetaContentMap().get(RESOURCE_META_FILE);</span><br><span class="line"><span class="comment">//not found resource</span></span><br><span class="line"><span class="keyword">if</span> (meta == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//only parse first line for faster</span></span><br><span class="line">ShareResPatchInfo.parseResPatchInfoFirstLine(meta, resPatchInfo);</span><br></pre></td></tr></table></figure>
<p>为了校验的速度，只读取了 assets/res_meta.txt 的第一行，并存入到 resPatchInfo 中</p>
<p>res_meta.txt 的第一行主要是资源的 crc 值和 md5 值 ，在后面会做校验。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (!ShareResPatchInfo.checkResPatchInfo(resPatchInfo)) &#123;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, ShareConstants.ERROR_PACKAGE_CHECK_RESOURCE_META_CORRUPTED);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验上面读取到的 md5 值是否为空以及 md5 值长度是否是 32 位</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">String resourcePath = directory + <span class="string">"/"</span> + RESOURCE_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">File resourceDir = <span class="keyword">new</span> File(resourcePath);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!resourceDir.exists() || !resourceDir.isDirectory()) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件夹是否存在。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">File resourceFile = <span class="keyword">new</span> File(resourcePath + RESOURCE_FILE);</span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(resourceFile)) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>校验资源补丁文件是否存在及合法性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    TinkerResourcePatcher.isResourceCanPatch(context);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"resource hook check failed."</span>, e);</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p>通过 context 来检查当前环境是否支持加载资源补丁。方法里面做的事就是通过反射来获取各种系统的属性和方法。简单地举例以下几种：</p>
<ul>
<li>ActivityThread : 当前的 ActivityThread 实例，app主线程的入口。利用 ActivityThread 可以获取到 LoadedApk 对象；</li>
<li>LoadedApk : 通过 LoadedApk 可以获取 mResDir 属性；</li>
<li>mResDir : 这个值很关键，就是资源文件的路径。在后面会被 hook 成资源补丁的路径；</li>
<li>addAssetPath : 通过 addAssetPath 方法将资源补丁文件加载进新的 AssetManager 中；</li>
<li>mActiveResources : ResourcesManager 的 Resources 容器。里面会存储着每个 apk 对应的 Resources 对象。mActiveResources 是 ArrayMap 类型的，不同的 apk 都有一个不同的 key 来获取对应的 apk 的 Resource 对象；</li>
<li>mAssets : 即 Resources 类中的 mAssets 属性，其实就是一个 AssetManager 对象。在资源打补丁的时候，Resources 中原来的 mAssets 对象会被替换成新的 AssetManager 对象。</li>
</ul>
<p>这里就不详细讲了，总结起来就一句话：获取 Android 系统中与资源有关的一些属性和方法，为接下来的加载资源补丁做准备。如果在 isResourceCanPatch 方法中报出异常了，就认为当前环境不能加载资源补丁了。</p>
<h2 id="tryLoadPatchFilesInternal-1"><a href="#tryLoadPatchFilesInternal-1" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>然后我们再在 tryLoadPatchFilesInternal 中往下看。会看到资源补丁加载代码的入口，即 TinkerResourceLoader.loadTinkerResources 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="loadTinkerResources"><a href="#loadTinkerResources" class="headerlink" title="loadTinkerResources"></a>loadTinkerResources</h2><p>loadTinkerResources 方法我们分段来看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  检查 res_meta.txt 中读取出来的 md5 值，如果 resPatchInfo 或者 md5 是空的，就说明补丁包中没有资源补丁，不需要加载</span></span><br><span class="line"><span class="keyword">if</span> (resPatchInfo == <span class="keyword">null</span> || resPatchInfo.resArscMd5 == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">String resourceString = directory + <span class="string">"/"</span> + RESOURCE_PATH +  <span class="string">"/"</span> + RESOURCE_FILE;</span><br><span class="line">File resourceFile = <span class="keyword">new</span> File(resourceString);</span><br><span class="line"><span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"><span class="comment">// 如果校验设置为 true ，就去校验资源补丁包 resources.apk 的 md5 值</span></span><br><span class="line"><span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!SharePatchFileUtil.checkResourceArscMd5(resourceFile, resPatchInfo.resArscMd5)) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"Failed to load resource file, path: "</span> + resourceFile.getPath() + <span class="string">", expect md5: "</span> + resPatchInfo.resArscMd5);</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_MD5_MISMATCH);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify resource file:"</span> + resourceFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是加载资源补丁了，如果加载失败了，会把 dex 补丁卸载了。防止 dex 补丁代码中会引用到资源补丁中的资源文件，导致程序崩溃或报错。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 加载资源</span></span><br><span class="line">    TinkerResourcePatcher.monkeyPatchExistingResources(application, resourceString);</span><br><span class="line">    Log.i(TAG, <span class="string">"monkeyPatchExistingResources resource file:"</span> + resourceString + <span class="string">", use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">&#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"install resources failed"</span>);</span><br><span class="line">    <span class="comment">//remove patch dex if resource is installed failed</span></span><br><span class="line">    <span class="comment">// 如果资源补丁加载失败的话，会移除 dex 补丁</span></span><br><span class="line">    <span class="comment">// 因为如果dex补丁代码中有引用到资源的话，会报错</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SystemClassLoaderAdder.uninstallPatchDex(application.getClassLoader());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">        Log.e(TAG, <span class="string">"uninstallPatchDex failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">    intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_RESOURCE_LOAD_EXCEPTION);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="monkeyPatchExistingResources"><a href="#monkeyPatchExistingResources" class="headerlink" title="monkeyPatchExistingResources"></a>monkeyPatchExistingResources</h2><p>monkeyPatchExistingResources 方法也一段一段来看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查资源补丁apk是否为空</span></span><br><span class="line"><span class="keyword">if</span> (externalResourceFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> ApplicationInfo appInfo = context.getApplicationInfo();</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Field[] packagesFields;</span><br><span class="line"><span class="comment">// 准备之前反射好的 packagesFiled 和 resourcePackagesFiled 字段</span></span><br><span class="line"><span class="comment">// 利用 packagesFiled 和 resourcePackagesFiled 可以获取 LoadedApk 对象</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">27</span>) &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled, resourcePackagesFiled&#125;;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    packagesFields = <span class="keyword">new</span> Field[]&#123;packagesFiled&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 遍历 packagesFields ，获取对应的值</span></span><br><span class="line"><span class="keyword">for</span> (Field field : packagesFields) &#123;</span><br><span class="line">    <span class="comment">// 获取 ActivityThread 中 packagesFiled 或 resourcePackagesFiled</span></span><br><span class="line">    <span class="comment">// value 其实为 Map&lt;String, WeakReference&lt;LoadedApk&gt;&gt; 类型</span></span><br><span class="line">    <span class="keyword">final</span> Object value = field.get(currentActivityThread);</span><br><span class="line">    <span class="comment">// 再对 value 进行遍历，获取 LoadedApk 对象</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, WeakReference&lt;?&gt;&gt; entry</span><br><span class="line">            : ((Map&lt;String, WeakReference&lt;?&gt;&gt;) value).entrySet()) &#123;</span><br><span class="line">        <span class="keyword">final</span> Object loadedApk = entry.getValue().get();</span><br><span class="line">        <span class="keyword">if</span> (loadedApk == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 LoadedApk 对象中获取 mResDir 属性，这个属性的意义在上面已经讲过了</span></span><br><span class="line">        <span class="keyword">final</span> String resDirPath = (String) resDir.get(loadedApk);</span><br><span class="line">        <span class="comment">// 将 mResDir 的值 hook 成资源补丁 apk 的路径</span></span><br><span class="line">        <span class="keyword">if</span> (appInfo.sourceDir.equals(resDirPath)) &#123;</span><br><span class="line">            resDir.set(loadedApk, externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码基本上都有注释了，接着往下看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create a new AssetManager instance and point it to the resources installed under</span></span><br><span class="line"><span class="comment">// 创建一个新的 AssetManager 实例，并把资源补丁apk加载进 AssetManager 中</span></span><br><span class="line"><span class="keyword">if</span> (((Integer) addAssetPathMethod.invoke(newAssetManager, externalResourceFile)) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Could not create new AssetManager"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Kitkat needs this method call, Lollipop doesn't. However, it doesn't seem to cause any harm</span></span><br><span class="line"><span class="comment">// in L, so we do it unconditionally.</span></span><br><span class="line"><span class="comment">// 创建出 AssetManager 后，调用 ensureStringBlocks 来确保资源的字符串索引创建出来</span></span><br><span class="line"><span class="keyword">if</span> (stringBlocksField != <span class="keyword">null</span> &amp;&amp; ensureStringBlocksMethod != <span class="keyword">null</span>) &#123;</span><br><span class="line">    stringBlocksField.set(newAssetManager, <span class="keyword">null</span>);</span><br><span class="line">    ensureStringBlocksMethod.invoke(newAssetManager);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在创建出新的 AssetManager 之后，最后要做的事就是用新的 AssetManager 来替换旧的。下面代码中的 references 就是上面提到的 mActiveResources 的 value 集合。也就是每个 apk 的 Resources 资源集合。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (WeakReference&lt;Resources&gt; wr : references) &#123;</span><br><span class="line">    <span class="keyword">final</span> Resources resources = wr.get();</span><br><span class="line">    <span class="keyword">if</span> (resources == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Set the AssetManager of the Resources instance to our brand new one</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//pre-N</span></span><br><span class="line">        <span class="comment">// Android N 之前的方案</span></span><br><span class="line">        <span class="comment">// 把原来 resources 的 mAssets 属性替换成新的 AssetManager 对象</span></span><br><span class="line">        assetsFiled.set(resources, newAssetManager);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">        <span class="comment">// N</span></span><br><span class="line">        <span class="comment">// Android N 之后， mAssets 属性被放在了 ResourcesImpl 中</span></span><br><span class="line">        <span class="comment">// 所以需要先获取 ResourcesImpl 对象再进行替换</span></span><br><span class="line">        <span class="keyword">final</span> Object resourceImpl = resourcesImplFiled.get(resources);</span><br><span class="line">        <span class="comment">// for Huawei HwResourcesImpl</span></span><br><span class="line">        <span class="keyword">final</span> Field implAssets = findField(resourceImpl, <span class="string">"mAssets"</span>);</span><br><span class="line">        implAssets.set(resourceImpl, newAssetManager);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 在 Resource 中会维护一个 mTypedArrayPool 资源池</span></span><br><span class="line">    <span class="comment">// 来减少频繁访问 AssetManager ，所以需要去释放这个资源池，否则取到的都是缓存</span></span><br><span class="line">    clearPreloadTypedArrayIssue(resources);</span><br><span class="line">    <span class="comment">// 最后调用 updateConfiguration 方法来确保资源更新了</span></span><br><span class="line">    resources.updateConfiguration(resources.getConfiguration(), resources.getDisplayMetrics());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Handle issues caused by WebView on Android N.</span></span><br><span class="line"><span class="comment">// Issue: On Android N, if an activity contains a webview, when screen rotates</span></span><br><span class="line"><span class="comment">// our resource patch may lost effects.</span></span><br><span class="line"><span class="comment">// for 5.x/6.x, we found Couldn't expand RemoteView for StatusBarNotification Exception</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (publicSourceDirField != <span class="keyword">null</span>) &#123;</span><br><span class="line">            publicSourceDirField.set(context.getApplicationInfo(), externalResourceFile);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后，就是来确认一下资源补丁是否已经加载成功了。具体的方法就是在资源补丁Apk的 assets 中有一个 Tinker 的测试资源，名字叫 only_use_to_test_tinker_resource.txt ，如果可以正确读取到并且没报错的话，就证明资源补丁加载成功了。否则就抛出异常，会执行 dex 补丁卸载的流程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkResUpdate(context)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_RES_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，资源补丁的加载流程就讲完了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7D_u8D44_u6E90_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7D_u8D44_u6E90_u8865_u4E]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(三):加载dex补丁流程]]></title>
    <link href="http://yuqirong.me/2019/02/28/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%89)/"/>
    <id>http://yuqirong.me/2019/02/28/Tinker源码分析(三)/</id>
    <published>2019-02-28T11:23:19.000Z</published>
    <updated>2019-03-09T17:25:13.488Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" class="headerlink" title="加载dex补丁流程"></a>加载dex补丁流程</h1><h2 id="TinkerDexLoader-loadTinkerJars"><a href="#TinkerDexLoader-loadTinkerJars" class="headerlink" title="TinkerDexLoader.loadTinkerJars"></a>TinkerDexLoader.loadTinkerJars</h2><p>判断一下 dexList 和 classLoader</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (loadDexList.isEmpty() &amp;&amp; classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"there is no dex to load"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PathClassLoader classLoader = (PathClassLoader) TinkerDexLoader.class.getClassLoader();</span><br><span class="line"><span class="keyword">if</span> (classLoader != <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"classloader: "</span> + classLoader.toString());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    Log.e(TAG, <span class="string">"classloader is null"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_CLASSLOADER_NULL);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果 TinkerLoadVerifyFlag 为 true 的话，会对每个 dex 进行 md5 校验</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">String dexPath = directory + <span class="string">"/"</span> + DEX_PATH + <span class="string">"/"</span>;</span><br><span class="line"></span><br><span class="line">ArrayList&lt;File&gt; legalFiles = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (ShareDexDiffPatchInfo info : loadDexList) &#123;</span><br><span class="line">    <span class="comment">//for dalvik, ignore art support dex</span></span><br><span class="line">    <span class="comment">// 对于 dalvik 虚拟机，忽略 art support dex</span></span><br><span class="line">    <span class="keyword">if</span> (isJustArtSupportDex(info)) &#123;</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String path = dexPath + info.realName;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line">        String checkMd5 = getInfoMd5(info);</span><br><span class="line">        <span class="comment">// 校验dex文件的 md5 值</span></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(file, checkMd5)) &#123;</span><br><span class="line">            <span class="comment">//it is good to delete the mismatch file</span></span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">            intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                file.getAbsolutePath());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.i(TAG, <span class="string">"verify dex file:"</span> + file.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// dex文件都通过的话，加入到 legalFiles 集合中 </span></span><br><span class="line">    legalFiles.add(file);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是 art 虚拟机并且是 Android N 及以上的环境，会另外加上 tinker_classN.apk</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// verify merge classN.apk</span></span><br><span class="line"><span class="keyword">if</span> (isVmArt &amp;&amp; !classNDexInfo.isEmpty()) &#123;</span><br><span class="line">    File classNFile = <span class="keyword">new</span> File(dexPath + ShareConstants.CLASS_N_APK_NAME);</span><br><span class="line">    <span class="keyword">long</span> start = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (application.isTinkerLoadVerifyFlag()) &#123;</span><br><span class="line">        <span class="keyword">for</span> (ShareDexDiffPatchInfo info : classNDexInfo) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!SharePatchFileUtil.verifyDexFileMd5(classNFile, info.rawName, info.destMd5InArt)) &#123;</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_MD5_MISMATCH);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_MISMATCH_DEX_PATH,</span><br><span class="line">                    classNFile.getAbsolutePath());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"verify dex file:"</span> + classNFile.getPath() + <span class="string">" md5, use time: "</span> + (System.currentTimeMillis() - start));</span><br><span class="line"></span><br><span class="line">    legalFiles.add(classNFile);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户是ART虚拟机并且做了OTA升级，那么在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍.这么做的原因是有些场景做了OTA后,oat的规则可能发生变化,在这种情况下去加载上个系统版本oat过的dex就会出现问题.</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line">File optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + oatDir);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span>[] parallelOTAResult = &#123;<span class="keyword">true</span>&#125;;</span><br><span class="line">            <span class="keyword">final</span> Throwable[] parallelOTAThrowable = <span class="keyword">new</span> Throwable[<span class="number">1</span>];</span><br><span class="line">            String targetISA;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                targetISA = ShareTinkerInternals.getCurrentInstructionSet();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable throwable) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"getCurrentInstructionSet fail:"</span> + throwable);</span><br><span class="line"><span class="comment">//                try &#123;</span></span><br><span class="line"><span class="comment">//                    targetISA = ShareOatUtil.getOatFileInstructionSet(testOptDexFile);</span></span><br><span class="line"><span class="comment">//                &#125; catch (Throwable throwable) &#123;</span></span><br><span class="line">                <span class="comment">// don't ota on the front</span></span><br><span class="line">                deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, throwable);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_GET_OTA_INSTRUCTION_SET_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            deleteOutOfDateOATFile(directory);</span><br><span class="line"></span><br><span class="line">            Log.w(TAG, <span class="string">"systemOTA, try parallel oat dexes, targetISA:"</span> + targetISA);</span><br><span class="line">            <span class="comment">// change dir</span></span><br><span class="line">            optimizeDir = <span class="keyword">new</span> File(directory + <span class="string">"/"</span> + INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 对 dex 文件作 odex 处理</span></span><br><span class="line">            TinkerDexOptimizer.optimizeAll(</span><br><span class="line">                legalFiles, optimizeDir, <span class="keyword">true</span>, targetISA,</span><br><span class="line">                <span class="keyword">new</span> TinkerDexOptimizer.ResultCallback() &#123;</span><br><span class="line">                    <span class="keyword">long</span> start;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">(File dexFile, File optimizedDir)</span> </span>&#123;</span><br><span class="line">                        start = System.currentTimeMillis();</span><br><span class="line">                        Log.i(TAG, <span class="string">"start to optimize dex:"</span> + dexFile.getPath());</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSuccess</span><span class="params">(File dexFile, File optimizedDir, File optimizedFile)</span> </span>&#123;</span><br><span class="line">                        <span class="comment">// Do nothing.</span></span><br><span class="line">                        Log.i(TAG, <span class="string">"success to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="annotation">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailed</span><span class="params">(File dexFile, File optimizedDir, Throwable thr)</span> </span>&#123;</span><br><span class="line">                        parallelOTAResult[<span class="number">0</span>] = <span class="keyword">false</span>;</span><br><span class="line">                        parallelOTAThrowable[<span class="number">0</span>] = thr;</span><br><span class="line">                        Log.i(TAG, <span class="string">"fail to optimize dex "</span> + dexFile.getPath() + <span class="string">", use time "</span> + (System.currentTimeMillis() - start));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            );</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!parallelOTAResult[<span class="number">0</span>]) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"parallel oat dexes failed"</span>);</span><br><span class="line">                intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_INTERPRET_EXCEPTION, parallelOTAThrowable[<span class="number">0</span>]);</span><br><span class="line">                ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_OTA_INTERPRET_ONLY_EXCEPTION);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h2 id="u52A0_u8F7Ddex"><a href="#u52A0_u8F7Ddex" class="headerlink" title="加载dex"></a>加载dex</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">       SystemClassLoaderAdder.installDexes(application, classLoader, optimizeDir, legalFiles);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">       Log.e(TAG, <span class="string">"install dexes failed"</span>);</span><br><span class="line"><span class="comment">//            e.printStackTrace();</span></span><br><span class="line">       intentResult.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">       ShareIntentUtil.setIntentReturnCode(intentResult, ShareConstants.ERROR_LOAD_PATCH_VERSION_DEX_LOAD_EXCEPTION);</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br><span class="line">	</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<h2 id="SystemClassLoaderAdder-installDexes"><a href="#SystemClassLoaderAdder-installDexes" class="headerlink" title="SystemClassLoaderAdder.installDexes"></a>SystemClassLoaderAdder.installDexes</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">installDexes</span><span class="params">(Application application, PathClassLoader loader, File dexOptDir, List&lt;File&gt; files)</span></span><br><span class="line">    <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">"installDexes dexOptDir: "</span> + dexOptDir.getAbsolutePath() + <span class="string">", dex size:"</span> + files.size());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!files.isEmpty()) &#123;</span><br><span class="line">        files = createSortedAdditionalPathEntries(files);</span><br><span class="line">        ClassLoader classLoader = loader;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">24</span> &amp;&amp; !checkIsProtectedApp(files)) &#123;</span><br><span class="line">            classLoader = AndroidNClassLoader.inject(loader, application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//because in dalvik, if inner class is not the same classloader with it wrapper class.</span></span><br><span class="line">        <span class="comment">//it won't fail at dex2opt</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">            V23.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">19</span>) &#123;</span><br><span class="line">            V19.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            V14.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            V4.install(classLoader, files, dexOptDir);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//install done</span></span><br><span class="line">        sPatchDexCount = files.size();</span><br><span class="line">        Log.i(TAG, <span class="string">"after loaded classloader: "</span> + classLoader + <span class="string">", dex size:"</span> + sPatchDexCount);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">            <span class="comment">//reset patch dex</span></span><br><span class="line">            SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在加载 dex 的时候，分别分成了四个版本：</p>
<ul>
<li>v4</li>
<li>v14</li>
<li>v19</li>
<li>v23</li>
</ul>
<p>其中如果是 SDK 24 及以上，需要改造一下 classloder</p>
<p>针对每个版本不同的源码，进行 dex 插入</p>
<p>我们就来看其中一个版本 v19</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">V19</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">install</span><span class="params">(ClassLoader loader, List&lt;File&gt; additionalClassPathEntries,</span><br><span class="line">                                File optimizedDirectory)</span></span><br><span class="line">        <span class="keyword">throws</span> IllegalArgumentException, IllegalAccessException,</span><br><span class="line">        NoSuchFieldException, InvocationTargetException, NoSuchMethodException, IOException </span>&#123;</span><br><span class="line">        <span class="comment">/* The patched class loader is expected to be a descendant of</span><br><span class="line">         * dalvik.system.BaseDexClassLoader. We modify its</span><br><span class="line">         * dalvik.system.DexPathList pathList field to append additional DEX</span><br><span class="line">         * file entries.</span><br><span class="line">         */</span></span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(loader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(loader);</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions = <span class="keyword">new</span> ArrayList&lt;IOException&gt;();</span><br><span class="line">        ShareReflectUtil.expandFieldArray(dexPathList, <span class="string">"dexElements"</span>, makeDexElements(dexPathList,</span><br><span class="line">            <span class="keyword">new</span> ArrayList&lt;File&gt;(additionalClassPathEntries), optimizedDirectory,</span><br><span class="line">            suppressedExceptions));</span><br><span class="line">        <span class="keyword">if</span> (suppressedExceptions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (IOException e : suppressedExceptions) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"Exception in makeDexElement"</span>, e);</span><br><span class="line">                <span class="keyword">throw</span> e;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A wrapper around</span><br><span class="line">     * &#123;<span class="doctag">@code</span> private static final dalvik.system.DexPathList#makeDexElements&#125;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Object[] makeDexElements(</span><br><span class="line">        Object dexPathList, ArrayList&lt;File&gt; files, File optimizedDirectory,</span><br><span class="line">        ArrayList&lt;IOException&gt; suppressedExceptions)</span><br><span class="line">        <span class="keyword">throws</span> IllegalAccessException, InvocationTargetException, NoSuchMethodException &#123;</span><br><span class="line"></span><br><span class="line">        Method makeDexElements = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, ArrayList.class, File.class,</span><br><span class="line">                ArrayList.class);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">            Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(ArrayList,File,ArrayList) failure"</span>);</span><br><span class="line">            <span class="comment">// 对不同的 rom 做兼容，有的 rom 的 makeDexElements 方法参数类型是 List</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                makeDexElements = ShareReflectUtil.findMethod(dexPathList, <span class="string">"makeDexElements"</span>, List.class, File.class, List.class);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e1) &#123;</span><br><span class="line">                Log.e(TAG, <span class="string">"NoSuchMethodException: makeDexElements(List,File,List) failure"</span>);</span><br><span class="line">                <span class="keyword">throw</span> e1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> (Object[]) makeDexElements.invoke(dexPathList, files, optimizedDirectory, suppressedExceptions);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先反射拿到反射得到 PathClassLoader 中的 pathList 对象,再将补丁文件通过反射调用makeDexElements 得到补丁文件的 Element[] ,再将补丁包的 Element[] 数组插入到 dexElements 中</p>
<p>另外，需要对 Android 7.0 及以上单独处理一下，具体看 <a href="https://mp.weixin.qq.com/s?__biz=MzAwNDY1ODY2OQ==&amp;mid=2649286341&amp;idx=1&amp;sn=054d595af6e824cbe4edd79427fc2706&amp;scene=0" target="_blank" rel="external">Android N混合编译与对热补丁影响解析</a></p>
<p>加载补丁操作做好之后，最后还要检查一下，如果没加载成功就会执行卸载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkDexInstall(classLoader)) &#123;</span><br><span class="line">    <span class="comment">//reset patch dex</span></span><br><span class="line">    SystemClassLoaderAdder.uninstallPatchDex(classLoader);</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(ShareConstants.CHECK_DEX_INSTALL_FAIL);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>具体验证补丁是否加载成功的方法就是判断 TinkerTestDexLoad.isPatch 的值。</p>
<p>在没有补丁加载的情况下都是返回 false 的, 在补丁中修改 isPatch 属性为 true 。所以只要反射拿到isPatch 的属性为 true 就说明补丁已经成功加载进来了。否则就调用 SystemClassLoaderAdder.uninstallPatchDex 执行卸载</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">uninstallPatchDex</span><span class="params">(ClassLoader classLoader)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sPatchDexCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">        Field pathListField = ShareReflectUtil.findField(classLoader, <span class="string">"pathList"</span>);</span><br><span class="line">        Object dexPathList = pathListField.get(classLoader);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(dexPathList, <span class="string">"dexElements"</span>, sPatchDexCount);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mPaths"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mFiles"</span>, sPatchDexCount);</span><br><span class="line">        ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mZips"</span>, sPatchDexCount);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ShareReflectUtil.reduceFieldArray(classLoader, <span class="string">"mDexs"</span>, sPatchDexCount);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>卸载补丁可以说是加载补丁的逆向操作，具体操作可以分成 v4 和 v14 两个版本</p>
<p>具体的内容就是把 dexElements 中的头部 element 去除了。</p>
<p>到这，dex 补丁加载的流程结束了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B"><a href="#u52A0_u8F7Ddex_u8865_u4E01_u6D41_u7A0B" cl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(二):加载补丁流程]]></title>
    <link href="http://yuqirong.me/2019/02/27/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2019/02/27/Tinker源码分析(二)/</id>
    <published>2019-02-27T13:43:16.000Z</published>
    <updated>2019-03-14T15:54:09.840Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink" title="tryLoad"></a>tryLoad</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Intent <span class="title">tryLoad</span><span class="params">(TinkerApplication app)</span> </span>&#123;</span><br><span class="line">    Intent resultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> begin = SystemClock.elapsedRealtime();</span><br><span class="line">    tryLoadPatchFilesInternal(app, resultIntent);</span><br><span class="line">    <span class="keyword">long</span> cost = SystemClock.elapsedRealtime() - begin;</span><br><span class="line">    ShareIntentUtil.setIntentPatchCostTime(resultIntent, cost);</span><br><span class="line">    <span class="keyword">return</span> resultIntent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载的流程主要在 tryLoadPatchFilesInternal 里面。tryLoadPatchFilesInternal 方法很长，我们需要分段来看。</p>
<h2 id="tryLoadPatchFilesInternal"><a href="#tryLoadPatchFilesInternal" class="headerlink" title="tryLoadPatchFilesInternal"></a>tryLoadPatchFilesInternal</h2><p>一开始是各种校验</p>
<p>检查 tinker 是否开启</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">int</span> tinkerFlag = app.getTinkerFlags();</span><br><span class="line"><span class="comment">// 检查 tinker 是否开启</span></span><br><span class="line"><span class="keyword">if</span> (!ShareTinkerInternals.isTinkerEnabled(tinkerFlag)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: tinker is disable, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前的进程</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查当前的进程，确保不是 :patch 进程</span></span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isInPatchProcess(app)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles: we don't load patch with :patch process itself, just return"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_DISABLE);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>获取 tinker 目录，检查目录是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// tinker 获取 tinker 目录，/data/data/tinker.sample.android/tinker</span></span><br><span class="line">File patchDirectoryFile = SharePatchFileUtil.getPatchDirectory(app);</span><br><span class="line"><span class="keyword">if</span> (patchDirectoryFile == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:getPatchDirectory == null"</span>);</span><br><span class="line">    <span class="comment">//treat as not exist</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">String patchDirectoryPath = patchDirectoryFile.getAbsolutePath();</span><br><span class="line"><span class="comment">// 检查 tinker 目录是否存在</span></span><br><span class="line"><span class="comment">//check patch directory whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch dir not exist:"</span> + patchDirectoryPath);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查 patch.info 文件是否存在, patch.info 是补丁信息文件，里面记录着新旧两个补丁版本的 md5 值</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 文件目录 /data/data/tinker.sample.android/tinker/patch.info</span></span><br><span class="line">File patchInfoFile = SharePatchFileUtil.getPatchInfoFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch.info 补丁信息文件是否存在</span></span><br><span class="line"><span class="comment">//check patch info file whether exist</span></span><br><span class="line"><span class="keyword">if</span> (!patchInfoFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patch info not exist:"</span> + patchInfoFile.getAbsolutePath());</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取 patch.info 文件，并包装成一个 SharePatchInfo ，并检查 patchInfo 是否为空 (先加锁 file lock 再解锁)</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//old = 641e634c5b8f1649c75caf73794acbdf</span></span><br><span class="line"><span class="comment">//new = 2c150d8560334966952678930ba67fa8</span></span><br><span class="line"><span class="comment">// tinker/info.lock</span></span><br><span class="line">File patchInfoLockFile = SharePatchFileUtil.getPatchInfoLockFile(patchDirectoryPath);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查 patch info 文件中的补丁版本信息</span></span><br><span class="line">patchInfo = SharePatchInfo.readAndCheckPropertyWithLock(patchInfoFile, patchInfoLockFile);</span><br><span class="line"><span class="keyword">if</span> (patchInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查读取出来的 patchInfo 补丁版本信息</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String oldVersion = patchInfo.oldVersion;</span><br><span class="line">String newVersion = patchInfo.newVersion;</span><br><span class="line">String oatDex = patchInfo.oatDir;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (oldVersion == <span class="keyword">null</span> || newVersion == <span class="keyword">null</span> || oatDex == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//it is nice to clean patch</span></span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchInfoCorrupted"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_CORRUPTED);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果发现 patchInfo 中的 isRemoveNewVersion 为 true 并且在主进程中运行的话，就代表需要清除补丁了</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> mainProcess = ShareTinkerInternals.isInMainProcess(app);</span><br><span class="line"><span class="keyword">boolean</span> isRemoveNewVersion = patchInfo.isRemoveNewVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// So far new version is not loaded in main process and other processes.</span></span><br><span class="line"><span class="comment">// We can remove new version directory safely.</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; isRemoveNewVersion) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"found clean patch mark and we are in main process, delete patch file now."</span>);</span><br><span class="line">    <span class="comment">// 获取新的补丁文件夹，例如 patch-2c150d85</span></span><br><span class="line">    String patchName = SharePatchFileUtil.getPatchVersionDirectory(newVersion);</span><br><span class="line">    <span class="keyword">if</span> (patchName != <span class="keyword">null</span>) &#123;</span><br><span class="line">	     <span class="comment">// 删除新的补丁文件夹   </span></span><br><span class="line">        String patchVersionDirFullPath = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirFullPath);</span><br><span class="line">        <span class="comment">// 如果旧版本和新版本一致，就把 oldVersion 和 newVersion 设置为空来清除补丁</span></span><br><span class="line">        <span class="keyword">if</span> (oldVersion.equals(newVersion)) &#123;</span><br><span class="line">            <span class="comment">// !oldVersion.equals(newVersion) means new patch is applied, just fall back to old one in that case.</span></span><br><span class="line">            <span class="comment">// Or we will set oldVersion and newVersion to empty string to clean patch.</span></span><br><span class="line">            oldVersion = <span class="string">""</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果 !oldVersion.equals(newVersion) 意味着新补丁已经应用了，需要回退到原来的旧版本</span></span><br><span class="line">        newVersion = oldVersion;</span><br><span class="line">        patchInfo.oldVersion = oldVersion;</span><br><span class="line">        patchInfo.newVersion = newVersion;</span><br><span class="line">        <span class="comment">// 把数据重新写入 patchInfo 文件中</span></span><br><span class="line">        SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile);</span><br><span class="line">        <span class="comment">// 杀掉主进程以外的所有进程</span></span><br><span class="line">        ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OLD_VERSION, oldVersion);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_NEW_VERSION, newVersion);</span><br></pre></td></tr></table></figure>
<p>根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">boolean</span> versionChanged = !(oldVersion.equals(newVersion));</span><br><span class="line"><span class="keyword">boolean</span> oatModeChanged = oatDex.equals(ShareConstants.CHANING_DEX_OPTIMIZE_PATH);</span><br><span class="line">oatDex = ShareTinkerInternals.getCurrentOatMode(app, oatDex);</span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, oatDex);</span><br><span class="line"></span><br><span class="line">String version = oldVersion;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据版本变化和是否是主进程的条件决定是否允许加载最新的补丁</span></span><br><span class="line"><span class="keyword">if</span> (versionChanged &amp;&amp; mainProcess) &#123;</span><br><span class="line">    version = newVersion;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (ShareTinkerInternals.isNullOrNil(version)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:version is blank, wait main process to restart"</span>);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_INFO_BLANK);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查当前新版本补丁文件夹是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//patch-641e634c</span></span><br><span class="line">String patchName = SharePatchFileUtil.getPatchVersionDirectory(version);</span><br><span class="line"><span class="keyword">if</span> (patchName == <span class="keyword">null</span>) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:patchName is null"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c</span></span><br><span class="line">String patchVersionDirectory = patchDirectoryPath + <span class="string">"/"</span> + patchName;</span><br><span class="line"></span><br><span class="line">File patchVersionDirectoryFile = <span class="keyword">new</span> File(patchVersionDirectory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!patchVersionDirectoryFile.exists()) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionDirectoryNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_DIRECTORY_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件是否存在并且可读</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tinker/patch.info/patch-641e634c/patch-641e634c.apk</span></span><br><span class="line"><span class="keyword">final</span> String patchVersionFileRelPath = SharePatchFileUtil.getPatchVersionFile(version);</span><br><span class="line">File patchVersionFile = (patchVersionFileRelPath != <span class="keyword">null</span> ? <span class="keyword">new</span> File(patchVersionDirectoryFile.getAbsolutePath(), patchVersionFileRelPath) : <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!SharePatchFileUtil.isLegalFile(patchVersionFile)) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchVersionFileNotFound"</span>);</span><br><span class="line">    <span class="comment">//we may delete patch info file</span></span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_VERSION_FILE_NOT_EXIST);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>检查补丁文件签名以及补丁文件中的 tinker id 和基准包的 tinker id 是否一致。</p>
<p>注意，这里补丁文件的 tinker id 是当前补丁基准包的 tinker id ，也就是有 bug 的基准包 tinker id 。另外一个 new tinker id 是补丁加载完成后的 tinker id ，就是 bug 修复后的 tinker id 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">ShareSecurityCheck securityCheck = <span class="keyword">new</span> ShareSecurityCheck(app);</span><br><span class="line"><span class="comment">// 1. 检查补丁包 apk 的签名</span></span><br><span class="line"><span class="comment">// 2. 检查基准包的 tinker id 与补丁包中是否一致</span></span><br><span class="line"><span class="comment">// 3. 检查 tinker 设置与补丁包中的类型是否符合</span></span><br><span class="line"><span class="keyword">int</span> returnCode = ShareTinkerInternals.checkTinkerPackage(app, tinkerFlag, patchVersionFile, securityCheck);</span><br><span class="line"><span class="keyword">if</span> (returnCode != ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkTinkerPackage"</span>);</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_PATCH_CHECK, returnCode);</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_PACKAGE_CHECK_FAIL);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_PACKAGE_CONFIG, securityCheck.getPackagePropertiesIfPresent());</span><br></pre></td></tr></table></figure>
<p>下面是 checkTinkerPackage 方法的具体代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">checkTinkerPackage</span><span class="params">(Context context, <span class="keyword">int</span> tinkerFlag, File patchFile, ShareSecurityCheck securityCheck)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查补丁文件签名和 tinker id 是否一致</span></span><br><span class="line">    <span class="comment">// 这里为了快速校验,就只检验补丁包内部以meta.txt结尾的文件的签名，而其他的文件的合法性则通过meta.txt文件内部记录的补丁文件Md5值来校验</span></span><br><span class="line">    <span class="keyword">int</span> returnCode = checkSignatureAndTinkerID(context, patchFile, securityCheck);</span><br><span class="line">    <span class="keyword">if</span> (returnCode == ShareConstants.ERROR_PACKAGE_CHECK_OK) &#123;</span><br><span class="line">        <span class="comment">// 检查配置的 tinker flag 和 meta.txt 是否匹配</span></span><br><span class="line">        <span class="comment">// 如果不匹配的话，中断接下来的流程</span></span><br><span class="line">        returnCode = checkPackageAndTinkerFlag(securityCheck, tinkerFlag);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> returnCode;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据不同的情况,最多有四个文件是以meta.txt结尾的:</p>
<ul>
<li>package_meta.txt 补丁包的基本信息</li>
<li>dex_meta.txt dex补丁的信息</li>
<li>so_meta.txt so补丁的信息</li>
<li>res_meta.txt 资源补丁的信息</li>
</ul>
<p>如果开启了支持 dex 热修复，检查 dex_meta.txt 文件中记录的dex文件信息对应的dex文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForDex = ShareTinkerInternals.isTinkerEnabledForDex(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/dex</span></span><br><span class="line">    <span class="comment">// 检查下发的meta文件中记录的dex信息中对应的dex文件是否存在</span></span><br><span class="line">    <span class="keyword">boolean</span> dexCheck = TinkerDexLoader.checkComplete(patchVersionDirectory, securityCheck, oatDex, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!dexCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:dex check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 so 热修复，检查 so_meta.txt 文件中记录的so文件信息对应的so文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForNativeLib = ShareTinkerInternals.isTinkerEnabledForNativeLib(tinkerFlag);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (isEnabledForNativeLib) &#123;</span><br><span class="line">    <span class="comment">//tinker/patch.info/patch-641e634c/lib</span></span><br><span class="line">    <span class="keyword">boolean</span> libCheck = TinkerSoLoader.checkComplete(patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!libCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:native lib check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果开启了支持 res 热修复，检查 res_meta.txt 文件中记录的res文件信息对应的res文件是否存在</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check resource</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> isEnabledForResource = ShareTinkerInternals.isTinkerEnabledForResource(tinkerFlag);</span><br><span class="line">Log.w(TAG, <span class="string">"tryLoadPatchFiles:isEnabledForResource:"</span> + isEnabledForResource);</span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> resourceCheck = TinkerResourceLoader.checkComplete(app, patchVersionDirectory, securityCheck, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!resourceCheck) &#123;</span><br><span class="line">        <span class="comment">//file not found, do not load patch</span></span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:resource check fail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>符合条件的话就更新版本信息,并将最新的patch info更新入文件.在v1.7.5的版本开始有了isSystemOTA判断,</p>
<p>只要用户是ART环境并且做了OTA升级，则在加载dex补丁的时候就会先把最近一次的补丁全部DexFile.loadDex一遍重新生成odex，再加载dex补丁。否则会报错</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//only work for art platform oat，because of interpret, refuse 4.4 art oat</span></span><br><span class="line"><span class="comment">//android o use quicken default, we don't need to use interpret mode</span></span><br><span class="line"><span class="keyword">boolean</span> isSystemOTA = ShareTinkerInternals.isVmArt()</span><br><span class="line">    &amp;&amp; ShareTinkerInternals.isSystemOTA(patchInfo.fingerPrint)</span><br><span class="line">    &amp;&amp; Build.VERSION.SDK_INT &gt;= <span class="number">21</span> &amp;&amp; !ShareTinkerInternals.isAfterAndroidO();</span><br><span class="line"></span><br><span class="line">resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_SYSTEM_OTA, isSystemOTA);</span><br><span class="line"></span><br><span class="line"><span class="comment">//we should first try rewrite patch info file, if there is a error, we can't load jar</span></span><br><span class="line"><span class="comment">// 把patch.info的旧版本的值更新为新版本的值，写入 patch.info 中</span></span><br><span class="line"><span class="keyword">if</span> (mainProcess &amp;&amp; (versionChanged || oatModeChanged)) &#123;</span><br><span class="line">    patchInfo.oldVersion = version;</span><br><span class="line">    patchInfo.oatDir = oatDex;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//update old version to new</span></span><br><span class="line">    <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Log.i(TAG, <span class="string">"tryLoadPatchFiles:success to rewrite patch info, kill other process."</span>);</span><br><span class="line">    ShareTinkerInternals.killProcessExceptMain(app);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (oatModeChanged) &#123;</span><br><span class="line">        <span class="comment">// delete interpret odex</span></span><br><span class="line">        <span class="comment">// for android o, directory change. Fortunately, we don't need to support android o interpret mode any more</span></span><br><span class="line">        Log.i(TAG, <span class="string">"tryLoadPatchFiles:oatModeChanged, try to delete interpret optimize files"</span>);</span><br><span class="line">        SharePatchFileUtil.deleteDir(patchVersionDirectory + <span class="string">"/"</span> + ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁的安全次数最多三次</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!checkSafeModeCount(app)) &#123;</span><br><span class="line">    resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_EXCEPTION, <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"checkSafeModeCount fail"</span>));</span><br><span class="line">    ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_UNCAUGHT_EXCEPTION);</span><br><span class="line">    Log.w(TAG, <span class="string">"tryLoadPatchFiles:checkSafeModeCount fail"</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁 jar ，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch jar</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerJars = TinkerDexLoader.loadTinkerJars(app, patchVersionDirectory, oatDex, resultIntent, isSystemOTA);</span><br><span class="line">    <span class="comment">// 如果是 ota 的话，更新 oat 的文件夹路径</span></span><br><span class="line">    <span class="keyword">if</span> (isSystemOTA) &#123;</span><br><span class="line">        <span class="comment">// update fingerprint after load success</span></span><br><span class="line">        patchInfo.fingerPrint = Build.FINGERPRINT;</span><br><span class="line">        patchInfo.oatDir = loadTinkerJars ? ShareConstants.INTERPRET_DEX_OPTIMIZE_PATH : ShareConstants.DEFAULT_DEX_OPTIMIZE_PATH;</span><br><span class="line">        <span class="comment">// reset to false</span></span><br><span class="line">        oatModeChanged = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!SharePatchInfo.rewritePatchInfoFileWithLock(patchInfoFile, patchInfo, patchInfoLockFile)) &#123;</span><br><span class="line">            ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_PATCH_REWRITE_PATCH_INFO_FAIL);</span><br><span class="line">            Log.w(TAG, <span class="string">"tryLoadPatchFiles:onReWritePatchInfoCorrupted"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// update oat dir</span></span><br><span class="line">        resultIntent.putExtra(ShareIntentUtil.INTENT_PATCH_OAT_DIR, patchInfo.oatDir);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerJars) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadDexesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>加载补丁资源，这一部分的代码我们后面会详细展开</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//now we can load patch resource</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForResource) &#123;</span><br><span class="line">    <span class="keyword">boolean</span> loadTinkerResources = TinkerResourceLoader.loadTinkerResources(app, patchVersionDirectory, resultIntent);</span><br><span class="line">    <span class="keyword">if</span> (!loadTinkerResources) &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"tryLoadPatchFiles:onPatchLoadResourcesFail"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>补丁加载流程结束</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Init component hotplug support.</span></span><br><span class="line"><span class="keyword">if</span> (isEnabledForDex &amp;&amp; isEnabledForResource) &#123;</span><br><span class="line">    ComponentHotplug.install(app, securityCheck);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//all is ok!</span></span><br><span class="line">ShareIntentUtil.setIntentReturnCode(resultIntent, ShareConstants.ERROR_LOAD_OK);</span><br><span class="line">Log.i(TAG, <span class="string">"tryLoadPatchFiles: load end, ok!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<p>前一篇讲到了利用反射执行的是 TinkerLoader.tryLoad 方法</p>
<h2 id="tryLoad"><a href="#tryLoad" class="headerlink"]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Tinker源码分析(一):TinkerApplication]]></title>
    <link href="http://yuqirong.me/2019/02/24/Tinker%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90(%E4%B8%80)/"/>
    <id>http://yuqirong.me/2019/02/24/Tinker源码分析(一)/</id>
    <published>2019-02-24T14:52:16.000Z</published>
    <updated>2019-03-09T17:25:02.046Z</updated>
    <content type="html"><![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication" class="headerlink" title="自动生成TinkerApplication"></a>自动生成TinkerApplication</h1><p>接入 Tinker 第一步就是改造 Application 。官方推荐是利用 @DefaultLifeCycle 动态生成 Application</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@DefaultLifeCycle</span>(application = <span class="string">"tinker.sample.android.app.SampleApplication"</span>,</span><br><span class="line">                  flags = ShareConstants.TINKER_ENABLE_ALL,</span><br><span class="line">                  loadVerifyFlag = <span class="keyword">false</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SampleApplicationLike</span> <span class="keyword">extends</span> <span class="title">DefaultApplicationLike</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那我们来解析一下 Tinker 是如何生成 Application 以及在 Application 中做了什么事？</p>
<p>看到 @DefaultLifeCycle 注解，我们可想而知应该是经过 processor 处理后动态生成了 Application 。</p>
<p>查看 Tinker 工程可以发现在 tinker-android-anno 下面有一个 AnnotationProcessor </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; supportedAnnotationTypes = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    supportedAnnotationTypes.add(DefaultLifeCycle.class.getName());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> supportedAnnotationTypes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    processDefaultLifeCycle(roundEnv.getElementsAnnotatedWith(DefaultLifeCycle.class));</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它正是处理 @DefaultLifeCycle 的。</p>
<p>下面重要看 processDefaultLifeCycle 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processDefaultLifeCycle</span><span class="params">(Set&lt;? extends Element&gt; elements)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// DefaultLifeCycle</span></span><br><span class="line">    <span class="keyword">for</span> (Element e : elements) &#123;</span><br><span class="line">        DefaultLifeCycle ca = e.getAnnotation(DefaultLifeCycle.class);</span><br><span class="line"></span><br><span class="line">        String lifeCycleClassName = ((TypeElement) e).getQualifiedName().toString();</span><br><span class="line">        String lifeCyclePackageName = lifeCycleClassName.substring(<span class="number">0</span>, lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        lifeCycleClassName = lifeCycleClassName.substring(lifeCycleClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String applicationClassName = ca.application();</span><br><span class="line">        <span class="keyword">if</span> (applicationClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            applicationClassName = lifeCyclePackageName + applicationClassName;</span><br><span class="line">        &#125;</span><br><span class="line">        String applicationPackageName = applicationClassName.substring(<span class="number">0</span>, applicationClassName.lastIndexOf(<span class="string">'.'</span>));</span><br><span class="line">        applicationClassName = applicationClassName.substring(applicationClassName.lastIndexOf(<span class="string">'.'</span>) + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        String loaderClassName = ca.loaderClass();</span><br><span class="line">        <span class="keyword">if</span> (loaderClassName.startsWith(<span class="string">"."</span>)) &#123;</span><br><span class="line">            loaderClassName = lifeCyclePackageName + loaderClassName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"*"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> InputStream is = AnnotationProcessor.class.getResourceAsStream(APPLICATION_TEMPLATE_PATH);</span><br><span class="line">        <span class="keyword">final</span> Scanner scanner = <span class="keyword">new</span> Scanner(is);</span><br><span class="line">        <span class="keyword">final</span> String template = scanner.useDelimiter(<span class="string">"\\A"</span>).next();</span><br><span class="line">        <span class="keyword">final</span> String fileContent = template</span><br><span class="line">            .replaceAll(<span class="string">"%PACKAGE%"</span>, applicationPackageName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION%"</span>, applicationClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%APPLICATION_LIFE_CYCLE%"</span>, lifeCyclePackageName + <span class="string">"."</span> + lifeCycleClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_FLAGS%"</span>, <span class="string">""</span> + ca.flags())</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOADER_CLASS%"</span>, <span class="string">""</span> + loaderClassName)</span><br><span class="line">            .replaceAll(<span class="string">"%TINKER_LOAD_VERIFY_FLAG%"</span>, <span class="string">""</span> + ca.loadVerifyFlag());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            JavaFileObject fileObject = processingEnv.getFiler().createSourceFile(applicationPackageName + <span class="string">"."</span> + applicationClassName);</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.NOTE, <span class="string">"Creating "</span> + fileObject.toUri());</span><br><span class="line">            Writer writer = fileObject.openWriter();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                PrintWriter pw = <span class="keyword">new</span> PrintWriter(writer);</span><br><span class="line">                pw.print(fileContent);</span><br><span class="line">                pw.flush();</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException x) &#123;</span><br><span class="line">            processingEnv.getMessager().printMessage(Diagnostic.Kind.ERROR, x.toString());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 processDefaultLifeCycle 方法看下来，其实主要在做的就是去读取一份模版，然后用注解中设置的值替换里面的一些占位符。这个模版就是 resouces/TinkerAnnoApplication.tmpl </p>
<pre><code>package %PACKAGE%;

import com.tencent.tinker.loader.app.TinkerApplication;

/**
 *
 * Generated application for tinker life cycle
 *
 */
public class %APPLICATION% extends TinkerApplication {

    public %APPLICATION%() {
        super(%TINKER_FLAGS%, &quot;%APPLICATION_LIFE_CYCLE%&quot;, &quot;%TINKER_LOADER_CLASS%&quot;, %TINKER_LOAD_VERIFY_FLAG%);
    }

}
</code></pre><p>最终生成的 SampleApplication 效果：</p>
<pre><code>/**
 *
 * Generated application for tinker life cycle
 *
 */
public class SampleApplication extends TinkerApplication {

    public SampleApplication() {
        super(7, &quot;tinker.sample.android.app.SampleApplicationLike&quot;, &quot;com.tencent.tinker.loader.TinkerLoader&quot;, false);
    }

}
</code></pre><h1 id="u89E3_u6790_TinkerApplication"><a href="#u89E3_u6790_TinkerApplication" class="headerlink" title="解析 TinkerApplication"></a>解析 TinkerApplication</h1><p>想要知道 TinkerApplication 里面干了什么？</p>
<p>一起看看 TinkerApplication.onCreate </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ComponentHotplug.ensureComponentHotplugInstalled(<span class="keyword">this</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEnvironmentException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"failed to make sure that ComponentHotplug logic is fine."</span>, e);</span><br><span class="line">        &#125;</span><br><span class="line">        invokeAppLikeOnCreate(applicationLike);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一步，调用 ensureDelegate 创建 application 代理，即 applicationLike</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">ensureDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (applicationLike == <span class="keyword">null</span>) &#123;</span><br><span class="line">        applicationLike = createDelegate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">createDelegate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Use reflection to create the delegate so it doesn't need to go into the primary dex.</span></span><br><span class="line">        <span class="comment">// And we can also patch it</span></span><br><span class="line">        Class&lt;?&gt; delegateClass = Class.forName(delegateClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Constructor&lt;?&gt; constructor = delegateClass.getConstructor(Application.class, <span class="keyword">int</span>.class, <span class="keyword">boolean</span>.class,</span><br><span class="line">            <span class="keyword">long</span>.class, <span class="keyword">long</span>.class, Intent.class);</span><br><span class="line">        <span class="keyword">return</span> constructor.newInstance(<span class="keyword">this</span>, tinkerFlags, tinkerLoadVerifyFlag,</span><br><span class="line">            applicationStartElapsedTime, applicationStartMillisTime, tinkerResultIntent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(<span class="string">"createDelegate failed"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用 invokeAppLikeOnCreate(applicationLike) 去回调 applicationLike 的 onCreate 方法。这样，applicationLike 和 application 的生命周期方法就做到同步了。另外，其余的生命周期方法也是如此来实现同步的，这里就不详细讲解了。</p>
<p>那么 Tinker 是什么时候加载的呢？</p>
<p>答案就在 attachBaseContext 中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    Thread.setDefaultUncaughtExceptionHandler(<span class="keyword">new</span> TinkerUncaughtHandler(<span class="keyword">this</span>));</span><br><span class="line">    onBaseContextAttached(base);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">onBaseContextAttached</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        applicationStartElapsedTime = SystemClock.elapsedRealtime();</span><br><span class="line">        applicationStartMillisTime = System.currentTimeMillis();</span><br><span class="line">        loadTinker();</span><br><span class="line">        ensureDelegate();</span><br><span class="line">        invokeAppLikeOnBaseContextAttached(applicationLike, base);</span><br><span class="line">        <span class="comment">//reset save mode</span></span><br><span class="line">        <span class="keyword">if</span> (useSafeMode) &#123;</span><br><span class="line">            ShareTinkerInternals.setSafeModeCount(<span class="keyword">this</span>, <span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TinkerRuntimeException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable thr) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> TinkerRuntimeException(thr.getMessage(), thr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到调用了 loadTinker 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadTinker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//reflect tinker loader, because loaderClass may be define by user!</span></span><br><span class="line">        Class&lt;?&gt; tinkerLoadClass = Class.forName(loaderClassName, <span class="keyword">false</span>, getClassLoader());</span><br><span class="line">        Method loadMethod = tinkerLoadClass.getMethod(TINKER_LOADER_METHOD, TinkerApplication.class);</span><br><span class="line">        Constructor&lt;?&gt; constructor = tinkerLoadClass.getConstructor();</span><br><span class="line">        tinkerResultIntent = (Intent) loadMethod.invoke(constructor.newInstance(), <span class="keyword">this</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        <span class="comment">//has exception, put exception error code</span></span><br><span class="line">        tinkerResultIntent = <span class="keyword">new</span> Intent();</span><br><span class="line">        ShareIntentUtil.setIntentReturnCode(tinkerResultIntent, ShareConstants.ERROR_LOAD_PATCH_UNKNOWN_EXCEPTION);</span><br><span class="line">        tinkerResultIntent.putExtra(INTENT_PATCH_EXCEPTION, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里的 loaderClassName 就是上面 @DefaultLifeCycle 中定义的 loaderClass 。默认的是 com.tencent.tinker.loader.TinkerLoader ，也支持用户自定义 TinkerLoader 。</p>
<p>所以 loadTinker 中干的事就是利用反射执行了 TinkerLoader.tryLoad 方法。</p>
<p>至于在 tryLoad 方法中到底做了什么事，我们等到下一篇再讲吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本系列 Tinker 源码解析基于 Tinker v1.9.12</p>
<h1 id="u81EA_u52A8_u751F_u6210TinkerApplication"><a href="#u81EA_u52A8_u751F_u6210TinkerApplication]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Tinker" scheme="http://yuqirong.me/tags/Tinker/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[利用AOP对点击事件作防抖处理]]></title>
    <link href="http://yuqirong.me/2019/02/23/%E5%88%A9%E7%94%A8AOP%E5%AF%B9%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6%E4%BD%9C%E9%98%B2%E6%8A%96%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2019/02/23/利用AOP对点击事件作防抖处理/</id>
    <published>2019-02-23T14:11:21.000Z</published>
    <updated>2019-02-23T15:21:40.273Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>最近项目中有一个需求，需要对重复的点击事件作过滤处理。</p>
<p>可能第一个想到的方法是在 OnClickListener.onClick 中根据时间间隔来判断，这也是比较传统的方案。但是缺点同样也很明显，就是对现有代码的侵入性太强了。因为点击事件回调的代码我们早已写好了，现在再去改动会很痛苦，并且改动的范围也很广。</p>
<p>那么有没有一种方法是不需要改动源代码，就可以实现对点击事件去重的呢？当然有，我们可以利用 AOP 来实现一套方案。接下来就来讲讲这套方案就具体实现。</p>
<h1 id="Body"><a href="#Body" class="headerlink" title="Body"></a>Body</h1><p>在写代码之前，需要先设置 AOP 的配置，AOP 一般采用的是 AspectJ 。而在 Android 中一般直接使用 <a href="https://github.com/JakeWharton/hugo" target="_blank" rel="external">hugo</a> 或者 <a href="https://github.com/HujiangTechnology/gradle_plugin_android_aspectjx" target="_blank" rel="external">gradle_plugin_android_aspectjx</a> 插件，这样就省去了配置 AspectJ 的麻烦。在这里我使用的就是 gradle_plugin_android_aspectjx 插件，gradle_plugin_android_aspectjx 具体的配置就不详细展开了，可以自行去了解。</p>
<p>配置好之后，我们设计一下具体的方案，如果有不需要点击过滤的，我们就配置一个 @Except 注解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Except &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之后我们就来写一下 AOP 处理的代码。首先我们来创建一个 SingleClickAspect 类，在这里面写 AOP 的代码（添加 @Aspect 注解来表明这是一个切面，需要 AspectJ 处理）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleClickAspect</span> </span>&#123;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后我们来定义一下 AOP 的连接点（Join Point）。因为我们是打算在 onClick 中处理事件去重的，所以连接点显而易见是 method execution 。</p>
<p>接着是切点（Pointcuts）。最基本的切点就是 View.OnClickListener.onClick 方法了。所以可以得出第一个切点表达式：</p>
<pre><code>execution(* android.view.View.OnClickListener.onClick(..))
</code></pre><p>另外，如果是在布局 xml 中直接使用 android:onclick=”xxx” 指定点击事件的话，我们也需要进行防重处理。如果有看过这一块源码的同学可能会知道，其实 android:onclick=”xxx” 最后调用的是 DeclaredOnClickListener 这个类来完成点击方法包装的。</p>
<p>所以我们的切点就是 DeclaredOnClickListener.onClick 方法了。可以得出第二个切点表达式：</p>
<pre><code>execution(* android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener.onClick(..))
</code></pre><p>最后，还有不少同学会使用 ButterKnife 来完成 view 的初始化操作，所以对 ButterKnife 也要囊括进来。（其实 ButterKnife 内部已经对点击事件进行去重了，具体可以看下 DebouncingOnClickListener，但是我们这里还是写一下吧）</p>
<pre><code>execution(@butterknife.OnClick * *(..))
</code></pre><p>没错，ButterKnife 的切点表达式很简单，就是对 @OnClick 注解的地方处理一下即可。</p>
<p>定义完切点表达式后，我们就要来写点击事件去重的代码了。这里根据需求我们可以得出通知（Advice<br>）使用 @Around 类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// normal onClick</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_POINTCUTS = <span class="string">"execution(* android.view.View.OnClickListener.onClick(..))"</span>;</span><br><span class="line"><span class="comment">// 如果 onClick 是写在 xml 里面的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_IN_XML_POINTCUTS = <span class="string">"execution(* android.support.v7.app.AppCompatViewInflater.DeclaredOnClickListener.onClick(..))"</span>;</span><br><span class="line"><span class="comment">// butterknife on click</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String ON_CLICK_IN_BUTTER_KNIFE_POINTCUTS = <span class="string">"execution(@butterknife.OnClick * *(..))"</span>;</span><br><span class="line"><span class="comment">// view tag unique key, must be one of resource id</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SINGLE_CLICK_KEY = R.string.me_yuqirong_singleclick_tag_key;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickPointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_IN_XML_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickInXmlPointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Pointcut</span>(ON_CLICK_IN_BUTTER_KNIFE_POINTCUTS)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClickInButterKnifePointcuts</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Around</span>(<span class="string">"onClickPointcuts() || onClickInXmlPointcuts() || onClickInButterKnifePointcuts()"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">throttleClick</span><span class="params">(ProceedingJoinPoint joinPoint)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// check for Except annotation</span></span><br><span class="line">        Signature signature = joinPoint.getSignature();</span><br><span class="line">        <span class="keyword">if</span> (signature <span class="keyword">instanceof</span> MethodSignature) &#123;</span><br><span class="line">            MethodSignature methodSignature = (MethodSignature) signature;</span><br><span class="line">            Method method = methodSignature.getMethod();</span><br><span class="line">            <span class="comment">// 如果有 Except 注解，就不需要做点击防抖处理</span></span><br><span class="line">            <span class="keyword">boolean</span> isExcept = method != <span class="keyword">null</span> &amp;&amp; method.isAnnotationPresent(Except.class);</span><br><span class="line">            <span class="keyword">if</span> (isExcept) &#123;</span><br><span class="line">                Log.d(TAG, <span class="string">"the click method is except, so proceed it"</span>);</span><br><span class="line">                joinPoint.proceed();</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Object[] args = joinPoint.getArgs();</span><br><span class="line">        View view = getViewFromArgs(args);</span><br><span class="line">        <span class="comment">// unknown click type, so skip it</span></span><br><span class="line">        <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"unknown type method, so proceed it"</span>);</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Long lastClickTime = (Long) view.getTag(SINGLE_CLICK_KEY);</span><br><span class="line">        <span class="comment">// if lastClickTime is null, means click first time</span></span><br><span class="line">        <span class="keyword">if</span> (lastClickTime == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"the click event is first time, so proceed it"</span>);</span><br><span class="line">            view.setTag(SINGLE_CLICK_KEY, SystemClock.elapsedRealtime());</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (canClick(lastClickTime)) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"the click event time interval is legal, so proceed it"</span>);</span><br><span class="line">            view.setTag(SINGLE_CLICK_KEY, SystemClock.elapsedRealtime());</span><br><span class="line">            joinPoint.proceed();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Log.d(TAG, <span class="string">"throttle the click event, view id = "</span> + view.getId());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        Log.d(TAG, e.getMessage());</span><br><span class="line">        joinPoint.proceed();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 获取 view 参数</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> args</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> View <span class="title">getViewFromArgs</span><span class="params">(Object[] args)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (args != <span class="keyword">null</span> &amp;&amp; args.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Object arg = args[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (arg <span class="keyword">instanceof</span> View) &#123;</span><br><span class="line">            <span class="keyword">return</span> (View) arg;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断是否达到可以点击的时间间隔，这里间隔就设置为500L</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> lastClickTime</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">canClick</span><span class="params">(<span class="keyword">long</span> lastClickTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> SystemClock.elapsedRealtime() - lastClickTime</span><br><span class="line">            &gt;= <span class="number">500L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码的逻辑很简单，先判断一下是否有 @Except 注解，如果有的话就直接通过了。</p>
<p>然后得到 onClick 方法的参数 view 。判断 view.getTag 有没有值。如果没有值，就说明是第一次点击，那么放行通过。否则就判断是否两次点击时间间隔有没有大于规定的时间间隔，从而实现点击事件的去重。</p>
<p>到这里，基本就完事了，整下来代码其实也就没多少量。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>以后在做其他需求的时候，也可以思考一下是否使用 AOP 可以达成目标，可能代码量会更少，侵入性也会更低。</p>
<p>另外 AOP 的使用范围还是比较广泛的，比如打印日志、埋点统计等。如果看完这篇博客有想法的同学，可以自己去试试！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>最近项目中有一个需求，需要对重复的点击事件作过滤处理。</p>
<p>可能第一个想到的方法是在 OnClic]]>
    </summary>
    
      <category term="AOP" scheme="http://yuqirong.me/tags/AOP/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用OpenCV对图片进行二值化和去燥处理]]></title>
    <link href="http://yuqirong.me/2019/01/13/%E4%BD%BF%E7%94%A8OpenCV%E5%AF%B9%E5%9B%BE%E7%89%87%E8%BF%9B%E8%A1%8C%E4%BA%8C%E5%80%BC%E5%8C%96%E5%92%8C%E5%8E%BB%E7%87%A5%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2019/01/13/使用OpenCV对图片进行二值化和去燥处理/</id>
    <published>2019-01-13T08:33:00.000Z</published>
    <updated>2019-01-18T14:10:55.063Z</updated>
    <content type="html"><![CDATA[<p>最近做的项目中有使用到 OpenCV ，并且利用了 OpenCV 对图片做一些简单的处理。所以今天打算记录一下一些常用的 OpenCV 操作。</p>
<p>以下的 OpenCV 代码都是基于 OpenCV v3.3.0 aar 版本</p>
<h1 id="u4E8C_u503C_u5316"><a href="#u4E8C_u503C_u5316" class="headerlink" title="二值化"></a>二值化</h1><p>所谓的二值化，就是将图片上的像素点的灰度值设置为0或255，也就是将整个图片呈现出明显的只有黑和白的视觉效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">binarization</span><span class="params">(Bitmap bitmap)</span> </span>&#123;</span><br><span class="line">   <span class="comment">// 创建一张新的bitmap</span></span><br><span class="line">   Bitmap result = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.ARGB_8888);</span><br><span class="line">   Mat origin = <span class="keyword">new</span> Mat();</span><br><span class="line">   Mat gray = <span class="keyword">new</span> Mat();</span><br><span class="line">   Mat out = <span class="keyword">new</span> Mat();</span><br><span class="line">   Utils.bitmapToMat(bitmap, origin);</span><br><span class="line">   Imgproc.cvtColor(origin, gray, Imgproc.COLOR_RGB2GRAY);</span><br><span class="line">   <span class="comment">// 二值化处理</span></span><br><span class="line">   Imgproc.adaptiveThreshold(gray, out, <span class="number">255.0</span>D, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, <span class="number">25</span>, <span class="number">10.0</span>D);</span><br><span class="line">   Utils.matToBitmap(out, result);</span><br><span class="line">   origin.release();</span><br><span class="line">   gray.release();</span><br><span class="line">   out.release();</span><br><span class="line">   <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u53BB_u71E5"><a href="#u53BB_u71E5" class="headerlink" title="去燥"></a>去燥</h1><p>如果发现二值化后燥点比较多，这时候就需要使用去燥处理了。其中参数 d 为去燥的强度。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Bitmap <span class="title">denoising</span><span class="params">(Bitmap bitmap, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">    Bitmap result = Bitmap.createBitmap(bitmap.getWidth(), bitmap.getHeight(), Bitmap.Config.RGB_565);</span><br><span class="line">    Mat origin = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat gray = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat bf = <span class="keyword">new</span> Mat();</span><br><span class="line">    Mat out = <span class="keyword">new</span> Mat();</span><br><span class="line">    Utils.bitmapToMat(bitmap, origin);</span><br><span class="line">    Imgproc.cvtColor(origin, gray, Imgproc.COLOR_RGB2GRAY);</span><br><span class="line">    <span class="comment">// 去燥</span></span><br><span class="line">    Imgproc.bilateralFilter(gray, bf, d, (<span class="keyword">double</span>) (d * <span class="number">2</span>), (<span class="keyword">double</span>) (d / <span class="number">2</span>));</span><br><span class="line">    Imgproc.adaptiveThreshold(bf, out, <span class="number">255.0</span>D, Imgproc.ADAPTIVE_THRESH_MEAN_C, Imgproc.THRESH_BINARY, <span class="number">25</span>, <span class="number">10.0</span>D);</span><br><span class="line">    Utils.matToBitmap(out, result);</span><br><span class="line">    origin.release();</span><br><span class="line">    gray.release();</span><br><span class="line">    bf.release();</span><br><span class="line">    out.release();</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看一下最终的效果吧</p>
<p>原图：</p>
<p><img src="/uploads/20190113/20190118220513.png" alt="source"></p>
<p>二值化：</p>
<p><img src="/uploads/20190113/20190118220610.png" alt="binarization"></p>
<p>去燥：</p>
<p><img src="/uploads/20190113/20190118220630.png" alt="denoising"></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近做的项目中有使用到 OpenCV ，并且利用了 OpenCV 对图片做一些简单的处理。所以今天打算记录一下一些常用的 OpenCV 操作。</p>
<p>以下的 OpenCV 代码都是基于 OpenCV v3.3.0 aar 版本</p>
<h1 id="u4E8C_u]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="OpenCV" scheme="http://yuqirong.me/tags/OpenCV/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（五）]]></title>
    <link href="http://yuqirong.me/2019/01/10/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%94%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/10/ARouter源码解析（五）/</id>
    <published>2019-01-10T13:42:23.000Z</published>
    <updated>2019-03-04T16:28:45.240Z</updated>
    <content type="html"><![CDATA[<p>arouter-gradle-plugin version : 1.0.2</p>
<p>AutoRegister : <a href="https://github.com/luckybilly/AutoRegister" target="_blank" rel="external">https://github.com/luckybilly/AutoRegister</a></p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在本系列的第一篇中讲过，ARouter 可以通过扫描 dex 文件中 class 的全类名，来加载 compiler 生成的路由类。但这种方式影响性能，并且效率也不高。所以在 ARouter v1.3.0 之后的版本中，加入了自动注册的方式进行路由表的加载，自动注册可以缩短初始化时间，解决应用加固导致无法直接访问 dex 文件从而初始化失败的问题。</p>
<p>那么自动注册到底是什么东东，为什么有这么强大的能力呢？</p>
<p>那么接下来，我们就来分析分析。</p>
<p>预先需要了解的知识点：</p>
<ul>
<li>自定义 gradle plugin</li>
<li>gradle transform api</li>
<li>使用 asm 实现字节码插桩</li>
</ul>
<h1 id="arouter-register"><a href="#arouter-register" class="headerlink" title="arouter-register"></a>arouter-register</h1><p>arouter-register 的入口就在 PluginLaunch</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginLaunch</span> <span class="keyword">implements</span> <span class="title">Plugin</span>&lt;<span class="title">Project</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">apply</span><span class="params">(Project project)</span> </span>&#123;</span><br><span class="line">        def isApp = project.plugins.hasPlugin(AppPlugin)</span><br><span class="line">        <span class="comment">//only application module needs this plugin to generate register code</span></span><br><span class="line">        <span class="keyword">if</span> (isApp) &#123;</span><br><span class="line">            Logger.make(project)</span><br><span class="line"></span><br><span class="line">            Logger.i(<span class="string">'Project enable arouter-register plugin'</span>)</span><br><span class="line"></span><br><span class="line">            def android = project.extensions.getByType(AppExtension)</span><br><span class="line">            def transformImpl = <span class="keyword">new</span> RegisterTransform(project)</span><br><span class="line"></span><br><span class="line">            <span class="comment">//init arouter-auto-register settings</span></span><br><span class="line">            ArrayList&lt;ScanSetting&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="number">3</span>)</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IRouteRoot'</span>))</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IInterceptorGroup'</span>))</span><br><span class="line">            list.add(<span class="keyword">new</span> ScanSetting(<span class="string">'IProviderGroup'</span>))</span><br><span class="line">            RegisterTransform.registerList = list</span><br><span class="line">            <span class="comment">//register this plugin</span></span><br><span class="line">            android.registerTransform(transformImpl)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知：</p>
<ul>
<li>只在 application module （一般都是 app module）生成自动注册的代码；</li>
<li>初始化了自动注册的设置，这样自动注册就知道需要注册 IRouteRoot IInterceptorGroup IProviderGroup 这三者；</li>
<li>注册 RegisterTransform ，字节码插桩将在 RegisterTransform 中完成；</li>
</ul>
<p>可以看出，重点就在 RegisterTransform 里面。那我们重点就关注下 RegisterTransform 的代码，这里就贴出 transform 方法的源码了。（关于 Transform 的 InputTypes 和 Scopes 知识点在这就不讲了，如有需要了解的同学可以看 <a href="https://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a>）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RegisterTransform</span> <span class="keyword">extends</span> <span class="title">Transform</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">transform</span><span class="params">(Context context, Collection&lt;TransformInput&gt; inputs</span><br><span class="line">	               , Collection&lt;TransformInput&gt; referencedInputs</span><br><span class="line">	               , TransformOutputProvider outputProvider</span><br><span class="line">	               , <span class="keyword">boolean</span> isIncremental)</span> <span class="keyword">throws</span> IOException, TransformException, InterruptedException </span>&#123;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">'Start scan register info in jar file.'</span>)</span><br><span class="line">	</span><br><span class="line">	    <span class="keyword">long</span> startTime = System.currentTimeMillis()</span><br><span class="line">	    <span class="keyword">boolean</span> leftSlash = File.separator == <span class="string">'/'</span></span><br><span class="line">	</span><br><span class="line">	    inputs.each &#123; TransformInput input -&gt;</span><br><span class="line">	</span><br><span class="line">	        <span class="comment">// 扫描所有的 jar 文件</span></span><br><span class="line">	        input.jarInputs.each &#123; JarInput jarInput -&gt;</span><br><span class="line">	            String destName = jarInput.name</span><br><span class="line">	            <span class="comment">// rename jar files</span></span><br><span class="line">	            def hexName = DigestUtils.md5Hex(jarInput.file.absolutePath)</span><br><span class="line">	            <span class="keyword">if</span> (destName.endsWith(<span class="string">".jar"</span>)) &#123;</span><br><span class="line">	                destName = destName.substring(<span class="number">0</span>, destName.length() - <span class="number">4</span>)</span><br><span class="line">	            &#125;</span><br><span class="line">	            <span class="comment">// 输入的 jar 文件</span></span><br><span class="line">	            File src = jarInput.file</span><br><span class="line">	            <span class="comment">// 输出的 jar 文件</span></span><br><span class="line">	            File dest = outputProvider.getContentLocation(destName + <span class="string">"_"</span> + hexName, jarInput.contentTypes, jarInput.scopes, Format.JAR)</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">// 扫描 jar 文件，查找实现 IRouteRoot IInterceptorGroup IProviderGroup 接口的类，并且找到 LogisticsCenter 在哪个 jar 文件中</span></span><br><span class="line">	            <span class="comment">// 不扫描 com.android.support 开头的 jar</span></span><br><span class="line">	            <span class="keyword">if</span> (ScanUtil.shouldProcessPreDexJar(src.absolutePath)) &#123;</span><br><span class="line">	                <span class="comment">// ScanUtil.scanJar 的代码就不详细展开了，感兴趣的同学可以自己去看下</span></span><br><span class="line">	                ScanUtil.scanJar(src, dest)</span><br><span class="line">	            &#125;</span><br><span class="line">	            FileUtils.copyFile(src, dest)</span><br><span class="line">	</span><br><span class="line">	        &#125;</span><br><span class="line">	        <span class="comment">// 扫描所有的 class 文件，查找实现 IRouteRoot IInterceptorGroup IProviderGroup 接口的类</span></span><br><span class="line">	        <span class="comment">// 和扫描 jar 做差不多类似的工作。不同的点就是不用再去找 LogisticsCenter 类</span></span><br><span class="line">	        input.directoryInputs.each &#123; DirectoryInput directoryInput -&gt;</span><br><span class="line">	            File dest = outputProvider.getContentLocation(directoryInput.name, directoryInput.contentTypes, directoryInput.scopes, Format.DIRECTORY)</span><br><span class="line">	            String root = directoryInput.file.<span class="function">absolutePath</span><br><span class="line">	            <span class="title">if</span> <span class="params">(!root.endsWith(File.separator)</span>)</span><br><span class="line">	                root +</span>= File.separator</span><br><span class="line">	            directoryInput.file.eachFileRecurse &#123; File file -&gt;</span><br><span class="line">	                def path = file.absolutePath.replace(root, <span class="string">''</span>)</span><br><span class="line">	                <span class="keyword">if</span> (!leftSlash) &#123;</span><br><span class="line">	                    path = path.replaceAll(<span class="string">"\\\\"</span>, <span class="string">"/"</span>)</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="comment">// 只处理 com/alibaba/android/arouter/routes/ 开头的 class</span></span><br><span class="line">	                <span class="keyword">if</span>(file.isFile() &amp;&amp; ScanUtil.shouldProcessClass(path))&#123;</span><br><span class="line">	                    ScanUtil.scanClass(file)</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;</span><br><span class="line">	</span><br><span class="line">	            <span class="comment">// copy to dest</span></span><br><span class="line">	            FileUtils.copyDirectory(directoryInput.file, dest)</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">'Scan finish, current cost time '</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>)</span><br><span class="line">	    </span><br><span class="line">	    <span class="comment">// 这里开始字节码插桩操作</span></span><br><span class="line">	    <span class="keyword">if</span> (fileContainsInitClass) &#123;</span><br><span class="line">	        <span class="comment">// 遍历之前找的 IRouteRoot IInterceptorGroup IProviderGroup</span></span><br><span class="line">	        registerList.each &#123; ext -&gt;</span><br><span class="line">	            Logger.i(<span class="string">'Insert register code to file '</span> + fileContainsInitClass.absolutePath)</span><br><span class="line">	</span><br><span class="line">	            <span class="keyword">if</span> (ext.classList.isEmpty()) &#123;</span><br><span class="line">	                Logger.e(<span class="string">"No class implements found for interface:"</span> + ext.interfaceName)</span><br><span class="line">	            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	                ext.classList.each &#123;</span><br><span class="line">	                    Logger.i(it)</span><br><span class="line">	                &#125;</span><br><span class="line">	                <span class="comment">// 对 LogisticsCenter.class 做字节码插桩</span></span><br><span class="line">	                RegisterCodeGenerator.insertInitCodeTo(ext)</span><br><span class="line">	            &#125;</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	</span><br><span class="line">	    Logger.i(<span class="string">"Generate code finish, current cost time: "</span> + (System.currentTimeMillis() - startTime) + <span class="string">"ms"</span>)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码的逻辑很清晰，按照之前设置好的 IRouteRoot IInterceptorGroup IProviderGroup 这三个接口，然后扫描整个项目的代码，分别找到这三者各自的实现类，然后加入到集合中。最后在 LogisticsCenter 中实现字节码插桩。</p>
<p>我们来详细看下 RegisterCodeGenerator.insertInitCodeTo(ext) 的代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertInitCodeTo</span><span class="params">(ScanSetting registerSetting)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (registerSetting != <span class="keyword">null</span> &amp;&amp; !registerSetting.classList.isEmpty()) &#123;</span><br><span class="line">        RegisterCodeGenerator processor = <span class="keyword">new</span> RegisterCodeGenerator(registerSetting)</span><br><span class="line">        <span class="comment">// RegisterTransform.fileContainsInitClass 就是包含了 LogisticsCenter.class 的那个 jar 文件</span></span><br><span class="line">        File file = RegisterTransform.<span class="function">fileContainsInitClass</span><br><span class="line">        <span class="title">if</span> <span class="params">(file.getName()</span>.<span class="title">endsWith</span><span class="params">(<span class="string">'.jar'</span>)</span>)</span><br><span class="line">        		 <span class="comment">// 开始处理</span></span><br><span class="line">            processor.<span class="title">insertInitCodeIntoJarFile</span><span class="params">(file)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span></span><br></pre></td></tr></table></figure>
<p>插入的操作在 insertInitCodeIntoJarFile 中实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> File <span class="title">insertInitCodeIntoJarFile</span><span class="params">(File jarFile)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (jarFile) &#123;</span><br><span class="line">        def optJar = <span class="keyword">new</span> File(jarFile.getParent(), jarFile.name + <span class="string">".opt"</span>)</span><br><span class="line">        <span class="keyword">if</span> (optJar.exists())</span><br><span class="line">            optJar.delete()</span><br><span class="line">        def file = <span class="keyword">new</span> JarFile(jarFile)</span><br><span class="line">        Enumeration enumeration = file.entries()</span><br><span class="line">        JarOutputStream jarOutputStream = <span class="keyword">new</span> JarOutputStream(<span class="keyword">new</span> FileOutputStream(optJar))</span><br><span class="line">        <span class="comment">// 遍历 jar 文件中的 class</span></span><br><span class="line">        <span class="keyword">while</span> (enumeration.hasMoreElements()) &#123;</span><br><span class="line">            JarEntry jarEntry = (JarEntry) enumeration.nextElement()</span><br><span class="line">            String entryName = jarEntry.getName()</span><br><span class="line">            ZipEntry zipEntry = <span class="keyword">new</span> ZipEntry(entryName)</span><br><span class="line">            InputStream inputStream = file.getInputStream(jarEntry)</span><br><span class="line">            jarOutputStream.putNextEntry(zipEntry)</span><br><span class="line">            <span class="comment">// 如果是 LogisticsCenter.class 的话</span></span><br><span class="line">            <span class="keyword">if</span> (ScanSetting.GENERATE_TO_CLASS_FILE_NAME == entryName) &#123;</span><br><span class="line"></span><br><span class="line">                Logger.i(<span class="string">'Insert init code to class &gt;&gt; '</span> + entryName)</span><br><span class="line">                <span class="comment">// 插桩操作</span></span><br><span class="line">                def bytes = referHackWhenInit(inputStream)</span><br><span class="line">                jarOutputStream.write(bytes)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                jarOutputStream.write(IOUtils.toByteArray(inputStream))</span><br><span class="line">            &#125;</span><br><span class="line">            inputStream.close()</span><br><span class="line">            jarOutputStream.closeEntry()</span><br><span class="line">        &#125;</span><br><span class="line">        jarOutputStream.close()</span><br><span class="line">        file.close()</span><br><span class="line">        <span class="comment">// 把字节码插桩的 jar 替换掉原来旧的 jar 文件</span></span><br><span class="line">        <span class="keyword">if</span> (jarFile.exists()) &#123;</span><br><span class="line">            jarFile.delete()</span><br><span class="line">        &#125;</span><br><span class="line">        optJar.renameTo(jarFile)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> jarFile</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>字节码插桩的代码还在 referHackWhenInit 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//refer hack class when object init</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">byte</span>[] referHackWhenInit(InputStream inputStream) &#123;</span><br><span class="line">    ClassReader cr = <span class="keyword">new</span> ClassReader(inputStream)</span><br><span class="line">    ClassWriter cw = <span class="keyword">new</span> ClassWriter(cr, <span class="number">0</span>)</span><br><span class="line">    ClassVisitor cv = <span class="keyword">new</span> MyClassVisitor(Opcodes.ASM5, cw)</span><br><span class="line">    cr.accept(cv, ClassReader.EXPAND_FRAMES)</span><br><span class="line">    <span class="keyword">return</span> cw.toByteArray()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClassVisitor</span> <span class="keyword">extends</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    MyClassVisitor(<span class="keyword">int</span> api, ClassVisitor cv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(api, cv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visit</span><span class="params">(<span class="keyword">int</span> version, <span class="keyword">int</span> access, String name, String signature,</span><br><span class="line">               String superName, String[] interfaces)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visit(version, access, name, signature, superName, interfaces)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function">MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span><br><span class="line">                              String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">        MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions)</span><br><span class="line">        <span class="comment">// 对 loadRouterMap 这个方法进行代码插入</span></span><br><span class="line">        <span class="keyword">if</span> (name == ScanSetting.GENERATE_TO_METHOD_NAME) &#123;</span><br><span class="line">            mv = <span class="keyword">new</span> RouteMethodVisitor(Opcodes.ASM5, mv)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> mv</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RouteMethodVisitor</span> <span class="keyword">extends</span> <span class="title">MethodVisitor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    RouteMethodVisitor(<span class="keyword">int</span> api, MethodVisitor mv) &#123;</span><br><span class="line">        <span class="keyword">super</span>(api, mv)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 插入的代码在 return 之前</span></span><br><span class="line">        <span class="keyword">if</span> ((opcode &gt;= Opcodes.IRETURN &amp;&amp; opcode &lt;= Opcodes.RETURN)) &#123;</span><br><span class="line">            extension.classList.each &#123; name -&gt;</span><br><span class="line">                name = name.replaceAll(<span class="string">"/"</span>, <span class="string">"."</span>)</span><br><span class="line">                mv.visitLdcInsn(name)<span class="comment">//这里的name就是之前扫描出来的 IRouteRoot IInterceptorGroup IProviderGroup 实现类名</span></span><br><span class="line">                <span class="comment">// 生成 LogisticsCenter.register(name) 代码</span></span><br><span class="line">                mv.visitMethodInsn(Opcodes.INVOKESTATIC</span><br><span class="line">                        , ScanSetting.GENERATE_TO_CLASS_NAME</span><br><span class="line">                        , ScanSetting.REGISTER_METHOD_NAME</span><br><span class="line">                        , <span class="string">"(Ljava/lang/String;)V"</span></span><br><span class="line">                        , <span class="keyword">false</span>)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">super</span>.visitInsn(opcode)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">visitMaxs</span><span class="params">(<span class="keyword">int</span> maxStack, <span class="keyword">int</span> maxLocals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.visitMaxs(maxStack + <span class="number">4</span>, maxLocals)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最终，生成的代码会像下面所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">loadRouterMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    registerByPlugin = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">//auto generate register code by gradle plugin: arouter-auto-register</span></span><br><span class="line">    <span class="comment">// looks like below:</span></span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$app"</span>);</span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app"</span>);</span><br><span class="line">    register(<span class="string">"com.alibaba.android.arouter.routes.ARouter$$Group$$arouter"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么顺便来跟踪一下 register 方法的代码，看看里面是如何完成路由表注册的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(String className)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!TextUtils.isEmpty(className)) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = Class.forName(className);</span><br><span class="line">            Object obj = clazz.getConstructor().newInstance();</span><br><span class="line">            <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IRouteRoot) &#123;</span><br><span class="line">                registerRouteRoot((IRouteRoot) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IProviderGroup) &#123;</span><br><span class="line">                registerProvider((IProviderGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> IInterceptorGroup) &#123;</span><br><span class="line">                registerInterceptor((IInterceptorGroup) obj);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"register failed, class name: "</span> + className</span><br><span class="line">                        + <span class="string">" should implements one of IRouteRoot/IProviderGroup/IInterceptorGroup."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(TAG,<span class="string">"register class error:"</span> + className);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IRouteRoot 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerRouteRoot</span><span class="params">(IRouteRoot routeRoot)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (routeRoot != <span class="keyword">null</span>) &#123;</span><br><span class="line">        routeRoot.loadInto(Warehouse.groupsIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IInterceptorGroup 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerInterceptor</span><span class="params">(IInterceptorGroup interceptorGroup)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (interceptorGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        interceptorGroup.loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 注册 IProviderGroup 类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerProvider</span><span class="params">(IProviderGroup providerGroup)</span> </span>&#123;</span><br><span class="line">    markRegisteredByPlugin();</span><br><span class="line">    <span class="keyword">if</span> (providerGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">        providerGroup.loadInto(Warehouse.providersIndex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 标记通过gradle plugin完成自动注册</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">markRegisteredByPlugin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!registerByPlugin) &#123;</span><br><span class="line">        registerByPlugin = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样相比之下，自动注册的方式确实比扫描 dex 文件更高效，扫描 dex 文件是在 app 运行时操作的，这样会影响 app 的性能，对用户造成不好的体验。而自动注册是在 build 的时候完成字节码插桩的，对运行时不产生影响。</p>
<p>学了今天这招，以后 compiler 生成的代码需要注册的步骤都可以通过自动注册来完成了，赞一个👍</p>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>之前看到自动注册这么神奇，所以想看下插入字节码之后 LogisticsCenter 代码的效果，所以反编译了一下 ARouter demo apk，可以看到 LogisticsCenter.smali 的 loadRouterMap 方法：</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">.method</span><span class="keyword"> private</span><span class="keyword"> static</span><span class="function"> loadRouterMap(</span><span class="function">)</span>V</span><br><span class="line"><span class="keyword">    .locals</span> 1</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 64</span><br><span class="line">   <span class="instruction"> const/4 </span><span class="variable">v0</span>, 0x0</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> sput-boolean </span><span class="variable">v0</span>, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span>-&gt;registerByPlugin:Z</span><br><span class="line"></span><br><span class="line"><span class="keyword">    .line</span> 69</span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$modulekotlin"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$arouterapi"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Root$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Interceptors$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulejava"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$modulekotlin"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$arouterapi"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> const-string </span><span class="variable">v0</span>, <span class="string">"com.alibaba.android.arouter.routes.ARouter$$Providers$$app"</span></span><br><span class="line"></span><br><span class="line">   <span class="instruction"> invoke-static </span>&#123;<span class="variable">v0</span>&#125;, <span class="class">Lcom/alibaba/android/arouter/core/LogisticsCenter;</span><span class="function">-&gt;register(</span><span class="class">Ljava/lang/String;</span><span class="function">)</span>V</span><br><span class="line"></span><br><span class="line">   <span class="instruction"> return-void</span><br><span class="line"></span><span class="keyword">.end method</span></span><br></pre></td></tr></table></figure>
<p>确实符合我们的预期啊，真好！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://juejin.im/post/5a2b95b96fb9a045284669a9" target="_blank" rel="external">AutoRegister:一种更高效的组件自动注册方案(android组件化开发)</a></li>
<li><a href="https://blog.csdn.net/sbsujjbcy/article/details/50839263" target="_blank" rel="external">Android 热修复使用Gradle Plugin1.5改造Nuwa插件</a></li>
<li><a href="http://quinnchen.me/2018/09/13/2018-09-13-asm-transform/" target="_blank" rel="external">一起玩转Android项目中的字节码</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-gradle-plugin version : 1.0.2</p>
<p>AutoRegister : <a href="https://github.com/luckybilly/AutoRegister" target="_blank" rel="ext]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yuqirong.me/tags/Gradle/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（四）]]></title>
    <link href="http://yuqirong.me/2019/01/05/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E5%9B%9B%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/05/ARouter源码解析（四）/</id>
    <published>2019-01-05T14:35:21.000Z</published>
    <updated>2019-03-04T16:26:35.735Z</updated>
    <content type="html"><![CDATA[<p>arouter-compiler version : 1.2.2</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 arouter-api 做了整个流程的分析，今天来看看 arouter-compiler 。</p>
<p>arouter-compiler 主要是利用 apt 在编译期自动生成代码的。之前我们看到的 <code>ARouter$$Root$$app</code> 、 <code>ARouter$$Group$$test</code> 和 <code>Test1Activity$$ARouter$$Autowired</code> 等都是 arouter-compiler 生成的。</p>
<p>那接下来就分析分析 arouter-compiler 是怎么生成这些源码的。</p>
<h1 id="arouter-compiler"><a href="#arouter-compiler" class="headerlink" title="arouter-compiler"></a>arouter-compiler</h1><p>arouter-compiler 中 processor 有三种：</p>
<ul>
<li>AutowiredProcessor : 用来生成像 <code>Test1Activity$$ARouter$$Autowired</code> 这种类型；</li>
<li>InterceptorProcessor : 用来生成像 <code>ARouter$$Interceptors$$app</code> 这种类型；</li>
<li>RouteProcessor : 用来生成像 <code>ARouter$$Root$$app</code> ，<code>ARouter$$Providers$$app</code> 和 <code>ARouter$$Group$$test</code> 这种类型；</li>
</ul>
<h2 id="RouteProcessor"><a href="#RouteProcessor" class="headerlink" title="RouteProcessor"></a>RouteProcessor</h2><p>在这里我们就只分析 RouteProcessor 了。</p>
<p>RouteProcessor 相比其他两个 Processor 来说，代码更长，逻辑更加复杂。并且 RouteProcessor 主要处理的是路由映射这一块。其他两个 RouteProcessor 也是大同小异，有兴趣的同学可以自行阅读源码。</p>
<p>先来看看 RouteProcessor 的定义：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">@AutoService</span>(Processor.class)</span><br><span class="line"><span class="variable">@SupportedOptions</span>(&#123;KEY_MODULE_NAME, KEY_GENERATE_DOC_NAME&#125;)</span><br><span class="line"><span class="variable">@SupportedSourceVersion</span>(SourceVersion.RELEASE_7)</span><br><span class="line"><span class="variable">@SupportedAnnotationTypes</span>(&#123;ANNOTATION_TYPE_ROUTE, ANNOTATION_TYPE_AUTOWIRED&#125;)</span><br><span class="line">public class RouteProcessor extends AbstractProcessor &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RouteProcessor 类上面的注解很多，我们一个一个来看：</p>
<ul>
<li>@AutoService 会自动在 META-INF 文件夹下生成 Processor 配置信息文件，避免手动配置的麻烦;</li>
<li>@SupportedOptions 指定 Processor 支持的选项参数名称，KEY_MODULE_NAME 就是 AROUTER_MODULE_NAME ，KEY_GENERATE_DOC_NAME 就是 AROUTER_GENERATE_DOC；没错，这两个就是我们一开始在 build.gradle 中配置的。</li>
<li>@SupportedSourceVersion 指定 Processor 支持的 JDK 的版本；</li>
<li>@SupportedAnnotationTypes 指定 Processor 处理的注解；</li>
</ul>
<p>接着，趁热打铁。来瞧瞧 RouteProcessor 的 init 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment processingEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.init(processingEnv);</span><br><span class="line"></span><br><span class="line">    mFiler = processingEnv.getFiler();                  <span class="comment">// Generate class.</span></span><br><span class="line">    types = processingEnv.getTypeUtils();            <span class="comment">// Get type utils.</span></span><br><span class="line">    elements = processingEnv.getElementUtils();      <span class="comment">// Get class meta.</span></span><br><span class="line"></span><br><span class="line">    typeUtils = <span class="keyword">new</span> TypeUtils(types, elements);</span><br><span class="line">    logger = <span class="keyword">new</span> Logger(processingEnv.getMessager());   <span class="comment">// Package the log utils.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Attempt to get user configuration [moduleName]</span></span><br><span class="line">    Map&lt;String, String&gt; options = processingEnv.getOptions();</span><br><span class="line">    <span class="keyword">if</span> (MapUtils.isNotEmpty(options)) &#123;</span><br><span class="line">        moduleName = options.get(KEY_MODULE_NAME);</span><br><span class="line">        generateDoc = VALUE_ENABLE.equals(options.get(KEY_GENERATE_DOC_NAME));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (StringUtils.isNotEmpty(moduleName)) &#123;</span><br><span class="line">        moduleName = moduleName.replaceAll(<span class="string">"[^0-9a-zA-Z_]+"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        logger.info(<span class="string">"The user has configuration the module name, it was ["</span> + moduleName + <span class="string">"]"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logger.error(NO_MODULE_NAME_TIPS);</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ARouter::Compiler &gt;&gt;&gt; No module name, for more information, look at gradle log."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要生成路由 doc</span></span><br><span class="line">    <span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            docWriter = mFiler.createResource(</span><br><span class="line">                    StandardLocation.SOURCE_OUTPUT,</span><br><span class="line">                    PACKAGE_OF_GENERATE_DOCS,</span><br><span class="line">                    <span class="string">"arouter-map-of-"</span> + moduleName + <span class="string">".json"</span></span><br><span class="line">            ).openWriter();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            logger.error(<span class="string">"Create doc writer failed, because "</span> + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    iProvider = elements.getTypeElement(Consts.IPROVIDER).asType();</span><br><span class="line"></span><br><span class="line">    logger.info(<span class="string">"&gt;&gt;&gt; RouteProcessor init. &lt;&lt;&lt;"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 init 方法中，主要获取了 KEY_MODULE_NAME 和 KEY_GENERATE_DOC_NAME 这两个编译选项参数。然后判断一下是否需要生成路由文档。</p>
<p>在 init 方法中获取参数后，接着就是 process 方法。</p>
<p>process 方法就好像是 main 方法一样，在这里面都是 processer 处理注解自动生成代码的逻辑。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(annotations)) &#123;</span><br><span class="line">        <span class="comment">// 获取 @Route 注解的集合</span></span><br><span class="line">        Set&lt;? extends Element&gt; routeElements = roundEnv.getElementsAnnotatedWith(Route.class);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            logger.info(<span class="string">"&gt;&gt;&gt; Found routes, start... &lt;&lt;&lt;"</span>);</span><br><span class="line">            <span class="keyword">this</span>.parseRoutes(routeElements);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            logger.error(e);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 process 中调用了 parseRoutes ，parseRoutes 方法实在是太长了，在这里我们进行分段讲解吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseRoutes</span><span class="params">(Set&lt;? extends Element&gt; routeElements)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (CollectionUtils.isNotEmpty(routeElements)) &#123;</span><br><span class="line">        <span class="comment">// prepare the type an so on.</span></span><br><span class="line">	</span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found routes, size is "</span> + routeElements.size() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">	</span><br><span class="line">        rootMap.clear();</span><br><span class="line">        <span class="comment">// Activity 类型</span></span><br><span class="line">        TypeMirror type_Activity = elements.getTypeElement(ACTIVITY).asType();</span><br><span class="line">        <span class="comment">// Service 类型</span></span><br><span class="line">        TypeMirror type_Service = elements.getTypeElement(SERVICE).asType();</span><br><span class="line">        <span class="comment">// Fragment 类型</span></span><br><span class="line">        TypeMirror fragmentTm = elements.getTypeElement(FRAGMENT).asType();</span><br><span class="line">        <span class="comment">// v4 Fragment 类型</span></span><br><span class="line">        TypeMirror fragmentTmV4 = elements.getTypeElement(Consts.FRAGMENT_V4).asType();</span><br><span class="line">	</span><br><span class="line">        <span class="comment">// IRouteGroup 类型</span></span><br><span class="line">        TypeElement type_IRouteGroup = elements.getTypeElement(IROUTE_GROUP);</span><br><span class="line">        <span class="comment">// IProviderGroup 类型</span></span><br><span class="line">        TypeElement type_IProviderGroup = elements.getTypeElement(IPROVIDER_GROUP);</span><br><span class="line">        <span class="comment">// 获取 RouteMeta 和 RouteType 的类名</span></span><br><span class="line">        ClassName routeMetaCn = ClassName.get(RouteMeta.class);</span><br><span class="line">        ClassName routeTypeCn = ClassName.get(RouteType.class);</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">           构造 ARouter$$Root$$xxx 的 loadInto 方法入参类型</span><br><span class="line">           Build input type, format as :</span><br><span class="line">	</span><br><span class="line">           Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt;</span><br><span class="line">         */</span></span><br><span class="line">        ParameterizedTypeName inputMapTypeOfRoot = ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ParameterizedTypeName.get(</span><br><span class="line">                        ClassName.get(Class.class),</span><br><span class="line">                        WildcardTypeName.subtypeOf(ClassName.get(type_IRouteGroup))</span><br><span class="line">                )</span><br><span class="line">        );</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造 ARouter$$Group$$xxx 的 loadInto 方法入参类型</span><br><span class="line">          Map&lt;String, RouteMeta&gt;</span><br><span class="line">         */</span></span><br><span class="line">        ParameterizedTypeName inputMapTypeOfGroup = ParameterizedTypeName.get(</span><br><span class="line">                ClassName.get(Map.class),</span><br><span class="line">                ClassName.get(String.class),</span><br><span class="line">                ClassName.get(RouteMeta.class)</span><br><span class="line">        );</span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造方法入参参数名称</span><br><span class="line">          Build input param name.</span><br><span class="line">         */</span></span><br><span class="line">        ParameterSpec rootParamSpec = ParameterSpec.builder(inputMapTypeOfRoot, <span class="string">"routes"</span>).build();</span><br><span class="line">        ParameterSpec groupParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"atlas"</span>).build();</span><br><span class="line">        ParameterSpec providerParamSpec = ParameterSpec.builder(inputMapTypeOfGroup, <span class="string">"providers"</span>).build();  <span class="comment">// Ps. its param type same as groupParamSpec!</span></span><br><span class="line">	</span><br><span class="line">        <span class="comment">/*</span><br><span class="line">          构造 ARouter$$Root$$xxx 的 loadInto 方法</span><br><span class="line">          Build method : 'loadInto'</span><br><span class="line">         */</span></span><br><span class="line">        MethodSpec.Builder loadIntoMethodOfRootBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">                .addAnnotation(Override.class)</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addParameter(rootParamSpec);</span><br><span class="line">	</span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>parseRoutes 方法一开始，做足了准备。下面就到了放大招的时候了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//  Follow a sequence, find out metas of group first, generate java file, then statistics them as root.</span></span><br><span class="line"><span class="keyword">for</span> (Element element : routeElements) &#123;</span><br><span class="line">    TypeMirror tm = element.asType();</span><br><span class="line">    Route route = element.getAnnotation(Route.class);</span><br><span class="line">    RouteMeta routeMeta;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果 element 修饰的类是 Activity 类型的</span></span><br><span class="line">    <span class="keyword">if</span> (types.isSubtype(tm, type_Activity)) &#123;                 <span class="comment">// Activity</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found activity route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 Activity 中 @Autowired 注解的属性，IProvider 类型的除外</span></span><br><span class="line">        Map&lt;String, Integer&gt; paramsType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        Map&lt;String, Autowired&gt; injectConfig = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Element field : element.getEnclosedElements()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (field.getKind().isField() &amp;&amp; field.getAnnotation(Autowired.class) != <span class="keyword">null</span> &amp;&amp; !types.isSubtype(field.asType(), iProvider)) &#123;</span><br><span class="line">                <span class="comment">// It must be field, then it has annotation, but it not be provider.</span></span><br><span class="line">                Autowired paramConfig = field.getAnnotation(Autowired.class);</span><br><span class="line">                String injectName = StringUtils.isEmpty(paramConfig.name()) ? field.getSimpleName().toString() : paramConfig.name();</span><br><span class="line">                paramsType.put(injectName, typeUtils.typeExchange(field));</span><br><span class="line">                injectConfig.put(injectName, paramConfig);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 构造 activity 类型的路由数据</span></span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.ACTIVITY, paramsType);</span><br><span class="line">        routeMeta.setInjectConfig(injectConfig);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123;         <span class="comment">// IProvider 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found provider route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.PROVIDER, <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, type_Service)) &#123;           <span class="comment">// Service 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found service route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.parse(SERVICE), <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, fragmentTm) || types.isSubtype(tm, fragmentTmV4)) &#123; <span class="comment">// fragment 类型</span></span><br><span class="line">        logger.info(<span class="string">"&gt;&gt;&gt; Found fragment route: "</span> + tm.toString() + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line">        routeMeta = <span class="keyword">new</span> RouteMeta(route, element, RouteType.parse(FRAGMENT), <span class="keyword">null</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"ARouter::Compiler &gt;&gt;&gt; Found unsupported class type, type = ["</span> + types.toString() + <span class="string">"]."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将生成好的 routeMeta 按组存放进入 groupMap 中</span></span><br><span class="line">    categories(routeMeta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这段代码主要将每个 routeElement 进行了分类，将 @Route 修饰的类信息封装进 RouteMeta 中。再把 RouteMeta 按照组名分好组存进 groupMap 中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 构造 ARouter$$Providers$$xxx 的 loadInto 方法</span></span><br><span class="line">MethodSpec.Builder loadIntoMethodOfProviderBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">        .addAnnotation(Override.class)</span><br><span class="line">        .addModifiers(PUBLIC)</span><br><span class="line">        .addParameter(providerParamSpec);</span><br><span class="line"></span><br><span class="line">Map&lt;String, List&lt;RouteDoc&gt;&gt; docSource = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start generate java source, structure is divided into upper and lower levels, used for demand initialization.</span></span><br><span class="line"><span class="keyword">for</span> (Map.Entry&lt;String, Set&lt;RouteMeta&gt;&gt; entry : groupMap.entrySet()) &#123;</span><br><span class="line">    <span class="comment">// 每组的组名</span></span><br><span class="line">    String groupName = entry.getKey();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 ARouter$$Group$$xxx 的 loadInto 方法</span></span><br><span class="line">    MethodSpec.Builder loadIntoMethodOfGroupBuilder = MethodSpec.methodBuilder(METHOD_LOAD_INTO)</span><br><span class="line">            .addAnnotation(Override.class)</span><br><span class="line">            .addModifiers(PUBLIC)</span><br><span class="line">            .addParameter(groupParamSpec);</span><br><span class="line"></span><br><span class="line">    List&lt;RouteDoc&gt; routeDocList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Build group method body</span></span><br><span class="line">    Set&lt;RouteMeta&gt; groupData = entry.getValue();</span><br><span class="line">    <span class="keyword">for</span> (RouteMeta routeMeta : groupData) &#123;</span><br><span class="line">        RouteDoc routeDoc = extractDocInfo(routeMeta);</span><br><span class="line">        <span class="comment">// 类名。比如 com.alibaba.android.arouter.demo.testservice.HelloService</span></span><br><span class="line">        ClassName className = ClassName.get((TypeElement) routeMeta.getRawType());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// Need cache provider's super class</span></span><br><span class="line">                <span class="comment">// 获取该节点下的接口</span></span><br><span class="line">                List&lt;? extends TypeMirror&gt; interfaces = ((TypeElement) routeMeta.getRawType()).getInterfaces();</span><br><span class="line">                <span class="comment">// 遍历接口</span></span><br><span class="line">                <span class="keyword">for</span> (TypeMirror tm : interfaces) &#123;</span><br><span class="line">                    routeDoc.addPrototype(tm.toString());</span><br><span class="line">                    <span class="comment">// 如果接口是 iProvider 类型</span></span><br><span class="line">                    <span class="keyword">if</span> (types.isSameType(tm, iProvider)) &#123;   <span class="comment">// Its implements iProvider interface himself.</span></span><br><span class="line">                        <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                        loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                <span class="string">"providers.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, null, "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">                                (routeMeta.getRawType()).toString(),</span><br><span class="line">                                routeMetaCn,</span><br><span class="line">                                routeTypeCn,</span><br><span class="line">                                className,</span><br><span class="line">                                routeMeta.getPath(),</span><br><span class="line">                                routeMeta.getGroup());</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (types.isSubtype(tm, iProvider)) &#123; <span class="comment">// 如果是 iProvider 的子接口</span></span><br><span class="line">                        <span class="comment">// This interface extend the IProvider, so it can be used for mark provider</span></span><br><span class="line">                        loadIntoMethodOfProviderBuilder.addStatement(</span><br><span class="line">                                <span class="string">"providers.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, null, "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">                                tm.toString(),    <span class="comment">// So stupid, will duplicate only save class name.</span></span><br><span class="line">                                routeMetaCn,</span><br><span class="line">                                routeTypeCn,</span><br><span class="line">                                className,</span><br><span class="line">                                routeMeta.getPath(),</span><br><span class="line">                                routeMeta.getGroup());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码最终会生成 ARouter$$Providers$$xxx 的 loadInto 方法，比如像这样：</p>
<pre><code>providers.put(&quot;com.alibaba.android.arouter.demo.testservice.HelloService&quot;, RouteMeta.build(RouteType.PROVIDER, HelloServiceImpl.class, &quot;/yourservicegroupname/hello&quot;, &quot;yourservicegroupname&quot;, null, -1, -2147483648));
</code></pre><p>那我们接着看。</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">    // 构造 RouteMeta 的 paramType 参数</span><br><span class="line">    StringBuilder mapBodyBuilder = new StringBuilder();</span><br><span class="line">    Map<span class="variable">&lt;String, Integer&gt;</span> paramsType = routeMeta.getParamsType();</span><br><span class="line">    Map<span class="variable">&lt;String, Autowired&gt;</span> injectConfigs = routeMeta.getInjectConfig();</span><br><span class="line">    if (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">        List<span class="variable">&lt;RouteDoc.Param&gt;</span> paramList = new ArrayList<span class="variable">&lt;&gt;</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Map.Entry<span class="variable">&lt;String, Integer&gt;</span> types : paramsType.entrySet()) &#123;</span><br><span class="line">            mapBodyBuilder.append(<span class="string">"put(\""</span>).append(types.getKey()).append(<span class="string">"\", "</span>).append(types.getValue()).append(<span class="string">"); "</span>);</span><br><span class="line"></span><br><span class="line">            RouteDoc.Param param = new RouteDoc.Param();</span><br><span class="line">            Autowired injectConfig = injectConfigs.get(types.getKey());</span><br><span class="line">            param.<span class="built_in">set</span>Key(types.getKey());</span><br><span class="line">            param.<span class="built_in">set</span>Type(TypeKind.values()[types.getValue()].name().<span class="keyword">to</span>LowerCase());</span><br><span class="line">            param.<span class="built_in">set</span>Description(injectConfig.desc());</span><br><span class="line">            param.<span class="built_in">set</span>Required(injectConfig.required());</span><br><span class="line"></span><br><span class="line">            paramList.add(param);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        routeDoc.<span class="built_in">set</span>Params(paramList);</span><br><span class="line">    &#125;</span><br><span class="line">    String mapBody = mapBodyBuilder.<span class="keyword">to</span>String();</span><br><span class="line"></span><br><span class="line">    // 以下代码生成这种模版 atlas.put(<span class="string">"/test/activity1"</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">"/test/activity1"</span>, <span class="string">"test"</span>, new java.util.HashMap<span class="variable">&lt;String, Integer&gt;</span>()&#123;&#123;put(<span class="string">"ser"</span>, <span class="number">9</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">load</span>IntoMethodOfGroupBuilder.addStatement(</span><br><span class="line">            <span class="string">"atlas.put($S, $T.build($T."</span> + routeMeta.getType() + <span class="string">", $T.class, $S, $S, "</span> + (StringUtils.isEmpty(mapBody) ? null : (<span class="string">"new java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;"</span> + mapBodyBuilder.<span class="keyword">to</span>String() + <span class="string">"&#125;&#125;"</span>)) + <span class="string">", "</span> + routeMeta.getPriority() + <span class="string">", "</span> + routeMeta.getExtra() + <span class="string">"))"</span>,</span><br><span class="line">            routeMeta.getPath(),</span><br><span class="line">            routeMetaCn,</span><br><span class="line">            routeTypeCn,</span><br><span class="line">            className,</span><br><span class="line">            routeMeta.getPath().<span class="keyword">to</span>LowerCase(),</span><br><span class="line">            routeMeta.getGroup().<span class="keyword">to</span>LowerCase());</span><br><span class="line"></span><br><span class="line">    routeDoc.<span class="built_in">set</span>ClassName(className.<span class="keyword">to</span>String());</span><br><span class="line">    routeDocList.add(routeDoc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 生成 ARouter$<span class="variable">$Group</span>$<span class="variable">$xxx</span> 类</span><br><span class="line">String <span class="keyword">group</span>FileName = NAME_OF_GROUP + <span class="keyword">group</span>Name;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(<span class="keyword">group</span>FileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(type_IRouteGroup))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(<span class="built_in">load</span>IntoMethodOfGroupBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated group: "</span> + <span class="keyword">group</span>Name + <span class="string">"&lt;&lt;&lt;"</span>);</span><br><span class="line">rootMap.put(<span class="keyword">group</span>Name, <span class="keyword">group</span>FileName);</span><br><span class="line">docSource.put(<span class="keyword">group</span>Name, routeDocList);</span><br></pre></td></tr></table></figure>
<p>上面代码主要做的事情就是遍历 groupmap 集合给 ARouter$$Group$$xxx 类中的 loadInto 添加方法体，并生成 java 文件。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (MapUtils.isNotEmpty(rootMap)) &#123;</span><br><span class="line">    <span class="comment">// Generate root meta by group name, it must be generated before root, then I can find out the class of group.</span></span><br><span class="line">    <span class="comment">// 生成 ARouter$$Root$$app 的 loadInto 方法体</span></span><br><span class="line">    <span class="keyword">for</span> (Map.Entry&lt;String, String&gt; entry : rootMap.entrySet()) &#123;</span><br><span class="line">        loadIntoMethodOfRootBuilder.addStatement(<span class="string">"routes.put($S, $T.class)"</span>, entry.getKey(), ClassName.get(PACKAGE_OF_GENERATE_FILE, entry.getValue()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Output route doc</span></span><br><span class="line"><span class="keyword">if</span> (generateDoc) &#123;</span><br><span class="line">    docWriter.append(JSON.toJSONString(docSource, SerializerFeature.PrettyFormat));</span><br><span class="line">    docWriter.flush();</span><br><span class="line">    docWriter.close();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 ARouter$$Providers$$app 类</span></span><br><span class="line">String providerMapFileName = NAME_OF_PROVIDER + SEPARATOR + moduleName;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(providerMapFileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(type_IProviderGroup))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(loadIntoMethodOfProviderBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated provider map, name is "</span> + providerMapFileName + <span class="string">" &lt;&lt;&lt;"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 ARouter$$Root$$app 类 </span></span><br><span class="line">String rootFileName = NAME_OF_ROOT + SEPARATOR + moduleName;</span><br><span class="line">JavaFile.builder(PACKAGE_OF_GENERATE_FILE,</span><br><span class="line">        TypeSpec.classBuilder(rootFileName)</span><br><span class="line">                .addJavadoc(WARNING_TIPS)</span><br><span class="line">                .addSuperinterface(ClassName.get(elements.getTypeElement(ITROUTE_ROOT)))</span><br><span class="line">                .addModifiers(PUBLIC)</span><br><span class="line">                .addMethod(loadIntoMethodOfRootBuilder.build())</span><br><span class="line">                .build()</span><br><span class="line">).build().writeTo(mFiler);</span><br><span class="line"></span><br><span class="line">logger.info(<span class="string">"&gt;&gt;&gt; Generated root, name is "</span> + rootFileName + <span class="string">" &lt;&lt;&lt;"</span>);</span><br></pre></td></tr></table></figure>
<p>以上，就是整个 RouteProcessor 的流程。看完 RouteProcessor 之后，相信你对 ARouter 的的了解也更加深入了。</p>
<p>之后，也会对 ARouter 的 arouter-register 模块做一个深入解析，敬请期待吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-compiler version : 1.2.2</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 arouter-]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（三）]]></title>
    <link href="http://yuqirong.me/2019/01/03/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%89%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/03/ARouter源码解析（三）/</id>
    <published>2019-01-03T13:46:43.000Z</published>
    <updated>2019-03-04T16:26:40.192Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>到现在为止，ARouter 还有最后的依赖注入还没有解析过，那么今天就来深入探究一下其实现原理。</p>
<p>PS : 因为依赖注入的原理还比较简单，所以本篇篇幅会较短。</p>
<h1 id="@Autowired_u89E3_u6790"><a href="#@Autowired_u89E3_u6790" class="headerlink" title="@Autowired解析"></a>@Autowired解析</h1><p>想要用 ARouter 实现依赖注入，需要在 Activity/Fragment 中加上</p>
<pre><code>ARouter.getInstance().inject(this);
</code></pre><p>那么我们这个代码就成为了我们分析的入口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object thiz)</span> </span>&#123;</span><br><span class="line">    _ARouter.inject(thiz);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARouter 内部还是调用了 _ARouter 的 inject 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object thiz)</span> </span>&#123;</span><br><span class="line">    AutowiredService autowiredService = ((AutowiredService) ARouter.getInstance().build(<span class="string">"/arouter/service/autowired"</span>).navigation());</span><br><span class="line">    <span class="comment">// 如果 autowiredService 不为空，完成依赖注入</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != autowiredService) &#123;</span><br><span class="line">        autowiredService.autowire(thiz);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现依赖注入和拦截器很相似，都是利用服务组件来完成的。依赖注入的服务组件叫 AutowiredService ，跟踪可以发现，它的实现类是 AutowiredServiceImpl 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Route</span>(path = <span class="string">"/arouter/service/autowired"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutowiredServiceImpl</span> <span class="keyword">implements</span> <span class="title">AutowiredService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> LruCache&lt;String, ISyringe&gt; classCache;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; blackList;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        classCache = <span class="keyword">new</span> LruCache&lt;&gt;(<span class="number">66</span>);</span><br><span class="line">        blackList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">autowire</span><span class="params">(Object instance)</span> </span>&#123;</span><br><span class="line">        String className = instance.getClass().getName();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 instance 这个类进入黑名单了，就不会完成依赖注入</span></span><br><span class="line">            <span class="keyword">if</span> (!blackList.contains(className)) &#123;</span><br><span class="line">                <span class="comment">// 先从缓存中取</span></span><br><span class="line">                ISyringe autowiredHelper = classCache.get(className);</span><br><span class="line">                <span class="comment">// 没有缓存就创建对象</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == autowiredHelper) &#123;  <span class="comment">// No cache.</span></span><br><span class="line">                    autowiredHelper = (ISyringe) Class.forName(instance.getClass().getName() + SUFFIX_AUTOWIRED).getConstructor().newInstance();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 完成依赖注入</span></span><br><span class="line">                autowiredHelper.inject(instance);</span><br><span class="line">                <span class="comment">// 放入缓存中</span></span><br><span class="line">                classCache.put(className, autowiredHelper);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">            <span class="comment">// 出错就加入黑名单中</span></span><br><span class="line">            blackList.add(className);    <span class="comment">// This instance need not autowired.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中 ISyringe 就是依赖注入抽取出来的接口，</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ISyringe</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object <span class="keyword">target</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么 ISyringe 的实现类又是谁呢？答案就是在编译期自动生成的类 <code>XXXX$$ARouter$$Autowired</code> ，我们找 demo 中生成的 <code>Test1Activity$$ARouter$$Autowired</code> 来看看</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test1Activity</span>$$<span class="title">ARouter</span>$$<span class="title">Autowired</span> <span class="keyword">implements</span> <span class="title">ISyringe</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> SerializationService serializationService;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">inject</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">    serializationService = ARouter.getInstance().navigation(SerializationService.class);</span><br><span class="line">    Test1Activity substitute = (Test1Activity)target;</span><br><span class="line">    substitute.name = substitute.getIntent().getStringExtra(<span class="string">"name"</span>);</span><br><span class="line">    substitute.age = substitute.getIntent().getIntExtra(<span class="string">"age"</span>, substitute.age);</span><br><span class="line">    substitute.height = substitute.getIntent().getIntExtra(<span class="string">"height"</span>, substitute.height);</span><br><span class="line">    substitute.girl = substitute.getIntent().getBooleanExtra(<span class="string">"boy"</span>, substitute.girl);</span><br><span class="line">    substitute.ch = substitute.getIntent().getCharExtra(<span class="string">"ch"</span>, substitute.ch);</span><br><span class="line">    substitute.fl = substitute.getIntent().getFloatExtra(<span class="string">"fl"</span>, substitute.fl);</span><br><span class="line">    substitute.dou = substitute.getIntent().getDoubleExtra(<span class="string">"dou"</span>, substitute.dou);</span><br><span class="line">    substitute.ser = (com.alibaba.android.arouter.demo.testinject.TestSerializable) substitute.getIntent().getSerializableExtra(<span class="string">"ser"</span>);</span><br><span class="line">    substitute.pac = substitute.getIntent().getParcelableExtra(<span class="string">"pac"</span>);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.obj = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"obj"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;TestObj&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'obj' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.objList = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"objList"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;List&lt;TestObj&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'objList' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != serializationService) &#123;</span><br><span class="line">      substitute.map = serializationService.parseObject(substitute.getIntent().getStringExtra(<span class="string">"map"</span>), <span class="keyword">new</span> com.alibaba.android.arouter.facade.model.TypeWrapper&lt;Map&lt;String, List&lt;TestObj&gt;&gt;&gt;()&#123;&#125;.getType());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      Log.e(<span class="string">"ARouter::"</span>, <span class="string">"You want automatic inject the field 'map' in class 'Test1Activity' , then you should implement 'SerializationService' to support object auto inject!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    substitute.url = substitute.getIntent().getStringExtra(<span class="string">"url"</span>);</span><br><span class="line">    substitute.helloService = ARouter.getInstance().navigation(HelloService.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面自动生成的代码中看出来，依赖注入实际上内部还是使用 <code>getIntent.getXxxExtra</code> 的形式来赋值的（同理，Fragment 用的是<code>getArguments().getXxx()</code> ）。需要注意的是，@Autowired 修饰的字段不能是 private 的，不然在自动生成代码的时候会报错。</p>
<p>另外，上面的代码中有一个 SerializationService 是用来干什么的？其实 SerializationService 是 json 序列化用的。在 demo 中官方给出了一个实现类 JsonServiceImpl ，内部用的是阿里的 fastjson 。如果有需要自定义的童鞋，可以参照着 JsonServiceImpl 自己去实现。</p>
<h1 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h1><p>看到这，基本上 ARouter 依赖注入的东西就讲完了。</p>
<p>这一系列下来，ARouter 代码层面的流程都讲的差不多。剩下就是 gradle-plugin 和 compiler 这两个部分还没解析过，等时间了再给大家讲。</p>
<p>bye bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>到现在为止，ARouter 还有最]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（二）]]></title>
    <link href="http://yuqirong.me/2019/01/02/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
    <id>http://yuqirong.me/2019/01/02/ARouter源码解析（二）/</id>
    <published>2019-01-02T12:16:40.000Z</published>
    <updated>2019-03-04T16:26:49.903Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>前几天对 ARouter 的页面跳转源码进行了分析，趁着今天有空，就讲讲 ARouter 里面的拦截器吧。</p>
<p>ARouter 拦截器的使用方法在这就不多说了，不了解的同学可以去 GitHub 上看看。那就直接进入正题了。</p>
<h1 id="u62E6_u622A_u5668_u89E3_u6790"><a href="#u62E6_u622A_u5668_u89E3_u6790" class="headerlink" title="拦截器解析"></a>拦截器解析</h1><p>把视线转移回 ARouter 的 init 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = _ARouter.logger;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</span><br><span class="line">        hasInit = _ARouter.init(application);</span><br><span class="line">        <span class="comment">// 如果初始化完成了</span></span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            _ARouter.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 init 中，判断了初始化完成后，调用了 <code>_ARouter.afterInit()</code> 来初始化拦截器，跟进代码去看看。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">afterInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Trigger interceptor init, use byName.</span></span><br><span class="line">    interceptorService = (InterceptorService) ARouter.getInstance().build(<span class="string">"/arouter/service/interceptor"</span>).navigation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现有个 InterceptorService ，InterceptorService 就是用来控制拦截的服务组件，来看看它的接口是怎么定义的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InterceptorService</span> <span class="keyword">extends</span> <span class="title">IProvider</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Do interceptions</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(Postcard postcard, InterceptorCallback callback)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前我们分析过，IProvider 也是可以用 <code>ARouter.getInstance().build(&quot;xxx&quot;).navigation()</code> 的形式获取的。关键的代码在 LogisticsCenter 的 completion 方法中</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Completion the postcard by route metas</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> postcard Incomplete postcard, should complete by this method.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;</span><br><span class="line">        <span class="comment">// 省略一大串代码</span></span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 省略一大串代码</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，如果是 PROVIDER 类型的，就会反射出一个单例对象，并且设置为绿色通道（即不受拦截器的影响）。更详细的代码就不过多介绍了，不理解的同学可以结合着上一篇博客私下回去再看。</p>
<p>所以其实在 afterInit 方法中，只是获取到了 InterceptorService 的实例对象，我们根据上面的 “/arouter/service/interceptor” 可以很轻松的查到，InterceptorService 接口的实现类就是 InterceptorServiceImpl </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Route</span>(path = <span class="string">"/arouter/service/interceptor"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterceptorServiceImpl</span> <span class="keyword">implements</span> <span class="title">InterceptorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> interceptorHasInit;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object interceptorInitLock = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(<span class="keyword">final</span> Context context)</span> </span>&#123;</span><br><span class="line">        LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (MapUtils.isNotEmpty(Warehouse.interceptorsIndex)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Map.Entry&lt;Integer, Class&lt;? extends IInterceptor&gt;&gt; entry : Warehouse.interceptorsIndex.entrySet()) &#123;</span><br><span class="line">                        Class&lt;? extends IInterceptor&gt; interceptorClass = entry.getValue();</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            IInterceptor iInterceptor = interceptorClass.getConstructor().newInstance();</span><br><span class="line">                            iInterceptor.init(context);</span><br><span class="line">                            Warehouse.interceptors.add(iInterceptor);</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init interceptor error! name = ["</span> + interceptorClass.getName() + <span class="string">"], reason = ["</span> + ex.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    interceptorHasInit = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    logger.info(TAG, <span class="string">"ARouter interceptors init over."</span>);</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">synchronized</span> (interceptorInitLock) &#123;</span><br><span class="line">                        interceptorInitLock.notifyAll();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看 InterceptorServiceImpl 的 init 方法。</p>
<p>在 init 方法中，做的主要事情就是遍历所有 IInterceptor class 并创建出对象，调用其 init 方法，完成初始化操作。</p>
<p>初始化完成之后，InterceptorService又是在哪里被使用的呢？</p>
<p>我们在 _ARouter 的 navigation 方法里可以看到它的踪迹：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Continue process</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> postcard route meta</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Interrupt process, pipeline will be destory when this method called.</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> exception Reson of interrupt.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不是绿色通道的话，就会启动拦截器去进行拦截。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doInterceptions</span><span class="params">(<span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> InterceptorCallback callback)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (<span class="keyword">null</span> != Warehouse.interceptors &amp;&amp; Warehouse.interceptors.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line"></span><br><span class="line">       checkInterceptorsInitStatus();</span><br><span class="line">       <span class="comment">// 如果拦截器还没有初始化好</span></span><br><span class="line">       <span class="keyword">if</span> (!interceptorHasInit) &#123;</span><br><span class="line">           callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"Interceptors initialization takes too much time."</span>));</span><br><span class="line">           <span class="keyword">return</span>;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       LogisticsCenter.executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               CancelableCountDownLatch interceptorCounter = <span class="keyword">new</span> CancelableCountDownLatch(Warehouse.interceptors.size());</span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   _excute(<span class="number">0</span>, interceptorCounter, postcard);</span><br><span class="line">                   <span class="comment">// 阻塞线程直到计数归0或者超时；超时时间 默认300s</span></span><br><span class="line">                   interceptorCounter.await(postcard.getTimeout(), TimeUnit.SECONDS);</span><br><span class="line">                   <span class="keyword">if</span> (interceptorCounter.getCount() &gt; <span class="number">0</span>) &#123;    <span class="comment">// 如果 count 大于 0 说明是拦截器超时</span></span><br><span class="line">                       callback.onInterrupt(<span class="keyword">new</span> HandlerException(<span class="string">"The interceptor processing timed out."</span>));</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">null</span> != postcard.getTag()) &#123;    <span class="comment">// 说明是某个拦截器中断了，导致整个流程中断</span></span><br><span class="line">                       callback.onInterrupt(<span class="keyword">new</span> HandlerException(postcard.getTag().toString()));</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 否则就通过</span></span><br><span class="line">                       callback.onContinue(postcard);</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                   callback.onInterrupt(e);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123; <span class="comment">// 如果没有拦截器 就通过</span></span><br><span class="line">       callback.onContinue(postcard);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line">* Excute interceptor</span><br><span class="line">*</span><br><span class="line">* <span class="doctag">@param</span> index    current interceptor index</span><br><span class="line">* <span class="doctag">@param</span> counter  interceptor counter</span><br><span class="line">* <span class="doctag">@param</span> postcard routeMeta</span><br><span class="line">*/</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">_excute</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> index, <span class="keyword">final</span> CancelableCountDownLatch counter, <span class="keyword">final</span> Postcard postcard)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (index &lt; Warehouse.interceptors.size()) &#123;</span><br><span class="line">       IInterceptor iInterceptor = Warehouse.interceptors.get(index);</span><br><span class="line">       iInterceptor.process(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// Last interceptor excute over with no exception.</span></span><br><span class="line">               counter.countDown();</span><br><span class="line">               <span class="comment">// 一个拦截器执行好后，执行下一个</span></span><br><span class="line">               _excute(index + <span class="number">1</span>, counter, postcard);  <span class="comment">// When counter is down, it will be execute continue ,but index bigger than interceptors size, then U know.</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="annotation">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">               <span class="comment">// Last interceptor excute over with fatal exception.</span></span><br><span class="line"></span><br><span class="line">               postcard.setTag(<span class="keyword">null</span> == exception ? <span class="keyword">new</span> HandlerException(<span class="string">"No message."</span>) : exception.getMessage());    <span class="comment">// save the exception message for backup.</span></span><br><span class="line">               <span class="comment">// 如果其中一个拦截器中断的话，就中断整个流程</span></span><br><span class="line">               counter.cancel();</span><br><span class="line">               <span class="comment">// Be attention, maybe the thread in callback has been changed,</span></span><br><span class="line">               <span class="comment">// then the catch block(L207) will be invalid.</span></span><br><span class="line">               <span class="comment">// The worst is the thread changed to main thread, then the app will be crash, if you throw this exception!</span></span><br><span class="line"><span class="comment">//                    if (!Looper.getMainLooper().equals(Looper.myLooper())) &#123;    // You shouldn't throw the exception if the thread is main thread.</span></span><br><span class="line"><span class="comment">//                        throw new HandlerException(exception.getMessage());</span></span><br><span class="line"><span class="comment">//                    &#125;</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上都加了注释了，这里就不再多讲了。</p>
<p>到这里整个 ARouter 拦截器的流程就差不多讲完了，如果还有哪里不懂的地方可以在评论区留言。</p>
<p>再见👋</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>前几天对 ARouter 的页面跳]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ARouter源码解析（一）]]></title>
    <link href="http://yuqirong.me/2018/12/24/ARouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yuqirong.me/2018/12/24/ARouter源码解析（一）/</id>
    <published>2018-12-24T13:13:20.000Z</published>
    <updated>2019-03-04T16:26:45.373Z</updated>
    <content type="html"><![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 ActivityRouter 的源码做了一次分析，相信大家对路由框架已经有一个大概的理解了。</p>
<p>而今天给大家分析一下 ARouter 。大家在项目组件化的过程中，可能绝大多数的开发者都会使用 ARouter 来作为项目的路由框架。毕竟 ARouter 是阿里出品，优点自然不必多说了。</p>
<p>所以在平常使用的过程中，不仅仅要做到会用，还要深入了解一下 ARouter 的内部原理。</p>
<p>本次 ARouter 的解析分为三部分：</p>
<ol>
<li>对 IRouteRoot 页面跳转进行源码解析；</li>
<li>对 IInterceptorGroup 拦截器进行源码解析；</li>
<li>对 @Autowired 自动注入进行源码解析；</li>
<li>对 ARouter 的 arouter-compiler 进行源码分析；</li>
<li>对 ARouter 的 arouter-register 进行源码分析；</li>
</ol>
<p>本篇是 ARouter 系列的第一篇，下面就对 IRouteRoot 页面跳转进行详细解析。</p>
<h1 id="ARouter__u6E90_u7801"><a href="#ARouter__u6E90_u7801" class="headerlink" title="ARouter 源码"></a>ARouter 源码</h1><p>使用 ARouter 的时候，都需要初始化</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (isDebug()) &#123;          </span><br><span class="line">    ARouter.openLog();</span><br><span class="line">    ARouter.openDebug();</span><br><span class="line">&#125;</span><br><span class="line">ARouter.init(mApplication);</span><br></pre></td></tr></table></figure>
<p>源码分析的入口，就在 ARouter.init 里</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!hasInit) &#123;</span><br><span class="line">        logger = _ARouter.logger;</span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init start."</span>);</span><br><span class="line">        hasInit = _ARouter.init(application);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (hasInit) &#123;</span><br><span class="line">            _ARouter.afterInit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        _ARouter.logger.info(Consts.TAG, <span class="string">"ARouter init over."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码上可以看到，ARouter 的内部其实是 _ARouter 在起作用，ARouter 只是把 _ARouter 再做了一层包装。那么我们就跟进 _ARouter 的 init 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">boolean</span> <span class="title">init</span><span class="params">(Application application)</span> </span>&#123;</span><br><span class="line">    mContext = application;</span><br><span class="line">    LogisticsCenter.init(mContext, executor);</span><br><span class="line">    logger.info(Consts.TAG, <span class="string">"ARouter init success!"</span>);</span><br><span class="line">    hasInit = <span class="keyword">true</span>;</span><br><span class="line">    mHandler = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最重要的一句代码还是 <code>LogisticsCenter.init(mContext, executor)</code> ，其中 executor 是线程池。</p>
<p>那么问题来了， LogisticsCenter 是干什么的呢？</p>
<pre><code>* LogisticsCenter contains all of the map.
* 
* 1. Creates instance when it is first used.
* 2. Handler Multi-Module relationship map(*)
* 3. Complex logic to solve duplicate group definition
</code></pre><p>根据官方的注释，LogisticsCenter 是包含了所有的映射，处理跨模块的映射关系以及匹配路由等。</p>
<p>所以根据之前 ActivityRouter 的经验猜测得到，LogisticsCenter 的 init 方法里面，肯定会去加载路由，并建立关系。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context, ThreadPoolExecutor tpe)</span> <span class="keyword">throws</span> HandlerException </span>&#123;</span><br><span class="line">    mContext = context;</span><br><span class="line">    executor = tpe;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">long</span> startInit = System.currentTimeMillis();</span><br><span class="line">        <span class="comment">//billy.qi modified at 2017-12-06</span></span><br><span class="line">        <span class="comment">//load by plugin first</span></span><br><span class="line">        loadRouterMap();</span><br><span class="line">        <span class="keyword">if</span> (registerByPlugin) &#123;</span><br><span class="line">            logger.info(TAG, <span class="string">"Load router map by arouter-auto-register plugin."</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Set&lt;String&gt; routerMap;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果是debug或者新版本的话，会去重新加载路由映射</span></span><br><span class="line">            <span class="keyword">if</span> (ARouter.debuggable() || PackageUtils.isNewVersion(context)) &#123;</span><br><span class="line">                logger.info(TAG, <span class="string">"Run with debug mode or new install, rebuild router map."</span>);</span><br><span class="line">                <span class="comment">// 加载路由映射</span></span><br><span class="line">                routerMap = ClassUtils.getFileNameByPackageName(mContext, ROUTE_ROOT_PAKCAGE);</span><br><span class="line">                <span class="comment">// 保存所有的路由映射到 SharedPreferences</span></span><br><span class="line">                <span class="keyword">if</span> (!routerMap.isEmpty()) &#123;</span><br><span class="line">                    context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).edit().putStringSet(AROUTER_SP_KEY_MAP, routerMap).apply();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 保存新版本号到 sharedpreference</span></span><br><span class="line">                PackageUtils.updateVersion(context);    <span class="comment">// Save new version name when router map update finishes.</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就从 SharedPreferences 中读取之前保存的所有路由映射</span></span><br><span class="line">                logger.info(TAG, <span class="string">"Load router map from cache."</span>);</span><br><span class="line">                routerMap = <span class="keyword">new</span> HashSet&lt;&gt;(context.getSharedPreferences(AROUTER_SP_CACHE_KEY, Context.MODE_PRIVATE).getStringSet(AROUTER_SP_KEY_MAP, <span class="keyword">new</span> HashSet&lt;String&gt;()));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            logger.info(TAG, <span class="string">"Find router map finished, map size = "</span> + routerMap.size() + <span class="string">", cost "</span> + (System.currentTimeMillis() - startInit) + <span class="string">" ms."</span>);</span><br><span class="line">            startInit = System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 把上面加载得到的路由映射根据ClassName分为三种，分别进行注册</span></span><br><span class="line">            <span class="comment">// IRouteRoot 页面跳转</span></span><br><span class="line">            <span class="comment">// IInterceptorGroup 拦截器</span></span><br><span class="line">            <span class="comment">// IProviderGroup 服务组件</span></span><br><span class="line">            <span class="keyword">for</span> (String className : routerMap) &#123;</span><br><span class="line">                <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_ROOT)) &#123;</span><br><span class="line">                    <span class="comment">// This one of root elements, load root.</span></span><br><span class="line">                    ((IRouteRoot) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.groupsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_INTERCEPTORS)) &#123;</span><br><span class="line">                    <span class="comment">// Load interceptorMeta</span></span><br><span class="line">                    ((IInterceptorGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.interceptorsIndex);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (className.startsWith(ROUTE_ROOT_PAKCAGE + DOT + SDK_NAME + SEPARATOR + SUFFIX_PROVIDERS)) &#123;</span><br><span class="line">                    <span class="comment">// Load providerIndex</span></span><br><span class="line">                    ((IProviderGroup) (Class.forName(className).getConstructor().newInstance())).loadInto(Warehouse.providersIndex);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">        </span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"ARouter init logistics center exception! ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LogisticsCenter 的 init 方法的代码基本上都可以看得懂，其中 <code>ClassUtils.getFileNameByPackageName</code> 是我们值得探究的地方。这句代码主要做的事情就是从 dex 中遍历 class 找到 arouter-compiler 生成的类集合。具体的分析我们到最后面再讲，这里先埋个伏笔。</p>
<p>接着往下看，我们知道，routerMap 中的 className 都是 arouter-compiler 在编译期生成的，那我们先来看看生成的类长什么样</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Root</span>$$<span class="title">app</span> <span class="keyword">implements</span> <span class="title">IRouteRoot</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, Class&lt;? extends IRouteGroup&gt;&gt; routes)</span> </span>&#123;</span><br><span class="line">    routes.put(<span class="string">"test"</span>, ARouter$$Group$$test.class);</span><br><span class="line">    routes.put(<span class="string">"yourservicegroupname"</span>, ARouter$$Group$$yourservicegroupname.class);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ARouter 的路由会分组加载，比如当前有 /test/abc 和 /test/def 两个路由，那他们同属于 /test 这个组。所以在 Warehouse.groupsIndex 中存放的 key 是路由组名，value 是对应组路由类。查找路由的时候也是根据组名 key ，再找到组路由类 value 中查找匹配的路由。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * DO NOT EDIT THIS FILE!!! IT WAS GENERATED BY AROUTER. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ARouter</span>$$<span class="title">Group</span>$$<span class="title">test</span> <span class="keyword">implements</span> <span class="title">IRouteGroup</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadInto</span><span class="params">(Map&lt;String, RouteMeta&gt; atlas)</span> </span>&#123;</span><br><span class="line">    atlas.put(<span class="string">"/test/activity1"</span>, RouteMeta.build(RouteType.ACTIVITY, Test1Activity.class, <span class="string">"/test/activity1"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"ser"</span>, <span class="number">9</span>); put(<span class="string">"ch"</span>, <span class="number">5</span>); put(<span class="string">"fl"</span>, <span class="number">6</span>); put(<span class="string">"dou"</span>, <span class="number">7</span>); put(<span class="string">"boy"</span>, <span class="number">0</span>); put(<span class="string">"url"</span>, <span class="number">8</span>); put(<span class="string">"pac"</span>, <span class="number">10</span>); put(<span class="string">"obj"</span>, <span class="number">11</span>); put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"objList"</span>, <span class="number">11</span>); put(<span class="string">"map"</span>, <span class="number">11</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); put(<span class="string">"height"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity2"</span>, RouteMeta.build(RouteType.ACTIVITY, Test2Activity.class, <span class="string">"/test/activity2"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"key1"</span>, <span class="number">8</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity3"</span>, RouteMeta.build(RouteType.ACTIVITY, Test3Activity.class, <span class="string">"/test/activity3"</span>, <span class="string">"test"</span>, <span class="keyword">new</span> java.util.HashMap&lt;String, Integer&gt;()&#123;&#123;put(<span class="string">"name"</span>, <span class="number">8</span>); put(<span class="string">"boy"</span>, <span class="number">0</span>); put(<span class="string">"age"</span>, <span class="number">3</span>); &#125;&#125;, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/activity4"</span>, RouteMeta.build(RouteType.ACTIVITY, Test4Activity.class, <span class="string">"/test/activity4"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/fragment"</span>, RouteMeta.build(RouteType.FRAGMENT, BlankFragment.class, <span class="string">"/test/fragment"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">    atlas.put(<span class="string">"/test/webview"</span>, RouteMeta.build(RouteType.ACTIVITY, TestWebview.class, <span class="string">"/test/webview"</span>, <span class="string">"test"</span>, <span class="keyword">null</span>, -<span class="number">1</span>, -<span class="number">2147483648</span>));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到路由相关的参数配置被构造成了一个 RouteMeta 对象。RouteMeta 类如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouteMeta</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RouteType type;         <span class="comment">// Type of route</span></span><br><span class="line">    <span class="keyword">private</span> Element rawType;        <span class="comment">// Raw type of route</span></span><br><span class="line">    <span class="keyword">private</span> Class&lt;?&gt; destination;   <span class="comment">// Destination</span></span><br><span class="line">    <span class="keyword">private</span> String path;            <span class="comment">// Path of route</span></span><br><span class="line">    <span class="keyword">private</span> String group;           <span class="comment">// Group of route</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> priority = -<span class="number">1</span>;      <span class="comment">// The smaller the number, the higher the priority</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> extra;              <span class="comment">// Extra data</span></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Integer&gt; paramsType;  <span class="comment">// Param type</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, Autowired&gt; injectConfig;  <span class="comment">// Cache inject config.</span></span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里，加载路由的部分就完成了，剩下的就是跳转路由了。</p>
<p>跳转路由的通常操作：</p>
<pre><code>ARouter.getInstance().build(&quot;/test/abc&quot;).navigation();
</code></pre><p>那先看一下 ARouter 的 build 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().build(path);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面调用的是 _ARouter 的 build 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取 PathReplaceService 实例，如果不为空，就处理 path</span></span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> build(path, extractGroup(path));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 截取跳转路径中的第一段作为分组名</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">extractGroup</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || !path.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Extract the default group failed, the path must be start with '/' and contain more than 2 '/'!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        String defaultGroup = path.substring(<span class="number">1</span>, path.indexOf(<span class="string">"/"</span>, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">if</span> (TextUtils.isEmpty(defaultGroup)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Extract the default group failed! There's nothing between 2 '/'!"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> defaultGroup;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, <span class="string">"Failed to extract default group! "</span> + e.getMessage());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PathReplaceService 是官方给我们预留的口子，用来对 path 做预处理。如果你有需求来对 path 做统一的预处理，那么直接实现 PathReplaceService 即可。</p>
<p>我们接着跟进，看下 <code>_ARouter.build(String path, String group)</code> 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Postcard <span class="title">build</span><span class="params">(String path, String group)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(path) || TextUtils.isEmpty(group)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(Consts.TAG + <span class="string">"Parameter is invalid!"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        PathReplaceService pService = ARouter.getInstance().navigation(PathReplaceService.class);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != pService) &#123;</span><br><span class="line">            path = pService.forString(path);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Postcard(path, group);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 <code>build(String path, String group)</code> 中直接创建了一个 Postcard 对象并返回。Postcard 类是继承了 RouteMeta ，额外添加了一些其他的信息。</p>
<p>有了 Postcard 之后，直接调用 navigation 进行跳转。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context context, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> ARouter.getInstance().navigation(context, <span class="keyword">this</span>, -<span class="number">1</span>, callback);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">navigation</span><span class="params">(Activity mContext, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    ARouter.getInstance().navigation(mContext, <span class="keyword">this</span>, requestCode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Postcard 的所有 navigation 方法最后都会调用 ARouter 的 navigation 这个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Object <span class="title">navigation</span><span class="params">(Context mContext, Postcard postcard, <span class="keyword">int</span> requestCode, NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _ARouter.getInstance().navigation(mContext, postcard, requestCode, callback);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后还是调用了 _ARouter.navigation </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 将 postcard 与路由表中进行匹配，并且填充 postcard 的数据</span></span><br><span class="line">        LogisticsCenter.completion(postcard);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoRouteFoundException ex) &#123;</span><br><span class="line">        logger.warning(Consts.TAG, ex.getMessage());</span><br><span class="line">        <span class="comment">// 如果 debug ，就显示匹配错误</span></span><br><span class="line">        <span class="keyword">if</span> (debuggable()) &#123;</span><br><span class="line">            <span class="comment">// Show friendly tips for user.</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    Toast.makeText(mContext, <span class="string">"There's no route matched!\n"</span> +</span><br><span class="line">                            <span class="string">" Path = ["</span> + postcard.getPath() + <span class="string">"]\n"</span> +</span><br><span class="line">                            <span class="string">" Group = ["</span> + postcard.getGroup() + <span class="string">"]"</span>, Toast.LENGTH_LONG).show();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调路由匹配失败</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">            callback.onLost(postcard);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;    </span><br><span class="line">            <span class="comment">// No callback for this invoke, then we use the global degrade service.</span></span><br><span class="line">            <span class="comment">// 如果没有回调，就调用全局降级的策略</span></span><br><span class="line">            DegradeService degradeService = ARouter.getInstance().navigation(DegradeService.class);</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> != degradeService) &#123;</span><br><span class="line">                degradeService.onLost(context, postcard);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 回调路由匹配成功</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">        callback.onFound(postcard);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果不是绿色通道，就调用拦截器，拦截器这部分后面单独出来讲，这里就不讲了</span></span><br><span class="line">    <span class="keyword">if</span> (!postcard.isGreenChannel()) &#123;   <span class="comment">// It must be run in async thread, maybe interceptor cost too mush time made ANR.</span></span><br><span class="line">        interceptorService.doInterceptions(postcard, <span class="keyword">new</span> InterceptorCallback() &#123;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Continue process</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> postcard route meta</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onContinue</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">                _navigation(context, postcard, requestCode, callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Interrupt process, pipeline will be destory when this method called.</span><br><span class="line">             *</span><br><span class="line">             * <span class="doctag">@param</span> exception Reson of interrupt.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">(Throwable exception)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> != callback) &#123;</span><br><span class="line">                    callback.onInterrupt(postcard);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                logger.info(Consts.TAG, <span class="string">"Navigation failed, termination by interceptor : "</span> + exception.getMessage());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则调用 _navigation 进行跳转</span></span><br><span class="line">        <span class="keyword">return</span> _navigation(context, postcard, requestCode, callback);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> Object <span class="title">_navigation</span><span class="params">(<span class="keyword">final</span> Context context, <span class="keyword">final</span> Postcard postcard, <span class="keyword">final</span> <span class="keyword">int</span> requestCode, <span class="keyword">final</span> NavigationCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Context currentContext = <span class="keyword">null</span> == context ? mContext : context;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (postcard.getType()) &#123;</span><br><span class="line">        <span class="keyword">case</span> ACTIVITY: <span class="comment">// 如果是 activity 的，执行跳转</span></span><br><span class="line">            <span class="comment">// Build intent</span></span><br><span class="line">            <span class="keyword">final</span> Intent intent = <span class="keyword">new</span> Intent(currentContext, postcard.getDestination());</span><br><span class="line">            intent.putExtras(postcard.getExtras());</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set flags.</span></span><br><span class="line">            <span class="keyword">int</span> flags = postcard.getFlags();</span><br><span class="line">            <span class="keyword">if</span> (-<span class="number">1</span> != flags) &#123;</span><br><span class="line">                intent.setFlags(flags);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(currentContext <span class="keyword">instanceof</span> Activity)) &#123;    <span class="comment">// Non activity, need less one flag.</span></span><br><span class="line">                intent.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Set Actions</span></span><br><span class="line">            String action = postcard.getAction();</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(action)) &#123;</span><br><span class="line">                intent.setAction(action);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Navigation in main looper.</span></span><br><span class="line">            runInMainThread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    startActivity(requestCode, currentContext, intent, postcard, callback);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> PROVIDER: <span class="comment">// 如果是服务组件，那么直接返回该组件</span></span><br><span class="line">            <span class="keyword">return</span> postcard.getProvider();</span><br><span class="line">        <span class="keyword">case</span> BOARDCAST:</span><br><span class="line">        <span class="keyword">case</span> CONTENT_PROVIDER:</span><br><span class="line">        <span class="keyword">case</span> FRAGMENT: <span class="comment">// 如果是 fragment 的话，返回该 fragment 的实例</span></span><br><span class="line">            Class fragmentMeta = postcard.getDestination();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Object instance = fragmentMeta.getConstructor().newInstance();</span><br><span class="line">                <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> Fragment) &#123;</span><br><span class="line">                    ((Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (instance <span class="keyword">instanceof</span> android.support.v4.app.Fragment) &#123;</span><br><span class="line">                    ((android.support.v4.app.Fragment) instance).setArguments(postcard.getExtras());</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span> instance;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception ex) &#123;</span><br><span class="line">                logger.error(Consts.TAG, <span class="string">"Fetch fragment instance error, "</span> + TextUtils.formatStackTrace(ex.getStackTrace()));</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">case</span> METHOD:</span><br><span class="line">        <span class="keyword">case</span> SERVICE:</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码基本上都写了注释，大家应该都能看懂。</p>
<p>我们重点来关注下 <code>LogisticsCenter.completion(postcard);</code> </p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">completion</span><span class="params">(Postcard postcard)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == postcard) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"No postcard!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先根据 path 去获取 RouteMeta</span></span><br><span class="line">    RouteMeta routeMeta = Warehouse.routes.get(postcard.getPath());</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == routeMeta) &#123;    <span class="comment">// 如果 routeMeta 为空，可能是不存在或者是未加载</span></span><br><span class="line">        Class&lt;? extends IRouteGroup&gt; groupMeta = Warehouse.groupsIndex.get(postcard.getGroup());  <span class="comment">// 加载分组下的路由映射</span></span><br><span class="line">        <span class="comment">// 如果不存在，就报错</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> == groupMeta) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoRouteFoundException(TAG + <span class="string">"There is no route match the path ["</span> + postcard.getPath() + <span class="string">"], in group ["</span> + postcard.getGroup() + <span class="string">"]"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// Load route and cache it into memory, then delete from metas.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] starts loading, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 实现按需加载</span></span><br><span class="line">                IRouteGroup iGroupInstance = groupMeta.getConstructor().newInstance();</span><br><span class="line">                iGroupInstance.loadInto(Warehouse.routes);</span><br><span class="line">                <span class="comment">// 移除 groupsIndex , 否则会造成死循环</span></span><br><span class="line">                Warehouse.groupsIndex.remove(postcard.getGroup());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (ARouter.debuggable()) &#123;</span><br><span class="line">                    logger.debug(TAG, String.format(Locale.getDefault(), <span class="string">"The group [%s] has already been loaded, trigger by [%s]"</span>, postcard.getGroup(), postcard.getPath()));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(TAG + <span class="string">"Fatal exception when loading group meta. ["</span> + e.getMessage() + <span class="string">"]"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 重新加载一遍</span></span><br><span class="line">            completion(postcard);   <span class="comment">// Reload</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 找到对应的 routeMeta， 填充 postcard 数据</span></span><br><span class="line">        postcard.setDestination(routeMeta.getDestination());</span><br><span class="line">        postcard.setType(routeMeta.getType());</span><br><span class="line">        postcard.setPriority(routeMeta.getPriority());</span><br><span class="line">        postcard.setExtra(routeMeta.getExtra());</span><br><span class="line"></span><br><span class="line">        Uri rawUri = postcard.getUri();</span><br><span class="line">        <span class="comment">// 如果 rawUri 不为空，则是 uri 跳转。就解析 rawUri 中的参数，放入 bundle 中</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">null</span> != rawUri) &#123;   <span class="comment">// Try to set params into bundle.</span></span><br><span class="line">            Map&lt;String, String&gt; resultMap = TextUtils.splitQueryParameters(rawUri);</span><br><span class="line">            Map&lt;String, Integer&gt; paramsType = routeMeta.getParamsType();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (MapUtils.isNotEmpty(paramsType)) &#123;</span><br><span class="line">                <span class="comment">// Set value by its type, just for params which annotation by @Param</span></span><br><span class="line">                <span class="keyword">for</span> (Map.Entry&lt;String, Integer&gt; params : paramsType.entrySet()) &#123;</span><br><span class="line">                    setValue(postcard,</span><br><span class="line">                            params.getValue(),</span><br><span class="line">                            params.getKey(),</span><br><span class="line">                            resultMap.get(params.getKey()));</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Save params name which need auto inject.</span></span><br><span class="line">                postcard.getExtras().putStringArray(ARouter.AUTO_INJECT, paramsType.keySet().toArray(<span class="keyword">new</span> String[]&#123;&#125;));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Save raw uri</span></span><br><span class="line">            postcard.withString(ARouter.RAW_URI, rawUri.toString());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果是 PROVIDER 和 FRAGMENT 类型的，开启绿色通道</span></span><br><span class="line">        <span class="keyword">switch</span> (routeMeta.getType()) &#123;</span><br><span class="line">            <span class="keyword">case</span> PROVIDER:  <span class="comment">// if the route is provider, should find its instance</span></span><br><span class="line">                <span class="comment">// Its provider, so it must implement IProvider</span></span><br><span class="line">                Class&lt;? extends IProvider&gt; providerMeta = (Class&lt;? extends IProvider&gt;) routeMeta.getDestination();</span><br><span class="line">                IProvider instance = Warehouse.providers.get(providerMeta);</span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">null</span> == instance) &#123; <span class="comment">// There's no instance of this provider</span></span><br><span class="line">                    IProvider provider;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        provider = providerMeta.getConstructor().newInstance();</span><br><span class="line">                        provider.init(mContext);</span><br><span class="line">                        Warehouse.providers.put(providerMeta, provider);</span><br><span class="line">                        instance = provider;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> HandlerException(<span class="string">"Init provider failed! "</span> + e.getMessage());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                postcard.setProvider(instance);</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Provider should skip all of interceptors</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FRAGMENT:</span><br><span class="line">                postcard.greenChannel();    <span class="comment">// Fragment needn't interceptors</span></span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个路由跳转的流程就讲完了，大致的流程可以分为</p>
<ol>
<li>加载路由映射</li>
<li>根据 path 构造出 Postcard 对象</li>
<li>区分 Postcard 的 type 来实现跳转</li>
</ol>
<h1 id="u756A_u5916"><a href="#u756A_u5916" class="headerlink" title="番外"></a>番外</h1><p>前面说过，ARouter 会在 dex 中寻找 arouter-compiler 生成的类。那我们最后来看看是怎么实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Set&lt;String&gt; <span class="title">getFileNameByPackageName</span><span class="params">(Context context, <span class="keyword">final</span> String packageName)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException, InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Set&lt;String&gt; classNames = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="comment">// 获取 dex 文件存放的路径</span></span><br><span class="line">    List&lt;String&gt; paths = getSourcePaths(context);</span><br><span class="line">    <span class="keyword">final</span> CountDownLatch parserCtl = <span class="keyword">new</span> CountDownLatch(paths.size());</span><br><span class="line">    <span class="comment">// 遍历所有 dex 文件的路径</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">final</span> String path : paths) &#123;</span><br><span class="line">        DefaultPoolExecutor.getInstance().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DexFile dexfile = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">// 根据路径加载 dex 文件</span></span><br><span class="line">                    <span class="keyword">if</span> (path.endsWith(EXTRACTED_SUFFIX)) &#123;</span><br><span class="line">                        <span class="comment">//NOT use new DexFile(path), because it will throw "permission error in /data/dalvik-cache"</span></span><br><span class="line">                        dexfile = DexFile.loadDex(path, path + <span class="string">".tmp"</span>, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        dexfile = <span class="keyword">new</span> DexFile(path);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 遍历 dexfile 的中所有 className 如果是 arouter 报名开头的，就加入到 classNames 中</span></span><br><span class="line">                    Enumeration&lt;String&gt; dexEntries = dexfile.entries();</span><br><span class="line">                    <span class="keyword">while</span> (dexEntries.hasMoreElements()) &#123;</span><br><span class="line">                        String className = dexEntries.nextElement();</span><br><span class="line">                        <span class="keyword">if</span> (className.startsWith(packageName)) &#123;</span><br><span class="line">                            classNames.add(className);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                    Log.e(<span class="string">"ARouter"</span>, <span class="string">"Scan map file in dex files made error."</span>, ignore);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (<span class="keyword">null</span> != dexfile) &#123;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            dexfile.close();</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (Throwable ignore) &#123;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    parserCtl.countDown();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parserCtl.await();</span><br><span class="line"></span><br><span class="line">    Log.d(Consts.TAG, <span class="string">"Filter "</span> + classNames.size() + <span class="string">" classes by packageName &lt;"</span> + packageName + <span class="string">"&gt;"</span>);</span><br><span class="line">    <span class="keyword">return</span> classNames;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再来看下 getSourcePaths 方法，看看它是怎么找 dex 文件路径的</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getSourcePaths</span><span class="params">(Context context)</span> <span class="keyword">throws</span> PackageManager.NameNotFoundException, IOException </span>&#123;</span><br><span class="line">        ApplicationInfo applicationInfo = context.getPackageManager().getApplicationInfo(context.getPackageName(), <span class="number">0</span>);</span><br><span class="line">        File sourceApk = <span class="keyword">new</span> File(applicationInfo.sourceDir);</span><br><span class="line"></span><br><span class="line">        List&lt;String&gt; sourcePaths = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        sourcePaths.add(applicationInfo.sourceDir); <span class="comment">//add the default apk path</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//the prefix of extracted file, ie: test.classes</span></span><br><span class="line">        String extractedFilePrefix = sourceApk.getName() + EXTRACTED_NAME_EXT;</span><br><span class="line"></span><br><span class="line"><span class="comment">//        如果VM已经支持了MultiDex，就不要去Secondary Folder加载 Classesx.zip了，那里已经么有了</span></span><br><span class="line"><span class="comment">//        通过是否存在sp中的multidex.version是不准确的，因为从低版本升级上来的用户，是包含这个sp配置的</span></span><br><span class="line">        <span class="keyword">if</span> (!isVMMultidexCapable()) &#123;</span><br><span class="line">            <span class="comment">//the total dex numbers</span></span><br><span class="line">            <span class="keyword">int</span> totalDexNumber = getMultiDexPreferences(context).getInt(KEY_DEX_NUMBER, <span class="number">1</span>);</span><br><span class="line">            File dexDir = <span class="keyword">new</span> File(applicationInfo.dataDir, SECONDARY_FOLDER_NAME);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> secondaryNumber = <span class="number">2</span>; secondaryNumber &lt;= totalDexNumber; secondaryNumber++) &#123;</span><br><span class="line">                <span class="comment">//for each dex file, ie: test.classes2.zip, test.classes3.zip...</span></span><br><span class="line">                String fileName = extractedFilePrefix + secondaryNumber + EXTRACTED_SUFFIX;</span><br><span class="line">                File extractedFile = <span class="keyword">new</span> File(dexDir, fileName);</span><br><span class="line">                <span class="keyword">if</span> (extractedFile.isFile()) &#123;</span><br><span class="line">                    sourcePaths.add(extractedFile.getAbsolutePath());</span><br><span class="line">                    <span class="comment">//we ignore the verify zip part</span></span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Missing extracted secondary dex file '"</span> + extractedFile.getPath() + <span class="string">"'"</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是debug的，那么额外去加载下 instant run 中的dex文件路径</span></span><br><span class="line">        <span class="keyword">if</span> (ARouter.debuggable()) &#123; <span class="comment">// Search instant run support only debuggable</span></span><br><span class="line">            sourcePaths.addAll(tryLoadInstantRunDexFile(applicationInfo));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sourcePaths;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>更多的细节有兴趣的同学可以自己回去看，这里因为篇幅的原因就不过多讲这些了。</p>
<p>那么今天就到这里结束了，关于 ARouter 系列的更多源码解析，可以看接下来的两篇博客。</p>
<p>bye</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>arouter-api version : 1.4.1</p>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>之前对 ActivityRoute]]>
    </summary>
    
      <category term="ARouter" scheme="http://yuqirong.me/tags/ARouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[从SVN迁移到GitLab]]></title>
    <link href="http://yuqirong.me/2018/11/15/%E4%BB%8ESVN%E8%BF%81%E7%A7%BB%E5%88%B0GitLab/"/>
    <id>http://yuqirong.me/2018/11/15/从SVN迁移到GitLab/</id>
    <published>2018-11-15T14:43:46.000Z</published>
    <updated>2018-11-15T15:04:08.674Z</updated>
    <content type="html"><![CDATA[<p>之前公司代码版本管理用的都是 SVN ，最近搭了 GitLab 。所以想把代码从 SVN 迁移到 GitLab 上。但是 SVN 的提交记录又不能丢，也要跟着一起迁移，所以本篇记录一下迁移的方法。</p>
<pre><code>yum install -y git-svn
</code></pre><p>安装 git-svn ，可以帮助你很轻松的从 SVN 转到 GitLab 上。</p>
<p>然后 cd 到要迁移到 SVN 项目的根目录下</p>
<pre><code>svn log --xml | grep author | sort -u | perl -pe &apos;s/.&gt;(.?)&lt;./$1 = /&apos;
</code></pre><p>这条命令会输出 SVN 所有提交过的人的名字，比如</p>
<author>xiaoming</author><br><author>xiaowang</author><br><author>xiaohong</author>

<p>然后新建一个文件，用于保存该记录</p>
<pre><code>touch svn-history.txt
</code></pre><p>再然后我们就要对这个记录做一些处理，能让 Git 识别这些代码提交者</p>
<pre><code>vi svn-history.txt
</code></pre><p>把内容改成如下：</p>
<p>xiaoming = xiaoming  <a href="&#x6d;&#x61;&#105;&#108;&#116;&#111;&#x3a;&#120;&#x69;&#x61;&#111;&#109;&#105;&#x6e;&#103;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;">&#120;&#x69;&#x61;&#111;&#109;&#105;&#x6e;&#103;&#64;&#x31;&#x36;&#x33;&#46;&#99;&#x6f;&#109;</a><br>xiaowang = xiaowang  <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#120;&#105;&#x61;&#111;&#x77;&#97;&#110;&#x67;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;">&#120;&#105;&#x61;&#111;&#x77;&#97;&#110;&#x67;&#x40;&#x71;&#x71;&#46;&#99;&#111;&#109;</a><br>xiaohong = xiaohong  <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#120;&#x69;&#97;&#x6f;&#x68;&#x6f;&#x6e;&#103;&#64;&#113;&#113;&#46;&#99;&#111;&#109;">&#120;&#x69;&#97;&#x6f;&#x68;&#x6f;&#x6e;&#103;&#64;&#113;&#113;&#46;&#99;&#111;&#109;</a></p>
<p>保存好后，输入命令</p>
<pre><code>git svn clone  svn://svn.yoursvnaddress.com/XXXX/  --no-metadata  --authors-file=svn-history.txt
</code></pre><p>这条命令会在当前目录下新建一个 XXXX 项目，这个 XXXX 项目是用 Git 的。</p>
<pre><code>cd XXXX
git remote add origin git@yougitaddress:xxx/XXXX.git
git push origin --all
</code></pre><p>这样就完成了从 SVN 到 GitLab 的迁移，并且是包含了 SVN 提交记录的。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前公司代码版本管理用的都是 SVN ，最近搭了 GitLab 。所以想把代码从 SVN 迁移到 GitLab 上。但是 SVN 的提交记录又不能丢，也要跟着一起迁移，所以本篇记录一下迁移的方法。</p>
<pre><code>yum install -y git-svn
]]>
    </summary>
    
      <category term="Git" scheme="http://yuqirong.me/tags/Git/"/>
    
      <category term="GitLab" scheme="http://yuqirong.me/tags/GitLab/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Linux上安装GitLab和Jenkins]]></title>
    <link href="http://yuqirong.me/2018/11/13/Linux%E4%B8%8A%E5%AE%89%E8%A3%85GitLab%E5%92%8CJenkins/"/>
    <id>http://yuqirong.me/2018/11/13/Linux上安装GitLab和Jenkins/</id>
    <published>2018-11-13T14:17:39.000Z</published>
    <updated>2018-11-13T15:01:46.571Z</updated>
    <content type="html"><![CDATA[<p>之前在公司的服务器上搭建了 GitLab 和 Jenkins ，所以打算把这过程记录下，以便下次有需要时可以复用。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>在搭建 GitLab 之前，肯定要先安装 Git 。</p>
<p>在 <a href="https://github.com/git/git/releases" target="_blank" rel="external">https://github.com/git/git/releases</a> 中选择最新版本的 Git，然后</p>
<pre><code>wget https://github.com/git/git/archive/v2.19.1.tar.gz
</code></pre><p>下载下来后，我们进行解压</p>
<pre><code>tar -zxvf v2.19.1.tar.gz
</code></pre><p>进入解压后的文件夹</p>
<pre><code>cd git-2.19.1
</code></pre><p>之后我们需要编译 Git 的源码，在这之前我们先安装编译需要的依赖，这里可能提示需要 su 权限才能安装</p>
<pre><code>yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker
</code></pre><p>安装好后我们进行编译</p>
<pre><code>make prefix=/usr/local/git all
</code></pre><p>之后我们安装 Git 到 /usr/local/git 路径</p>
<pre><code>make prefix=/usr/local/git install
</code></pre><p>安装完成后 Git 会自动将配置添加到环境变量 PATH 中，如果没有的话需要手动添加，可以自行百度</p>
<p>最后输入</p>
<pre><code>git --version
</code></pre><p>查看 Git 是否安装成功。</p>
<h1 id="GitLab"><a href="#GitLab" class="headerlink" title="GitLab"></a>GitLab</h1><p>安装依赖</p>
<pre><code>//配置系统防火墙,把HTTP和SSH端口开放.
sudo yum install curl openssh-server postfix cronie
sudo service postfix start
sudo lokkit -s http -s ssh
sudo chkconfig postfix on
</code></pre><p>如果提示无法找到 lokkit 命令，那么需要运行以下命令安装</p>
<pre><code>yum install lokkit
</code></pre><p>这里需要注意的是 lokkit 会把 iptables 打开，如果不想要 iptables 的话，可以进行关闭</p>
<pre><code>service iptables stop
</code></pre><p>第二步，就是下载 GitLab 安装包。下载地址：<a href="https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7" target="_blank" rel="external">https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7</a></p>
<pre><code>wget https://mirrors.tuna.tsinghua.edu.cn/gitlab-ce/yum/el7/gitlab-ce-11.4.5-ce.0.el7.x86_64.rpm
</code></pre><p>下载好后，进行安装</p>
<pre><code>rpm -Uvh gitlab-ce-11.4.5-ce.0.el7.x86_64.rpm
</code></pre><p>修改 GitLab 配置文件指定服务器ip和自定义端口</p>
<pre><code>vim  /etc/gitlab/gitlab.rb
</code></pre><p>指定访问ip及端口用号</p>
<p>external-url ‘<a href="http://www.xxx.com" target="_blank" rel="external">http://www.xxx.com</a>‘</p>
<p>保存并退出，执行以下命令更新配置。</p>
<pre><code>sudo gitlab-ctl reconfigure
</code></pre><p>最后，根据上面配置的 external-url 就可以访问 GitLab 了。</p>
<h1 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h1><p>安装 Jenkins 是需要 Java 环境的，这里就不讲 Linux 系统安装 Java 了，有需要的可以自行百度。</p>
<p>Jenkins 安装教程：<a href="https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins+on+Red+Hat+distributions#InstallingJenkinson" target="_blank" rel="external">https://wiki.jenkins.io/display/JENKINS/Installing+Jenkins+on+Red+Hat+distributions#InstallingJenkinson</a></p>
<p>选择最新版 ，使用 yum 方式下载安装</p>
<pre><code>sudo wget -O /etc/yum.repos.d/jenkins.repo http://pkg.jenkins-ci.org/redhat/jenkins.repo
sudo rpm --import https://jenkins-ci.org/redhat/jenkins-ci.org.key
sudo yum install jenkins
</code></pre><p>接下来配置 Jenkins 端口</p>
<pre><code>vi /etc/sysconfig/jenkins
</code></pre><p>查找/JENKINS_PORT，修改JENKINS_PORT=”8080”，默认为“8080”，我修改为了9090。/JENKINS_LISTEN_ADDRESS 是对应 Jenkins 的 ip ，默认是 0.0.0.0 。</p>
<p>启动 Jenkins</p>
<pre><code>service jenkins restart
</code></pre><p>在浏览器中输入 Jenkins 的网址，就可以使用了。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在公司的服务器上搭建了 GitLab 和 Jenkins ，所以打算把这过程记录下，以便下次有需要时可以复用。</p>
<h1 id="Git"><a href="#Git" class="headerlink" title="Git"></a>Git</h1><p>在]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ActivityRouter源码解析]]></title>
    <link href="http://yuqirong.me/2018/07/22/ActivityRouter%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2018/07/22/ActivityRouter源码解析/</id>
    <published>2018-07-22T14:32:15.000Z</published>
    <updated>2019-03-04T16:31:33.611Z</updated>
    <content type="html"><![CDATA[<p>ActivityRouter ：<a href="https://github.com/mzule/ActivityRouter" target="_blank" rel="external">https://github.com/mzule/ActivityRouter</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>在如今的 Android 组件化开发中，一款好的路由框架是不可或缺的。比如目前阿里的 ARouter 、美团的 WMRouter 等。路由框架可以降低 Activity 之间的耦合，从而在不需要关心目标 Activity 的具体实现类， 利用协议完成跳转。</p>
<h1 id="ActivityRouter_u4F7F_u7528_u65B9_u6CD5"><a href="#ActivityRouter_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="ActivityRouter使用方法"></a>ActivityRouter使用方法</h1><p>在AndroidManifest.xml配置</p>
<pre><code>&lt;activity
    android:name=&quot;com.github.mzule.activityrouter.router.RouterActivity&quot;
    android:theme=&quot;@android:style/Theme.NoDisplay&quot;&gt;
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
        &lt;data android:scheme=&quot;mzule&quot; /&gt;&lt;!--改成自己的scheme--&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>在需要配置的Activity上添加注解</p>
<pre><code>@Router(&quot;main&quot;)
public class MainActivity extends Activity {
    ...
}
</code></pre><p>想要跳转到 MainActivity ，只要调用以下代码即可</p>
<pre><code>Routers.open(context, &quot;mzule://main&quot;)
</code></pre><p>如果想用 @Router 来调用方法</p>
<pre><code>@Router(&quot;logout&quot;)
public static void logout(Context context, Bundle bundle) {
    Toast.makeText(context, &quot;logout&quot;, Toast.LENGTH_SHORT).show();
}
</code></pre><h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><p>ActivityRouter 工程的结构如下</p>
<p><img src="/uploads/20180722/20181216160032.png" alt="ActivityRouter"></p>
<ul>
<li>activityrouter: 路由跳转的具体实现代码</li>
<li>annotaition: 路由注解</li>
<li>app: 路由 demo</li>
<li>app_module: 路由 demo module</li>
<li>compiler: 注解处理</li>
<li>stub: 壳 module</li>
</ul>
<h2 id="annotation"><a href="#annotation" class="headerlink" title="annotation"></a>annotation</h2><p>先来看看 Router 的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Target</span>(&#123;ElementType.TYPE, ElementType.METHOD&#125;)</span><br><span class="line"><span class="annotation">@Retention</span>(RetentionPolicy.CLASS)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> Router &#123;</span><br><span class="line"></span><br><span class="line">    String[] value();</span><br><span class="line"></span><br><span class="line">    String[] stringParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] intParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] longParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] booleanParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] shortParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] floatParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] doubleParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] byteParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] charParams() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    String[] transfer() <span class="keyword">default</span> <span class="string">""</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@Router 定义了该 Activity 路由的名字以及一些参数，这里可以注意到 @Retention 是 CLASS ，所以后面肯定在编译期间利用 Processor 来解析 @Router 生成路由表的。</p>
<p>另外，看到 @Target 是 ElementType.TYPE 和 ElementType.METHOD ，其实 @Router 除了跳转 Activity 之外，还有一个功能就是可以执行方法，只要在方法加上 @Router 即可。</p>
<p>路由表的生成源码我们到后面再讲，先来看看有了协议之后，Routers 是如何实现跳转 Activity 的。</p>
<h2 id="activityrouter"><a href="#activityrouter" class="headerlink" title="activityrouter"></a>activityrouter</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Routers</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(Context context, String url)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> open(context, Uri.parse(url));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(Context context, String url, RouterCallback callback)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> open(context, Uri.parse(url), callback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(Context context, Uri uri)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> open(context, uri, getGlobalCallback(context));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(Context context, Uri uri, RouterCallback callback)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> open(context, uri, -<span class="number">1</span>, callback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openForResult</span><span class="params">(Activity activity, String url, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> openForResult(activity, Uri.parse(url), requestCode);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openForResult</span><span class="params">(Activity activity, String url, <span class="keyword">int</span> requestCode, RouterCallback callback)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> openForResult(activity, Uri.parse(url), requestCode, callback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openForResult</span><span class="params">(Activity activity, Uri uri, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> openForResult(activity, uri, requestCode, getGlobalCallback(activity));</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">openForResult</span><span class="params">(Activity activity, Uri uri, <span class="keyword">int</span> requestCode, RouterCallback callback)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> open(activity, uri, requestCode, callback);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到不同的 open openForResult 方法重载，最后都是调用了 <code>open(Context context, Uri uri, int requestCode, RouterCallback callback)</code> 。那么接着跟踪：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">open</span><span class="params">(Context context, Uri uri, <span class="keyword">int</span> requestCode, RouterCallback callback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果有 callback 在跳转前回调 </span></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (callback.beforeOpen(context, uri)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 执行路由跳转</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        success = doOpen(context, uri, requestCode);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 错误回调</span></span><br><span class="line">            callback.error(context, uri, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 成功或失败回调</span></span><br><span class="line">    <span class="keyword">if</span> (callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">            callback.afterOpen(context, uri);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            callback.notFound(context, uri);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>open 方法中有很多都是不同状态下 callback 的回调，真正跳转的逻辑放在了 doOpen 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">doOpen</span><span class="params">(Context context, Uri uri, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果没有初始化的话，调用 Router.init 进行初始化路由表</span></span><br><span class="line">    initIfNeed();</span><br><span class="line">    <span class="comment">// 解析 uri 得到对应的 path</span></span><br><span class="line">    Path path = Path.create(uri);</span><br><span class="line">    <span class="comment">// 根据 path 去查找与之对应匹配的 mapping ，然后实现跳转</span></span><br><span class="line">    <span class="keyword">for</span> (Mapping mapping : mappings) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mapping.match(path)) &#123;</span><br><span class="line">            <span class="comment">// 如果 activity 是空的，就说明是执行方法的</span></span><br><span class="line">            <span class="keyword">if</span> (mapping.getActivity() == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mapping.getMethod().invoke(context, mapping.parseExtras(uri));</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 否则就是利用 intent 来跳转 activity</span></span><br><span class="line">            Intent intent = <span class="keyword">new</span> Intent(context, mapping.getActivity());</span><br><span class="line">            intent.putExtras(mapping.parseExtras(uri));</span><br><span class="line">            intent.putExtra(KEY_RAW_URL, uri.toString());</span><br><span class="line">            <span class="keyword">if</span> (!(context <span class="keyword">instanceof</span> Activity)) &#123;</span><br><span class="line">                intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requestCode &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (context <span class="keyword">instanceof</span> Activity) &#123;</span><br><span class="line">                    ((Activity) context).startActivityForResult(intent, requestCode);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"can not startActivityForResult context "</span> + context);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                context.startActivity(intent);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们一步步来分析 doOpen 中的具体步骤。先从 <code>Path path = Path.create(uri);</code> 开始看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Path <span class="title">create</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    Path path = <span class="keyword">new</span> Path(uri.getScheme().concat(<span class="string">"://"</span>));</span><br><span class="line">    String urlPath = uri.getPath();</span><br><span class="line">    <span class="keyword">if</span> (urlPath == <span class="keyword">null</span>) &#123;</span><br><span class="line">        urlPath = <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (urlPath.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">        urlPath = urlPath.substring(<span class="number">0</span>, urlPath.length() - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    parse(path, uri.getHost() + urlPath);</span><br><span class="line">    <span class="keyword">return</span> path;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">parse</span><span class="params">(Path scheme, String s)</span> </span>&#123;</span><br><span class="line">    String[] components = s.split(<span class="string">"/"</span>);</span><br><span class="line">    Path curPath = scheme;</span><br><span class="line">    <span class="keyword">for</span> (String component : components) &#123;</span><br><span class="line">        Path temp = <span class="keyword">new</span> Path(component);</span><br><span class="line">        curPath.next = temp;</span><br><span class="line">        curPath = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码看完可能会让有些同学感觉很绕，简单地解释下。上面这段代码主要做的事情就是把传入的 uri 解析，生成了一个 Path 对象。该 Path 对象主要包含了 uri 中的 scheme 、host 、path 这三部分，利用单链表的特点把这三部分串连起来。这个 Path 也就是后面用来匹配路由表用的。</p>
<p>可能还有一些同学对 uri 的 scheme 、 host 等不了解，在这里就简单地普及下。</p>
<p>比如现在有一个 uri </p>
<pre><code>mzule://main/home/login?username=tom
</code></pre><p>这个 uri 就可以分解为</p>
<p>scheme ：mzule ，就是 “://” 前面的字符串<br>host ：main ，“://” 后面的字符串<br>path ：home 和 login 都属于 path，就是 “/” 与 “/” 之间的字符串<br>query ：参数，可以理解成键值对，多个之间用 &amp; 连接。获取 username 这个参数，对应的值就是 tom</p>
<p>生成好了 Path 之后，就是遍历路由表进行匹配了。</p>
<p>所谓的路由表其实就是一个 List </p>
<pre><code>private static List&lt;Mapping&gt; mappings = new ArrayList&lt;&gt;();
</code></pre><p>在调用 RouterInit.init 时候会把路由数据添加到 List 中。准确的说， RouterInit.init 中调用了 Router.map 方法来实现添加的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">(String format, Class&lt;? extends Activity&gt; activity, MethodInvoker method, ExtraTypes extraTypes)</span> </span>&#123;</span><br><span class="line">    mappings.add(<span class="keyword">new</span> Mapping(format, activity, method, extraTypes));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么，我们来看下 Mapping 的结构</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Mapping</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> String format;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Class&lt;? extends Activity&gt; activity;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> MethodInvoker method;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> ExtraTypes extraTypes;</span><br><span class="line">    <span class="keyword">private</span> Path formatPath;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>format 就是我们传入的 uri</li>
<li>activity 就是路由对应的 activity</li>
<li>method 表示是否是执行方法</li>
<li>extraTypes 是所携带的参数类型</li>
<li>formatPath 就是 uri 对应的 Path</li>
</ul>
<p>具体的 Mapping 初始化是在 Processor 生成的代码中完成的，我们到后面再讲。</p>
<p>在回过头来看 doOpen 方法，在 mapping.match(path) 方法中用来判断该 path 有没有匹配路由表中的路由</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">match</span><span class="params">(Path fullLink)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (formatPath.isHttp()) &#123;</span><br><span class="line">        <span class="keyword">return</span> Path.match(formatPath, fullLink);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// fullLink without host</span></span><br><span class="line">        <span class="keyword">boolean</span> match = Path.match(formatPath.next(), fullLink.next());</span><br><span class="line">        <span class="keyword">if</span> (!match &amp;&amp; fullLink.next() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// fullLink with host</span></span><br><span class="line">            match = Path.match(formatPath.next(), fullLink.next().next());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> match;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mapping 的 match 方法就是把自身的 formatPath 和 fullLink 进行比较，最终调用的还是 Path.match 方法，本质就是把 Path 链表中的每一项进行比较，来判断两个 Path 是否相等。这里就不展示具体源码了，有兴趣的同学可以自己回去看。</p>
<p>再后面的就是判断 activity ，如果是空的，就认为是执行方法，否则就构造 Intent 来实现跳转，再利用 requestCode 来判断是 startActivity 还是 startActivityForResult 。其中执行方法主要调用了 MethodInvoker.invoke 方法</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MethodInvoker</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">invoke</span><span class="params">(Context context, Bundle bundle)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再重点关注下 mapping.parseExtras(uri) 这句代码。这里主要做的事情就是构造 Bundle 传入 uri 的参数。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bundle <span class="title">parseExtras</span><span class="params">(Uri uri)</span> </span>&#123;</span><br><span class="line">    Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">    <span class="comment">// path segments // ignore scheme</span></span><br><span class="line">    Path p = formatPath.next();</span><br><span class="line">    Path y = Path.create(uri).next();</span><br><span class="line">    <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">    		<span class="comment">// 是否是 path 中传递参数</span></span><br><span class="line">        <span class="keyword">if</span> (p.isArgument()) &#123;</span><br><span class="line">            put(bundle, p.argument(), y.value());</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next();</span><br><span class="line">        y = y.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 解析 uri 中的参数，放入 bundle 中</span></span><br><span class="line">    Set&lt;String&gt; names = UriCompact.getQueryParameterNames(uri);</span><br><span class="line">    <span class="keyword">for</span> (String name : names) &#123;</span><br><span class="line">        String value = uri.getQueryParameter(name);</span><br><span class="line">        put(bundle, name, value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bundle;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 本方法主要做的事情就是根据参数名来判断参数类型</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(Bundle bundle, String name, String value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> type = extraTypes.getType(name);</span><br><span class="line">    name = extraTypes.transfer(name);</span><br><span class="line">    <span class="keyword">if</span> (type == ExtraTypes.STRING) &#123;</span><br><span class="line">        type = extraTypes.getType(name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">switch</span> (type) &#123;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.INT:</span><br><span class="line">            bundle.putInt(name, Integer.parseInt(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.LONG:</span><br><span class="line">            bundle.putLong(name, Long.parseLong(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.BOOL:</span><br><span class="line">            bundle.putBoolean(name, Boolean.parseBoolean(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.SHORT:</span><br><span class="line">            bundle.putShort(name, Short.parseShort(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.FLOAT:</span><br><span class="line">            bundle.putFloat(name, Float.parseFloat(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.DOUBLE:</span><br><span class="line">            bundle.putDouble(name, Double.parseDouble(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.BYTE:</span><br><span class="line">            bundle.putByte(name, Byte.parseByte(value));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ExtraTypes.CHAR:</span><br><span class="line">            bundle.putChar(name, value.charAt(<span class="number">0</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            bundle.putString(name, value);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码很简单，基本上都加了注释，相信大家都看得懂，就不讲咯。</p>
<p>到这里，整个 ActivityRouter 的流程就讲完啦。</p>
<p>剩下的，就是 Processor 解析注解生成代码了。</p>
<h2 id="compiler"><a href="#compiler" class="headerlink" title="compiler"></a>compiler</h2><p>先告诉处理器支持的注解</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; ret = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    ret.add(Modules.class.getCanonicalName());</span><br><span class="line">    ret.add(Module.class.getCanonicalName());</span><br><span class="line">    ret.add(Router.class.getCanonicalName());</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>剩下主要看 RouterProcessor 的 process 方法。</p>
<p>方法的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    debug(<span class="string">"process apt with "</span> + annotations.toString());</span><br><span class="line">    <span class="keyword">if</span> (annotations.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> hasModule = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> hasModules = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// module</span></span><br><span class="line">    String moduleName = <span class="string">"RouterMapping"</span>;</span><br><span class="line">    Set&lt;? extends Element&gt; moduleList = roundEnv.getElementsAnnotatedWith(Module.class);</span><br><span class="line">    <span class="keyword">if</span> (moduleList != <span class="keyword">null</span> &amp;&amp; moduleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Module annotation = moduleList.iterator().next().getAnnotation(Module.class);</span><br><span class="line">        moduleName = moduleName + <span class="string">"_"</span> + annotation.value();</span><br><span class="line">        hasModule = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// modules</span></span><br><span class="line">    String[] moduleNames = <span class="keyword">null</span>;</span><br><span class="line">    Set&lt;? extends Element&gt; modulesList = roundEnv.getElementsAnnotatedWith(Modules.class);</span><br><span class="line">    <span class="keyword">if</span> (modulesList != <span class="keyword">null</span> &amp;&amp; modulesList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        Element modules = modulesList.iterator().next();</span><br><span class="line">        moduleNames = modules.getAnnotation(Modules.class).value();</span><br><span class="line">        hasModules = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RouterInit</span></span><br><span class="line">    <span class="keyword">if</span> (hasModules) &#123;</span><br><span class="line">        debug(<span class="string">"generate modules RouterInit"</span>);</span><br><span class="line">        generateModulesRouterInit(moduleNames);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasModule) &#123;</span><br><span class="line">        debug(<span class="string">"generate default RouterInit"</span>);</span><br><span class="line">        generateDefaultRouterInit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// RouterMapping</span></span><br><span class="line">    <span class="keyword">return</span> handleRouter(moduleName, roundEnv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>process 方法中的逻辑可以分为三部分：</p>
<ul>
<li>判断是否有 @module 和 @modules ，即是否是组件化开发的</li>
<li>生成 RouterInit</li>
<li>生成 RouterMapping</li>
</ul>
<p>那我们慢慢分析，先来看第一部分</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// module</span></span><br><span class="line">String moduleName = <span class="string">"RouterMapping"</span>;</span><br><span class="line">Set&lt;? extends Element&gt; moduleList = roundEnv.getElementsAnnotatedWith(Module.class);</span><br><span class="line"><span class="keyword">if</span> (moduleList != <span class="keyword">null</span> &amp;&amp; moduleList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Module annotation = moduleList.iterator().next().getAnnotation(Module.class);</span><br><span class="line">    <span class="comment">// 如果是多 module 组件化开发的话，每个 module 需要标注 @module ，这样每个module都会生成一个属于自己的 RouterMapping ，防止重复</span></span><br><span class="line">    <span class="comment">// 比如 @Module("abc") moduleName 就是 RouterMapping_abc</span></span><br><span class="line">    moduleName = moduleName + <span class="string">"_"</span> + annotation.value();</span><br><span class="line">    hasModule = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// @Modules 的作用就是把上面生成的各个 RouterMapping 给汇总起来，统一到 RouterInit 里面，这样只要调用 RouterInit.init 方法就完成了各模块的路由初始化</span></span><br><span class="line">String[] moduleNames = <span class="keyword">null</span>;</span><br><span class="line">Set&lt;? extends Element&gt; modulesList = roundEnv.getElementsAnnotatedWith(Modules.class);</span><br><span class="line"><span class="keyword">if</span> (modulesList != <span class="keyword">null</span> &amp;&amp; modulesList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    Element modules = modulesList.iterator().next();</span><br><span class="line">    <span class="comment">// 比如@Modules("abc","def") , moduleNames 就是 [“abc”, "def"]</span></span><br><span class="line">    moduleNames = modules.getAnnotation(Modules.class).value();</span><br><span class="line">    hasModules = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是生成 RouterInit 类</p>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (hasModules) &#123;</span><br><span class="line">    <span class="keyword">debug</span>(<span class="string">"generate modules RouterInit"</span>);</span><br><span class="line">    generateModulesRouterInit(moduleNames);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasModule) &#123;</span><br><span class="line">    <span class="keyword">debug</span>(<span class="string">"generate default RouterInit"</span>);</span><br><span class="line">    generateDefaultRouterInit();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是多 module 组件化开发，最终会调用 generateModulesRouterInit ，否则调用的就是默认的 generateDefaultRouterInit 。</p>
<p>这里我们就看 generateModulesRouterInit 的代码吧。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">generateModulesRouterInit</span><span class="params">(String[] moduleNames)</span> </span>&#123;</span><br><span class="line">    MethodSpec.Builder initMethod = MethodSpec.methodBuilder(<span class="string">"init"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC);</span><br><span class="line">    <span class="keyword">for</span> (String module : moduleNames) &#123;</span><br><span class="line">        initMethod.addStatement(<span class="string">"RouterMapping_"</span> + module + <span class="string">".map()"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeSpec routerInit = TypeSpec.classBuilder(<span class="string">"RouterInit"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(initMethod.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JavaFile.builder(<span class="string">"com.github.mzule.activityrouter.router"</span>, routerInit)</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，利用了 javapoet 来生成 java 代码，这代码很简单，就不用多讲啦，直接来看下最后生成 RouterInit 类的代码吧</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.github.mzule.activityrouter.router;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterInit</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RouterMapping_app.map();</span><br><span class="line">    RouterMapping_sdk.map();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RouterInit 生成好之后，最后的工作就是生成对应的 RouterMapping_app 和 RouterMapping_sdk 这两个类了。</p>
<p>生成的入口就是 handleRouter(moduleName, roundEnv) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">handleRouter</span><span class="params">(String genClassName, RoundEnvironment roundEnv)</span> </span>&#123;</span><br><span class="line">    Set&lt;? extends Element&gt; elements = roundEnv.getElementsAnnotatedWith(Router.class);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义方法 public static final void map()</span></span><br><span class="line">    MethodSpec.Builder mapMethod = MethodSpec.methodBuilder(<span class="string">"map"</span>)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL, Modifier.STATIC)</span><br><span class="line">            .addStatement(<span class="string">"java.util.Map&lt;String,String&gt; transfer = null"</span>)</span><br><span class="line">            .addStatement(<span class="string">"com.github.mzule.activityrouter.router.ExtraTypes extraTypes"</span>)</span><br><span class="line">            .addCode(<span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历 @Router 修饰的 element</span></span><br><span class="line">    <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">        Router router = element.getAnnotation(Router.class);</span><br><span class="line">        <span class="comment">// 判断 @Router 中有没有 transfer</span></span><br><span class="line">        String[] transfer = router.transfer();</span><br><span class="line">        <span class="keyword">if</span> (transfer.length &gt; <span class="number">0</span> &amp;&amp; !<span class="string">""</span>.equals(transfer[<span class="number">0</span>])) &#123;</span><br><span class="line">            mapMethod.addStatement(<span class="string">"transfer = new java.util.HashMap&lt;String, String&gt;()"</span>);</span><br><span class="line">            <span class="keyword">for</span> (String s : transfer) &#123;</span><br><span class="line">                String[] components = s.split(<span class="string">"=&gt;"</span>);</span><br><span class="line">                <span class="keyword">if</span> (components.length != <span class="number">2</span>) &#123;</span><br><span class="line">                    error(<span class="string">"transfer `"</span> + s + <span class="string">"` not match a=&gt;b format"</span>);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                mapMethod.addStatement(<span class="string">"transfer.put($S, $S)"</span>, components[<span class="number">0</span>], components[<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mapMethod.addStatement(<span class="string">"transfer = null"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 解析路由参数类型</span></span><br><span class="line">        mapMethod.addStatement(<span class="string">"extraTypes = new com.github.mzule.activityrouter.router.ExtraTypes()"</span>);</span><br><span class="line">        mapMethod.addStatement(<span class="string">"extraTypes.setTransfer(transfer)"</span>);</span><br><span class="line"></span><br><span class="line">        addStatement(mapMethod, <span class="keyword">int</span>.class, router.intParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">long</span>.class, router.longParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">boolean</span>.class, router.booleanParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">short</span>.class, router.shortParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">float</span>.class, router.floatParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">double</span>.class, router.doubleParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">byte</span>.class, router.byteParams());</span><br><span class="line">        addStatement(mapMethod, <span class="keyword">char</span>.class, router.charParams());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历 @Router 生成所有路由的解析代码</span></span><br><span class="line">        <span class="keyword">for</span> (String format : router.value()) &#123;</span><br><span class="line">            ClassName className;</span><br><span class="line">            Name methodName = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (element.getKind() == ElementKind.CLASS) &#123;</span><br><span class="line">                className = ClassName.get((TypeElement) element);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (element.getKind() == ElementKind.METHOD) &#123;</span><br><span class="line">                className = ClassName.get((TypeElement) element.getEnclosingElement());</span><br><span class="line">                methodName = element.getSimpleName();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"unknow type"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (format.startsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                error(<span class="string">"Router#value can not start with '/'. at ["</span> + className + <span class="string">"]@Router(\""</span> + format + <span class="string">"\")"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (format.endsWith(<span class="string">"/"</span>)) &#123;</span><br><span class="line">                error(<span class="string">"Router#value can not end with '/'. at ["</span> + className + <span class="string">"]@Router(\""</span> + format + <span class="string">"\")"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果 @Router 是修饰类的 就是路由跳转的</span></span><br><span class="line">            <span class="keyword">if</span> (element.getKind() == ElementKind.CLASS) &#123;</span><br><span class="line">                mapMethod.addStatement(<span class="string">"com.github.mzule.activityrouter.router.Routers.map($S, $T.class, null, extraTypes)"</span>, format, className);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就是路由调用方法的，第三个参数传入 MethodInvoker 对象</span></span><br><span class="line">                mapMethod.addStatement(<span class="string">"com.github.mzule.activityrouter.router.Routers.map($S, null, "</span> +</span><br><span class="line">                        <span class="string">"new MethodInvoker() &#123;\n"</span> +</span><br><span class="line">                        <span class="string">"   public void invoke(android.content.Context context, android.os.Bundle bundle) &#123;\n"</span> +</span><br><span class="line">                        <span class="string">"       $T.$N(context, bundle);\n"</span> +</span><br><span class="line">                        <span class="string">"   &#125;\n"</span> +</span><br><span class="line">                        <span class="string">"&#125;, "</span> +</span><br><span class="line">                        <span class="string">"extraTypes)"</span>, format, className, methodName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        mapMethod.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TypeSpec routerMapping = TypeSpec.classBuilder(genClassName)</span><br><span class="line">            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)</span><br><span class="line">            .addMethod(mapMethod.build())</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 生成 RouterMapping_xxx 类</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JavaFile.builder(<span class="string">"com.github.mzule.activityrouter.router"</span>, routerMapping)</span><br><span class="line">                .build()</span><br><span class="line">                .writeTo(filer);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生成 extraTypes 参数类型设置代码</span></span><br><span class="line"><span class="comment">// 比如 </span></span><br><span class="line"><span class="comment">// extraTypes.setLongExtra("id,updateTime".split(","));</span></span><br><span class="line"><span class="comment">// extraTypes.setBooleanExtra("web".split(","));</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addStatement</span><span class="params">(MethodSpec.Builder mapMethod, Class typeClz, String[] args)</span> </span>&#123;</span><br><span class="line">    String extras = join(args);</span><br><span class="line">    <span class="keyword">if</span> (extras.length() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        String typeName = typeClz.getSimpleName();</span><br><span class="line">        String s = typeName.substring(<span class="number">0</span>, <span class="number">1</span>).toUpperCase() + typeName.replaceFirst(<span class="string">"\\w"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">        mapMethod.addStatement(<span class="string">"extraTypes.set"</span> + s + <span class="string">"Extra($S.split(\",\"))"</span>, extras);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来看一下最后生成的 RouterMapping_xxx 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterMapping_app</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">map</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    java.util.Map&lt;String,String&gt; transfer = <span class="keyword">null</span>;</span><br><span class="line">    com.github.mzule.activityrouter.router.ExtraTypes extraTypes;</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"user/:userId"</span>, UserActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"user/:nickname/city/:city/gender/:gender/age/:age"</span>, UserActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">new</span> java.util.HashMap&lt;String, String&gt;();</span><br><span class="line">    transfer.put(<span class="string">"web"</span>, <span class="string">"fromWeb"</span>);</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    extraTypes.setLongExtra(<span class="string">"id,updateTime"</span>.split(<span class="string">","</span>));</span><br><span class="line">    extraTypes.setBooleanExtra(<span class="string">"web"</span>.split(<span class="string">","</span>));</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"http://mzule.com/main"</span>, MainActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"main"</span>, MainActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"home"</span>, MainActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"with_host"</span>, HostActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"home/:homeName"</span>, HomeActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"logout"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> MethodInvoker() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(android.content.Context context, android.os.Bundle bundle)</span> </span>&#123;</span><br><span class="line">               NonUIActions.logout(context, bundle);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"upload"</span>, <span class="keyword">null</span>, <span class="keyword">new</span> MethodInvoker() &#123;</span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invoke</span><span class="params">(android.content.Context context, android.os.Bundle bundle)</span> </span>&#123;</span><br><span class="line">               NonUIActions.uploadLog(context, bundle);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;, extraTypes);</span><br><span class="line"></span><br><span class="line">    transfer = <span class="keyword">null</span>;</span><br><span class="line">    extraTypes = <span class="keyword">new</span> com.github.mzule.activityrouter.router.ExtraTypes();</span><br><span class="line">    extraTypes.setTransfer(transfer);</span><br><span class="line">    com.github.mzule.activityrouter.router.Routers.map(<span class="string">"user/collection"</span>, UserCollectionActivity.class, <span class="keyword">null</span>, extraTypes);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，ActivityRouter 所有的流程都已经讲完啦！！！</p>
<h2 id="RouterActivity"><a href="#RouterActivity" class="headerlink" title="RouterActivity"></a>RouterActivity</h2><p>对啦，还有一点，ActivityRouter 支持从外部唤起 Activity 。</p>
<p>在 AndroidManifest.xml 中声明 RouterActivity ，填写对应 scheme 和 host 。</p>
<pre><code>&lt;activity
    android:name=&quot;com.github.mzule.activityrouter.router.RouterActivity&quot;
    android:theme=&quot;@android:style/Theme.NoDisplay&quot;&gt;
    ...
    &lt;intent-filter&gt;
        &lt;action android:name=&quot;android.intent.action.VIEW&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.DEFAULT&quot; /&gt;
        &lt;category android:name=&quot;android.intent.category.BROWSABLE&quot; /&gt;
        &lt;data android:scheme=&quot;http&quot; android:host=&quot;mzule.com&quot; /&gt;
    &lt;/intent-filter&gt;
&lt;/activity&gt;
</code></pre><p>其实先唤起的是 RouterActivity ，然后在 RouterActivity 中根据 uri 再跳转到对应的 Activity ，这点可以从 RouterActivity 的代码中印证。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RouterActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line"></span><br><span class="line">        RouterCallback callback = getRouterCallback();</span><br><span class="line"></span><br><span class="line">        Uri uri = getIntent().getData();</span><br><span class="line">        <span class="keyword">if</span> (uri != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Routers.open(<span class="keyword">this</span>, uri, callback);</span><br><span class="line">        &#125;</span><br><span class="line">        finish();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> RouterCallback <span class="title">getRouterCallback</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getApplication() <span class="keyword">instanceof</span> RouterCallbackProvider) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((RouterCallbackProvider) getApplication()).provideRouterCallback();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下真的是讲完啦</p>
<p>讲完啦</p>
<p>完啦</p>
<p>啦</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>其实现在市面的路由框架基本上都是这种套路，了解其中的奥义可以更好地使用它。</p>
<p>感兴趣的同学可以再去看下 ARouter 之类的源码，相信收获会更大！</p>
<p>再见👋</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>ActivityRouter ：<a href="https://github.com/mzule/ActivityRouter" target="_blank" rel="external">https://github.com/mzule/ActivityRouter<]]>
    </summary>
    
      <category term="ActivityRouter" scheme="http://yuqirong.me/tags/ActivityRouter/"/>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="组件化" scheme="http://yuqirong.me/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Architecture Component之Lifecycle解析]]></title>
    <link href="http://yuqirong.me/2018/07/15/Android%20Architecture%20Component%E4%B9%8BLifecycle%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2018/07/15/Android Architecture Component之Lifecycle解析/</id>
    <published>2018-07-14T16:29:11.000Z</published>
    <updated>2018-11-11T12:07:49.022Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>终于到了最后的关头，Android Architecture Component 系列的最后一节内容。今天给大家带来的就是 Lifecycle 的解析。</p>
<p>至于 Lifecycle 的作用就不过多介绍，简单的来说就是让你自己定义的东西可以感知生命周期。比如你想设计了一个 GPS 位置监听器，打算在 Activity 可交互状态下发送地址位置，那么就可以利用 Lifecycle 来做这件事，这样和 Activity 的耦合性就减少了很多。</p>
<p>废话不多说了，就来看看 Lifecycle 内部的实现原理吧。</p>
<h1 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h1><h1 id="Part_1"><a href="#Part_1" class="headerlink" title="Part 1"></a>Part 1</h1><h2 id="LifecycleOwner"><a href="#LifecycleOwner" class="headerlink" title="LifecycleOwner"></a>LifecycleOwner</h2><p>先来看 LifecycleOwner 接口，这个接口定义就说明了某样东西是具有生命周期的。getLifecycle() 方法返回生命周期。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleOwner</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the Lifecycle of the provider.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> The lifecycle of the provider.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="function">Lifecycle <span class="title">getLifecycle</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>官方建议除了 Activity 和 Fragment 之外，其他的代码都不应该实现 LifecycleOwner 这个接口。</p>
<p>目前 SupportActivity 和 Fragment 都实现了该接口。</p>
<h2 id="Lifecycle-1"><a href="#Lifecycle-1" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>在上面我们看到 LifecycleOwner 接口的 getLifecycle() 方法返回了 Lifecycle 。Lifecycle 代表着生命周期，那么来看看 Lifecycle 是怎么定义的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Lifecycle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">removeObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@MainThread</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> State <span class="title">getCurrentState</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> Event &#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onCreate event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_CREATE,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onStart event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_START,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onResume event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_RESUME,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onPause event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_PAUSE,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onStop event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_STOP,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Constant for onDestroy event of the &#123;<span class="doctag">@link</span> LifecycleOwner&#125;.</span><br><span class="line">         */</span></span><br><span class="line">        ON_DESTROY,</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * An &#123;<span class="doctag">@link</span> Event Event&#125; constant that can be used to match all events.</span><br><span class="line">         */</span></span><br><span class="line">        ON_ANY</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> State &#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Destroyed state for a LifecycleOwner. After this event, this Lifecycle will not dispatch</span><br><span class="line">         * any more events. For instance, for an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state is reached</span><br><span class="line">         * &lt;b&gt;right before&lt;/b&gt; Activity's &#123;<span class="doctag">@link</span> android.app.Activity#onDestroy() onDestroy&#125; call.</span><br><span class="line">         */</span></span><br><span class="line">        DESTROYED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Initialized state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this is</span><br><span class="line">         * the state when it is constructed but has not received</span><br><span class="line">         * &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; yet.</span><br><span class="line">         */</span></span><br><span class="line">        INITIALIZED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Created state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="line">         * is reached in two cases:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onCreate(android.os.Bundle) onCreate&#125; call;</span><br><span class="line">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onStop() onStop&#125; call.</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span></span><br><span class="line">        CREATED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Started state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="line">         * is reached in two cases:</span><br><span class="line">         * &lt;ul&gt;</span><br><span class="line">         *     &lt;li&gt;after &#123;<span class="doctag">@link</span> android.app.Activity#onStart() onStart&#125; call;</span><br><span class="line">         *     &lt;li&gt;&lt;b&gt;right before&lt;/b&gt; &#123;<span class="doctag">@link</span> android.app.Activity#onPause() onPause&#125; call.</span><br><span class="line">         * &lt;/ul&gt;</span><br><span class="line">         */</span></span><br><span class="line">        STARTED,</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Resumed state for a LifecycleOwner. For an &#123;<span class="doctag">@link</span> android.app.Activity&#125;, this state</span><br><span class="line">         * is reached after &#123;<span class="doctag">@link</span> android.app.Activity#onResume() onResume&#125; is called.</span><br><span class="line">         */</span></span><br><span class="line">        RESUMED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Compares if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;.</span><br><span class="line">         *</span><br><span class="line">         * <span class="doctag">@param</span> state State to compare with</span><br><span class="line">         * <span class="doctag">@return</span> true if this State is greater or equal to the given &#123;<span class="doctag">@code</span> state&#125;</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAtLeast</span><span class="params">(@NonNull State state)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> compareTo(state) &gt;= <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Lifecycle 是个抽象类，其中定义了：</p>
<ul>
<li>addObserver ：增加观察者，观察者可以观察到该生命周期的变化，具体的观察者就是 LifecycleObserver ；</li>
<li>removeObserver ：移除观察者 LifecycleObserver ；</li>
<li>getCurrentState ：返回当前生命周期的状态；</li>
<li>Event ：生命周期事件；</li>
<li>State ：生命周期状态；</li>
</ul>
<p>至于 Event 和 State 的关系我们等到了下面再讲。</p>
<p>到这，我们来看看 SupportActivity 和 Fragment 在 getLifecycle 方法中返回了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Lifecycle <span class="title">getLifecycle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mLifecycleRegistry;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现返回的是 LifecycleRegistry 的一个对象，而 LifecycleRegistry 就是 Lifecycle 的实现类。</p>
<p>我们先把对 LifecycleRegistry 的解析放一放，先来看看生命周期观察者 LifecycleObserver 。</p>
<h2 id="LifecycleObserver"><a href="#LifecycleObserver" class="headerlink" title="LifecycleObserver"></a>LifecycleObserver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>LifecycleObserver 是个空接口，里面什么都没有。那我们自己定义一个类 MyLifecycleObserver 来实现 LifecycleObserver 接口，以达到观察生命周期的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLifecycleObserver</span> <span class="keyword">implements</span> <span class="title">LifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@OnLifecycleEvent</span>(Lifecycle.Event.ON_ANY)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onAny</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"onAny:"</span> + event.name());</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@OnLifecycleEvent</span>(Lifecycle.Event.ON_CREATE)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"onCreate"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@OnLifecycleEvent</span>(Lifecycle.Event.ON_DESTROY)</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	    System.out.println(<span class="string">"onDestroy"</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 MainActivity 里面添加我们的 MyLifecycleObserver 观察者。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_main);</span><br><span class="line">    getLifecycle().addObserver(<span class="keyword">new</span> MyLifecycleObserver());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过之前分析的代码我们可以观察到，getLifecycle() 返回的就是 LifecycleRegistry 对象。所以其实调用的就是 LifecycleRegistry 的 addObserver 方法来添加观察者的。</p>
<h2 id="LifecycleRegistry"><a href="#LifecycleRegistry" class="headerlink" title="LifecycleRegistry"></a>LifecycleRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addObserver</span><span class="params">(@NonNull LifecycleObserver observer)</span> </span>&#123;</span><br><span class="line">    State initialState = mState == DESTROYED ? DESTROYED : INITIALIZED;</span><br><span class="line">    ObserverWithState statefulObserver = <span class="keyword">new</span> ObserverWithState(observer, initialState);</span><br><span class="line">    ObserverWithState previous = mObserverMap.putIfAbsent(observer, statefulObserver);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (previous != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// it is null we should be destroyed. Fallback quickly</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> isReentrance = mAddingObserverCounter != <span class="number">0</span> || mHandlingEvent;</span><br><span class="line">    State targetState = calculateTargetState(observer);</span><br><span class="line">    mAddingObserverCounter++;</span><br><span class="line">    <span class="keyword">while</span> ((statefulObserver.mState.compareTo(targetState) &lt; <span class="number">0</span></span><br><span class="line">            &amp;&amp; mObserverMap.contains(observer))) &#123;</span><br><span class="line">        pushParentState(statefulObserver.mState);</span><br><span class="line">        statefulObserver.dispatchEvent(lifecycleOwner, upEvent(statefulObserver.mState));</span><br><span class="line">        popParentState();</span><br><span class="line">        <span class="comment">// mState / subling may have been changed recalculate</span></span><br><span class="line">        targetState = calculateTargetState(observer);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!isReentrance) &#123;</span><br><span class="line">        <span class="comment">// we do sync only on the top level.</span></span><br><span class="line">        sync();</span><br><span class="line">    &#125;</span><br><span class="line">    mAddingObserverCounter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开始，针对每个 LifecycleObserver 对象设置了一个初始状态 initialState ，然后结合初始状态 initialState 和 observer ，把它俩包装成一个 ObserverWithState 对象。并保存到 mObserverMap 中。 mObserverMap 缓存了所有的生命周期观察者。</p>
<p>我们来看看 ObserverWithState 里面的操作。</p>
<h2 id="ObserverWithState"><a href="#ObserverWithState" class="headerlink" title="ObserverWithState"></a>ObserverWithState</h2><p>ObserverWithState 是 LifecycleRegistry 的静态内部类。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWithState</span> </span>&#123;</span><br><span class="line">    State mState;</span><br><span class="line">    GenericLifecycleObserver mLifecycleObserver;</span><br><span class="line"></span><br><span class="line">    ObserverWithState(LifecycleObserver observer, State initialState) &#123;</span><br><span class="line">        mLifecycleObserver = Lifecycling.getCallback(observer);</span><br><span class="line">        mState = initialState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">        State newState = getStateAfter(event);</span><br><span class="line">        mState = min(mState, newState);</span><br><span class="line">        mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">        mState = newState;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 ObserverWithState 中，我们有点蹊跷，mLifecycleObserver 的类型是 GenericLifecycleObserver ，但是我们传入的是 LifecycleObserver 类型。所以在 Lifecycling.getCallback(observer) 这句代码中做的事情就是把 LifecycleObserver 转化成 GenericLifecycleObserver ，我们深入了解下。</p>
<h2 id="Lifecycling"><a href="#Lifecycling" class="headerlink" title="Lifecycling"></a>Lifecycling</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> GenericLifecycleObserver <span class="title">getCallback</span><span class="params">(Object object)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> FullLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FullLifecycleObserverAdapter((FullLifecycleObserver) object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (object <span class="keyword">instanceof</span> GenericLifecycleObserver) &#123;</span><br><span class="line">        <span class="keyword">return</span> (GenericLifecycleObserver) object;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; klass = object.getClass();</span><br><span class="line">    <span class="keyword">int</span> type = getObserverConstructorType(klass);</span><br><span class="line">    <span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">        List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors =</span><br><span class="line">                sClassToAdapters.get(klass);</span><br><span class="line">        <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">            GeneratedAdapter generatedAdapter = createGeneratedAdapter(</span><br><span class="line">                    constructors.get(<span class="number">0</span>), object);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">        &#125;</span><br><span class="line">        GeneratedAdapter[] adapters = <span class="keyword">new</span> GeneratedAdapter[constructors.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">            adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ReflectiveGenericLifecycleObserver(object);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码可以大概知道，在 getCallback 中主要做的事情就是利用适配器 Adapter 把 LifeObserver 转化成 GenericLifecycleObserver 。</p>
<p>之前我们定义的 MyLifecycleObserver 是直接实现 LifecycleObserver 接口的，所以它不属于 FullLifecycleObserver 或者 FullLifecycleObserver ，因此它会去执行 getObserverConstructorType(klass) 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getObserverConstructorType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果之前解析过了，直接返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (sCallbackCache.containsKey(klass)) &#123;</span><br><span class="line">        <span class="keyword">return</span> sCallbackCache.get(klass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则调用 resolveObserverCallbackType 进行解析类型</span></span><br><span class="line">    <span class="keyword">int</span> type = resolveObserverCallbackType(klass);</span><br><span class="line">    sCallbackCache.put(klass, type);</span><br><span class="line">    <span class="keyword">return</span> type;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 getObserverConstructorType 中，主要还是要看 resolveObserverCallbackType 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">resolveObserverCallbackType</span><span class="params">(Class&lt;?&gt; klass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// anonymous class bug:35073837</span></span><br><span class="line">    <span class="keyword">if</span> (klass.getCanonicalName() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意这里调用了 generatedConstructor 来生成了 GeneratedAdapter 的构造器</span></span><br><span class="line">    Constructor&lt;? extends GeneratedAdapter&gt; constructor = generatedConstructor(klass);</span><br><span class="line">    <span class="keyword">if</span> (constructor != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 得到构造器后进行缓存</span></span><br><span class="line">        sClassToAdapters.put(klass, Collections</span><br><span class="line">                .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor));</span><br><span class="line">        <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> hasLifecycleMethods = ClassesInfoCache.sInstance.hasLifecycleMethods(klass);</span><br><span class="line">    <span class="keyword">if</span> (hasLifecycleMethods) &#123;</span><br><span class="line">        <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt; superclass = klass.getSuperclass();</span><br><span class="line">    List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; adapterConstructors = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (isLifecycleParent(superclass)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (getObserverConstructorType(superclass) == REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        adapterConstructors = <span class="keyword">new</span> ArrayList&lt;&gt;(sClassToAdapters.get(superclass));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (Class&lt;?&gt; intrface : klass.getInterfaces()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!isLifecycleParent(intrface)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (getObserverConstructorType(intrface) == REFLECTIVE_CALLBACK) &#123;</span><br><span class="line">            <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (adapterConstructors == <span class="keyword">null</span>) &#123;</span><br><span class="line">            adapterConstructors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        adapterConstructors.addAll(sClassToAdapters.get(intrface));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (adapterConstructors != <span class="keyword">null</span>) &#123;</span><br><span class="line">        sClassToAdapters.put(klass, adapterConstructors);</span><br><span class="line">        <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> REFLECTIVE_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>resolveObserverCallbackType 方法中调用 generatedConstructor 来生成 MyLifecycleObserver 的 GeneratedAdapter 构造器。看到这里可能很多人会懵逼，什么是 GeneratedAdapter ？</p>
<h2 id="GeneratedAdapter"><a href="#GeneratedAdapter" class="headerlink" title="GeneratedAdapter"></a>GeneratedAdapter</h2><p>其实 GeneratedAdapter 可以理解为系统为我们的 MyLifecycleObserver 而设计适配器。</p>
<p>比如，我们在 MyLifecycleObserver 里设计了 onCreate 方法在生命周期的创建状态来回调，但是系统并不知道这个 onCreate 方法。所以需要设计出一套适配器来适配我们的 MyLifecycleObserver 。</p>
<p>那么这个适配器的代码也需要我们来写吗？不需要，在编译期时 apt 自动帮我们生成好了。我们可以在 build/generated/source/apt 目录下找到自动生成的 GeneratedAdapter 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyLifecycleObserver_LifecycleAdapter</span> <span class="keyword">implements</span> <span class="title">GeneratedAdapter</span> </span>&#123;</span><br><span class="line">  <span class="keyword">final</span> MyLifecycleObserver mReceiver;</span><br><span class="line"></span><br><span class="line">  MyLifecycleObserver_LifecycleAdapter(MyLifecycleObserver receiver) &#123;</span><br><span class="line">    <span class="keyword">this</span>.mReceiver = receiver;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callMethods</span><span class="params">(LifecycleOwner owner, Lifecycle.Event event, <span class="keyword">boolean</span> onAny,</span><br><span class="line">      MethodCallsLogger logger)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> hasLogger = logger != <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (onAny) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"onAny"</span>, <span class="number">4</span>)) &#123;</span><br><span class="line">        mReceiver.onAny(owner,event);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_CREATE) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"onCreate"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.onCreate();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (event == Lifecycle.Event.ON_DESTROY) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!hasLogger || logger.approveCall(<span class="string">"onDestroy"</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">        mReceiver.onDestroy();</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里就真相大白了吧，所以在 generatedConstructor 方法中生成的就是 MyLifecycleObserver_LifecycleAdapter 的构造器。</p>
<p>具体代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Nullable</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends GeneratedAdapter&gt; generatedConstructor(Class&lt;?&gt; klass) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Package aPackage = klass.getPackage();</span><br><span class="line">        String name = klass.getCanonicalName();</span><br><span class="line">        <span class="keyword">final</span> String fullPackage = aPackage != <span class="keyword">null</span> ? aPackage.getName() : <span class="string">""</span>;</span><br><span class="line">        <span class="comment">// 获取apt自动生成的GeneratedAdapter的类名，在这里就是 MyLifecycleObserver_LifecycleAdapter</span></span><br><span class="line">        <span class="keyword">final</span> String adapterName = getAdapterName(fullPackage.isEmpty() ? name :</span><br><span class="line">                name.substring(fullPackage.length() + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) <span class="keyword">final</span> Class&lt;? extends GeneratedAdapter&gt; aClass =</span><br><span class="line">                (Class&lt;? extends GeneratedAdapter&gt;) Class.forName(</span><br><span class="line">                        fullPackage.isEmpty() ? adapterName : fullPackage + <span class="string">"."</span> + adapterName);</span><br><span class="line">        Constructor&lt;? extends GeneratedAdapter&gt; constructor =</span><br><span class="line">                aClass.getDeclaredConstructor(klass);</span><br><span class="line">        <span class="keyword">if</span> (!constructor.isAccessible()) &#123;</span><br><span class="line">            constructor.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> constructor;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">        <span class="comment">// this should not happen</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们再回到 resolveObserverCallbackType 方法，获取到 MyLifecycleObserver_LifecycleAdapter 构造器后，直接返回了 GENERATED_CALLBACK 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Constructor&lt;? extends GeneratedAdapter&gt; constructor = generatedConstructor(klass);</span><br><span class="line"><span class="keyword">if</span> (constructor != <span class="keyword">null</span>) &#123;</span><br><span class="line">    sClassToAdapters.put(klass, Collections</span><br><span class="line">            .&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt;singletonList(constructor));</span><br><span class="line">    <span class="keyword">return</span> GENERATED_CALLBACK;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后在 getCallback 方法中会执行：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (type == GENERATED_CALLBACK) &#123;</span><br><span class="line">    List&lt;Constructor&lt;? extends GeneratedAdapter&gt;&gt; constructors =</span><br><span class="line">            sClassToAdapters.get(klass);</span><br><span class="line">    <span class="comment">// MyLifecycleObserver_LifecycleAdapter 的构造器只有一个，所以适配创建出来的是 SingleGeneratedAdapterObserver</span></span><br><span class="line">    <span class="keyword">if</span> (constructors.size() == <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 这里的 generatedAdapter 就是 MyLifecycleObserver_LifecycleAdapter</span></span><br><span class="line">        GeneratedAdapter generatedAdapter = createGeneratedAdapter(</span><br><span class="line">                constructors.get(<span class="number">0</span>), object);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 单个构造器</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> SingleGeneratedAdapterObserver(generatedAdapter);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 至于什么时候 MyLifecycleObserver_LifecycleAdapter 会有多个构造器目前我还不清楚，如果有大神知道的话请告知我下</span></span><br><span class="line">    GeneratedAdapter[] adapters = <span class="keyword">new</span> GeneratedAdapter[constructors.size()];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; constructors.size(); i++) &#123;</span><br><span class="line">        adapters[i] = createGeneratedAdapter(constructors.get(i), object);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 多个构造器</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> CompositeGeneratedAdaptersObserver(adapters);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为 MyLifecycleObserver_LifecycleAdapter 的构造器就只有一个，所以 LifecycleObserver 转化成了 SingleGeneratedAdapterObserver 。</p>
<h2 id="SingleGeneratedAdapterObserver"><a href="#SingleGeneratedAdapterObserver" class="headerlink" title="SingleGeneratedAdapterObserver"></a>SingleGeneratedAdapterObserver</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingleGeneratedAdapterObserver</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> GeneratedAdapter mGeneratedAdapter;</span><br><span class="line"></span><br><span class="line">    SingleGeneratedAdapterObserver(GeneratedAdapter generatedAdapter) &#123;</span><br><span class="line">        mGeneratedAdapter = generatedAdapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="keyword">false</span>, <span class="keyword">null</span>);</span><br><span class="line">        mGeneratedAdapter.callMethods(source, event, <span class="keyword">true</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>SingleGeneratedAdapterObserver 是实现了 GenericLifecycleObserver 这个接口的。经过上面的一系列操作，我们的 MyLifecycleObserver 就被适配成了 SingleGeneratedAdapterObserver 。</p>
<h2 id="ObserverWithState-1"><a href="#ObserverWithState-1" class="headerlink" title="ObserverWithState"></a>ObserverWithState</h2><p>其实在 ObserverWithState 还有一个方法 ： dispatchEvent 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchEvent</span><span class="params">(LifecycleOwner owner, Event event)</span> </span>&#123;</span><br><span class="line">    State newState = getStateAfter(event);</span><br><span class="line">    mState = min(mState, newState);</span><br><span class="line">    <span class="comment">// mLifecycleObserver 就是上面的 SingleGeneratedAdapterObserver</span></span><br><span class="line">    mLifecycleObserver.onStateChanged(owner, event);</span><br><span class="line">    mState = newState;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dispatchEvent 会在生命周期发生改变时，然后通知观察者的时候调用。</p>
<p>所以我们可以理一理调用链：</p>
<p>生命周期发生改变 -&gt; ObserverWithState.dispatchEvent -&gt; SingleGeneratedAdapterObserver.onStateChanged -&gt; MyLifecycleObserver_LifecycleAdapter.callMethods -&gt; MyLifecycleObserver.onCreate/onAny/onDestroy</p>
<p>看完有没有一种原来如此、恍然大悟的感觉？</p>
<h1 id="Part_2"><a href="#Part_2" class="headerlink" title="Part 2"></a>Part 2</h1><p>那么什么时候会去调用 ObserverWithState.dispatchEvent 的方法呢？</p>
<p>答案就是在 LifecycleRegistry.handleLifecycleEvent 。 handleLifecycleEvent 方法就是被设计为设置生命周期状态并通知观察者的。</p>
<h2 id="LifecycleRegistry-1"><a href="#LifecycleRegistry-1" class="headerlink" title="LifecycleRegistry"></a>LifecycleRegistry</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleLifecycleEvent</span><span class="params">(@NonNull Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据 event 来得到下一个生命周期的状态值</span></span><br><span class="line">    State next = getStateAfter(event);</span><br><span class="line">    <span class="comment">// 将当前生命周期状态值改成 next ，并通知观察者</span></span><br><span class="line">    moveToState(next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里正好把 event 和 state 的关系捋一捋，这是官方给出的参考图，简明扼要。</p>
<p><img src="/uploads/20180715/20180715050357.png" alt="event and state"></p>
<p>下面就来看看 moveToState 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">moveToState</span><span class="params">(State next)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mState == next) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mState = next;</span><br><span class="line">    <span class="keyword">if</span> (mHandlingEvent || mAddingObserverCounter != <span class="number">0</span>) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// we will figure out what to do on upper level.</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mHandlingEvent = <span class="keyword">true</span>;</span><br><span class="line">    sync();</span><br><span class="line">    mHandlingEvent = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果当前生命周期的状态已经同步完成了，就直接 return 掉。否则就会同步并调用 sync 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">sync</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    LifecycleOwner lifecycleOwner = mLifecycleOwner.get();</span><br><span class="line">    <span class="keyword">if</span> (lifecycleOwner == <span class="keyword">null</span>) &#123;</span><br><span class="line">        Log.w(LOG_TAG, <span class="string">"LifecycleOwner is garbage collected, you shouldn't try dispatch "</span></span><br><span class="line">                + <span class="string">"new events from it."</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (!isSynced()) &#123;</span><br><span class="line">        mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// no need to check eldest for nullability, because isSynced does it for us.</span></span><br><span class="line">        <span class="keyword">if</span> (mState.compareTo(mObserverMap.eldest().getValue().mState) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            backwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; newest = mObserverMap.newest();</span><br><span class="line">        <span class="keyword">if</span> (!mNewEventOccurred &amp;&amp; newest != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; mState.compareTo(newest.getValue().mState) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            forwardPass(lifecycleOwner);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mNewEventOccurred = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要做的事情就是比较当前生命周期的状态和我们存放在 mObserverMap 中最早或最新放入的观察者的状态，通过上面的分析，我们知道是 ObserverWithState 里面一开始有我们添加观察者时的初始状态。</p>
<p>假如生命周期当前状态 mState 是 STARTED ,而观察者的状态是 CREATED，那么我们需要通过 forwardPass() 通知所有的观察者当前生命周期的状态改变到了 STARTED ，请同步。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">forwardPass</span><span class="params">(LifecycleOwner lifecycleOwner)</span> </span>&#123;</span><br><span class="line">    Iterator&lt;Entry&lt;LifecycleObserver, ObserverWithState&gt;&gt; ascendingIterator =</span><br><span class="line">            mObserverMap.iteratorWithAdditions();</span><br><span class="line">    <span class="keyword">while</span> (ascendingIterator.hasNext() &amp;&amp; !mNewEventOccurred) &#123;</span><br><span class="line">        Entry&lt;LifecycleObserver, ObserverWithState&gt; entry = ascendingIterator.next();</span><br><span class="line">        ObserverWithState observer = entry.getValue();</span><br><span class="line">        <span class="keyword">while</span> ((observer.mState.compareTo(mState) &lt; <span class="number">0</span> &amp;&amp; !mNewEventOccurred</span><br><span class="line">                &amp;&amp; mObserverMap.contains(entry.getKey()))) &#123;</span><br><span class="line">            pushParentState(observer.mState);</span><br><span class="line">            observer.dispatchEvent(lifecycleOwner, upEvent(observer.mState));</span><br><span class="line">            popParentState();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先循坏遍历存储了所有观察者的 mObserverMap ，第二个 while 是要分发处理各个状态经过的 event 。</p>
<p>比如当前状态 mState 是 RESUMED ，而 ObserverWithState 中的 state 是 INITIALIZED 。那么调用 ObserverWithState 的 dispatchEvent 方法就要分发 ON_CREATE ，ON_START ，ON_RESUME 了。</p>
<h1 id="Part_3"><a href="#Part_3" class="headerlink" title="Part 3"></a>Part 3</h1><p>问题又来了，到底是谁调用了 handleLifecycleEvent 呢？</p>
<p>我们可以在最终 merge 好的 AndroidManifest 中去寻找答案。</p>
<p>我们发现了这货 ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">provider</span></span><br><span class="line">    <span class="attribute">android:name</span>=<span class="value">"android.arch.lifecycle.ProcessLifecycleOwnerInitializer"</span></span><br><span class="line">    <span class="attribute">android:authorities</span>=<span class="value">"com.yuqirong.multiscrolllayout.lifecycle-trojan"</span></span><br><span class="line">    <span class="attribute">android:exported</span>=<span class="value">"false"</span></span><br><span class="line">    <span class="attribute">android:multiprocess</span>=<span class="value">"true"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>进 ProcessLifecycleOwnerInitializer 里看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProcessLifecycleOwnerInitializer</span> <span class="keyword">extends</span> <span class="title">ContentProvider</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        LifecycleDispatcher.init(getContext());</span><br><span class="line">        ProcessLifecycleOwner.init(getContext());</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面有个 LifecycleDispatcher ，一听名字上就猜到它做的是生命周期分发的工作。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleDispatcher</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">"android.arch.lifecycle"</span></span><br><span class="line">            + <span class="string">".LifecycleDispatcher.report_fragment_tag"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicBoolean sInitialized = <span class="keyword">new</span> AtomicBoolean(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInitialized.getAndSet(<span class="keyword">true</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 注册了ActivityLifecycleCallbacks</span></span><br><span class="line">        ((Application) context.getApplicationContext())</span><br><span class="line">                .registerActivityLifecycleCallbacks(<span class="keyword">new</span> DispatcherActivityCallback());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="annotation">@VisibleForTesting</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">DispatcherActivityCallback</span> <span class="keyword">extends</span> <span class="title">EmptyActivityLifecycleCallbacks</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> FragmentCallback mFragmentCallback;</span><br><span class="line"></span><br><span class="line">        DispatcherActivityCallback() &#123;</span><br><span class="line">            mFragmentCallback = <span class="keyword">new</span> FragmentCallback();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Activity activity, Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 注册了一个FragmentLifecycleCallbacks，这个是监控fragment的生命周期回调</span></span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                ((FragmentActivity) activity).getSupportFragmentManager()</span><br><span class="line">                        .registerFragmentLifecycleCallbacks(mFragmentCallback, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 这句代码很关键 </span></span><br><span class="line">            ReportFragment.injectIfNeededIn(activity);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityStopped</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivitySaveInstanceState</span><span class="params">(Activity activity, Bundle outState)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> FragmentActivity) &#123;</span><br><span class="line">                markState((FragmentActivity) activity, CREATED);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现有一个 ReportFragment.injectIfNeededIn(activity); 进这里面看看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReportFragment</span> <span class="keyword">extends</span> <span class="title">Fragment</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String REPORT_FRAGMENT_TAG = <span class="string">"android.arch.lifecycle"</span></span><br><span class="line">            + <span class="string">".LifecycleDispatcher.report_fragment_tag"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectIfNeededIn</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ProcessLifecycleOwner should always correctly work and some activities may not extend</span></span><br><span class="line">        <span class="comment">// FragmentActivity from support lib, so we use framework fragments for activities</span></span><br><span class="line">        android.app.FragmentManager manager = activity.getFragmentManager();</span><br><span class="line">        <span class="keyword">if</span> (manager.findFragmentByTag(REPORT_FRAGMENT_TAG) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            manager.beginTransaction().add(<span class="keyword">new</span> ReportFragment(), REPORT_FRAGMENT_TAG).commit();</span><br><span class="line">            <span class="comment">// Hopefully, we are the first to make a transaction.</span></span><br><span class="line">            manager.executePendingTransactions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">static</span> ReportFragment <span class="title">get</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (ReportFragment) activity.getFragmentManager().findFragmentByTag(</span><br><span class="line">                REPORT_FRAGMENT_TAG);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ActivityInitializationListener mProcessListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchCreate</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onCreate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchStart</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onStart();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchResume</span><span class="params">(ActivityInitializationListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            listener.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onActivityCreated</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onActivityCreated(savedInstanceState);</span><br><span class="line">        dispatchCreate(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_CREATE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        dispatchStart(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_START);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        dispatchResume(mProcessListener);</span><br><span class="line">        dispatch(Lifecycle.Event.ON_RESUME);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_PAUSE);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_STOP);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        dispatch(Lifecycle.Event.ON_DESTROY);</span><br><span class="line">        <span class="comment">// just want to be sure that we won't leak reference to an activity</span></span><br><span class="line">        mProcessListener = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatch</span><span class="params">(Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        Activity activity = getActivity();</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleRegistryOwner) &#123;</span><br><span class="line">            ((LifecycleRegistryOwner) activity).getLifecycle().handleLifecycleEvent(event);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> LifecycleOwner) &#123;</span><br><span class="line">            Lifecycle lifecycle = ((LifecycleOwner) activity).getLifecycle();</span><br><span class="line">            <span class="keyword">if</span> (lifecycle <span class="keyword">instanceof</span> LifecycleRegistry) &#123;</span><br><span class="line">                ((LifecycleRegistry) lifecycle).handleLifecycleEvent(event);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setProcessListener</span><span class="params">(ActivityInitializationListener processListener)</span> </span>&#123;</span><br><span class="line">        mProcessListener = processListener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">ActivityInitializationListener</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>把 ReportFragment 加入到 Activity 中,然后在其各个生命周期中都会调用 dispatch() 方法。而 dispatch 方法最后调用了 LifecycleRegistry.RehandleLifecycleEvent 。</p>
<p>至此，Lifecycle 的整个流程都梳理完成了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>我们终于完成了对 Android Architecture Component 的整体源码解析，其中涉及到了 LiveData 、 ViewModel 和 Lifecycle 。当然出此之外还有 Room 和 Paging Library 等也是不错的选择，暂时就告一段落了。至于 Room 等有兴趣的同学可以下去自己研究下，拜拜！</p>
<p>bye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>终于到了最后的关头，Android Architecture Component 系列的最后一节内容。今天给]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Architecture Component" scheme="http://yuqirong.me/tags/Android-Architecture-Component/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Architecture Component之ViewModel解析]]></title>
    <link href="http://yuqirong.me/2018/07/09/Android%20Architecture%20Component%E4%B9%8BViewModel%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2018/07/09/Android Architecture Component之ViewModel解析/</id>
    <published>2018-07-09T14:52:33.000Z</published>
    <updated>2018-11-11T12:22:46.628Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前给大家分析过了 LiveData ，今天就来看看 ViewModel 。</p>
<p>ViewModel 的作用就相当于 MVP 中的 Presenter ，是用来衔接 Model 和 View 的。通常把一些与 View 无关的业务逻辑写在 ViewModel 里面。ViewModel 内部创建出 LiveData 对象，利用 LiveData 对象来传递数据给 View 。</p>
<p>ViewModel 相对于 Presenter 而言，有以下几个好处：</p>
<ol>
<li>ViewModel 并不直接持有 View ，所以在 ViewModel 销毁时不需要像 Presenter 一样地去手动解除 View 的绑定，也就不会造成持有 View 导致的内存泄漏；</li>
<li>比如 Activity 配置改变的情况下，ViewModel 会保存不会丢失数据；</li>
<li>ViewModel 可以做到在同一个 Activity 的情况下，多个 Fragment 共享数据；</li>
</ol>
<p>下面是官方给出的 ViewModel 生命周期图，大家随意感受一下：</p>
<p><img src="/uploads/20180709/20180709221953.png" alt="ViewModel Lifecycle"></p>
<p>那么就开始进入正题吧。</p>
<p>本次解析的 ViewModel 源码基于 <code>android.arch.lifecycle:extensions:1.1.1</code></p>
<h1 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h1><p>先来看看 ViewModel 是怎么被创建出来的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">XXXViewModel xxxViewModel = ViewModelProviders.of(activity).get(XXXViewModel.class)</span><br></pre></td></tr></table></figure>
<p>可以看到 ViewModel 并不是简单地 new 出来的，这其中的逻辑要需要我们一步一步慢慢揭开。</p>
<p>那么 ViewModel 是怎样被定义的呢？</p>
<h2 id="ViewModel-1"><a href="#ViewModel-1" class="headerlink" title="ViewModel"></a>ViewModel</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * This method will be called when this ViewModel is no longer used and will be destroyed.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     * It is useful when ViewModel observes some data and you need to clear this subscription to</span><br><span class="line">     * prevent a leak of this ViewModel.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCleared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 ViewModel 是个抽象类，里面只有一个 onCleared() 方法。 onCleared() 会在 ViewModel 被销毁时回调，所以可以在 onCleared() 里面做一些释放资源、清理内存的操作。</p>
<p>另外，ViewModel 还有一个子类： AndroidViewModel 。AndroidViewModel 在 ViewModel 的基础上内部包含了 application 。</p>
<h2 id="ViewModelProviders"><a href="#ViewModelProviders" class="headerlink" title="ViewModelProviders"></a>ViewModelProviders</h2><p>我们就来抽丝剥茧了，先从 ViewModelProviders 入手。创建 ViewModel 时在 ViewModelProviders 中调用了 of 方法。</p>
<h3 id="of"><a href="#of" class="headerlink" title="of"></a>of</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of(activity, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> of(fragment, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull Fragment fragment, @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    Application application = checkApplication(checkActivity(fragment));</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(fragment), factory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelProvider <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity,</span><br><span class="line">        @Nullable Factory factory)</span> </span>&#123;</span><br><span class="line">    Application application = checkApplication(activity);</span><br><span class="line">    <span class="keyword">if</span> (factory == <span class="keyword">null</span>) &#123;</span><br><span class="line">        factory = ViewModelProvider.AndroidViewModelFactory.getInstance(application);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ViewModelProvider(ViewModelStores.of(activity), factory);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>of 方法可以分为两个入口，分别对应着 Fragment 和 Activity 。这也说明了 ViewModel 的作用域其实是分为两个维度的。但是这两个方法内部的代码很像，逻辑基本都是：</p>
<ol>
<li>先去获取 application ；</li>
<li>创建 factory ；</li>
<li>创建 ViewModelProvider ，ViewModelProvider 顾名思义就是提供 ViewModel 的；</li>
</ol>
<p>第一步就不用说了，直接进入第二步吧。</p>
<h2 id="Factory"><a href="#Factory" class="headerlink" title="Factory"></a>Factory</h2><p>Factory 是什么东东呢，说白了就是 ViewModel 的制造工厂。所有的 ViewModel 都是由 Factory 来创建出来的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a new instance of the given &#123;<span class="doctag">@code</span> Class&#125;.</span><br><span class="line">     * &lt;p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> modelClass a &#123;<span class="doctag">@code</span> Class&#125; whose instance is requested</span><br><span class="line">     * <span class="doctag">@param</span> &lt;T&gt;        The type parameter for the ViewModel.</span><br><span class="line">     * <span class="doctag">@return</span> a newly created ViewModel</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Factory 是个接口，里面定义了 create 方法来创建 ViewModel 。来看看它的实现类 NewInstanceFactory 。</p>
<h3 id="NewInstanceFactory"><a href="#NewInstanceFactory" class="headerlink" title="NewInstanceFactory"></a>NewInstanceFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Simple factory, which calls empty constructor on the give class.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">NewInstanceFactory</span> <span class="keyword">implements</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"ClassNewInstance"</span>)</span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> modelClass.newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实没啥好说的，就是利用反射来创建实例了，是一个很简单的实现类。NewInstanceFactory 其实是创建普通 ViewModel 的工厂，而如果想创建 AndroidViewModel 的话，工厂就要选择 AndroidViewModelFactory 了。</p>
<h3 id="AndroidViewModelFactory"><a href="#AndroidViewModelFactory" class="headerlink" title="AndroidViewModelFactory"></a>AndroidViewModelFactory</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &#123;<span class="doctag">@link</span> Factory&#125; which may create &#123;<span class="doctag">@link</span> AndroidViewModel&#125; and</span><br><span class="line"> * &#123;<span class="doctag">@link</span> ViewModel&#125;, which have an empty constructor.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AndroidViewModelFactory</span> <span class="keyword">extends</span> <span class="title">ViewModelProvider</span>.<span class="title">NewInstanceFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AndroidViewModelFactory sInstance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieve a singleton instance of AndroidViewModelFactory.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span><br><span class="line">     * <span class="doctag">@return</span> A valid &#123;<span class="doctag">@link</span> AndroidViewModelFactory&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> AndroidViewModelFactory <span class="title">getInstance</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            sInstance = <span class="keyword">new</span> AndroidViewModelFactory(application);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Application mApplication;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a &#123;<span class="doctag">@code</span> AndroidViewModelFactory&#125;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> application an application to pass in &#123;<span class="doctag">@link</span> AndroidViewModel&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AndroidViewModelFactory</span><span class="params">(@NonNull Application application)</span> </span>&#123;</span><br><span class="line">        mApplication = application;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">create</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (AndroidViewModel.class.isAssignableFrom(modelClass)) &#123;</span><br><span class="line">            <span class="comment">//noinspection TryWithIdenticalCatches</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> modelClass.getConstructor(Application.class).newInstance(mApplication);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Cannot create an instance of "</span> + modelClass, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.create(modelClass);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 AndroidViewModelFactory 的 create 方法中，对创建 ViewModel 的方案做了兼容，所以 AndroidViewModelFactory 是同时适用于创建 ViewModel 和 AndroidViewModel 的。并且 AndroidViewModelFactory 是单例工厂，防止多次创建浪费内存。</p>
<p>额外补充一点，在 ViewModelProviders 中有一个内部类 DefaultFactory ，现在已经被打上废弃的标签了，可以猜出这个 DefaultFactory 应该是早期版本的默认工厂类，现在已经被 AndroidViewModelFactory 代替了。</p>
<h2 id="ViewModelStores"><a href="#ViewModelStores" class="headerlink" title="ViewModelStores"></a>ViewModelStores</h2><p>到这里 Factory 就有了，那么就重点来看看 <code>ViewModelStores.of(activity)</code> 这段代码了。ViewModelStores 是根据作用域用来提供 ViewModelStore 的，而 ViewModelStore 的作用就是存储 ViewModel ，内部是利用 key/value 将 ViewModel 保存在 HashMap 中，方便读写，这里就不展示 ViewModelStore 的源码了，大家可以把 ViewModelStore 当作 HashMap 就行。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Factory methods for &#123;<span class="doctag">@link</span> ViewModelStore&#125; class.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@SuppressWarnings</span>(<span class="string">"WeakerAccess"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewModelStores</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">ViewModelStores</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given activity.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> activity an activity whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span><br><span class="line">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="annotation">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (activity <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) activity).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(activity).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the &#123;<span class="doctag">@link</span> ViewModelStore&#125; of the given fragment.</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> fragment a fragment whose &#123;<span class="doctag">@code</span> ViewModelStore&#125; is requested</span><br><span class="line">     * <span class="doctag">@return</span> a &#123;<span class="doctag">@code</span> ViewModelStore&#125;</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@NonNull</span></span><br><span class="line">    <span class="annotation">@MainThread</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ViewModelStore <span class="title">of</span><span class="params">(@NonNull Fragment fragment)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (fragment <span class="keyword">instanceof</span> ViewModelStoreOwner) &#123;</span><br><span class="line">            <span class="keyword">return</span> ((ViewModelStoreOwner) fragment).getViewModelStore();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> holderFragmentFor(fragment).getViewModelStore();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据 ViewModelProviders 的思路，ViewModelStores 也是分为了两个方法，对应着 Fragment 和 Activity 。</p>
<ol>
<li>如果 Activity 和 Fragment 实现了 ViewModelStoreOwner 的接口，那么直接返回内部的 ViewModelStore 就行了；</li>
<li>如果是之前老早版本的 Activity 或者 Fragment ，那么它们肯定是没有实现 ViewModelStoreOwner 接口的，那该怎么办呢？很简单，新创建一个 Fragment 来关联 ViewModelStoreOwner 就好了啊！</li>
</ol>
<p>所以就有了 holderFragmentFor(activity) 和 holderFragmentFor(fragment) 这段了。</p>
<h2 id="HolderFragment"><a href="#HolderFragment" class="headerlink" title="HolderFragment"></a>HolderFragment</h2><p>HolderFragment 实现了 ViewModelStoreOwner 接口，所以 HolderFragment 的作用就是代替了那些之前没有实现 ViewModelStoreOwner 接口的 Activity/Fragment 。这样，Activity/Fragment 也间接地拥有了 ViewModelStore 。</p>
<p>HolderFragment 的代码我们就只看 holderFragmentFor(activity) 这一段吧，holderFragmentFor(fragment) 也是类似的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * <span class="doctag">@hide</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@RestrictTo</span>(RestrictTo.Scope.LIBRARY_GROUP)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> sHolderFragmentManager.holderFragmentFor(activity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">HolderFragmentManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">	</span><br><span class="line">    <span class="function">HolderFragment <span class="title">holderFragmentFor</span><span class="params">(FragmentActivity activity)</span> </span>&#123;</span><br><span class="line">        FragmentManager fm = activity.getSupportFragmentManager();</span><br><span class="line">        HolderFragment holder = findHolderFragment(fm);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line">        holder = mNotCommittedActivityHolders.get(activity);</span><br><span class="line">        <span class="keyword">if</span> (holder != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> holder;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!mActivityCallbacksIsAdded) &#123;</span><br><span class="line">            mActivityCallbacksIsAdded = <span class="keyword">true</span>;</span><br><span class="line">            activity.getApplication().registerActivityLifecycleCallbacks(mActivityCallbacks);</span><br><span class="line">        &#125;</span><br><span class="line">        holder = createHolderFragment(fm);</span><br><span class="line">        mNotCommittedActivityHolders.put(activity, holder);</span><br><span class="line">        <span class="keyword">return</span> holder;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实就是把 HolderFragment 添加进 Activity 里面，这样 HolderFragment 就和 Activity 的生命周期关联在一起了。实际上获取的就是 HolderFragment 里面的 ViewModelStore 。每个 Activity 里面只有一个 HolderFragment 。</p>
<p>Fragment 也是同理，利用 getChildFragmentManager() 来往里添加 HolderFragment 。这里就不讲了，有兴趣的同学可以自己回去看看源码。</p>
<p>至此，用来创建 ViewModelProvider 的两个入参 ViewModelStore 和 Factory 都讲完了。</p>
<h2 id="ViewModelProvider"><a href="#ViewModelProvider" class="headerlink" title="ViewModelProvider"></a>ViewModelProvider</h2><p>创建出 ViewModelProvider 后，最后一步就是调用它的 get 方法返回 ViewModel 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    String canonicalName = modelClass.getCanonicalName();</span><br><span class="line">    <span class="keyword">if</span> (canonicalName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Local and anonymous classes can not be ViewModels"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> get(DEFAULT_KEY + <span class="string">":"</span> + canonicalName, modelClass);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span></span><br><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="keyword">public</span> &lt;T extends ViewModel&gt; <span class="function">T <span class="title">get</span><span class="params">(@NonNull String key, @NonNull Class&lt;T&gt; modelClass)</span> </span>&#123;</span><br><span class="line">    ViewModel viewModel = mViewModelStore.get(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (modelClass.isInstance(viewModel)) &#123;</span><br><span class="line">        <span class="comment">//noinspection unchecked</span></span><br><span class="line">        <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//noinspection StatementWithEmptyBody</span></span><br><span class="line">        <span class="keyword">if</span> (viewModel != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// <span class="doctag">TODO:</span> log a warning.</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    viewModel = mFactory.create(modelClass);</span><br><span class="line">    mViewModelStore.put(key, viewModel);</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="keyword">return</span> (T) viewModel;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>get 方法很 easy ，就是利用 class 的 canonicalName 生成一个唯一的 key ，然后利用 key 去 mViewModelStore 中获取。如果有值就返回，否则就利用 factory 创建新的 ViewModel ，然后保存到 mViewModelStore 中并返回。</p>
<p>整个 ViewModel 的源码流程基本上就讲完了，其实并不复杂。回去多多体会，总能明白其中的奥秘。</p>
<p>下面，额外给大家补充几个小点，加个鸡腿。</p>
<h1 id="Tip"><a href="#Tip" class="headerlink" title="Tip"></a>Tip</h1><h2 id="ViewModel_u7684onCleared_u4EC0_u4E48_u65F6_u5019_u56DE_u8C03"><a href="#ViewModel_u7684onCleared_u4EC0_u4E48_u65F6_u5019_u56DE_u8C03" class="headerlink" title="ViewModel的onCleared什么时候回调"></a>ViewModel的onCleared什么时候回调</h2><p>之前说过，ViewModel 是保存在 ViewModelStore 里面的，所以 ViewModel 的销毁一定是在 ViewModelStore 里面操作的。</p>
<h3 id="ViewModelStore"><a href="#ViewModelStore" class="headerlink" title="ViewModelStore"></a>ViewModelStore</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> *  Clears internal storage and notifies ViewModels that they are no longer used.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (ViewModel vm : mMap.values()) &#123;</span><br><span class="line">        vm.onCleared();</span><br><span class="line">    &#125;</span><br><span class="line">    mMap.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 ViewModelStore 的 clear() 方法内部调用 ViewModel 的 onCleared() 方法。那么哪里调用了 ViewModelStore 的 clear() 方法呢？</p>
<h3 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called when the fragment is no longer in use.  This is called</span><br><span class="line"> * after &#123;<span class="doctag">@link</span> #onStop()&#125; and before &#123;<span class="doctag">@link</span> #onDetach()&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@CallSuper</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mCalled = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// Use mStateSaved instead of isStateSaved() since we're past onStop()</span></span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore != <span class="keyword">null</span> &amp;&amp; !mHost.mFragmentManager.mStateSaved) &#123;</span><br><span class="line">        mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以从代码上看到，Fragment 的销毁操作调用是在 onDestroy() 中。</p>
<p>另外，如果状态保存标记值 mStateSaved 为 true 的情况下，是不会去清除 ViewModel 的，这也是为什么上面中讲的配置改变的情况下，数据得以保持住的原因。</p>
<h3 id="FragmentActivity"><a href="#FragmentActivity" class="headerlink" title="FragmentActivity"></a>FragmentActivity</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Destroy all fragments.</span><br><span class="line"> */</span></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onDestroy();</span><br><span class="line"></span><br><span class="line">    doReallyStop(<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mViewModelStore != <span class="keyword">null</span> &amp;&amp; !mRetaining) &#123;</span><br><span class="line">        mViewModelStore.clear();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mFragments.dispatchDestroy();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同理， Activity 的销毁操作也是在 onDestroy() 完成的。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>终于把 LiveData 和 ViewModel 都分析了一遍，现在还差一个 Lifecycle 。</p>
<p>那么等有时间再写吧，bye bye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前给大家分析过了 LiveData ，今天就来看看 ViewModel 。</p>
<p>ViewMode]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Architecture Component" scheme="http://yuqirong.me/tags/Android-Architecture-Component/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android Architecture Component之LiveData解析]]></title>
    <link href="http://yuqirong.me/2018/06/20/Android%20Architecture%20Component%E4%B9%8BLiveData%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2018/06/20/Android Architecture Component之LiveData解析/</id>
    <published>2018-06-20T14:07:08.000Z</published>
    <updated>2018-07-14T16:30:33.283Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>Android Architecture Component 是 Google 在 2017 年推出的一套帮助开发者解决 Android 架构设计的方案。里面有众多吸引人的亮点，比如 Lifecycle、ViewModel 和 LiveData 等组件的设计，确实是一款牛逼的架构。</p>
<p>相信很多同学都用过这个架构了，在这就不多介绍了。今天就给大家来解析一下其中的 LiveData 是如何工作的。</p>
<p>LiveData 表示的是动态的数据，比如我们从网络上获取的数据，或者从数据库中获取的数据等，都可以用 LiveData 来概括。其中 setValue 方法是需要运行在主线程中的，而 postValue 方法是可以在子线程运行的。</p>
<p>PS: 本次源码解析基于 android.arch.lifecycle:extensions:1.1.1</p>
<h1 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h1><h2 id="Observer"><a href="#Observer" class="headerlink" title="Observer"></a>Observer</h2><p>LiveData 应用的主要是观察者模式，因为数据是多变的，所以肯定需要观察者来观察。而观察者和数据源建立连接就是通过 observe 方法来实现的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> SafeIterableMap&lt;Observer&lt;T&gt;, ObserverWrapper&gt; mObservers = <span class="keyword">new</span> SafeIterableMap&lt;&gt;();</span><br></pre></td></tr></table></figure>
<p>这个 LiveData 的所有观察者 Observer 都会被保存在 mObservers 这个 map 里面。那么对应的 value 值 ObserverWrapper 又是什么东西呢？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ObserverWrapper</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Observer&lt;T&gt; mObserver;</span><br><span class="line">        <span class="keyword">boolean</span> mActive;</span><br><span class="line">        <span class="keyword">int</span> mLastVersion = START_VERSION;</span><br><span class="line"></span><br><span class="line">        ObserverWrapper(Observer&lt;T&gt; observer) &#123;</span><br><span class="line">            mObserver = observer;</span><br><span class="line">        &#125;</span><br><span class="line">		</span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">activeStateChanged</span><span class="params">(<span class="keyword">boolean</span> newActive)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (newActive == mActive) &#123;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// immediately set active state, so we'd never dispatch anything to inactive</span></span><br><span class="line">            <span class="comment">// owner</span></span><br><span class="line">            mActive = newActive;</span><br><span class="line">            <span class="keyword">boolean</span> wasInactive = LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span>;</span><br><span class="line">            LiveData.<span class="keyword">this</span>.mActiveCount += mActive ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 如果现在第一次新增活跃的观察者，那么回调 onActive ，onActive 是个空方法</span></span><br><span class="line">            <span class="keyword">if</span> (wasInactive &amp;&amp; mActive) &#123;</span><br><span class="line">                onActive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果现在没有活跃的观察者了，那么回调 onInactive ，onInactive 是个空方法</span></span><br><span class="line">            <span class="keyword">if</span> (LiveData.<span class="keyword">this</span>.mActiveCount == <span class="number">0</span> &amp;&amp; !mActive) &#123;</span><br><span class="line">                onInactive();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 向观察者发送 LiveData 的值</span></span><br><span class="line">            <span class="keyword">if</span> (mActive) &#123;</span><br><span class="line">                dispatchingValue(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ObserverWrapper 是 Observer 的包装类，在 Observer 的基础上增加了 mActive 和 mLastVersion 。mActive 用来标识观察者是否是活跃，也就是说是否是在可用的生命周期内。</p>
<p>但是 ObserverWrapper 是个抽象类啊，到底是谁来实现它的呢？答案有两个。</p>
<ul>
<li>LifecycleBoundObserver</li>
<li>AlwaysActiveObserver</li>
</ul>
<p>我们重点来讲讲 LifecycleBoundObserver 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LifecycleBoundObserver</span> <span class="keyword">extends</span> <span class="title">ObserverWrapper</span> <span class="keyword">implements</span> <span class="title">GenericLifecycleObserver</span> </span>&#123;</span><br><span class="line">    <span class="annotation">@NonNull</span> <span class="keyword">final</span> LifecycleOwner mOwner;</span><br><span class="line"></span><br><span class="line">    LifecycleBoundObserver(<span class="annotation">@NonNull</span> LifecycleOwner owner, Observer&lt;T&gt; observer) &#123;</span><br><span class="line">        <span class="keyword">super</span>(observer);</span><br><span class="line">        mOwner = owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldBeActive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner.getLifecycle().getCurrentState().isAtLeast(STARTED);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStateChanged</span><span class="params">(LifecycleOwner source, Lifecycle.Event event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mOwner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">            <span class="comment">// 移除观察者，在这个方法中会移除生命周期监听并回调activeStateChanged 方法</span></span><br><span class="line">            removeObserver(mObserver);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        activeStateChanged(shouldBeActive());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isAttachedTo</span><span class="params">(LifecycleOwner owner)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mOwner == owner;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">detachObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mOwner.getLifecycle().removeObserver(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出，LifecycleBoundObserver 是把 ObserverWrapper 和 Lifecycle 相结合了。这样，在 LiveData 里就可以获取到观察者的生命周期了。当观察者的生命周期可用时，LiveData 会把数据发送给观察者，而当观察者生命周期不可用的时候，即 <code>mOwner.getLifecycle().getCurrentState() == DESTROYED</code> ，LiveData 就会选择不发送，并且自动解绑，防止造成内存泄漏等问题。</p>
<p>最后补充一下，LiveData 认为观察者生命周期可用的依据就是在 onStart 调用之后，在 onPause 调用之前。</p>
<p>平时使用 observe 的就是直接利用的是 LifecycleBoundObserver ，而另一个 AlwaysActiveObserver 顾名思义就是一直是活跃的，和观察者的生命周期无关了。我们调用 observeForever 方法内部使用的就是 AlwaysActiveObserver 。</p>
<h2 id="observe"><a href="#observe" class="headerlink" title="observe"></a>observe</h2><p>顺便，我们把 observe 方法也一起看了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">observe</span><span class="params">(@NonNull LifecycleOwner owner, @NonNull Observer&lt;T&gt; observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (owner.getLifecycle().getCurrentState() == DESTROYED) &#123;</span><br><span class="line">        <span class="comment">// ignore</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    LifecycleBoundObserver wrapper = <span class="keyword">new</span> LifecycleBoundObserver(owner, observer);</span><br><span class="line">    ObserverWrapper existing = mObservers.putIfAbsent(observer, wrapper);</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span> &amp;&amp; !existing.isAttachedTo(owner)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Cannot add the same observer"</span></span><br><span class="line">                + <span class="string">" with different lifecycles"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (existing != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    owner.getLifecycle().addObserver(wrapper);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码比较简单，就是利用了之前我们分析的 LifecycleBoundObserver ，再把它保存到 map 中。<br>最后，将 LifecycleBoundObserver 的生命周期监听注册好，OK，万事具备。</p>
<p>还有，另外一个 observeForever 方法就不看了，和 observe 方法差不多。</p>
<h2 id="setData_or_postData"><a href="#setData_or_postData" class="headerlink" title="setData or postData"></a>setData or postData</h2><p>setData 或者 postData 是当数据改变后向观察者传递值的。postData 最后也会调用 setData ，所以在这我们就只看 setData 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@MainThread</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    assertMainThread(<span class="string">"setValue"</span>);</span><br><span class="line">    mVersion++;</span><br><span class="line">    <span class="comment">// mData 保存的就是改变后的数据</span></span><br><span class="line">    mData = value;</span><br><span class="line">    dispatchingValue(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现这个 setData 的代码中判断了是否是主线程，所以这个方法只能在主线程中调用了。另外，调用后相应的版本也会自增。最后就是调用 dispatchingValue 方法去分发这个数据 mData 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dispatchingValue</span><span class="params">(@Nullable ObserverWrapper initiator)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mDispatchingValue) &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    mDispatchingValue = <span class="keyword">true</span>;</span><br><span class="line">    do &#123;</span><br><span class="line">        mDispatchInvalidated = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (initiator != <span class="keyword">null</span>) &#123;</span><br><span class="line">            considerNotify(initiator);</span><br><span class="line">            initiator = <span class="keyword">null</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Iterator&lt;Map.Entry&lt;Observer&lt;T&gt;, ObserverWrapper&gt;&gt; iterator =</span><br><span class="line">                    mObservers.iteratorWithAdditions(); iterator.hasNext(); ) &#123;</span><br><span class="line">                considerNotify(iterator.next().getValue());</span><br><span class="line">                <span class="keyword">if</span> (mDispatchInvalidated) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (mDispatchInvalidated);</span><br><span class="line">    mDispatchingValue = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 dispatchingValue 就是循环遍历 mObservers 这个 map ，向每一个观察者都发送新的数据。具体的代码在 considerNotify 方法中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">considerNotify</span><span class="params">(ObserverWrapper observer)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!observer.mActive) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Check latest state b4 dispatch. Maybe it changed state but we didn't get the event yet.</span></span><br><span class="line">    <span class="comment">//</span></span><br><span class="line">    <span class="comment">// we still first check observer.active to keep it as the entrance for events. So even if</span></span><br><span class="line">    <span class="comment">// the observer moved to an active state, if we've not received that event, we better not</span></span><br><span class="line">    <span class="comment">// notify for a more predictable notification order.</span></span><br><span class="line">    <span class="keyword">if</span> (!observer.shouldBeActive()) &#123;</span><br><span class="line">        observer.activeStateChanged(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (observer.mLastVersion &gt;= mVersion) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    observer.mLastVersion = mVersion;</span><br><span class="line">    <span class="comment">//noinspection unchecked</span></span><br><span class="line">    <span class="comment">// 调用 Observer 的 onChanged 方法实现回调</span></span><br><span class="line">    observer.mObserver.onChanged((T) mData);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好啦，到这里就把 LiveData 整个流程讲的差不多了。当然还有一些细节没讲到，感兴趣的同学就自己回去看看源码吧。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>LiveData 讲完了，再说一点，我们在实际的使用中用的都是 LiveData 的实现类 MutableLiveData 。</p>
<p>剩下的就不多说了，那么就静静等待解析 ViewModel 和 Lifecycle 吧。</p>
<p>bye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>Android Architecture Component 是 Google 在 2017 年推出的一套帮]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Architecture Component" scheme="http://yuqirong.me/tags/Android-Architecture-Component/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
