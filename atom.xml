<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[blog for yuqirong]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.github.io/"/>
  <updated>2016-02-01T14:59:37.599Z</updated>
  <id>http://yuqirong.github.io/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[实现炫酷的CheckBox，就这么简单]]></title>
    <link href="http://yuqirong.github.io/2015/12/05/%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84CheckBox%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://yuqirong.github.io/2015/12/05/实现炫酷的CheckBox，就这么简单/</id>
    <published>2015-12-05T15:10:32.000Z</published>
    <updated>2016-02-01T14:59:37.599Z</updated>
    <content type="html"><![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andyxialm/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a>，它的效果预览触动到我了，于是趁着今天有空就试着自己写一写。尽管效果可能不如SmoothCheckBox那样动感，但是基本的效果还是实现了。按照惯例，下面就贴出我写的CheckBox的gif： </p>
<p><img src="/uploads/20151205/20151205234652.gif" alt="这里写图片描述"></p>
<p>gif的效果可能有点过快，在真机上运行的效果会更好一些。我们主要的思路就是利用属性动画来动态地画出选中状态以及对勾的绘制过程。看到上面的效果图，相信大家都迫不及待地要跃跃欲试了，那就让我们开始吧。</p>
<p>自定义View的第一步：自定义属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;SmoothCheckBox&quot;&gt;
        &lt;!-- 动画持续时间 --&gt;
        &lt;attr name=&quot;duration&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框宽度 --&gt;
        &lt;attr name=&quot;strikeWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框颜色 --&gt;
        &lt;attr name=&quot;borderColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 选中状态的颜色 --&gt;
        &lt;attr name=&quot;trimColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾颜色 --&gt;
        &lt;attr name=&quot;tickColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾宽度 --&gt;
        &lt;attr name=&quot;tickWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>我们把CheckBox取名为SmoothCheckBox(没办法(⊙﹏⊙)，这名字挺好听的)，定义了几个等等要用到的属性。这一步很简单，相信大家都熟练了。</p>
<p>接下来看一看<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>:</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 40;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 40;
    }
    setMeasuredDimension(mWidth, mHeight);
    int size = Math.min(mWidth, mHeight);
    center = size / 2;
    mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
    startPoint.set(center * 14 / 30, center * 28 / 30);
    breakPoint.set(center * 26 / 30, center * 40 / 30);
    endPoint.set(center * 44 / 30, center * 20 / 30);

    downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
    upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
    totalLength = downLength + upLength;
}
</code></pre><p>一开始是测量了SmoothCheckBox的宽、高度，默认的宽高度随便定义了一个，当然你们可以自己去修改和完善它。然后就是设置半径之类的，最后的startPoint、breakPoint、endPoint分别对应着选中时对勾的三个点(至于为何是这几个数字，那完全是经验值);downLength就是startPoint和breakPoint的距离，而相对应的upLength就是breakPoint和endPoint的距离。即以下图示：</p>
<p><img src="/uploads/20151205/20151205000130.png" alt="这里写图片描述"></p>
<p>在看<code>onDraw(Canvas canvas)</code>之前我们先来看两组动画，分别是选中状态时的动画以及未选中状态的动画：</p>
<pre><code> // 由未选中到选中的动画
private void checkedAnimation() {
    animatedValue = 0f;
    tickValue = 0f;
    // 选中时底色的动画
    mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    // 对勾的动画
    mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
    mTickValueAnimator.setInterpolator(new LinearInterpolator());
    mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            tickValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            //当底色的动画完成后再开始对勾的动画
            mTickValueAnimator.start();
            Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
        }
    });
    mValueAnimator.start();
}

// 由选中到未选中的动画
private void uncheckedAnimation() {
    animatedValue = 0f;
    mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateInterpolator());
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.start();
}
</code></pre><p>这两组动画在点击SmoothCheckBox的时候会调用。相似的，都是在动画执行中得到动画执行的进度，再来调用<code>postInvalidate();</code>让SmoothCheckBox重绘。看完这个之后就是终极大招<code>onDraw(Canvas canvas)</code>了:</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    drawBorder(canvas);
    drawTrim(canvas);
    if (isChecked) {
        drawTick(canvas);
    }
    canvas.restore();
}

// 画对勾
private void drawTick(Canvas canvas) {
    // 得到画对勾的进度
    float temp = tickValue * totalLength;
    Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
    //判断是否是刚开始画对勾的时候,即等于startPoint
    if (Float.compare(tickValue, 0f) == 0) {
        Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
        path.reset();
        path.moveTo(startPoint.x, startPoint.y);
    }
    // 如果画对勾的进度已经超过breakPoint的时候,即(breakPoint,endPoint]
    if (temp &gt; downLength) {
        path.moveTo(startPoint.x, startPoint.y);
        path.lineTo(breakPoint.x, breakPoint.y);
        Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
        path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
    } else {
        //画对勾的进度介于startPoinit和breakPoint之间，即(startPoint,breakPoint]
        Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
        path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
    }
    canvas.drawPath(path, tickPaint);
}

// 画边框
private void drawBorder(Canvas canvas) {
    float temp;
    // 通过animatedValue让边框产生一个“OverShooting”的动画
    if (animatedValue &gt; 1f) {
        temp = animatedValue * mRadius;
    } else {
        temp = mRadius;
    }
    canvas.drawCircle(center, center, temp, borderPaint);
}

// 画checkbox内部
private void drawTrim(Canvas canvas) {
    canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
}
</code></pre><p><code>onDraw(Canvas canvas)</code>代码中的逻辑基本都加了注释，主要就是原理搞懂了就比较简单了。在绘制对勾时要区分当前处于绘制对勾的哪种状态，然后对应做处理画出线条，剩下的就简单了。关于SmoothCheckBox的讲解到这里就差不多了。</p>
<p>下面就贴出SmoothCheckBox的完整代码：</p>
<pre><code>public class SmoothCheckBox extends View implements View.OnClickListener {

    // 动画持续时间
    private long duration;
    // 边框宽度
    private float mStrokeWidth;
    // 对勾宽度
    private float mTickWidth;
    // 内饰画笔
    private Paint trimPaint;
    // 边框画笔
    private Paint borderPaint;
    // 对勾画笔
    private Paint tickPaint;
    // 默认边框宽度
    private float defaultStrikeWidth;
    // 默认对勾宽度
    private float defaultTickWidth;
    // 宽度
    private int mWidth;
    // 高度
    private int mHeight;
    // 边框颜色
    private int borderColor;
    // 内饰颜色
    private int trimColor;
    // 对勾颜色
    private int tickColor;
    // 半径
    private int mRadius;
    // 中心点
    private int center;
    // 是否是选中
    private boolean isChecked;
    //对勾向下的长度
    private float downLength;
    //对勾向上的长度
    private float upLength;
    // 对勾的总长度
    private float totalLength;
    // 监听器
    private OnCheckedChangeListener listener;

    private ValueAnimator mValueAnimator;

    private ValueAnimator mTickValueAnimator;

    private float animatedValue;

    private float tickValue;
    // 对勾开始点
    private Point startPoint = new Point();
    // 对勾转折点
    private Point breakPoint = new Point();
    // 对勾结束点
    private Point endPoint = new Point();

    private static final String TAG = &quot;SmoothCheckBox&quot;;

    private static final String KEY_INSTANCE_STATE = &quot;InstanceState&quot;;

    private Path path = new Path();

    public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
        this.listener = listener;
    }

    public SmoothCheckBox(Context context) {
        this(context, null);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.SmoothCheckBox);
        duration = a.getInt(R.styleable.SmoothCheckBox_duration, 600);

        defaultStrikeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, getResources().getDisplayMetrics());
        mStrokeWidth = a.getDimension(R.styleable.SmoothCheckBox_strikeWidth, defaultStrikeWidth);
        defaultTickWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
        mTickWidth = a.getDimension(R.styleable.SmoothCheckBox_tickWidth, defaultTickWidth);
        borderColor = a.getColor(R.styleable.SmoothCheckBox_borderColor, getResources().getColor(android.R.color.darker_gray));
        trimColor = a.getColor(R.styleable.SmoothCheckBox_trimColor, getResources().getColor(android.R.color.holo_green_light));
        tickColor = a.getColor(R.styleable.SmoothCheckBox_tickColor, getResources().getColor(android.R.color.white));
        a.recycle();

        trimPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        trimPaint.setStyle(Paint.Style.FILL);
        trimPaint.setColor(trimColor);

        borderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        borderPaint.setStrokeWidth(mStrokeWidth);
        borderPaint.setColor(borderColor);
        borderPaint.setStyle(Paint.Style.STROKE);

        tickPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        tickPaint.setColor(tickColor);
        tickPaint.setStyle(Paint.Style.STROKE);
        tickPaint.setStrokeCap(Paint.Cap.ROUND);
        tickPaint.setStrokeWidth(mTickWidth);

        setOnClickListener(this);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = 40;
        }

        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = 40;
        }
        setMeasuredDimension(mWidth, mHeight);
        int size = Math.min(mWidth, mHeight);
        center = size / 2;
        mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
        startPoint.set(center * 14 / 30, center * 28 / 30);
        breakPoint.set(center * 26 / 30, center * 40 / 30);
        endPoint.set(center * 44 / 30, center * 20 / 30);

        downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
        upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
        totalLength = downLength + upLength;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        drawBorder(canvas);
        drawTrim(canvas);
        if (isChecked) {
            drawTick(canvas);
        }
        canvas.restore();
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INSTANCE_STATE, super.onSaveInstanceState());
        bundle.putBoolean(KEY_INSTANCE_STATE, isChecked);
        return bundle;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            Bundle bundle = (Bundle) state;
            boolean isChecked = bundle.getBoolean(KEY_INSTANCE_STATE);
            setChecked(isChecked);
            super.onRestoreInstanceState(bundle.getParcelable(KEY_INSTANCE_STATE));
            return;
        }
        super.onRestoreInstanceState(state);
    }

    // 切换状态
    private void toggle() {
        isChecked = !isChecked;
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
        if (isChecked) {
            checkedAnimation();
        } else {
            uncheckedAnimation();
        }
    }

    // 由未选中到选中的动画
    private void checkedAnimation() {
        animatedValue = 0f;
        tickValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
        mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
        mTickValueAnimator.setInterpolator(new LinearInterpolator());
        mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                tickValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                mTickValueAnimator.start();
                Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
            }
        });
        mValueAnimator.start();
    }

    // 由选中到未选中的动画
    private void uncheckedAnimation() {
        animatedValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateInterpolator());
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.start();
    }

    // 画对勾
    private void drawTick(Canvas canvas) {
        float temp = tickValue * totalLength;
        Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
        if (Float.compare(tickValue, 0f) == 0) {
            Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
            path.reset();
            path.moveTo(startPoint.x, startPoint.y);
        }
        if (temp &gt; downLength) {
            path.moveTo(startPoint.x, startPoint.y);
            path.lineTo(breakPoint.x, breakPoint.y);
            Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
            path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
        } else {
            Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
            path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
        }
        canvas.drawPath(path, tickPaint);
    }

    // 画边框
    private void drawBorder(Canvas canvas) {
        float temp;
        if (animatedValue &gt; 1f) {
            temp = animatedValue * mRadius;
        } else {
            temp = mRadius;
        }
        canvas.drawCircle(center, center, temp, borderPaint);
    }

    // 画checkbox内部
    private void drawTrim(Canvas canvas) {
        canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
    }

    @Override
    public void onClick(View view) {
        toggle();
    }

    /**
     * 判断checkbox是否选中状态
     *
     * @return
     */
    public boolean isChecked() {
        return isChecked;
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked 是否选中
     */
    public void setChecked(boolean isChecked) {
        this.setChecked(isChecked, false);
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked   是否选中
     * @param isAnimation 切换时是否有动画
     */
    public void setChecked(boolean isChecked, boolean isAnimation) {
        this.isChecked = isChecked;
        if (isAnimation) {
            if (isChecked) {
                checkedAnimation();
            } else {
                uncheckedAnimation();
            }
        } else {
            animatedValue = isChecked ? 1f : 0f;
            tickValue = 1f;
            invalidate();
        }
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
    }

    public interface OnCheckedChangeListener {
        void onCheckedChanged(SmoothCheckBox smoothCheckBox, boolean isChecked);
    }
}
</code></pre><p>下面是SmoothCheckBox的源码下载，如果有问题可以在下面留言来交流：</p>
<p><a href="/uploads/20151205/SmoothCheckBox.rar">SmoothCheckBox.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探Android ORM框架之greenDAO]]></title>
    <link href="http://yuqirong.github.io/2015/11/24/%E5%88%9D%E6%8E%A2Android%20ORM%E6%A1%86%E6%9E%B6%E4%B9%8BgreenDAO/"/>
    <id>http://yuqirong.github.io/2015/11/24/初探Android ORM框架之greenDAO/</id>
    <published>2015-11-24T13:14:30.000Z</published>
    <updated>2016-01-26T17:08:09.986Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许多ORM (对象关系映射 英语：Object Relational Mapping) 的第三方框架，比如greenDAO、ActiveAndroid、ormlite等。说到ORM，相信有过J2EE开发经验的童鞋对此并不陌生，在web开发中就有Hibernate、MyBatis等框架提供使用。那么今天就来介绍一下主角：greenDAO。</p>
<p>根据 <a href="http://greenrobot.org/" target="_blank" rel="external">greenrobot</a> 官方的介绍，greenDAO是一款轻量，快速，适用于Android数据库的ORM框架。具有很高的性能以及消耗很少的内存。其他的优点和特性就不在这里一一介绍了，想要了解的同学可以去访问它的项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a>。</p>
<p>说了这么多，下面就开始我们的正题吧。</p>
<p>在使用greenDAO之前，我们有一件事情不得不做，那就是用代码生成器生成数据模型以及xxxDao等</p>
<p>新建一个java module，取名greendaogeneration(名字随意取，不要在意细节↖(^ω^)↗)，然后在build.gradle(Module:greendaogeneration)中添加依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao-generator:2.0.0&#39;</code></p>
<p>在 src/main 目录下新建一个与 java 同层级的 java-gen 目录，然后配置 Android 工程的 build.gradle(Module:app)，分别添加如下sourceSets。</p>
<pre><code>android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.yuqirong.greendaodemo&quot;
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
    sourceSets {
        main {
            java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/java-gen&apos;]
        }
    }
}
</code></pre><p>然后在greendaogeneration中创建一个GreenDaoGeneration类，用于生成代码：</p>
<pre><code>public class GreenDaoGeneration {

    public static void main(String[] arg0) {

        try {
            Schema schema = new Schema(1, &quot;com.yuqirong.greendao&quot;);
            addLocation(schema);
            new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void addLocation(Schema schema){
        Entity location= schema.addEntity(&quot;Location&quot;);
        location.addIdProperty();
        location.addDoubleProperty(&quot;lon&quot;);
        location.addIntProperty(&quot;level&quot;);
        location.addStringProperty(&quot;address&quot;);
        location.addStringProperty(&quot;city_name&quot;);
        location.addIntProperty(&quot;alevel&quot;);
        location.addDoubleProperty(&quot;lat&quot;);
    }
}
</code></pre><p>其中在创建Schema对象的参数中，第一个表示数据库的版本号，我们传入了“1”，第二个参数是生成代码的包名，我们传入了”com.yuqirong.greendao”，那么生成的代码就自动在”com.yuqirong.greendao”包下了。</p>
<p>在addLocatiion方法中，我们打算把“Location”这个类(其实到现在为止，Location实体类还未生成)保存在数据库中，<code>schema.addEntity(&quot;Location&quot;)</code>传入的Location，那么该表的表名就叫Location，然后我们又定义了在Location表中会有lon、lat、city_name三个字段。所以如果你想创建多张表，那么就要像addLocation()这样的方法多写几个。好了，该做的差不多都做了，最后再<code>new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);</code>把之前的schema传入，第二个参数传的是之前创建的java-gen的路径(建议传入绝对路径，之前在这里被坑了好久↖(~^~)↗)。代码运行之后再到”com.yuqirong.greendao”路径下去看，发现会有许多类生成：</p>
<p><img src="/uploads/20151124/20151124235609.png" alt="这里写图片描述"></p>
<p>至于这些类的作用，我们到下面再说。</p>
<p>第二步在Android Studio的build.gradle(Module:app)中添加以下依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao:2.0.0&#39;</code>  </p>
<p>这样我们就可以在项目中使用greenDAO了。</p>
<p>在正式使用greenDAO前我们需要了解几个greenDAO中的类(也就是上面代码生成的几个类)：</p>
<ul>
<li><p>DaoMaster ：一看这个类名我们就知道这个类肯定是大总管级别的，DaoMaster继承自AbstractDaoMaster。在AbstractDaoMaster中保存了sqlitedatebase对象以及以Map的形式保存了各种操作DAO。DaoMaster还提供了一些创建和删除table的静态方法。另外在DaoMaster类里面有一个静态内部类DevOpenHelper，DevOpenHelper间接继承了SQLiteOpenHelper，通常我们会用<code>new DaoMaster.DevOpenHelper(this, &quot;notes-db&quot;, null)</code>来得到一个DevOpenHelper对象，第一个参数是Context，第二个参数是数据库名，第三个参数是CursorFactory，通常我们传入null。就上面这样简单的一句话你就实际上创建了一个SQLiteOpenHelper对象，而不需要输入<code>&quot;CREATE TABLE...&quot;</code> SQL语句，greenDAO已经帮你做好了一切。</p>
</li>
<li><p>DaoSession：会话层。主要功能就是操作具体的DAO对象，比如各种getXXXDao()方法。</p>
</li>
<li><p>XXXDao：实际生成的DAO类(即生成的LocationDao)，主要对应于某张表的CRUD，比如说LocationDao，那相对应就是对Location表的操作。</p>
</li>
<li><p>XXXEntity：主要是各个实体类(也就是上面生成的Location)，里面的属性与表中的字段相对应。比如上面的LocationDao，那么实体类就是Location，Location实体类中有lon，lat，city_name,alevel,level,address六个属性，那么在Location表中就有lon，lat，city_name,alevel,level,address六个字段。</p>
</li>
</ul>
<p>通过上面几个类作用的介绍，相信大家对greenDAO有了一个初步的印象，下面我们就要真枪实弹了，一起来看一个简单的Demo吧：</p>
<pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(context, &quot;location&quot;, null);
SQLiteDatabase writableDB = devOpenHelper.getWritableDatabase();
DaoMaster daoMaster = new DaoMaster(writableDB);
DaoSession daoSession = daoMaster.newSession();
</code></pre><p>上面的代码很简单，我们创建了一个名叫“location”的数据库，然后通过daoMaster得到了daoSession，有了daoSession，我们就可以得到各种xxxDao，之后的CRUD都是通过xxxDao来操作。</p>
<pre><code>LocationDao locationDao = daoSession.getLocationDao();
Location local = new Location(null,120.15507,2,&quot;&quot;,&quot;杭州市&quot;,4,30.27408);
locationDao.insert(local);
</code></pre><p>我们创建了一个Location的对象，然后调用<code>locationDao.insert()</code>方法就把local的数据插入到location的表中，是不是简单到难以让人置信?!只需要三行代码，而不再需要原生的ContentValues了。不得不感叹greenDAO太方便了。</p>
<p>除了添加数据的，greenDAO还提供删除数据的方法：<code>locationDao.deleteByKey(id);</code>id为当前要删除的那行的主键。</p>
<p>更新数据的方法：<code>locationDao.update(local);</code>local为新的数据。</p>
<p>查询数据的方法： </p>
<ul>
<li><code>locationDao.queryRaw(String where, String...selectionArg)</code>,可以看到greenDAO支持sql语句查询。</li>
<li><p>greenDAO还支持一种更为简单的查询方式，不再需要你去写sql语句(查询Location的lon大于120度和lat大于30度)： </p>
<pre><code>List&lt;Location&gt; list = locationDao.queryBuilder()
                        .where(LocationDao.Properties.Lat.gt(30d), LocationDao.Properties.Lon.gt(120d))
                        .build()
                        .list();
</code></pre></li>
</ul>
<p>好了，关于greenDAO的简单使用就先到这里，至于深入使用我们有机会再讲吧！</p>
<p>依据惯例，下面提供本Demo的源码:</p>
<p><a href="/uploads/20151124/GreenDaoDemo.rar">GreenDaoDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许]]>
    </summary>
    
      <category term="greenDAO" scheme="http://yuqirong.github.io/tags/greenDAO/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现满屏表情下落的动画效果，你也可以]]></title>
    <link href="http://yuqirong.github.io/2015/11/12/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%BB%A1%E5%B1%8F%E8%A1%A8%E6%83%85%E4%B8%8B%E8%90%BD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"/>
    <id>http://yuqirong.github.io/2015/11/12/简单实现满屏表情下落的动画效果，你也可以/</id>
    <published>2015-11-12T14:39:14.000Z</published>
    <updated>2016-01-26T17:08:09.987Z</updated>
    <content type="html"><![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img src="/uploads/20151112/20151112224542.gif" alt="这里写图片描述"></p>
<p>看完上面的效果图，大家一定都迫不及待地想要试一试了，那就让我们来动手吧。</p>
<p>首先我们定义一个实体类DropLook:</p>
<pre><code>/**
 * 下落的表情
 */
public class DropLook {

    // x轴坐标
    private float x;
    // y轴坐标
    private float y;
    // 初始旋转角度
    private float rotation;
    // 下落速度
    private float speed;
    // 旋转速度
    private float rotationSpeed;
    // 宽度
    private int width;
    // 高度
    private int height;
    // 图片
    private Bitmap bitmap;

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public float getRotationSpeed() {
        return rotationSpeed;
    }

    public void setRotationSpeed(float rotationSpeed) {
        this.rotationSpeed = rotationSpeed;
    }

    public float getRotation() {
        return rotation;
    }

    public void setRotation(float rotation) {
        this.rotation = rotation;
    }

    public float getSpeed() {
        return speed;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public Bitmap getBitmap() {
        return bitmap;
    }

    public void setBitmap(Bitmap bitmap) {
        this.bitmap = bitmap;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

}
</code></pre><p>我们定义的实体类很简单，只是设置了如宽高、x，y坐标、下落速度等。接下来我们再创建一个DropLookFactory类，用来创建DropLook对象。</p>
<pre><code>public class DropLookFactory {

    private DropLookFactory() {

    }

    public static DropLook createDropLook(int width, int height,Bitmap originalBitmap) {
        DropLook look = new DropLook();
        if (originalBitmap == null) {
            throw new NullPointerException(&quot;originalBitmap cannot be null&quot;);
        }
        // 设置与图片等宽
        look.setWidth(originalBitmap.getWidth());
        // 设置与图片等高
        look.setHeight(originalBitmap.getHeight());
        // 设置起始位置的X坐标
        look.setX((float) Math.random() * (width - look.getWidth()));
        // 设置起始位置的Y坐标
        look.setY((float) Math.random() * (height - look.getHeight()));
        // 设置速度
        look.setSpeed(20 + (float) Math.random() * 40);
        // 设置初始旋转角度
        look.setRotation((float) Math.random() * 180 - 90);
        // 设置旋转速度
        look.setRotationSpeed((float) Math.random() * 90 - 60);
        // 设置图片
        look.setBitmap(originalBitmap);
        return look;
    }

}
</code></pre><p>其中<code>createDropLook(Context context, float xRange, Bitmap originalBitmap)</code>的第一个参数代表着下落表情在x轴上的范围，第二个参数代表在y轴上的范围，第三个参数是表情的图片。在createDropLook方法中相信大家都看得懂，主要就是用随机数初始化DropLook的坐标及下落速度等。</p>
<p>好了，下面就是今天的重头戏DropLookView，先来看看onMeasure(): </p>
<pre><code> @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = Tools.dip2px(getContext(),200);
    }
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = Tools.dip2px(getContext(),200);
    }
    setMeasuredDimension(mWidth, mHeight);
    if (looks.size() == 0) {
        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
            looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
        }
        Log.i(TAG, &quot;num = &quot; + looks.size());
    }
}
</code></pre><p>onMeasure里主要是对View的测量，如果是<code>wrap_content</code>的话设置一个默认的宽高度200dp。然后就是初始化DropLook，looks是DropLook类的集合，用于管理DropLook。而<code>DEFAULT_LOOK_NUMS</code>是默认的looks集合的数量。</p>
<p>接下来就是最关键的onDraw():</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    long nowTime = System.currentTimeMillis();
    if (nowTime - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - nowTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

        DropLook look = looks.get(i);
        mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
        mMatrix.postRotate(look.getRotation());
        mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
        canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

        look.setY(look.getY() + look.getSpeed());
        if (look.getY() &gt; getHeight()) {
            look.setY((float) (0 - Math.random() * look.getHeight()));
        }

        look.setRotation(look.getRotation() + look.getRotationSpeed());
    }

    canvas.restore();
    startTime = System.currentTimeMillis();
    invalidate();
}
</code></pre><p>一开始判断时间间隔如果没有超过100ms，就让线程睡眠一会。然后就是用drawBitmap的方法把looks里面逐个绘制出来。并且再把look的y轴坐标加上下落速度等，旋转的角度也是如此。最后就是调用invalidate()不断地重绘。总体上并没有什么难点。</p>
<p>以下是DropLookView的完整代码：</p>
<pre><code>/**
 * 表情下落view
 */
public class DropLookView extends View {

    // 表情
    private Bitmap mBitmap;
    // 所有表情集合
    List&lt;DropLook&gt; looks = new ArrayList();
    // view开始时间
    private long startTime;
    // view宽度
    private int mWidth;
    // view高度
    private int mHeight;
    // 画笔
    private Paint mPaint;
    // 默认表情下落数
    private static final int DEFAULT_DROP_LOOK_NUMS = 35;

    private static final String TAG = &quot;DropLookView&quot;;

    private Matrix mMatrix = new Matrix();

    public DropLookView(Context context) {
        this(context, null);
    }

    public DropLookView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DropLookView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        // 图片
        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.d_5_xiaoku);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = Tools.dip2px(getContext(),200);
        }
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = Tools.dip2px(getContext(),200);
        }
        setMeasuredDimension(mWidth, mHeight);
        if (looks.size() == 0) {
            for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
                looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
            }
            Log.i(TAG, &quot;num = &quot; + looks.size());
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        long nowTime = System.currentTimeMillis();
        if (nowTime - startTime &lt; 100) {
            try {
                Thread.sleep(100 + startTime - nowTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

            DropLook look = looks.get(i);
            mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
            mMatrix.postRotate(look.getRotation());
            mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
            canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

            look.setY(look.getY() + look.getSpeed());
            if (look.getY() &gt; getHeight()) {
                look.setY((float) (0 - Math.random() * look.getHeight()));
            }

            look.setRotation(look.getRotation() + look.getRotationSpeed());
        }

        canvas.restore();
        startTime = System.currentTimeMillis();
        invalidate();
    }

}
</code></pre><p>该讲的也差不多讲完了，其实并没有想象中的那么有难度，实现起来也比较容易。当然DropLookView也有需要改进的地方。比如说可以在布局文件中自定义表情下落的数量等。这些就需要自己根据需求来更改了，那今天就先这样吧。</p>
<p>下面是本Demo的完整代码：<br><a href="/uploads/20151112/DropDownView.rar">DropLookView.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img sr]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android onTouch事件传递机制解析]]></title>
    <link href="http://yuqirong.github.io/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.github.io/2015/10/29/Android onTouch事件传递机制解析/</id>
    <published>2015-10-29T14:56:09.000Z</published>
    <updated>2016-01-30T14:15:37.497Z</updated>
    <content type="html"><![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事件传递的机制了，顺便写一篇博客来记录一下。下面就让我们来看看吧。</p>
<p>大家都知道一般我们使用的UI控件都是继承自共同的父类——View。所以View这个类应该掌管着onTouch事件的相关处理。那就让我们去看看：在View中寻找Touch相关的方法，其中一个很容易地引起了我们的注意：dispatchTouchEvent(MotionEvent event)。根据方法名的意思应该是负责分发触摸事件的，下面给出了源码：</p>
<pre><code>/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
 public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}
</code></pre><p>源码有点长，但我们不必每一行都看。首先注意到dispatchTouchEvent的返回值是boolean类型的，注释上的解释：<code>@return True if the event was handled by the view, false otherwise.</code>也就是说如果该触摸事件被这个View消费了就返回true，否则返回false。在方法中首先判断了该event是否是否得到了焦点，如果没有得到焦点直接返回false。然后让我们把目光转向<code>if (li != null &amp;&amp; li.mOnTouchListener != null&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED&amp;&amp; li.mOnTouchListener.onTouch(this, event))</code>这个片段，看到这里有一个名为li的局部变量，属于 ListenerInfo 类，经 mListenerInfo 赋值得到。ListenerInfo只是一个包装类，里面封装了大量的监听器。再在 View 类中去寻找 mListenerInfo ，可以看到下面的代码：</p>
<pre><code>  ListenerInfo getListenerInfo() {
    if (mListenerInfo != null) {
        return mListenerInfo;
    }
    mListenerInfo = new ListenerInfo();
    return mListenerInfo;
}
</code></pre><p>因此我们可以知道mListenerInfo是不为空的，所以li也不是空，第一个判断为true，然后看到li.mOnTouchListener，前面说过ListenerInfo是一个监听器的封装类，所以我们同样去追踪mOnTouchListener：</p>
<pre><code>/**
 * Register a callback to be invoked when a touch event is sent to this view.
 * @param l the touch listener to attach to this view
 */
public void setOnTouchListener(OnTouchListener l) {
    getListenerInfo().mOnTouchListener = l;
}
</code></pre><p>正是通过上面的方法来设置 mOnTouchListener 的，我想上面的方法大家肯定都很熟悉吧，正是我们平时经常用的 xxx.setOnTouchListener ，好了我们从中得知如果设置了OnTouchListener则第二个判断也为true，第三个判断为如果该View是否为enable，默认都是enable的，所以同样为true。还剩最后一个：<code>li.mOnTouchListener.onTouch(this, event)</code>，显然是回调了第二个判断中监听器的onTouch()方法，如果onTouch()方法返回true,则上面四个判断全部为true,dispatchTouchEvent()方法会返回true，并且不会执行<code>if (!result &amp;&amp; onTouchEvent(event))</code>这个判断；而在这个判断中我们又看到了一个熟悉的方法：onTouchEvent()。所以想要执行onTouchEvent，则在上面的四个判断中必须至少有一个false。</p>
<p>那就假定我们在onTouch()方法中返回的是false，这样就顺利地执行了onTouchEvent，那就看看onTouchEvent的源码吧：</p>
<pre><code>/**
 * Implement this method to handle touch screen motion events.
 * &lt;p&gt;
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * &lt;ul&gt;
 * &lt;li&gt;obeying click sound preferences
 * &lt;li&gt;dispatching OnClickListener calls
 * &lt;li&gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * &lt;/ul&gt;
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>这段源码比 dispatchTouchEvent 的还要长，不过同样我们挑重点的看：<br><code>if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE)</code><br>看到这句话就大概知道了主要是判断该view是否是可点击的，如果可以点击则接着执行，否则直接返回false。可以看到if里面用switch来判断是哪种触摸事件，但在最后都是返回true的。还有一点要注意：在 ACTION_UP 中会执行 performClick() 方法：</p>
<pre><code>public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}
</code></pre><p>可以看到上面的<code>li.mOnClickListener.onClick(this);</code>，没错，我们好像又有了新的发现。根据上面的经验，这句代码会去回调我们设置好的点击事件监听器。也就是我们平常用的xxx.setOnClickListener(listener);</p>
<pre><code>/**
 * Register a callback to be invoked when this view is clicked. If this view is not
 * clickable, it becomes clickable.
 *
 * @param l The callback that will run
 *
 * @see #setClickable(boolean)
 */
public void setOnClickListener(@Nullable OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}
</code></pre><p>我们可以看到上面方法设置正是mListenerInfo的点击监听器，验证了上面的猜想。到了这里onTouch事件的传递机制基本已经分析完成了,也算是告一段落了。</p>
<p>好了，这下我们可以解决开头的问题了，顺便我们再来小结一下：在dispatchTouchEvent中，如果设置了OnTouchListener并且View是enable的，那么首先被执行的是OnTouchListener中的<code>onTouch(View v, MotionEvent event)</code>。若onTouch返回true,则dispatchTouchEvent不再往下执行并且返回true；不然会执行onTouchEvent，在onTouchEvent中若View是可点击的，则返回true，不然为false。还有在onTouchEvent中若View是可点击以及当前触摸事件为ACTION_UP，会执行performClick()，回调OnClickListener的onClick方法。下面是我画的一张草图：<br><img src="/uploads/20151029/20151029230937.png" alt="这里写图片描述"></p>
<p>还有一点值得注意的地方是：假如当前事件是ACTION_DOWN，只有dispatchTouchEvent返回true了之后该View才会接收到接下来的ACTION_MOVE,ACTION_UP事件，也就是说只有事件被消费了才能接收接下来的事件。</p>
<p>好了，今天就到这里了，如果有什么问题可以在下面留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义View之实现文字百分比进度条]]></title>
    <link href="http://yuqirong.github.io/2015/10/23/%E8%87%AA%E5%AE%9A%E4%B9%89View%E4%B9%8B%E5%AE%9E%E7%8E%B0%E6%96%87%E5%AD%97%E7%99%BE%E5%88%86%E6%AF%94%E8%BF%9B%E5%BA%A6%E6%9D%A1/"/>
    <id>http://yuqirong.github.io/2015/10/23/自定义View之实现文字百分比进度条/</id>
    <published>2015-10-23T15:26:56.000Z</published>
    <updated>2016-01-26T17:08:09.988Z</updated>
    <content type="html"><![CDATA[<p>之前在学习自定义View的时候看到鸿洋的 <a href="http://blog.csdn.net/lmj623565791/article/details/43371299" target="_blank" rel="external">《Android 打造形形色色的进度条 实现可以如此简单》</a> 中自带百分比的进度条，于是照着例子自己实现了一下。下面是View的样子：<br><img src="/uploads/20151023/20151023211913.gif" alt="这里写图片描述"></p>
<p>大家都知道自定义View的主要步骤：  </p>
<ol>
<li>自定义View的一些属性  </li>
<li>在构造器中初始化属性  </li>
<li>重写onMeasure()方法  </li>
<li>重写onDraw()方法  </li>
</ol>
<p>下面就来实现第一步：<br>先在values文件夹中新建attrs.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;PercentProgressView&quot;&gt;
        &lt;!-- 进度条当前进度的颜色 --&gt;
        &lt;attr name=&quot;progress_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的当前进度 --&gt;
        &lt;attr name=&quot;progress&quot; format=&quot;integer|float&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的总进度 --&gt;
        &lt;attr name=&quot;total&quot; format=&quot;integer|float&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条总进度的颜色 --&gt;
        &lt;attr name=&quot;total_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 百分比字体的大小 --&gt;
        &lt;attr name=&quot;text_size&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- 进度条的宽度 --&gt;
        &lt;attr name=&quot;progress_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- 百分比字体的偏移量 --&gt;
        &lt;attr name=&quot;text_offset&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>好了我差不多就定义以上几种属性，有需要的可以在后面再添加。这样我们的第一步就完成了。下面我们就来看看第二步吧。</p>
<pre><code>// 画笔
private Paint mPaint;
// 当前进度颜色
private int mProgressColor;
// 总进度颜色
private int mTotalColor;
// view的宽度
private int mWidth;
// view的高度
private int mHeight;
// 当前进度
private float mProgress;
// 总进度
private float mTotal;
// 字体大小
private float mTextSize;
// 进度文字偏移
private float mTextOffset;
// 进度条高度
private float mProgressHeight;
// 真实宽度
private int realWidth;
// 文字默认宽度
private static final float TEXT_SIZE = 20;
// 文字偏移
private static final float TEXT_OFFSET = 10;
// 默认进度条高度
private static final float DEFAULT_PROGRESS_HEIGHT = 4;

public PercentProgressView(Context context) {
    this(context, null);
}

public PercentProgressView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public PercentProgressView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PercentProgressView);
    // 当前进度颜色
    mProgressColor = a.getColor(R.styleable.PercentProgressView_progress_color, Color.RED);
    // 总进度颜色
    mTotalColor = a.getColor(R.styleable.PercentProgressView_total_color, Color.GRAY);
    // 当前的进度
    mProgress = a.getFloat(R.styleable.PercentProgressView_progress, 0f);
    // 总量
    mTotal = a.getFloat(R.styleable.PercentProgressView_total, 100f);
    // 字体大小
    float defaultTextSize = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_SP, TEXT_SIZE, getResources()
                    .getDisplayMetrics());
    mTextSize = a.getDimension(R.styleable.PercentProgressView_text_size, defaultTextSize);
    // 进度条高度
    float defaultProgressHeight = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, DEFAULT_PROGRESS_HEIGHT, getResources()
                    .getDisplayMetrics());
    mProgressHeight = a.getDimension(R.styleable.PercentProgressView_progress_height, defaultProgressHeight);
    // 进度文字偏移
    float defaultTextOffset = TypedValue.applyDimension(
            TypedValue.COMPLEX_UNIT_DIP, TEXT_OFFSET, getResources()
                    .getDisplayMetrics());
    mTextOffset = a.getDimension(R.styleable.PercentProgressView_text_offset, defaultTextOffset);
    // 回收TypedArray
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    mPaint.setTextSize(mTextSize);
    mPaint.setStrokeWidth(mProgressHeight);
    mPaint.setColor(mProgressColor);
}
</code></pre><p>在第二步中我们主要做的就是把上一步定义的属性在构造器中初始化，设置一些默认值以及创建一个新的Paint对象。其实并没什么难度，都是一些重复性的东西。</p>
<p>接下来要做的就是重写onMeasure()方法来测量View。宽度我们可以设置为match_parent，高度为可自定义，所以我们要测量一下高度。使用MeasureSpec.getMode(heightMeasureSpec)来判断用户设置的模式，如果是 MeasureSpec.EXACTLY 则不直接返回 MeasureSpec.getSize(heightMeasureSpec) 就可以了，不然的话要比较文字和进度条的高度，取两者的最大值。最后调用setMeasuredDimension(width,height)。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int mode = MeasureSpec.getMode(heightMeasureSpec);
    int size = MeasureSpec.getSize(heightMeasureSpec);
    mWidth = MeasureSpec.getSize(widthMeasureSpec);
    mHeight = measureHeight(mode, size);
    setMeasuredDimension(mWidth, mHeight);
    realWidth = getMeasuredWidth() - getPaddingLeft() - getPaddingRight();
}

//测量高度
private int measureHeight(int mode, int size) {
    int result;
    if (mode == MeasureSpec.EXACTLY) {
        //精确的情况下
        result = size;
    } else {
        int h = (int) (getPaddingBottom() + getPaddingTop() +
                Math.max(mProgressHeight, Math.abs(mPaint.descent() - mPaint.ascent())));
        result = h;
        if (mode == MeasureSpec.AT_MOST) {
            result = Math.min(h, size);
        }
    }
    return result;
}
</code></pre><p>上面三步完成之后就到了最后的重点onDraw()方法了。根据思路我们应该先画出已完成进度的矩形，再画出百分比文字，最后画出未完成的进度。需要注意的是绘制文字的时候Y轴起点为文字的baseline，而不是文字的顶部。下面给出了绘制时大概的思路图：<br><img src="/uploads/20151023/20151023214750.png" alt="这里写图片描述"></p>
<pre><code>   @Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);

    canvas.save();
    // 设置画笔颜色为已完成的颜色
    mPaint.setColor(mProgressColor);
    float p = getPercent();
    // 得到百分比
    String s = (int) (p * 100) + &quot;%&quot;;
    // 测量文字的宽度
    float textWidth = mPaint.measureText(s);

    canvas.drawRect(getPaddingLeft(), (mHeight - mProgressHeight) / 2,
            getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p, (mHeight + mProgressHeight) / 2, mPaint);
    // 测量文字的高度
    float textHeight = Math.abs((mPaint.descent() + mPaint.ascent()) / 2);

    canvas.drawText(s, getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p + mTextOffset / 2,
            textHeight + mHeight / 2, mPaint);
    // 设置画笔颜色为未完成的颜色
    mPaint.setColor(mTotalColor);

    canvas.drawRect(getPaddingLeft() + (realWidth - textWidth - mTextOffset) * p + mTextOffset + textWidth, (mHeight - mProgressHeight) / 2,
            mWidth - getPaddingRight(), (mHeight + mProgressHeight) / 2, mPaint);
    canvas.restore();
}
</code></pre><p>到了这里整体的View差不多已经写完了，其实总体并没有什么难点。只要搞清思路，相信大家都能定义出自己想要的View。  </p>
<p>以下是完整代码下载地址：<br><a href="/uploads/20151023/PercentProgressView.rar">PercentProgressView.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在学习自定义View的时候看到鸿洋的 <a href="http://blog.csdn.net/lmj623565791/article/details/43371299" target="_blank" rel="external">《Android 打造形形色色的]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.github.io/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[探究Android异步消息的处理之Handler详解]]></title>
    <link href="http://yuqirong.github.io/2015/09/29/%E6%8E%A2%E7%A9%B6Android%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E7%9A%84%E5%A4%84%E7%90%86%E4%B9%8BHandler%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yuqirong.github.io/2015/09/29/探究Android异步消息的处理之Handler详解/</id>
    <published>2015-09-29T05:19:12.000Z</published>
    <updated>2016-01-30T14:16:24.441Z</updated>
    <content type="html"><![CDATA[<p>在学习Android的路上，大家肯定会遇到异步消息处理，Android提供给我们一个类来处理相关的问题，那就是Handler。相信大家大多都用过Handler了，下面我们就来看看Handler最简单的用法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"FirstActivity"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Handler <span class="keyword">handler</span> = <span class="keyword">new</span> Handler() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">                    Log.i(TAG, <span class="string">"handler receive msg.what = "</span> + msg.what);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_first);</span><br><span class="line">        <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//这里做相关操作</span></span><br><span class="line">                <span class="keyword">handler</span>.sendEmptyMessage(<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码实现了在子线程中发出一个消息，然后在主线程中接收消息。Handler其他类似的用法在这就不过多叙述了。下面我们来看看Handler到底是怎么实现异步消息处理的吧！</p>
<p>先来看看我们new一个Handler的对象到底发生了什么（只截取了关键源码）：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Handler</span><span class="params">(Callback callback, <span class="keyword">boolean</span> async)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (FIND_POTENTIAL_LEAKS) &#123;</span><br><span class="line">            <span class="keyword">final</span> Class&lt;? <span class="keyword">extends</span> Handler&gt; klass = getClass();</span><br><span class="line">            <span class="keyword">if</span> ((klass.isAnonymousClass() || klass.isMemberClass() || klass.isLocalClass()) &amp;&amp;</span><br><span class="line">                    (klass.getModifiers() &amp; Modifier.STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.w(TAG, <span class="string">"The following Handler class should be static or leaks might occur: "</span> +</span><br><span class="line">                    klass.getCanonicalName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mLooper = Looper.myLooper();</span><br><span class="line">        <span class="keyword">if</span> (mLooper == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                <span class="string">"Can't create handler inside thread that has not called Looper.prepare()"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        mQueue = mLooper.mQueue;</span><br><span class="line">        mCallback = callback;</span><br><span class="line">        mAsynchronous = async;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以看到我们平常写的 new Handler()；其实是调用了另外一个构造方法，并且判断了mLooper是不是为空，为空则抛出一个异常<strong>“Can’t create handler inside thread that has not called Looper.prepare()”</strong>，mLooper其实是一个Looper类的成员变量，官方文档上对Looper类的解释是 <strong>Class used to run a message loop for a thread.</strong>也就是说Looper用于在一个线程中传递message的。  然后我们根据异常的提示知道要在new一个Handler的对象之前必须<br>先调用Looper.prepare()。那接下来就只能先去看看Looper.prepare()方法了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;Looper&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;Looper&gt;();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Looper sMainLooper;  <span class="comment">// guarded by Looper.class</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> MessageQueue mQueue;</span><br><span class="line">    <span class="keyword">final</span> Thread mThread;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Printer mLogging;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/** Initialize the current thread as a looper.</span><br><span class="line">      * This gives you a chance to create handlers that then reference</span><br><span class="line">      * this looper, before actually starting the loop. Be sure to call</span><br><span class="line">      * &#123;<span class="doctag">@link</span> #loop()&#125; after calling this method, and end it by calling</span><br><span class="line">      * &#123;<span class="doctag">@link</span> #quit()&#125;.</span><br><span class="line">      */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        prepare(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">prepare</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (sThreadLocal.get() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Only one Looper may be created per thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        sThreadLocal.set(<span class="keyword">new</span> Looper(quitAllowed));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">Looper</span><span class="params">(<span class="keyword">boolean</span> quitAllowed)</span> </span>&#123;</span><br><span class="line">        mQueue = <span class="keyword">new</span> MessageQueue(quitAllowed);</span><br><span class="line">        mThread = Thread.currentThread();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Run the message queue in this thread. Be sure to call</span><br><span class="line">     * &#123;<span class="doctag">@link</span> #quit()&#125; to end the loop.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="function"><span class="keyword">void</span> <span class="title">loop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Looper me = myLooper();</span><br><span class="line">        <span class="keyword">if</span> (me == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"No Looper; Looper.prepare() wasn't called on this thread."</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">final</span> MessageQueue queue = me.mQueue;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Make sure the identity of this thread is that of the local process,</span></span><br><span class="line">        <span class="comment">// and keep track of what that identity token actually is.</span></span><br><span class="line">        Binder.clearCallingIdentity();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> ident = Binder.clearCallingIdentity();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Message msg = queue.next(); <span class="comment">// might block</span></span><br><span class="line">            <span class="keyword">if</span> (msg == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// No message indicates that the message queue is quitting.</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// This must be in a local variable, in case a UI event sets the logger</span></span><br><span class="line">            Printer logging = me.mLogging;</span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&gt;&gt;&gt;&gt;&gt; Dispatching to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> +</span><br><span class="line">                        msg.callback + <span class="string">": "</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.<span class="keyword">target</span>.dispatchMessage(msg);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (logging != <span class="keyword">null</span>) &#123;</span><br><span class="line">                logging.println(<span class="string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> + msg.<span class="keyword">target</span> + <span class="string">" "</span> + msg.callback);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// Make sure that during the course of dispatching the</span></span><br><span class="line">            <span class="comment">// identity of the thread wasn't corrupted.</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> newIdent = Binder.clearCallingIdentity();</span><br><span class="line">            <span class="keyword">if</span> (ident != newIdent) &#123;</span><br><span class="line">                Log.wtf(TAG, <span class="string">"Thread identity changed from 0x"</span></span><br><span class="line">                        + Long.toHexString(ident) + <span class="string">" to 0x"</span></span><br><span class="line">                        + Long.toHexString(newIdent) + <span class="string">" while dispatching to "</span></span><br><span class="line">                        + msg.<span class="keyword">target</span>.getClass().getName() + <span class="string">" "</span></span><br><span class="line">                        + msg.callback + <span class="string">" what="</span> + msg.what);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            msg.recycleUnchecked();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Return the Looper object associated with the current thread.  Returns</span><br><span class="line">     * null if the calling thread is not associated with a Looper.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="annotation">@Nullable</span> <span class="function">Looper <span class="title">myLooper</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> sThreadLocal.<span class="title">get</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>prepare()方法就是将一个sThreadLocal和新建的Looper对象相绑定，同时mQueue成员变量也创建了新的MessageQueue对象，MessageQueue这个类就是用于存储Message的队列。在prepare()方法的注释上写着在调用prepare()方法之后还要调用loop()方法，我们再看loop方法，可以看到方法里写了一个for的死循环，主要用于在MessageQueue里不断地去取Message，如果msg为空，则阻塞；不然会调用msg.target.dispatchMessage(msg)这个方法。dispatchMessage()这个方法我会在后面讲解，先暂时放一边不管。</p>
<p>好了，捋一捋思路，当你在新建一个Handler对象时，要先确保调用了Looper.prepare()方法，然后调用Looper.loop()方法让MessageQueue这个队列“动”起来。这样你就成功地创建了一个Handler的对象。然后我们再使用Handler的sendMessage系列方法来发送一个消息。下面我们就来看看sendMessage系列方法里到底干了什么：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">boolean</span> <span class="title">sendMessageAtTime</span><span class="params">(Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        MessageQueue queue = mQueue;</span><br><span class="line">        <span class="keyword">if</span> (queue == <span class="keyword">null</span>) &#123;</span><br><span class="line">            RuntimeException e = <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                    <span class="keyword">this</span> + <span class="string">" sendMessageAtTime() called with no mQueue"</span>);</span><br><span class="line">            Log.w(<span class="string">"Looper"</span>, e.getMessage(), e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> <span class="title">enqueueMessage</span><span class="params">(queue, msg, uptimeMillis)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">boolean</span> <span class="title">enqueueMessage</span><span class="params">(MessageQueue queue, Message msg, <span class="keyword">long</span> uptimeMillis)</span> </span>&#123;</span><br><span class="line">        msg.<span class="keyword">target</span> = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAsynchronous) &#123;</span><br><span class="line">            msg.setAsynchronous(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">return</span> queue.<span class="title">enqueueMessage</span><span class="params">(msg, uptimeMillis)</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>为什么我就贴出一个方法呢？这是因为Handler一系列的sendMessage方法基本上最后都是调用了sendMessageAtTime这个方法。从源码中我们看到主要就是干了把Message加入队列这个事,并把当前的Handler对象赋给了msg的target。再联系上面的Looper.loop方法，我们大概就懂了。好了，我们回过头来看看上面的msg.target.dispatchMessage(msg)主要的功能。其实就是调用了Handler的dispatchMessage方法：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">void</span> <span class="title">dispatchMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (msg.callback != <span class="keyword">null</span>) &#123;</span><br><span class="line">           handleCallback(msg);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (mCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">if</span> (mCallback.handleMessage(msg)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           handleMessage(msg);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们看到了一行熟悉的代码：handleMessage(msg)，这不正是我们再创建Handler对象时重写的那个方法么！好了，这一切的逻辑我们似乎已经搞清了：首先调用Looper.prepare()创建一个Looper对象，然后handler发送消息后把消息加入到MessageQueue里，因为之前调用了Looper.loop(),所以MessageQueue在不断地做出队的操作，然后再根据message的target变量分发消息，回到handler的handleMessage()方法。</p>
<p>也许有人会有疑问了，为什么在主线程中创建Handler对象可以直接使用而不需要调用Looper.prepare()和Looper.loop()两个方法呢？这是因为在ActivityThread里面已经调用了，下面附上ActivityThread的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** </span><br><span class="line"> * This manages the execution of the main thread in an </span><br><span class="line"> * application process, scheduling and executing activities, </span><br><span class="line"> * broadcasts, and other operations on it as the activity </span><br><span class="line"> * manager requests. </span><br><span class="line"> * </span><br><span class="line"> * &#123;<span class="doctag">@hide</span>&#125; </span><br><span class="line"> */</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityThread</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> ContextImpl mSystemContext = <span class="keyword">null</span>;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> IPackageManager sPackageManager;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// 创建ApplicationThread实例，以接收AMS指令并执行  </span></span><br><span class="line">    <span class="keyword">final</span> ApplicationThread mAppThread = <span class="keyword">new</span> ApplicationThread();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> Looper mLooper = Looper.myLooper();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> H mH = <span class="keyword">new</span> H();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;IBinder, ActivityClientRecord&gt; mActivities  </span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;IBinder, ActivityClientRecord&gt;();  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// List of new activities (via ActivityRecord.nextIdle) that should  </span></span><br><span class="line">    <span class="comment">// be reported when next we idle.  </span></span><br><span class="line">    ActivityClientRecord mNewActivities = <span class="keyword">null</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="comment">// Number of activities that are currently visible on-screen.  </span></span><br><span class="line">    <span class="keyword">int</span> mNumVisibleActivities = <span class="number">0</span>;  </span><br><span class="line">      </span><br><span class="line">    <span class="keyword">final</span> HashMap&lt;IBinder, Service&gt; mServices  </span><br><span class="line">            = <span class="keyword">new</span> HashMap&lt;IBinder, Service&gt;();  </span><br><span class="line">      </span><br><span class="line">    Application mInitialApplication;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;Application&gt; mAllApplications  </span><br><span class="line">            = <span class="keyword">new</span> ArrayList&lt;Application&gt;();  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> ThreadLocal&lt;ActivityThread&gt; sThreadLocal = <span class="keyword">new</span> ThreadLocal&lt;ActivityThread&gt;();  </span><br><span class="line">    Instrumentation mInstrumentation;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> Handler sMainThreadHandler;  <span class="comment">// set once in main()  </span></span><br><span class="line">  </span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ActivityClientRecord</span> </span>&#123;  </span><br><span class="line">        IBinder token;  </span><br><span class="line">        <span class="keyword">int</span> ident;  </span><br><span class="line">        Intent intent;  </span><br><span class="line">        Bundle state;  </span><br><span class="line">        Activity activity;  </span><br><span class="line">        Window window;  </span><br><span class="line">        Activity parent;  </span><br><span class="line">        String embeddedID;  </span><br><span class="line">        Activity.NonConfigurationInstances lastNonConfigurationInstances;  </span><br><span class="line">        <span class="keyword">boolean</span> paused;  </span><br><span class="line">        <span class="keyword">boolean</span> stopped;  </span><br><span class="line">        <span class="keyword">boolean</span> hideForNow;  </span><br><span class="line">        Configuration newConfig;  </span><br><span class="line">        Configuration createdConfig;  </span><br><span class="line">        ActivityClientRecord nextIdle;  </span><br><span class="line">  </span><br><span class="line">        String profileFile;  </span><br><span class="line">        ParcelFileDescriptor profileFd;  </span><br><span class="line">        <span class="keyword">boolean</span> autoStopProfiler;  </span><br><span class="line">  </span><br><span class="line">        ActivityInfo activityInfo;  </span><br><span class="line">        CompatibilityInfo compatInfo;  </span><br><span class="line">        LoadedApk packageInfo; <span class="comment">//包信息，通过调用ActivityThread.getPapckageInfo而获得  </span></span><br><span class="line">  </span><br><span class="line">        List&lt;ResultInfo&gt; pendingResults;  </span><br><span class="line">        List&lt;Intent&gt; pendingIntents;  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">boolean</span> startsNotResumed;  </span><br><span class="line">        <span class="keyword">boolean</span> isForward;  </span><br><span class="line">        <span class="keyword">int</span> pendingConfigChanges;  </span><br><span class="line">        <span class="keyword">boolean</span> onlyLocalRequest;  </span><br><span class="line">  </span><br><span class="line">        View mPendingRemoveWindow;  </span><br><span class="line">        WindowManager mPendingRemoveWindowManager;  </span><br><span class="line">  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ApplicationThread</span> <span class="keyword">extends</span> <span class="title">ApplicationThreadNative</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">updatePendingConfiguration</span><span class="params">(Configuration config)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">synchronized</span> (mPackages) &#123;  </span><br><span class="line">                <span class="keyword">if</span> (mPendingConfiguration == <span class="keyword">null</span> ||  </span><br><span class="line">                        mPendingConfiguration.isOtherSeqNewer(config)) &#123;  </span><br><span class="line">                    mPendingConfiguration = config;  </span><br><span class="line">                &#125;  </span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">schedulePauseActivity</span><span class="params">(IBinder token, <span class="keyword">boolean</span> finished,  </span><br><span class="line">                <span class="keyword">boolean</span> userLeaving, <span class="keyword">int</span> configChanges)</span> </span>&#123;  </span><br><span class="line">            queueOrSendMessage(  </span><br><span class="line">                    finished ? H.PAUSE_ACTIVITY_FINISHING : H.PAUSE_ACTIVITY,  </span><br><span class="line">                    token,  </span><br><span class="line">                    (userLeaving ? <span class="number">1</span> : <span class="number">0</span>),  </span><br><span class="line">                    configChanges);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// we use token to identify this activity without having to send the  </span></span><br><span class="line">        <span class="comment">// activity itself back to the activity manager. (matters more with ipc)  </span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">scheduleLaunchActivity</span><span class="params">(Intent intent, IBinder token, <span class="keyword">int</span> ident,  </span><br><span class="line">                ActivityInfo info, Configuration curConfig, CompatibilityInfo compatInfo,  </span><br><span class="line">                Bundle state, List&lt;ResultInfo&gt; pendingResults,  </span><br><span class="line">                List&lt;Intent&gt; pendingNewIntents, <span class="keyword">boolean</span> notResumed, <span class="keyword">boolean</span> isForward,  </span><br><span class="line">                String profileName, ParcelFileDescriptor profileFd, <span class="keyword">boolean</span> autoStopProfiler)</span> </span>&#123;  </span><br><span class="line">            ActivityClientRecord r = <span class="keyword">new</span> ActivityClientRecord();  </span><br><span class="line">  </span><br><span class="line">            r.token = token;  </span><br><span class="line">            r.ident = ident;  </span><br><span class="line">            r.intent = intent;  </span><br><span class="line">            r.activityInfo = info;  </span><br><span class="line">            r.compatInfo = compatInfo;  </span><br><span class="line">            r.state = state;  </span><br><span class="line">  </span><br><span class="line">            r.pendingResults = pendingResults;  </span><br><span class="line">            r.pendingIntents = pendingNewIntents;  </span><br><span class="line">  </span><br><span class="line">            r.startsNotResumed = notResumed;  </span><br><span class="line">            r.isForward = isForward;  </span><br><span class="line">  </span><br><span class="line">            r.profileFile = profileName;  </span><br><span class="line">            r.profileFd = profileFd;  </span><br><span class="line">            r.autoStopProfiler = autoStopProfiler;  </span><br><span class="line">  </span><br><span class="line">            updatePendingConfiguration(curConfig);  </span><br><span class="line">  </span><br><span class="line">            queueOrSendMessage(H.LAUNCH_ACTIVITY, r);  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">H</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;  </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&gt;&gt;&gt; handling: "</span> + codeToString(msg.what));  </span><br><span class="line">            <span class="keyword">switch</span> (msg.what) &#123;  </span><br><span class="line">                <span class="keyword">case</span> LAUNCH_ACTIVITY: &#123;  </span><br><span class="line">                    Trace.traceBegin(Trace.TRACE_TAG_ACTIVITY_MANAGER, <span class="string">"activityStart"</span>);  </span><br><span class="line">                    ActivityClientRecord r = (ActivityClientRecord)msg.obj;  </span><br><span class="line">  </span><br><span class="line">                    r.packageInfo = getPackageInfoNoCheck(  </span><br><span class="line">                            r.activityInfo.applicationInfo, r.compatInfo);  </span><br><span class="line">                    handleLaunchActivity(r, <span class="keyword">null</span>);  </span><br><span class="line">                    Trace.traceEnd(Trace.TRACE_TAG_ACTIVITY_MANAGER);  </span><br><span class="line">                &#125; <span class="keyword">break</span>;  </span><br><span class="line">                ...  </span><br><span class="line">            &#125;  </span><br><span class="line">            <span class="keyword">if</span> (DEBUG_MESSAGES) Slog.v(TAG, <span class="string">"&lt;&lt;&lt; done: "</span> + codeToString(msg.what));  </span><br><span class="line">        &#125;  </span><br><span class="line">         </span><br><span class="line">        ...  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ActivityThread <span class="title">currentActivityThread</span><span class="params">()</span> </span>&#123;  </span><br><span class="line">        <span class="keyword">return</span> sThreadLocal.get();  </span><br><span class="line">    &#125;  </span><br><span class="line">  </span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;  </span><br><span class="line">        SamplingProfilerIntegration.start();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// CloseGuard defaults to true and can be quite spammy.  We  </span></span><br><span class="line">        <span class="comment">// disable it here, but selectively enable it later (via  </span></span><br><span class="line">        <span class="comment">// StrictMode) on debug builds, but using DropBox, not logs.  </span></span><br><span class="line">        CloseGuard.setEnabled(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        Environment.initForCurrentUser();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// Set the reporter for event logging in libcore  </span></span><br><span class="line">        EventLogger.setReporter(<span class="keyword">new</span> EventLoggingReporter());  </span><br><span class="line">  </span><br><span class="line">        Process.setArgV0(<span class="string">"&lt;pre-initialized&gt;"</span>);  </span><br><span class="line">  </span><br><span class="line">        Looper.prepareMainLooper();  </span><br><span class="line">  </span><br><span class="line">        <span class="comment">// 创建ActivityThread实例  </span></span><br><span class="line">        ActivityThread thread = <span class="keyword">new</span> ActivityThread();  </span><br><span class="line">        thread.attach(<span class="keyword">false</span>);  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (sMainThreadHandler == <span class="keyword">null</span>) &#123;  </span><br><span class="line">            sMainThreadHandler = thread.getHandler();  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        AsyncTask.init();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">false</span>) &#123;  </span><br><span class="line">            Looper.myLooper().setMessageLogging(<span class="keyword">new</span>  </span><br><span class="line">                    LogPrinter(Log.DEBUG, <span class="string">"ActivityThread"</span>));  </span><br><span class="line">        &#125;  </span><br><span class="line">  </span><br><span class="line">        Looper.loop();  </span><br><span class="line">  </span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Main thread loop unexpectedly exited"</span>);  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到上面的main方法里已经调用了prepare和loop的方法。好了，今天该讲的差不多了，就到这吧。</p>
<p>由于第一次写讲解源码的博客，不便之处请大家多多包涵。有问题的可以在下面评论。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在学习Android的路上，大家肯定会遇到异步消息处理，Android提供给我们一个类来处理相关的问题，那就是Handler。相信大家大多都用过Handler了，下面我们就来看看Handler最简单的用法：</p>
<figure class="highlight aspe]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.github.io/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Activity生命周期的小结]]></title>
    <link href="http://yuqirong.github.io/2015/08/26/%E5%85%B3%E4%BA%8EActivity%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yuqirong.github.io/2015/08/26/关于Activity生命周期的小结/</id>
    <published>2015-08-26T14:13:31.000Z</published>
    <updated>2016-01-26T17:08:09.985Z</updated>
    <content type="html"><![CDATA[<p>开头先说一下写这篇博客的初衷，由于博主在找实习的过程中面试经常被问到Activity生命周期有关的问题，所以特此写一篇博客来记一下。 </p>
<p>Activity作为四大组件之一，几乎是每个人开始学习Android最先接触到的。常见的生命周期方法大家肯定都是非常熟悉的，所以Activity生命周期的顺序在这就不必过多叙述了。今天讲一下由FirstActivity启动SecondActivity而调用生命周期方法的顺序问题。</p>
<p>首先我们创建一个如下图的FirstActivity:<br><img src="/uploads/20150826/20150826213244536.jpg" alt="这里写图片描述"><br>很简单，LinearLayout里只有一个Button，用于启动SecondActivity。</p>
<p>以下为FirstActivity的布局 activity_first.xml:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/second"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"start SecondActivity"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>FirstActivity的代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FirstActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"Activity"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_first);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onCreate"</span>);</span><br><span class="line"></span><br><span class="line">        Button button = (Button) findViewById(R.id.second);</span><br><span class="line">        button.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                startActivity(<span class="keyword">new</span> Intent(FirstActivity.<span class="keyword">this</span>,SecondActivity.class));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStart();</span><br><span class="line">        Log.i(TAG,<span class="string">"FirstActivity onStart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onResume();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onResume"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onPause();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onPause"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onStop();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onStop"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onDestroy"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestart();</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onRestart"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState, PersistableBundle outPersistentState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState, outPersistentState);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onSaveInstanceState"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onRestoreInstanceState"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onConfigurationChanged</span><span class="params">(Configuration newConfig)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onConfigurationChanged(newConfig);</span><br><span class="line">        Log.i(TAG, <span class="string">"FirstActivity onConfigurationChanged"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要是在生命周期方法中设置了Log打印。</p>
<p>SecondActivity的代码与FirstActivity并无差异，主要将Log中的FirstActivity替换成了SecondActivity。</p>
<p>接下来我们就启动FirstActivity，可以看到Logcat中打印了如下的日志：<br><img src="/uploads/20150826/20150826212633880.jpg" alt="这里写图片描述"><br>一切如我们想象的一样，然后我们点击按钮用于启动SecondActivity，可以看到打印出来的日志：<br><img src="/uploads/20150826/20150826214443682.jpg" alt="这里写图片描述"><br>可以看到FirstActivity和SecondActivity的生命周期方法是交叉着的，并不是先让FirstActivity执行完然后再执行SecondActivity的方法，这正是我们需要注意的。</p>
<p>然后我们点击Back键，返回FirstActivity:<br><img src="/uploads/20150826/20150826214330231.jpg" alt="这里写图片描述"><br>FirstActivity调用的是onRestart方法，因为先前FirstActivity已经创建，所以并不会重新调用onCreate方法。最后再次点击Back键，退出Activity：<br><img src="/uploads/20150826/20150826214929167.jpg" alt="这里写图片描述"><br>写到这里本篇博客的要讲内容已经差不多了，下面再补充一下关于切换横竖屏时Activity的生命周期调用，先前在网上看的一些博文叙述的都已经过时了，大都是在Android 2.2 或者 2.3 时写的，已经不适用于Android 4.0以上的版本了。所以在这里重新写一下：</p>
<p>测试机型：红米2<br>Android版本：5.1.0</p>
<ol>
<li>不设置android:configChanges时，无论是切横屏还是切竖屏都会重新调用各个生命周期，<strong>但都是调用一次</strong>（原先Android 2.X 的说法是切横屏时会执行一次,切竖屏时会执行两次，只适用于Android 2.X 版本）</li>
<li>设置android:configChages=”orientation”时，结果和不设置一样，仍然是重新调用生命周期方法，而且横竖屏都是一次（Android2.X版本：设置Activity的android:configChanges=”orientation”时,切屏还是会重新调用各个生命周期,切横、竖屏时只会执行一次）。</li>
<li>设置为android:configChanges=”orientation|keyboardHidden”时，Android 4.0以上和不设置一样，仍然是重新调用生命周期方法，而且横竖屏都是一次；<strong>Android2.X版本切屏不会重新调用各个生命周期,只会执行onConfigurationChanged方法</strong>.</li>
<li>Android4.0版本只有设置Activity的android:configChanges=”orientation|keyboardHidden|screenSize”时，才不重新创建Activity，但会调用onConfigurationChanged方法.</li>
</ol>
<p>好了，今天就到这里吧。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>开头先说一下写这篇博客的初衷，由于博主在找实习的过程中面试经常被问到Activity生命周期有关的问题，所以特此写一篇博客来记一下。 </p>
<p>Activity作为四大组件之一，几乎是每个人开始学习Android最先接触到的。常见的生命周期方法大家肯定都是非常熟悉的，]]>
    </summary>
    
      <category term="Activity" scheme="http://yuqirong.github.io/tags/Activity/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/tags/Android/"/>
    
      <category term="Android" scheme="http://yuqirong.github.io/categories/Android/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Hexo入门指南(一)]]></title>
    <link href="http://yuqirong.github.io/2015/07/12/Hexo%E5%85%A5%E9%97%A8%E6%8C%87%E5%8D%97(%E4%B8%80)/"/>
    <id>http://yuqirong.github.io/2015/07/12/Hexo入门指南(一)/</id>
    <published>2015-07-12T12:37:29.000Z</published>
    <updated>2016-02-01T16:42:33.638Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>对于一个程序员而言，我想GitHub和个人博客应该程序员的“标配”吧，在个人博客上可以记载一路上的酸甜苦辣，回过头来看看，何尝不是一种享受呢。想不想拥有一个属于自己的博客？接下来本篇博文就来教你如何搭建一款属于自己的博客。</p>
<p>在开讲之前，需要我们自己有一个GitHub的账号(相信大多数的程序员都有)，然后在GitHub上创建一个新的Repo,名字叫xxx.github.io(xxx为自己GitHub的用户名，如我的GitHub的用户名叫yuqirong,则要创建repo名就是<a href="https://github.com/yuqirong/yuqirong.github.io" target="_blank" rel="external">yuqirong.github.io</a>),搞定了这个我们就做好了第一步。</p>
<p>经过上面步骤，我们已经拥有了一个初步域名：<a href="http://xxx.github.io,而服务器就是用的是GitHub的。所以下面我们就要精心地装扮一下我们的博客了。这里介绍一下[Hexo](https://hexo.io/zh-cn/docs/index.html)，[Hexo](https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">http://xxx.github.io,而服务器就是用的是GitHub的。所以下面我们就要精心地装扮一下我们的博客了。这里介绍一下[Hexo](https://hexo.io/zh-cn/docs/index.html)，[Hexo](https://hexo.io/zh-cn/docs/index.html</a>) 是一个快速、简洁且高效的博客框架。<a href="https://hexo.io/zh-cn/docs/index.html" target="_blank" rel="external">Hexo</a> 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。也就是说你不需要去写一大堆的html，js，css等，Hexo会帮你实现所有。听完这句话是不是很激动呢，那下面就开始安装Hexo。</p>
<h1 id="u5B89_u88C5_u524D_u63D0"><a href="#u5B89_u88C5_u524D_u63D0" class="headerlink" title="安装前提"></a>安装前提</h1><p>安装 Hexo 相当简单。但是Hexo是基于Node.js的，所以在安装前，必须安装Node.js：</p>
<p><a href="http://nodejs.org/" target="_blank" rel="external">Node.js</a></p>
<p>装完了Node.js还有一个必须也要有，那就是Git(相信大多数程序员的电脑都都有安装)：</p>
<p><a href="http://git-scm.com/" target="_blank" rel="external">Git</a></p>
<p>装完了上面两个就可以安装Hexo了：</p>
<pre><code>$ npm install -g hexo-cli
</code></pre><p>恭喜你，Hexo成功地安装在你的电脑上了。</p>
<h1 id="u5EFA_u7ACB_u7F51_u7AD9"><a href="#u5EFA_u7ACB_u7F51_u7AD9" class="headerlink" title="建立网站"></a>建立网站</h1><p>先把之前创建的xxx.github.io的仓库clone到你的本地，然后执行：</p>
<pre><code>$ hexo init &lt;folder&gt;
$ cd &lt;folder&gt;
$ npm install
</code></pre><p>注意：上面的<folder>就是你clone下来的xxx.github.io</folder></p>
<p>执行后可以去xxx.github.io里看到有许多的文件夹生成：</p>
<pre><code>├──    .deploy_git
├── node_modules
├── _config.yml
├── package.json
├── scaffolds
├── source
└── themes
</code></pre><p>在这里介绍一下这些文件及文件夹的作用：</p>
<ul>
<li>.deploy_git：这个可以不管，主要是网站部署到GitHub上时生成的文件。</li>
<li>node_modules：主要是Hexo的文件。</li>
<li>_config.yml：整个网站的配置信息，之后会在这里配置大部分的参数。</li>
<li>package.json：应用程序的信息。没什么卵用。</li>
<li>scaffolds：模版文件夹。当您新建文章时，Hexo会根据scaffold来建立文件。(来自官方的解释)</li>
<li>source：是存放用户资源的文件夹，之后我们写的博客文章和一些图片等都存放在此文件夹下。</li>
<li>themes：下载下来的博客主题都存放在这里，初始时会有一个landscape主题。</li>
</ul>
<h1 id="u914D_u7F6E"><a href="#u914D_u7F6E" class="headerlink" title="配置"></a>配置</h1><p>打开xxx.github.io/_config.yml，你可以看到开头有title、subtitle、description和author等。那接下来就来配置网站吧！</p>
<pre><code># Site
title        网站标题
subtitle    网站副标题
description    网站描述
author        您的名字
language    网站使用的语言
timezone    网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：America/New_York, Japan, 和 UTC 。


# URL
## If your site is put in a subdirectory, set url as &apos;http://yoursite.com/child&apos; and root as &apos;/child/&apos;
url            网址     如http://xxx.github.io
root        网站根目录    
permalink    文章的永久链接格式：year/:month/:day/:title/
permalink_default    永久链接中各部分的默认值    
</code></pre><p>经过了上面的配置，你就有了一个自定义的网站了。有点小激动吧。离网站建成还差最后一步，那就 是部署了。</p>
<h1 id="u90E8_u7F72"><a href="#u90E8_u7F72" class="headerlink" title="部署"></a>部署</h1><p>我们发现在网站中竟然没有自己的博文，那马上来写一篇吧：</p>
<pre><code>$ hexo new page
</code></pre><p>在xxx.github.io/source/_posts/目录下可以看到有一个page.md文件，那就是我们刚刚新创建的page，而写博文需要用MarkDown语法来写。如果你还不了解MarkDown，那就<a href="https://github.com/younghz/Markdown" target="_blank" rel="external">点击这里</a>吧。</p>
<p>经过上面的步骤，相信我们已经有一篇原创的博文了，那就让Hexo生成静态文件：</p>
<pre><code>$ hexo generate
</code></pre><p>我们打开xxx.github.io/目录会发现已经有了一个public的文件夹，没错，整个网站的静态文件都在public文件夹里面。也就是说，把publish文件夹里面的东西push到xxx.github.io中，那整个网站就搭建完成了。那就赶快执行吧！</p>
<p>在执行部署命令之前，还有一项配置没做：<br>打开xxx.github.io/_config.yml，拉到底部，会看到#Deployment，那就是我们要配置的部署选项</p>
<pre><code># Deployment
## Docs: http://hexo.io/docs/deployment.html
deploy:
  type: git
  repo: https://github.com/xxx/xxx.github.io
  branch: master
  message: Site updated
</code></pre><p>上面repo中的xxx就是你的GitHub账号的用户名，branch设置成master。message就是你每次push到GitHub时的备注。</p>
<p>到了这里，就可以真正地部署了：</p>
<pre><code>$ hexo deploy
</code></pre><p>执行完后你再打开<a href="http://xxx.github.io，你会惊喜地发现一个完全属于你自己的个人网站诞生了！" target="_blank" rel="external">http://xxx.github.io，你会惊喜地发现一个完全属于你自己的个人网站诞生了！</a></p>
<p>Hexo的初步入门就差不多到这里了，后面还将会有关于Hexo的博文更新，敬请关注。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><ul>
<li><a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="external">Hexo官方文档</a></li>
<li><a href="http://gold.xitu.io/entry/56657fe160b202595a6f8ef6" target="_blank" rel="external">如何在一天之内搭建以你自己名字为域名的很 cool 的个人博客</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>对于一个程序员而言，我想GitHub和个人博客应该程序员的“标配”吧，在个人博客上可以记载一路上的酸甜苦]]>
    </summary>
    
      <category term="Hexo" scheme="http://yuqirong.github.io/tags/Hexo/"/>
    
      <category term="Hexo" scheme="http://yuqirong.github.io/categories/Hexo/"/>
    
  </entry>
  
</feed>
