<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-10-30T06:31:07.279Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Dynamic-Load-Apk源码解析]]></title>
    <link href="http://yuqirong.me/2016/10/29/Dynamic-Load-Apk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/10/29/Dynamic-Load-Apk源码解析/</id>
    <published>2016-10-29T13:57:12.000Z</published>
    <updated>2016-10-30T06:31:07.279Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架。<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 是任主席主导开发的一款插件化框架，其中心思想主要就是两个字——<strong>代理</strong>。和我之前分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 插件化框架不同的是，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架完全基于在应用层上实现，并不依靠 ActivityThread 、Instrumentation 等。另外，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架在插件化发展历程中诞生较早，对后来不断涌现的插件化框架具有深刻的指导意义。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>注：本文分析的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 为 master 分支，版本为1.0.0；</p>
<p>其实 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的思想很巧妙，大致的思路如下：在宿主中首先申明了一些 ProxyActivity 以及 ProxyService ，插件中的 PluginActivity 要继承指定的 DLBasePluginActivity 。然后启动插件中的 Activity 时，实际上启动的是 ProxyActivity , 之后利用接口回调调用了 PluginActivity 中的生命周期方法。也就是说，PluginActivity 并不是实质上的 Activity ，其实只是一个普通的 Java 类。</p>
<p>在分析源码之前，先在这里简单地说一下 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的结构：</p>
<p><img src="/uploads/20161029/20161029223619.png" alt="dynamic-load-apk的类结构"></p>
<p>从上面的图中大致可以看出来，整个框架中的 Java 类基本可以分为五种类型：</p>
<ul>
<li><strong>DLPluginManager</strong> ：顾名思义，是整个插件的管理类。主要作用就是加载以及管理插件，启动插件中的Activity、Service等；</li>
<li><strong>DLProxyActivity 、DLProxyFragmentActivity 、DLProxyService</strong> ：代理组件。可以看到有 Activity 、Service 等，在启动插件时实质上启动的是这些代理组件，之后在代理组件中利用接口回调插件的相关“生命周期”；</li>
<li><strong>DLProxyImpl 、DLServiceProxyImpl</strong> ：属于启动插件过程中一些公共逻辑代码。在代理组件连接插件组件时，把一些公共的方法抽取出来放入了这些类中；</li>
<li><strong>DLBasePluginActivity 、DLBasePluginFragmentActivity 、DLBasePluginService</strong> ：插件的基类。用户使用的插件需要继承自这些基类，之后接口才会回调插件的“生命周期”。</li>
<li><strong>DLPlugin 、DLServicePlugin</strong> ：插件“生命周期”定义的接口。在这两个类中定义了 Activity 、Service 相关的生命周期方法。</li>
</ul>
<p>那么接下来我们就一一来解析源码吧。</p>
<h2 id="DLPluginManager-loadApk"><a href="#DLPluginManager-loadApk" class="headerlink" title="DLPluginManager.loadApk"></a>DLPluginManager.loadApk</h2><p>DLPluginManager 是个单例类，我们先来看看它的初始化方法 <code>DLPluginManager.getInstance(Context context)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DLPluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context.getApplicationContext();</span><br><span class="line">    mNativeLibDir = mContext.getDir(<span class="string">"pluginlib"</span>, Context.MODE_PRIVATE).getAbsolutePath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DLPluginManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DLPluginManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> DLPluginManager(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在构造函数中设置了 .so 文件存储的目录。初始化完成后，通过 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 方法来加载插件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DLPluginPackage <span class="title">loadApk</span><span class="params">(<span class="keyword">final</span> String dexPath, <span class="keyword">boolean</span> hasSoLib)</span> </span>&#123;</span><br><span class="line">    mFrom = DLConstants.FROM_EXTERNAL;</span><br><span class="line"></span><br><span class="line">    PackageInfo packageInfo = mContext.getPackageManager().getPackageArchiveInfo(dexPath,</span><br><span class="line">            PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES);</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 得到插件信息封装类</span></span><br><span class="line">    DLPluginPackage pluginPackage = preparePluginEnv(packageInfo, dexPath);</span><br><span class="line">	<span class="comment">// 如果有 .so 文件，则复制到 mNativeLibDir 目录</span></span><br><span class="line">    <span class="keyword">if</span> (hasSoLib) &#123;</span><br><span class="line">        copySoLib(dexPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 主要做了两件事：</p>
<ol>
<li>在 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法中把插件 packageInfo 封装成 pluginPackage ；</li>
<li>复制 .so 文件到 mNativeLibDir 目录，主要流程就是在 SoLibManager 中利用 I/O 流复制文件。在这里就不讲了，代码比较简单，有兴趣的童鞋可以自己回去看源码；</li>
</ol>
<p>那么我们就跟着主流程来看看 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DLPluginPackage <span class="title">preparePluginEnv</span><span class="params">(PackageInfo packageInfo, String dexPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先查看缓存中有没有该 pluginPackage</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageInfo.packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pluginPackage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 ClassLoader</span></span><br><span class="line">    DexClassLoader dexClassLoader = createDexClassLoader(dexPath); </span><br><span class="line">    AssetManager assetManager = createAssetManager(dexPath);</span><br><span class="line">    <span class="comment">// 得到插件 res 资源</span></span><br><span class="line">    Resources resources = createResources(assetManager);</span><br><span class="line">    <span class="comment">// create pluginPackage</span></span><br><span class="line">    pluginPackage = <span class="keyword">new</span> DLPluginPackage(dexClassLoader, resources, packageInfo);</span><br><span class="line">    mPackagesHolder.put(packageInfo.packageName, pluginPackage);</span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码可知，在方法中创建了插件的 ClassLoader ，插件的 res 资源。如果你看过我另一篇插件化框架分析的文章<a href="/2016/10/02/插件化框架android-pluginmgr全解析">《插件化框架android-pluginmgr全解析》</a>，那么想必对这其中的原理已经熟知了：</p>
<ol>
<li>插件的类加载器是 DexClassLoader 或其子类，可以指定加载 dex 的目录。对应着上面的 <code>createDexClassLoader(dexPath)</code> 方法；</li>
<li>插件的 res 资源访问主要通过 AssetManager 的 <code>addAssetPath</code> 方法来获取。需要注意的是，<code>addAssetPath</code> 方法是 @hide 的，需要反射来执行。对应着 <code>createAssetManager(dexPath)</code> 方法；</li>
</ol>
<p>createXxxx 方法具体的代码就不在这里贴出来了，想了解的可以查看源码。通过这些 createXxxx 方法，就把插件的 ClassLoader 和 res 资源问题解决了。最后封装成一个 pluginPackage 对象，方便之后使用。</p>
<h2 id="DLPluginManager-startPluginActivityForResult"><a href="#DLPluginManager-startPluginActivityForResult" class="headerlink" title="DLPluginManager.startPluginActivityForResult"></a>DLPluginManager.startPluginActivityForResult</h2><p>加载完插件之后，我们就要着手于如何启动插件了。想要启动插件，就要调用 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法，而 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法内部又是调用 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法的，所以我们直接查看 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startPluginActivityForResult</span><span class="params">(Context context, DLIntent dlIntent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否宿主内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">        dlIntent.setClassName(context, dlIntent.getPluginClass());</span><br><span class="line">        performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">        <span class="keyword">return</span> DLPluginManager.START_RESULT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String packageName = dlIntent.getPluginPackage();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"disallow null packageName."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件信息</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_PKG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件 Activity 的全类名</span></span><br><span class="line">    <span class="keyword">final</span> String className = getPluginActivityFullPath(dlIntent, pluginPackage);</span><br><span class="line">    <span class="comment">// 得到对应的 class</span></span><br><span class="line">    Class&lt;?&gt; clazz = loadPluginClass(pluginPackage.classLoader, className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据插件 class 继承的是哪个基类，分别得到对应的代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginActivity ，得到的就是 DLProxyActivity 代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginFragmentActivity ，得到的就是 DLProxyFragmentActivity 代理类</span></span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = getProxyActivityClass(clazz);</span><br><span class="line">    <span class="keyword">if</span> (activityClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把插件信息传入 Intent 中</span></span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);</span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);</span><br><span class="line">    <span class="comment">// 这里启动的是上面得到的代理类 Activity</span></span><br><span class="line">    dlIntent.setClass(mContext, activityClass);</span><br><span class="line">    <span class="comment">// 启动 Activity</span></span><br><span class="line">    performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">    <span class="keyword">return</span> START_RESULT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法里基本上都有注释，要明白的是，intent 启动的是代理的 Activity ，并不是我们插件的 Activity 。另外，在 DLPluginManager 里还有启动插件 Service 的相关代码，不过具体的流程和启动插件 Activity 是相似的。如果有想要进一步了解的童鞋可以自行看源码。</p>
<h2 id="DLProxyActivity"><a href="#DLProxyActivity" class="headerlink" title="DLProxyActivity"></a>DLProxyActivity</h2><p>经过上一步之后，我们就启动了代理类 Activity 。代理类 Activity 有两种：DLProxyActivity 和 DLProxyFragmentActivity 。但是其中的逻辑都是一样的。在这里我们只分析 DLProxyActivity 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLProxyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> DLPlugin mRemoteActivity;</span><br><span class="line">    <span class="keyword">private</span> DLProxyImpl impl = <span class="keyword">new</span> DLProxyImpl(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        impl.onCreate(getIntent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类的结构上看到，DLProxyActivity 实现了 DLAttachable 接口。那么 DLAttachable 接口的作用是什么呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * when the proxy impl ( &#123;<span class="doctag">@see</span> DLProxyImpl#launchTargetActivity()&#125; ) launch</span><br><span class="line">     * the plugin activity , dl will call this method to attach the proxy activity</span><br><span class="line">     * and pluginManager to the plugin activity. the proxy activity will load</span><br><span class="line">     * the plugin's resource, so the proxy activity is a resource delegate for</span><br><span class="line">     * plugin activity.</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> proxyActivity a instance of DLPlugin, &#123;<span class="doctag">@see</span> DLBasePluginActivity&#125;</span><br><span class="line">     *            and &#123;<span class="doctag">@see</span> DLBasePluginFragmentActivity&#125;</span><br><span class="line">     * <span class="doctag">@param</span> pluginManager DLPluginManager instance, manager the plugins</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(DLPlugin proxyActivity, DLPluginManager pluginManager)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释的意思是，<code>attach(DLPlugin proxyActivity, DLPluginManager pluginManager)</code> 方法可以在 ProxyImpl 调用 <code>launchTargetActivity()</code> 时把 PluginActivity 和 ProxyActivity 绑定在一起。那样就达到了可以在 ProxyActivity 中使用 PluginActivity 的效果。那么到底在什么时候调用 <code>proxyImpl.launchTargetActivity()</code> 方法呢？我们回到上面的 DLProxyActivity 类中来，看到了 DLProxyActivity 中有一个 <code>impl</code> 成员变量。在 <code>onCreate(Bundle savedInstanceState)</code> 中调用了 <code>impl.onCreate(getIntent())</code> ，我们猜想在 <code>impl.onCreate(getIntent())</code> 的方法里一定会去调用 <code>launchTargetActivity()</code> 方法。下面我们就来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the extra's class loader</span></span><br><span class="line">    intent.setExtrasClassLoader(DLConfigs.sPluginClassloader);</span><br><span class="line">    <span class="comment">// 得到传过来的插件 Activity 包名和全类名</span></span><br><span class="line">    mPackageName = intent.getStringExtra(DLConstants.EXTRA_PACKAGE);</span><br><span class="line">    mClass = intent.getStringExtra(DLConstants.EXTRA_CLASS);</span><br><span class="line">    Log.d(TAG, <span class="string">"mClass="</span> + mClass + <span class="string">" mPackageName="</span> + mPackageName);</span><br><span class="line">    <span class="comment">// 得到插件相关的信息</span></span><br><span class="line">    mPluginManager = DLPluginManager.getInstance(mProxyActivity);</span><br><span class="line">    mPluginPackage = mPluginManager.getPackage(mPackageName);</span><br><span class="line">    mAssetManager = mPluginPackage.assetManager;</span><br><span class="line">    mResources = mPluginPackage.resources;</span><br><span class="line">    <span class="comment">// 得到要启动插件的 activityInfo，设置插件 Activity 的主题</span></span><br><span class="line">    initializeActivityInfo();</span><br><span class="line">    <span class="comment">// 把 DLProxyActivity 的主题设置为插件 Activity 的主题</span></span><br><span class="line">    handleActivityInfo();</span><br><span class="line">    launchTargetActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onCreate(Intent intent)</code> 中得到了之前插件 Activity 相关的信息。然后把 DLProxyActivity 的主题设置为 PluginActivity 的主题。最后调用了  <code>launchTargetActivity()</code> ，说明我们的猜想是正确的。来看看在 <code>launchTargetActivity</code> 方法中到底干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launchTargetActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 得到插件 Activity 的 class</span></span><br><span class="line">        Class&lt;?&gt; localClass = getClassLoader().loadClass(mClass);</span><br><span class="line">        Constructor&lt;?&gt; localConstructor = localClass.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">		<span class="comment">// 创建插件 Activity 的对象</span></span><br><span class="line">        Object instance = localConstructor.newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</span><br><span class="line">        mPluginActivity = (DLPlugin) instance;</span><br><span class="line">		<span class="comment">// 调用 attach 方法，把插件和代理绑定起来</span></span><br><span class="line">        ((DLAttachable) mProxyActivity).attach(mPluginActivity, mPluginManager);</span><br><span class="line">        Log.d(TAG, <span class="string">"instance = "</span> + instance);</span><br><span class="line">        <span class="comment">// attach the proxy activity and plugin package to the mPluginActivity</span></span><br><span class="line">		<span class="comment">// 手动调用插件的 attach 方法</span></span><br><span class="line">        mPluginActivity.attach(mProxyActivity, mPluginPackage);</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putInt(DLConstants.FROM, DLConstants.FROM_EXTERNAL);</span><br><span class="line">		<span class="comment">// 手动调用插件的 onCreate 方法</span></span><br><span class="line">        mPluginActivity.onCreate(bundle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在方法中使用反射创建了插件 Activity 的对象，又因为插件 Activity 必须继承指定的基类，这些基类是实现了 DLPlugin 接口的。所以插件 Activity 可以强转为 DLPlugin 。DLPlugin 接口定义了一系列的 Activity 生命周期方法，之后手动回调了 <code>attach</code> 和 <code>onCreate</code> 方法。</p>
<p>现在我们再回过头来看看 DLProxyActivity 里的其他生命周期方法，发现都有一句 <code>mRemoteActivity.onXxxxx()</code> 。其中的 mRemoteActivity 就是通过 DLAttachable 接口绑定的插件 Activity 对象。所以每当代理 ProxyActivity 回调生命周期方法时，都调用了 DLPlugin 接口一致的生命周期方法，这样就实现了插件 Activity 也有“生命周期”方法。</p>
<h2 id="DLBasePluginActivity"><a href="#DLBasePluginActivity" class="headerlink" title="DLBasePluginActivity"></a>DLBasePluginActivity</h2><p>讲解了 DLProxyActivity 之后，再来看看 DLBasePluginActivity 就发现轻松多了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLBasePluginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.setContentView(layoutResID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProxyActivity.setContentView(layoutResID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DLBasePluginActivity 实现了 DLPlugin 接口，就有了 <code>onCreate()</code> 、<code>onResume()</code> 这些“生命周期”方法。另外在重写的方法中会判断当前否被代理，以此来确定直接走父类逻辑还是代理 Activity 或是空逻辑。</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>讲到这里，整个启动插件 Activity 的流程就走完了。除此之外，还有启动插件 Service 其实也是相似的流程。现在的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架如果实际使用起来可能有比较多的问题，作者也基本上很早就停止更新了。但是这并不妨碍我们分析源码，学习其中的精髓。我想大部分人看完源码都会体会到 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 的核心思想——代理，这也正是和其他插件化框架不同的地方。在这里感谢那些为 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 作出贡献的人。</p>
<p>如果有问题可以留言，Goodbye !</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>Reference：</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">DynamicLoadApk 源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Gradle配置的小结]]></title>
    <link href="http://yuqirong.me/2016/10/23/%E5%85%B3%E4%BA%8EGradle%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yuqirong.me/2016/10/23/关于Gradle配置的小结/</id>
    <published>2016-10-23T07:34:50.000Z</published>
    <updated>2016-10-23T10:39:21.370Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免的，比如配置签名、引入依赖等。那么 Gradle 到底是什么东西呢？ Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言 (DSL) 来声明项目设置，抛弃了基于 XML 的各种繁琐配置 (此定义来自于百度百科-_- !) 。啰里啰唆一堆，幸运的是，一般来说 Android 开发者只要会配置 Gradle 就可以了，并不需要深入了解。那么下面我们就来揭开 Gradle 的面纱吧。</p>
<h1 id="Gradle__u914D_u7F6E"><a href="#Gradle__u914D_u7F6E" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h1><p>首先贴出一张自己项目的文件目录结构图：</p>
<p><img src="/uploads/20161023/20161023155409.png" alt="文件目录结构图"></p>
<p>从上图中我们可以看到，与 Gradle 有关的文件基本上分为四种：</p>
<ol>
<li>app 下的 build.gradle (当然其他 module 下也有)；</li>
<li>根目录下的 gradle 文件夹；</li>
<li>根目录下的 build.gradle ；</li>
<li>根目录下的 settings.gradle ；</li>
</ol>
<p>也许有人会说根目录下还有一个 config.gradle 文件呢，其实这是我自定义的 gradle 文件，自定义 Gradle 文件会在下面中讲解，这里先搁置一下。好了，那么我们一个一个地来看看他们的作用吧。</p>
<h2 id="app__u4E0B_u7684_build-gradle"><a href="#app__u4E0B_u7684_build-gradle" class="headerlink" title="app 下的 build.gradle"></a>app 下的 build.gradle</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span> <span class="comment">// 编译sdk版本</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.2"</span> <span class="comment">// 构建工具版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span> <span class="comment">// 开启混淆</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span> <span class="comment">// 对齐zip</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span> <span class="comment">// 删除无用资源</span></span><br><span class="line">            debuggable <span class="keyword">false</span> <span class="comment">// 是否debug</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span> <span class="comment">// 版本命名后缀</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span> <span class="comment">// 混淆文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一句 <code>apply plugin: &#39;com.android.application&#39;</code> 主要用来申明这是一个 Android 程序。而 dependencies 用于引入依赖，这个相信大家都比较了解了。其他的配置比较简单都有注释，就不展开讲了。</p>
<p>当然除了上面的配置之外，还有很多配置也常常写入到 app/build.gradle 中。我们慢慢往下看。</p>
<ul>
<li>签名配置：</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">	</span><br><span class="line">    release &#123; <span class="comment">// 正式版本的签名</span></span><br><span class="line">        storeFile file(<span class="string">"../koku.jks"</span>) <span class="comment">// 密钥文件位置</span></span><br><span class="line">        storePassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 密钥密码</span></span><br><span class="line">        keyAlias <span class="string">"koku"</span> <span class="comment">// 密钥别名</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 别名密码</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">debug</span> &#123; <span class="comment">// debug版本的签名</span></span><br><span class="line">        <span class="comment">// no keystore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时只要在 buildTypes 的 release 中加一句 <code>signingConfig signingConfigs.release</code> 就好了。</p>
<p>如果你觉得把密钥密码和别名密码放在 app/build.gradle 里不安全，那么可以把相关密码放到不加入版本控制系统的 gradle.properties 文件：</p>
<pre><code>KEYSTORE_PASSWORD=xxxxxxxxxx
KEY_PASSWORD=xxxxxxxxx
</code></pre><p>对应的 signingConfigs 配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword KEYSTORE_PASSWORD</span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserDataException(<span class="string">"You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java 编译版本配置：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123; <span class="comment">// java 版本</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意下，如果 Java 编译版本为1.8的话，另外在 defaultConfig 里要配置 Jack 编译器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jackOptions</span> &#123;</span><br><span class="line">    <span class="title">enabled</span> <span class="built_in">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lint 检查配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lintOptions</span> &#123;</span><br><span class="line">    <span class="title">abortOnError</span> <span class="built_in">false</span> // 是否忽略lint报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多渠道信息配置：</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">productFlavors</span> &#123;</span><br><span class="line">    <span class="tag">xiaomi</span> &#123;&#125;</span><br><span class="line">    <span class="tag">googleplay</span> &#123;&#125;</span><br><span class="line">    <span class="tag">wandoujia</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 app/build.gradle 文件配置如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        <span class="comment">// 默认是umeng的渠道</span></span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"umeng"</span>]</span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    java 版本</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// no keystore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 开启混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 对齐zip</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 删除无用资源</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 是否debug</span></span><br><span class="line">            debuggable <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 命名后缀</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span></span><br><span class="line">            <span class="comment">// 签名</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 输出apk名称为koku_v1.0_2015-01-15_wandoujia.apk</span></span><br><span class="line">                        <span class="keyword">def</span> fileName = <span class="string">"koku_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk"</span></span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        googleplay &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对很多渠道</span></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> releaseTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再多嘴一句，有了以上的 build.gradle 配置之后，如果想使用 Gradle 多渠道打包，需要在 AndroidManifest.xml 中申明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data <span class="string">android:</span>name=<span class="string">"UMENG_CHANNEL"</span> <span class="string">android:</span>value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>最后使用命令 <code>gradlew assembleRelease</code> 打包即可。</p>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939" class="headerlink" title="根目录下的 gradle 文件夹"></a>根目录下的 gradle 文件夹</h2><p>gradle 文件夹中主要是 gradle-wrapper.properties 文件比较重要，主要用来声明 Gradle 目录以及 Gradle 下载路径等：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">distributionBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">distributionPath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">zipStoreBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">zipStorePath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">distributionUrl=<span class="value">https\://services.gradle.org/distributions/gradle-<span class="number">2.14</span>.<span class="number">1</span>-all.zip</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_build-gradle"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_build-gradle" class="headerlink" title="根目录下的 build.gradle"></a>根目录下的 build.gradle</h2><p>根目录下的 build.gradle 主要作用就是定义项目中公共属性，比如有依赖仓库、 Gradle 构建版本等：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:2.2.1'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h2><p>setting.gradle 的作用就是一些模块被包含后，会在这里进行申明：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':app'</span></span><br></pre></td></tr></table></figure>
<h2 id="u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6"><a href="#u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6" class="headerlink" title="自定义 Gradle 文件"></a>自定义 Gradle 文件</h2><p>在上面我们留了一个悬念，就是如何添加我们自定义的 Gradle 文件。接下来我们就动手来实践一下。在项目根目录下创建文件 config.gradle 。然后在根目录下的 build.gradle 开头添加一句 <code>apply from: &quot;config.gradle&quot;</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">"config.gradle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这句话就代表着把 config.gradle 添加进来了。然后我们可以在 config.gradle 中申明一些配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line"></span><br><span class="line">    android = [</span><br><span class="line"><span class="label">            compileSdkVersion:</span> <span class="number">23</span>,</span><br><span class="line"><span class="label">            buildToolsVersion:</span> <span class="string">"23.0.3"</span>,</span><br><span class="line">            <span class="string">applicationId    :</span> <span class="string">"com.yuqirong.koku"</span>,</span><br><span class="line">            <span class="string">minSdkVersion    :</span> <span class="number">14</span>,</span><br><span class="line">            <span class="string">targetSdkVersion :</span> <span class="number">23</span>,</span><br><span class="line">            <span class="string">versionCode      :</span> <span class="number">3</span>,</span><br><span class="line">            <span class="string">versionName      :</span> <span class="string">"1.4"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"appcompat-v7"</span>            : <span class="string">'com.android.support:appcompat-v7:23.0.1'</span>,</span><br><span class="line">            <span class="string">"recyclerview-v7"</span>         : <span class="string">'com.android.support:recyclerview-v7:24.2.1'</span>,</span><br><span class="line">            <span class="string">"design"</span>                  : <span class="string">'com.android.support:design:23.0.1'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 app/build.gradle 中去使用：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId rootProject.ext.android.applicationId</span><br><span class="line">        minSdkVersion rootProject.ext.android.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.android.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.android.versionCode</span><br><span class="line">        versionName rootProject.ext.android.versionName</span><br><span class="line"></span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"appcompat-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"recyclerview-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"design"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，我们把一些固定的配置“拎”出来放到 config.gradle 中，这样以后直接更改 config.gradle 就行了，方便多人协作开发。</p>
<h1 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h1><p>关于 Gradle 的平时经常使用方法基本上就上面这些了。其他的一些比如 <code>buildConfigField</code> 之类的可以自行百度，相信聪明的你很快就会了。但是 Gradle 并没有以上讲得那么简单，还需要童鞋们继续努力学习了。</p>
<p>如果对本文有不明白的地方，欢迎留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://stormzhang.com/android/2016/07/02/gradle-for-android-beginners/" target="_blank" rel="external">给 ANDROID 初学者的 GRADLE 知识普及</a></li>
<li><a href="http://stormzhang.com/android/2016/07/15/android-gradle-config/" target="_blank" rel="external">ANDROID 开发你需要了解的 GRADLE 配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yuqirong.me/tags/Gradle/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[插件化框架android-pluginmgr全解析]]></title>
    <link href="http://yuqirong.me/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/10/02/插件化框架android-pluginmgr全解析/</id>
    <published>2016-10-02T02:03:34.000Z</published>
    <updated>2016-10-05T10:49:56.283Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD"><a href="#0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD" class="headerlink" title="0x00 前言：插件化的介绍"></a>0x00 前言：插件化的介绍</h1><p>阅读须知：阅读本文的童鞋最好是有过插件化框架使用经历或者对插件化框架有过了解的。前方高能，大牛绕道。</p>
<p>最近一直在关注 Android 插件化方面，所以今天的主题就确定是 Android 中比较热门的“插件化”了。所谓的插件化就是下载 apk 到指定目录，不需要安装该 apk ，就能利用某个已安装的 apk （即“宿主”）调用起该未安装 apk 中的 Activity 、Service 等组件（即“插件”）。</p>
<p>Android 插件化的发展到目前为止也有一段时间了，从一开始任主席的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 到今天要分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 再到360的 <a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">DroidPlugin</a> ，也代表着插件化的思想从顶部的应用层向下到 Framework 层渗入。最早插件化的思想是 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 实现的， <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 在“宿主” ProxyActivity 的生命周期中利用接口回调了“插件” PluginActivity 的“生命周期”，以此来间接实现 PluginActivity 的“生命周期”。也就是说，其实插件中的 “PluginActivity” 并不具有真正 Activity 的性质，实质就是一个普通类，只是利用接口回调了类中的生命周期方法而已。比接口回调更好的方案就是利用 ActivityThread 、Instrumentation 等去动态地 Hook 即将创建的 ProxyActivity ，也就是说表面上创建的是 ProxyActivity ，其实实际上是创建了 PluginActivity 。这种思想相比于 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">dynamic-load-apk</a> 而言，插件中 Activity 已经是实质上的 Activity ，具备了生命周期方法。今天我们要解析的 android-pluginmgr 插件化框架就是基于这种思想的。最后就是像 <a href="https://github.com/DroidPluginTeam/DroidPlugin" target="_blank" rel="external">DroidPlugin</a> 这种插件化框架，改动了 ActivityManagerService 、 PackageManagerService 等 Android 源码，以此来实现插件化。总之，并没有哪种插件化框架是最好的，一切都是要根据自身实际情况而决定的。</p>
<p>熟悉插件化的童鞋都知道，插件化要解决的有三个基本难题：</p>
<ol>
<li>插件中 ClassLoader 的问题；</li>
<li>插件中的资源文件访问问题；</li>
<li>插件中 Activity 组件的生命周期问题。</li>
</ol>
<p>基本上，解决了上面三个问题，就可以算是一个合格的插件化框架了。但是要注意的是，插件化远远不止这三个问题，比如还有插件中 .so 文件加载，支持 Service 插件化等问题。</p>
<p>好了，讲了这么多废话，接下来我们就来分析 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的源码吧。</p>
<h1 id="0x01_PluginManager-init"><a href="#0x01_PluginManager-init" class="headerlink" title="0x01 PluginManager.init"></a>0x01 PluginManager.init</h1><p>注：本文分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 为 master 分支，版本为0.2.2；</p>
<h2 id="android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5"><a href="#android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5" class="headerlink" title="android-pluginmgr的简单用法"></a>android-pluginmgr的简单用法</h2><p>我们先简单地来看一下 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 框架的用法（来自于 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的 <a href="https://github.com/houkx/android-pluginmgr/blob/master/README.md" target="_blank" rel="external">README.md</a> ）：</p>
<ol>
<li><p>declare permission in your <code>AndroidManifest.xml</code>: </p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.MOUNT_UNMOUNT_FILESYSTEMS&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.WRITE_EXTERNAL_STORAGE&quot; /&gt;
</code></pre></li>
<li><p>regist an activity:</p>
<pre><code>&lt;activity android:name=&quot;androidx.pluginmgr.DynamicActivity&quot; /&gt;
</code></pre></li>
<li><p>init PluginMgr in your application:</p>
<pre><code>@Override
public void onCreate(){
   PluginManager.init(this);
   //...
}
</code></pre></li>
<li><p>load plugin from plug apk:</p>
<pre><code>PluginManager pluginMgr = PluginManager.getSingleton();
File myPlug = new File(&quot;/mnt/sdcard/Download/myplug.apk&quot;);
PlugInfo plug = pluginMgr.loadPlugin(myPlug).iterator().next();
</code></pre></li>
<li><p>start activity:</p>
<pre><code>mgr.startMainActivity(context, plug);
</code></pre></li>
</ol>
<p>基本的用法就像以上这五步，另外需要注意的是，“插件”中所需要的权限都要在“宿主”的 AndroidManifest.xml 中进行申明。</p>
<h2 id="PluginManager-init_28this_29_u6E90_u7801"><a href="#PluginManager-init_28this_29_u6E90_u7801" class="headerlink" title="PluginManager.init(this)源码"></a>PluginManager.init(this)源码</h2><p>下面我们来分析下 <code>PluginManager.init(this);</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 初始化插件管理器,请不要传入易变的Context,那将造成内存泄露!</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context Application上下文</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (SINGLETON != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Trace.store(<span class="string">"PluginManager have been initialized, YOU needn't initialize it again!"</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Trace.store(<span class="string">"init PluginManager..."</span>);</span><br><span class="line">    SINGLETON = <span class="keyword">new</span> PluginManager(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在 <code>init(Context context)</code> 中主要创建了一个 <code>SINGLETON</code> 单例，所以我们就要追踪 <code>PluginManager</code> 构造器的源码了：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 插件管理器私有构造器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> context Application上下文</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isMainThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException(<span class="string">"PluginManager must init in UI Thread!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.context = context;</span><br><span class="line">    File optimizedDexPath = context.getDir(Globals.PRIVATE_PLUGIN_OUTPUT_DIR_NAME, Context.MODE_PRIVATE);</span><br><span class="line">    dexOutputPath = optimizedDexPath.getAbsolutePath();</span><br><span class="line">    dexInternalStoragePath = context.getDir(</span><br><span class="line">            Globals.PRIVATE_PLUGIN_ODEX_OUTPUT_DIR_NAME, Context.MODE_PRIVATE</span><br><span class="line">    );</span><br><span class="line">    DelegateActivityThread delegateActivityThread = DelegateActivityThread.getSingleton();</span><br><span class="line">    Instrumentation originInstrumentation = delegateActivityThread.getInstrumentation();</span><br><span class="line">    <span class="keyword">if</span> (!(originInstrumentation <span class="keyword">instanceof</span> PluginInstrumentation)) &#123;</span><br><span class="line">        PluginInstrumentation pluginInstrumentation = <span class="keyword">new</span> PluginInstrumentation(originInstrumentation);</span><br><span class="line">        delegateActivityThread.setInstrumentation(pluginInstrumentation);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中做的事情有点多，我们一步步来看下。一开始得到插件 dex opt 输出路径 <code>dexOutputPath</code> 和私有目录中存储插件的路径 <code>dexInternalStoragePath</code> 。这些路径都是在 <code>Global</code> 类中事先定义好的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 私有目录中保存插件文件的文件夹名</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_PLUGIN_OUTPUT_DIR_NAME = <span class="string">"plugins-file"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 私有目录中保存插件odex的文件夹名</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String PRIVATE_PLUGIN_ODEX_OUTPUT_DIR_NAME = <span class="string">"plugins-opt"</span>;</span><br></pre></td></tr></table></figure>
<p>但是根据常量定义的名称来看，总感觉作者在 <code>context.getDir()</code> 时把这两个路径搞反了 \(╯-╰)/。</p>
<p>之后在构造器中创建了 <code>DelegateActivityThread</code> 类的单例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateActivityThread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DelegateActivityThread SINGLETON = <span class="keyword">new</span> DelegateActivityThread();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Reflect activityThreadReflect;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegateActivityThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        activityThreadReflect = Reflect.on(ActivityThread.currentActivityThread());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DelegateActivityThread <span class="title">getSingleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SINGLETON;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Application <span class="title">getInitialApplication</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityThreadReflect.get(<span class="string">"mInitialApplication"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Instrumentation <span class="title">getInstrumentation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> activityThreadReflect.get(<span class="string">"mInstrumentation"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setInstrumentation</span><span class="params">(Instrumentation newInstrumentation)</span> </span>&#123;</span><br><span class="line">        activityThreadReflect.set(<span class="string">"mInstrumentation"</span>, newInstrumentation);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DelegateActivityThread 类的主要作用就是使用反射包装了当前的 ActivityThread ，并且一开始在 DelegateActivityThread 中使用 PluginInstrumentation 替换原始的 Instrumentation 。其实 Activity 的生命周期调用都是通过 Instrumentation 来完成的。我们来看看 PluginInstrumentation 的构造器相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginInstrumentation</span> <span class="keyword">extends</span> <span class="title">DelegateInstrumentation</span></span><br><span class="line"></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 当前正在运行的插件</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> PlugInfo currentPlugin;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> mBase 真正的Instrumentation</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PluginInstrumentation</span><span class="params">(Instrumentation mBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(mBase);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到 PluginInstrumentation 是继承自 DelegateInstrumentation 类的，而 DelegateInstrumentation 本质上就是 Instrumentation 。 DelegateInstrumentation 类中的方法都是直接调用 Instrumentation 类的:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DelegateInstrumentation</span> <span class="keyword">extends</span> <span class="title">Instrumentation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Instrumentation mBase;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * <span class="doctag">@param</span> mBase 真正的Instrumentation</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">DelegateInstrumentation</span><span class="params">(Instrumentation mBase)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mBase = mBase;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle arguments)</span> </span>&#123;</span><br><span class="line">        mBase.onCreate(arguments);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBase.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mBase.onStart();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，在 <code>PluginManager.init()</code> 方法中大概做的就是这些逻辑了。</p>
<h1 id="0x02_PluginManager-loadPlugin"><a href="#0x02_PluginManager-loadPlugin" class="headerlink" title="0x02 PluginManager.loadPlugin"></a>0x02 PluginManager.loadPlugin</h1><p>看完了上面的 <code>PluginManager.init()</code> 之后，下一步就是调用 <code>pluginManager.loadPlugin</code> 去加载插件。一起来看看相关源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 加载指定插件或指定目录下的所有插件</span><br><span class="line"> * &lt;p&gt;</span><br><span class="line"> * 都使用文件名作为Id</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> pluginSrcDirFile - apk或apk目录</span><br><span class="line"> * <span class="doctag">@return</span> 插件集合</span><br><span class="line"> * <span class="doctag">@throws</span> Exception</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;PlugInfo&gt; <span class="title">loadPlugin</span><span class="params">(<span class="keyword">final</span> File pluginSrcDirFile)</span></span><br><span class="line">        <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pluginSrcDirFile == <span class="keyword">null</span> || !pluginSrcDirFile.exists()) &#123;</span><br><span class="line">        Trace.store(<span class="string">"invalidate plugin file or Directory :"</span></span><br><span class="line">                + pluginSrcDirFile);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pluginSrcDirFile.isFile()) &#123;</span><br><span class="line">        PlugInfo one = buildPlugInfo(pluginSrcDirFile, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (one != <span class="keyword">null</span>) &#123;</span><br><span class="line">            savePluginToMap(one);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Collections.singletonList(one);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        synchronized (this) &#123;</span></span><br><span class="line"><span class="comment">//            pluginPkgToInfoMap.clear();</span></span><br><span class="line"><span class="comment">//        &#125;</span></span><br><span class="line">    File[] pluginApkFiles = pluginSrcDirFile.listFiles(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (pluginApkFiles == <span class="keyword">null</span> || pluginApkFiles.length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> FileNotFoundException(<span class="string">"could not find plugins in:"</span></span><br><span class="line">                + pluginSrcDirFile);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (File pluginApk : pluginApkFiles) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            PlugInfo plugInfo = buildPlugInfo(pluginApk, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (plugInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                savePluginToMap(plugInfo);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pluginPkgToInfoMap.values();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loadPlugin</code> 代码的注释中，我们可以知道加载的插件可以是一个也可以是一个文件夹下的多个。因为会根据传入的 <code>pluginSrcDirFile</code> 参数去判断是文件还是文件夹，其实道理都是一样的，无非就是多了一个 for 循环而已。在这里要注意一下，PluginManager 是实现了 FileFilter 接口的，因此在加载多个插件时，调用 <code>listFiles(this)</code> 会过滤当前文件夹下非 apk 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">accept</span><span class="params">(File pathname)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> !pathname.isDirectory() &amp;&amp; pathname.getName().endsWith(<span class="string">".apk"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，我们在 <code>loadPlugin()</code> 的代码中会注意到，无论是加载单个插件还是多个插件都会调用 <code>buildPlugInfo()</code> 方法。顾名思义，就是根据传入的插件文件去加载：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> PlugInfo <span class="title">buildPlugInfo</span><span class="params">(File pluginApk, String pluginId,</span><br><span class="line">                               String targetFileName)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    PlugInfo info = <span class="keyword">new</span> PlugInfo();</span><br><span class="line">    info.setId(pluginId == <span class="keyword">null</span> ? pluginApk.getName() : pluginId);</span><br><span class="line"></span><br><span class="line">    File privateFile = <span class="keyword">new</span> File(dexInternalStoragePath,</span><br><span class="line">            targetFileName == <span class="keyword">null</span> ? pluginApk.getName() : targetFileName);</span><br><span class="line"></span><br><span class="line">    info.setFilePath(privateFile.getAbsolutePath());</span><br><span class="line">    <span class="comment">//Copy Plugin to Private Dir</span></span><br><span class="line">    <span class="keyword">if</span> (!pluginApk.getAbsolutePath().equals(privateFile.getAbsolutePath())) &#123;</span><br><span class="line">        copyApkToPrivatePath(pluginApk, privateFile);</span><br><span class="line">    &#125;</span><br><span class="line">    String dexPath = privateFile.getAbsolutePath();</span><br><span class="line">    <span class="comment">//Load Plugin Manifest</span></span><br><span class="line">    PluginManifestUtil.setManifestInfo(context, dexPath, info);</span><br><span class="line">    <span class="comment">//Load Plugin Res</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        AssetManager am = AssetManager.class.newInstance();</span><br><span class="line">        am.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class)</span><br><span class="line">                .invoke(am, dexPath);</span><br><span class="line">        info.setAssetManager(am);</span><br><span class="line">        Resources hotRes = context.getResources();</span><br><span class="line">        Resources res = <span class="keyword">new</span> Resources(am, hotRes.getDisplayMetrics(),</span><br><span class="line">                hotRes.getConfiguration());</span><br><span class="line">        info.setResources(res);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Resources&amp;Assets for "</span></span><br><span class="line">                + info.getPackageName() + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Load  classLoader for Plugin</span></span><br><span class="line">    PluginClassLoader pluginClassLoader = <span class="keyword">new</span> PluginClassLoader(info, dexPath, dexOutputPath</span><br><span class="line">            , getPluginLibPath(info).getAbsolutePath(), pluginParentClassLoader);</span><br><span class="line">    info.setClassLoader(pluginClassLoader);</span><br><span class="line">    ApplicationInfo appInfo = info.getPackageInfo().applicationInfo;</span><br><span class="line">    Application app = makeApplication(info, appInfo);</span><br><span class="line">    attachBaseContext(info, app);</span><br><span class="line">    info.setApplication(app);</span><br><span class="line">    Trace.store(<span class="string">"Build pluginInfo =&gt; "</span> + info);</span><br><span class="line">    <span class="keyword">return</span> info;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中看到， <code>buildPlugInfo()</code> 方法中做的大致有四步：</p>
<ol>
<li>复制插件 apk 到指定目录；</li>
<li>加载插件 apk 的 AndroidManifest.xml 文件；</li>
<li>加载插件 apk 中的资源文件；</li>
<li>为插件 apk 设置 ClassLoader。</li>
</ol>
<h2 id="u590D_u5236_u63D2_u4EF6_apk__u5230_u6307_u5B9A_u76EE_u5F55"><a href="#u590D_u5236_u63D2_u4EF6_apk__u5230_u6307_u5B9A_u76EE_u5F55" class="headerlink" title="复制插件 apk 到指定目录"></a>复制插件 apk 到指定目录</h2><p>下面我们慢慢来分析，第一步，会把传入的插件 apk 复制到 <code>dexInternalStoragePath</code> 路径下，也就是之前在 PluginManager 的构造器中所指定的目录。这部分的代码很简单，就省略了。</p>
<h2 id="u52A0_u8F7D_u63D2_u4EF6_apk__u7684_AndroidManifest-xml__u6587_u4EF6"><a href="#u52A0_u8F7D_u63D2_u4EF6_apk__u7684_AndroidManifest-xml__u6587_u4EF6" class="headerlink" title="加载插件 apk 的 AndroidManifest.xml 文件"></a>加载插件 apk 的 AndroidManifest.xml 文件</h2><p>第二步，根据代码可知，会使用 <code>PluginManifestUtil.setManifestInfo()</code> 去加载 AndroidManifest 里的信息，那就去看下相关的代码实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setManifestInfo</span><span class="params">(Context context, String apkPath, PlugInfo info)</span></span><br><span class="line">		<span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到AndroidManifest文件</span></span><br><span class="line">	ZipFile zipFile = <span class="keyword">new</span> ZipFile(<span class="keyword">new</span> File(apkPath), ZipFile.OPEN_READ);</span><br><span class="line">	ZipEntry manifestXmlEntry = zipFile.getEntry(XmlManifestReader.DEFAULT_XML);</span><br><span class="line">	<span class="comment">// 解析AndroidManifest文件</span></span><br><span class="line">	String manifestXML = XmlManifestReader.getManifestXMLFromAPK(zipFile,</span><br><span class="line">			manifestXmlEntry);</span><br><span class="line">	<span class="comment">// 创建相应的packageInfo</span></span><br><span class="line">	PackageInfo pkgInfo = context.getPackageManager()</span><br><span class="line">			.getPackageArchiveInfo(</span><br><span class="line">					apkPath,</span><br><span class="line">					PackageManager.GET_ACTIVITIES</span><br><span class="line">							| PackageManager.GET_RECEIVERS<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_PROVIDERS<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_META_DATA<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_SHARED_LIBRARY_FILES<span class="comment">//</span></span><br><span class="line">							| PackageManager.GET_SERVICES<span class="comment">//</span></span><br><span class="line">			<span class="comment">// | PackageManager.GET_SIGNATURES//</span></span><br><span class="line">			);</span><br><span class="line">    <span class="keyword">if</span> (pkgInfo == <span class="keyword">null</span> || pkgInfo.activities == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> XmlPullParserException(<span class="string">"No any activity in "</span> + apkPath);</span><br><span class="line">    &#125;</span><br><span class="line">    pkgInfo.applicationInfo.publicSourceDir = apkPath;</span><br><span class="line">    pkgInfo.applicationInfo.sourceDir = apkPath;</span><br><span class="line">	<span class="comment">// 得到libDir，加载.so文件</span></span><br><span class="line">	File libDir = PluginManager.getSingleton().getPluginLibPath(info);</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (extractLibFile(zipFile, libDir)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.GINGERBREAD) &#123;</span><br><span class="line">				pkgInfo.applicationInfo.nativeLibraryDir = libDir.getAbsolutePath();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		zipFile.close();</span><br><span class="line">	&#125;</span><br><span class="line">    info.setPackageInfo(pkgInfo);</span><br><span class="line">    setAttrs(info, manifestXML);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中，一开始会通过 apk 得到 AndroidManifest.xml 文件。然后使用 <code>XmlManifestReader</code> 去读取 AndroidManifest 中的信息。在 <code>XmlManifestReader</code> 中会使用 <code>XmlPullParser</code> 去解析 xml ， <code>XmlManifestReader</code> 相关的源码就不贴出来了，想要进一步了解的童鞋可以自己去看，<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/utils/XmlManifestReader.java" target="_blank" rel="external">点击这里查看 XmlManifestReader 源码</a>。接下来根据 <code>apkPath</code> 得到相应的 <code>pkgInfo</code> ，并且若有 libDir 会去加载相应的 .so 文件。最后会调用 <code>setAttrs(info, manifestXML)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setAttrs</span><span class="params">(PlugInfo info, String manifestXML)</span></span><br><span class="line">		<span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	XmlPullParserFactory factory = XmlPullParserFactory.newInstance();</span><br><span class="line">	factory.setNamespaceAware(<span class="keyword">true</span>);</span><br><span class="line">	XmlPullParser parser = factory.newPullParser();</span><br><span class="line">	parser.setInput(<span class="keyword">new</span> StringReader(manifestXML));</span><br><span class="line">	<span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">	String namespaceAndroid = <span class="keyword">null</span>;</span><br><span class="line">	do &#123;</span><br><span class="line">		<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_DOCUMENT: &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">			String tag = parser.getName();</span><br><span class="line">			<span class="keyword">if</span> (tag.equals(<span class="string">"manifest"</span>)) &#123;</span><br><span class="line">				namespaceAndroid = parser.getNamespace(<span class="string">"android"</span>);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"activity"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addActivity(info, namespaceAndroid, parser);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"receiver"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addReceiver(info, namespaceAndroid, parser);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"service"</span>.equals(parser.getName())) &#123;</span><br><span class="line">				addService(info, namespaceAndroid, parser);</span><br><span class="line">			&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"application"</span>.equals(parser.getName()))&#123;</span><br><span class="line">				parseApplicationInfo(info, namespaceAndroid, parser);</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.END_TAG: &#123;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		eventType = parser.next();</span><br><span class="line">	&#125; <span class="keyword">while</span> (eventType != XmlPullParser.END_DOCUMENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setAttrs(PlugInfo info, String manifestXML)</code> 方法中，使用了 pull 方式去解析 manifest ，并且根据 activity 、 recevicer 、 service 等调用不同的 <code>addXxxx()</code> 方法。这些方法其实本质上是一样的，我们就挑 <code>addActivity()</code> 方法来看一下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addActivity</span><span class="params">(PlugInfo info, String namespace,</span><br><span class="line">		XmlPullParser parser)</span> <span class="keyword">throws</span> XmlPullParserException, IOException </span>&#123;</span><br><span class="line">	<span class="keyword">int</span> eventType = parser.getEventType();</span><br><span class="line">	String activityName = parser.getAttributeValue(namespace, <span class="string">"name"</span>);</span><br><span class="line">	String packageName = info.getPackageInfo().packageName;</span><br><span class="line">	activityName = getName(activityName, packageName);</span><br><span class="line">	ResolveInfo act = <span class="keyword">new</span> ResolveInfo();</span><br><span class="line">	act.activityInfo = info.findActivityByClassNameFromPkg(activityName);</span><br><span class="line">	do &#123;</span><br><span class="line">		<span class="keyword">switch</span> (eventType) &#123;</span><br><span class="line">		<span class="keyword">case</span> XmlPullParser.START_TAG: &#123;</span><br><span class="line">			String tag = parser.getName();</span><br><span class="line">			<span class="keyword">if</span> (<span class="string">"intent-filter"</span>.equals(tag)) &#123;</span><br><span class="line">				<span class="keyword">if</span> (act.filter == <span class="keyword">null</span>) &#123;</span><br><span class="line">					act.filter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"action"</span>.equals(tag)) &#123;</span><br><span class="line">				String actionName = parser.getAttributeValue(namespace,</span><br><span class="line">						<span class="string">"name"</span>);</span><br><span class="line">				act.filter.addAction(actionName);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"category"</span>.equals(tag)) &#123;</span><br><span class="line">				String category = parser.getAttributeValue(namespace,</span><br><span class="line">						<span class="string">"name"</span>);</span><br><span class="line">				act.filter.addCategory(category);</span><br><span class="line">			&#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="string">"data"</span>.equals(tag)) &#123;</span><br><span class="line">				<span class="comment">// TODO parse data</span></span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		eventType = parser.next();</span><br><span class="line">	&#125; <span class="keyword">while</span> (!<span class="string">"activity"</span>.equals(parser.getName()));</span><br><span class="line">	<span class="comment">//</span></span><br><span class="line">	info.addActivity(act);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <code>addActivity()</code> 代码中的逻辑比较简单，就是创建一个 <code>ResolveInfo</code> 类的对象 <code>act</code> ，把 Activity 相关的信息全部装进去，比如有 ActivityInfo 、 intent-filter 等。最后把 <code>act</code> 添加到 <code>info</code> 中。其他的 <code>addReceiver</code> 和 <code>addService</code> 也是同一个逻辑。而 <code>parseApplicationInfo</code> 也是把 Application 的相关信息封装到 <code>info</code> 中。感兴趣的同学可以看一下相关的源码，<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/utils/PluginManifestUtil.java" target="_blank" rel="external">点击这里查看</a>。到这里，就把加载插件中 AndroidManifest.xml 的代码分析完了。</p>
<h2 id="u52A0_u8F7D_u63D2_u4EF6_apk__u4E2D_u7684_u8D44_u6E90_u6587_u4EF6"><a href="#u52A0_u8F7D_u63D2_u4EF6_apk__u4E2D_u7684_u8D44_u6E90_u6587_u4EF6" class="headerlink" title="加载插件 apk 中的资源文件"></a>加载插件 apk 中的资源文件</h2><p>再回到 <code>buildPlugInfo()</code> 的代码中去，接下来就是第三步，加载插件中的资源文件了。</p>
<p>为了方便，我们把相关的代码复制到这里来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    AssetManager am = AssetManager.class.newInstance();</span><br><span class="line">    am.getClass().getMethod(<span class="string">"addAssetPath"</span>, String.class)</span><br><span class="line">            .invoke(am, dexPath);</span><br><span class="line">    info.setAssetManager(am);</span><br><span class="line">    Resources hotRes = context.getResources();</span><br><span class="line">    Resources res = <span class="keyword">new</span> Resources(am, hotRes.getDisplayMetrics(),</span><br><span class="line">            hotRes.getConfiguration());</span><br><span class="line">    info.setResources(res);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Resources&amp;Assets for "</span></span><br><span class="line">            + info.getPackageName() + <span class="string">" : "</span> + e.getMessage());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先通过反射得到 <code>AssetManager</code> 的对象 <code>am</code>，然后通过反射其 <code>addAssetPath</code> 方法传入 <code>dexPath</code> 参数来加载插件的资源文件，接下来就得到相应插件的 <code>Resource</code> 对象 <code>res</code> 了。这样就实现了访问插件中的资源文件了。那么到底  <code>addAssetPath</code> 这个方法有什么魔力呢？我们查看一下 Android 相关的源代码（<a href="https://android.googlesource.com/platform/frameworks/base/+/56a2301/core/java/android/content/res/AssetManager.java" target="_blank" rel="external">android/content/res/AssetManager.java</a>）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Add an additional set of assets to the asset manager.  This can be</span><br><span class="line"> * either a directory or ZIP file.  Not for use by applications.  Returns</span><br><span class="line"> * the cookie of the added asset, or 0 on failure.</span><br><span class="line"> * &#123;<span class="doctag">@hide</span>&#125;</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">addAssetPath</span><span class="params">(String path)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> res = addAssetPathNative(path);</span><br><span class="line">        makeStringBlocks(mStringBlocks);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>查看方法的注释我们知道，这个 <code>addAssetPath()</code> 方法就是用来添加额外的资源文件到 AssetManager 中去的，但是已经被 hide 了。所以我们只能通过反射的方式来执行了。这样就解决了加载插件中的资源文件的问题了。</p>
<p>其实，大多数插件化框架都是通过反射 <code>addAssetPath()</code> 的方式来解决加载插件资源问题，基本上已经成为了标准方案了。</p>
<h2 id="u4E3A_u63D2_u4EF6_apk__u8BBE_u7F6E_ClassLoader"><a href="#u4E3A_u63D2_u4EF6_apk__u8BBE_u7F6E_ClassLoader" class="headerlink" title="为插件 apk 设置 ClassLoader"></a>为插件 apk 设置 ClassLoader</h2><p>终于到了最后一个步骤了，如何为插件设置 ClassLoader 呢？其实解决的方案就是通过 <code>DexClassLoader</code> 。我们先来看 <code>buildPlugInfo()</code> 中的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">PluginClassLoader pluginClassLoader = <span class="keyword">new</span> PluginClassLoader(info, dexPath, dexOutputPath</span><br><span class="line">        , getPluginLibPath(info).getAbsolutePath(), pluginParentClassLoader);</span><br><span class="line">info.setClassLoader(pluginClassLoader);</span><br><span class="line">ApplicationInfo appInfo = info.getPackageInfo().applicationInfo;</span><br><span class="line">Application app = makeApplication(info, appInfo);</span><br><span class="line">attachBaseContext(info, app);</span><br><span class="line">info.setApplication(app);</span><br><span class="line">Trace.store(<span class="string">"Build pluginInfo =&gt; "</span> + info);</span><br></pre></td></tr></table></figure>
<p>在代码中创建了 <code>pluginClassLoader</code> 对象，而 <code>PluginClassLoader</code> 正是继承自 <code>DexClassLoader</code> 的，将 <code>dexPath</code> 、 <code>dexOutputPath</code> 等参数传入后，就可以去加载插件中的类了。 基本上所有的插件化框架都是通过 <code>DexClassLoder</code> 来作为插件 apk 的 ClassLoader 的。</p>
<p>之后在 <code>makeApplication(info, appInfo)</code> 就使用 <code>PluginClassLoader</code> 利用反射去创建插件的 Application 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 构造插件的Application</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> plugInfo 插件信息</span><br><span class="line"> * <span class="doctag">@param</span> appInfo 插件ApplicationInfo</span><br><span class="line"> * <span class="doctag">@return</span> 插件App</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Application <span class="title">makeApplication</span><span class="params">(PlugInfo plugInfo, ApplicationInfo appInfo)</span> </span>&#123;</span><br><span class="line">    String appClassName = appInfo.className;</span><br><span class="line">    <span class="keyword">if</span> (appClassName == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//Default Application</span></span><br><span class="line">        appClassName = Application.class.getName();</span><br><span class="line">    &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> (Application) plugInfo.getClassLoader().loadClass(appClassName).newInstance();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create Application for "</span></span><br><span class="line">                    + plugInfo.getPackageName() + <span class="string">": "</span></span><br><span class="line">                    + e.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>创建完插件的 Application 之后， 再调用 <code>attachBaseContext(info, app)</code> 方法把 Application 的 mBase 属性替换成 <code>PluginContext</code> 对象，<code>PluginContext</code> 类继承自 <a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/delegate/LayoutInflaterProxyContext.java" target="_blank" rel="external">LayoutInflaterProxyContext</a> ，里面封装了一些插件的信息，比如有插件资源、插件 ClassLoader 等。值得一提的是，在插件中 PluginContext 可以得到“宿主”的 Context ，也就是所谓的“破壳”。具体可查看<a href="https://github.com/houkx/android-pluginmgr/blob/master/android-pluginmgr/src/main/java/androidx/pluginmgr/environment/PluginContext.java" target="_blank" rel="external"> PluginContext 的源码</a>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(PlugInfo info, Application app)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field mBase = ContextWrapper.class.getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">        mBase.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        mBase.set(app, <span class="keyword">new</span> PluginContext(context.getApplicationContext(), info));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>讲到这里基本上把 <code>buildPlugInfo()</code> 中的逻辑讲完了， <code>pluginManager.loadPlugin</code> 剩下的代码都比较简单，相信大家一看就懂了。 </p>
<h1 id="0x03_PluginManager-startActivity"><a href="#0x03_PluginManager-startActivity" class="headerlink" title="0x03 PluginManager.startActivity"></a>0x03 PluginManager.startActivity</h1><h2 id="startActivity"><a href="#startActivity" class="headerlink" title="startActivity"></a>startActivity</h2><p>在加载好插件 apk 之后，就可以使用插件了。和平常无异，我们使用 <code>PluginManager.startActivity</code> 来启动插件中的 Activity 。其实 <code>PluginManager</code> 有很多 startActivity 的方法：</p>
<p><img src="/uploads/20161002/201610041161253.jpg" alt="startActivity截图"></p>
<p>但是终于都会调用 <code>startActivity(Context from, PlugInfo plugInfo, ActivityInfo activityInfo, Intent intent)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> DynamicActivitySelector activitySelector = DefaultActivitySelector.getDefault();</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 启动插件的指定Activity</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> from         fromContext</span><br><span class="line"> * <span class="doctag">@param</span> plugInfo     插件信息</span><br><span class="line"> * <span class="doctag">@param</span> activityInfo 要启动的插件activity信息</span><br><span class="line"> * <span class="doctag">@param</span> intent       通过此Intent可以向插件传参, 可以为null</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startActivity</span><span class="params">(Context from, PlugInfo plugInfo, ActivityInfo activityInfo, Intent intent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (activityInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ActivityNotFoundException(<span class="string">"Cannot find ActivityInfo from plugin, could you declare this Activity in plugin?"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (intent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        intent = <span class="keyword">new</span> Intent();</span><br><span class="line">    &#125;</span><br><span class="line">    CreateActivityData createActivityData = <span class="keyword">new</span> CreateActivityData(activityInfo.name, plugInfo.getPackageName());</span><br><span class="line">    intent.setClass(from, activitySelector.selectDynamicActivity(activityInfo));</span><br><span class="line">    intent.putExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN, createActivityData);</span><br><span class="line">    from.startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先来看代码， <code>CreateActivityData</code> 类是用来存储一个将要创建的插件 Activity 的数据，实现了 <code>Serializable</code> 接口，因此可以被序列化。总之， <code>CreateActivityData</code> 会存储将要创建的插件 Activity 的类名和包名，再把它放入 <code>intent</code> 中。之后， <code>intent</code> 设置要创建的 Activity 为 <code>activitySelector.selectDynamicActivity(activityInfo)</code> ，<code>activitySelector</code> 是 <code>DefaultActivitySelector</code> 类的对象，那么这 <code>DefaultActivitySelector</code> 到底是什么东西呢？一起来看看 <code>DefaultActivitySelector</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultActivitySelector</span> <span class="keyword">implements</span> <span class="title">DynamicActivitySelector</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> DynamicActivitySelector DEFAULT = <span class="keyword">new</span> DefaultActivitySelector();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;? extends Activity&gt; selectDynamicActivity(ActivityInfo pluginActivityInfo) &#123;</span><br><span class="line">        <span class="keyword">return</span> DynamicActivity.class;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DynamicActivitySelector <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> DEFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实很简单，不管传入的 <code>pluginActivityInfo</code> 参数是什么，返回的都是 <code>DynamicActivity.class</code> 。也就是我们在介绍<a href="/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/#android-pluginmgr_u7684_u7B80_u5355_u7528_u6CD5"> android-pluginmgr 简单用法</a>时，第二步在 AndroidManifest 中注册的那个 <code>DynamicActivity</code> 。<br>看到这里的代码，我们一定可以猜到什么。因为这里的 <code>intent</code> 中设置即将启动的 Activity 仍然为 <code>DynamicActivity</code> ，所以在后面的代码中肯定会去动态地替换掉 <code>DynamicActivity</code>。</p>
<h2 id="u52A8_u6001Hook"><a href="#u52A8_u6001Hook" class="headerlink" title="动态Hook"></a>动态Hook</h2><p>之前在 <a href="/2016/10/02/%E6%8F%92%E4%BB%B6%E5%8C%96%E6%A1%86%E6%9E%B6android-pluginmgr%E5%85%A8%E8%A7%A3%E6%9E%90/#PluginManager-init_28this_29_u6E90_u7801">PluginManager.init(this) 源码</a>这一小节中介绍了，当前 <code>ActivityThread</code> 的 <code>Instrumentation</code> 已经被替换成了 <code>PluginInstrumentation</code>。所以在创建 Activity 的时候会去调用 <code>PluginInstrumentation</code> 里面的方法。这样就可以在里面“做手脚”，实现了动态去替换 Activity 的思路。我们先来看一下 <code>PluginInstrumentation</code> 中部分方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">replaceIntentTargetIfNeed</span><span class="params">(Context from, Intent intent)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!intent.hasExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN) &amp;&amp; currentPlugin != <span class="keyword">null</span>)</span><br><span class="line">	&#123;</span><br><span class="line">        ComponentName componentName = intent.getComponent();</span><br><span class="line">        <span class="keyword">if</span> (componentName != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            String pkgName = componentName.getPackageName();</span><br><span class="line">            String activityName = componentName.getClassName();</span><br><span class="line">            <span class="keyword">if</span> (pkgName != <span class="keyword">null</span>)</span><br><span class="line">			&#123;</span><br><span class="line">                CreateActivityData createActivityData = <span class="keyword">new</span> CreateActivityData(activityName, currentPlugin.getPackageName());</span><br><span class="line">                ActivityInfo activityInfo = currentPlugin.findActivityByClassName(activityName);</span><br><span class="line">                <span class="keyword">if</span> (activityInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    intent.setClass(from, PluginManager.getSingleton().getActivitySelector().selectDynamicActivity(activityInfo));</span><br><span class="line">                    intent.putExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN, createActivityData);</span><br><span class="line">                    intent.setExtrasClassLoader(currentPlugin.getClassLoader());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Fragment fragment, Intent intent, <span class="keyword">int</span> requestCode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, fragment, intent, requestCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Fragment fragment, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, fragment, intent, requestCode, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, target, intent, requestCode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ActivityResult <span class="title">execStartActivity</span><span class="params">(Context who, IBinder contextThread, IBinder token, Activity target, Intent intent, <span class="keyword">int</span> requestCode, Bundle options)</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    replaceIntentTargetIfNeed(who, intent);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.execStartActivity(who, contextThread, token, target, intent, requestCode, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现，在所有的 <code>execStartActivity()</code> 方法执行前，都加上了 <code>replaceIntentTargetIfNeed(Context from, Intent intent)</code> 这个方法，在方法里面 <code>intent.setClass</code> 中设置的还是 <code>DynamicActivity.class</code> ，把插件信息都检查了一遍。</p>
<p>在这之后，会去执行 <code>PluginInstrumentation.newActivity</code> 方法来创建即将要启动的Activity 。也正是在这里，对之前的 <code>DynamicActivity</code> 进行 Hook ，达到启动插件 Activity 的目的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Activity <span class="title">newActivity</span><span class="params">(ClassLoader cl, String className, Intent intent)</span> <span class="keyword">throws</span> InstantiationException, IllegalAccessException, ClassNotFoundException</span><br><span class="line"></span>&#123;</span><br><span class="line">    CreateActivityData activityData = (CreateActivityData) intent.getSerializableExtra(Globals.FLAG_ACTIVITY_FROM_PLUGIN);</span><br><span class="line">    <span class="comment">//如果activityData存在,那么说明将要创建的是插件Activity</span></span><br><span class="line">    <span class="keyword">if</span> (activityData != <span class="keyword">null</span> &amp;&amp; PluginManager.getSingleton().getPlugins().size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//这里找不到插件信息就会抛异常的,不用担心空指针</span></span><br><span class="line">        PlugInfo plugInfo;</span><br><span class="line">        <span class="keyword">try</span></span><br><span class="line">		&#123;</span><br><span class="line">            Log.d(getClass().getSimpleName(), <span class="string">"+++ Start Plugin Activity =&gt; "</span> + activityData.pluginPkg + <span class="string">" / "</span> + activityData.activityName);</span><br><span class="line">            <span class="comment">// 得到插件信息类</span></span><br><span class="line">            plugInfo = PluginManager.getSingleton().tryGetPluginInfo(activityData.pluginPkg);</span><br><span class="line">            <span class="comment">// 在该方法中会调用插件的Application.onCreate()</span></span><br><span class="line">            plugInfo.ensureApplicationCreated();</span><br><span class="line">        &#125;</span><br><span class="line">		<span class="keyword">catch</span> (PluginNotFoundException e)</span><br><span class="line">		&#123;</span><br><span class="line">            PluginManager.getSingleton().dump();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalAccessException(<span class="string">"Cannot get plugin Info : "</span> + activityData.pluginPkg);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (activityData.activityName != <span class="keyword">null</span>)</span><br><span class="line">		&#123;</span><br><span class="line">            <span class="comment">// 在这里替换了className，变成了插件Activity的className</span></span><br><span class="line">            className = activityData.activityName;</span><br><span class="line">            <span class="comment">// 替换classloader</span></span><br><span class="line">            cl = plugInfo.getClassLoader();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.newActivity(cl, className, intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>newActivity()</code> 方法中，先拿到了插件信息 <code>plugInfo</code> ，然后会确保插件的 <code>Application</code> 已经创建。然后在第25行会去替换掉 <code>className</code> 和 <code>cl</code> 。这样，原本要创建的是 <code>DynamicActivity</code> 就变成了插件的 <code>Activity</code> 了，从而实现了创建插件 Activity 的目的，并且这个 Activity 是真实的 Activity 组件，具备生命周期的。</p>
<p>也许有童鞋会有疑问，如果直接在 <code>startActivity</code> 中设置要启动的 Activity 为插件 Activity ，这样不行吗？答案是肯定的，因为这样就会抛出一个异常：<code>ActivityNotFoundException:...have you declared this activity in your AndroidManifest.xml?</code>我相信这个异常大家很熟悉的吧，在刚开始学习 Android 时，大家都会犯的一个错误。所以，我想我们也明白了为什么要花这么大的一个功夫去动态地替换要创建的 Activity ，就是为了绕过这个 <code>ActivityNotFoundException</code> 异常，达到去“欺骗” Android 系统的效果。</p>
<p>既然创建好了，那么就来看看 <code>PluginInstrumentation</code> 里调用相关生命周期的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">callActivityOnCreate</span><span class="params">(Activity activity, Bundle icicle)</span> </span>&#123;</span><br><span class="line">    lookupActivityInPlugin(activity);</span><br><span class="line">    <span class="keyword">if</span> (currentPlugin != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//初始化插件Activity</span></span><br><span class="line">        Context baseContext = activity.getBaseContext();</span><br><span class="line">        PluginContext pluginContext = <span class="keyword">new</span> PluginContext(baseContext, currentPlugin);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//在许多设备上，Activity自身hold资源</span></span><br><span class="line">                Reflect.on(activity).set(<span class="string">"mResources"</span>, pluginContext.getResources());</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ignored) &#123;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Field field = ContextWrapper.class.getDeclaredField(<span class="string">"mBase"</span>);</span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            field.set(activity, pluginContext);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Reflect.on(activity).set(<span class="string">"mApplication"</span>, currentPlugin.getApplication());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ReflectException e) &#123;</span><br><span class="line">                Trace.store(<span class="string">"Application not inject success into : "</span> + activity);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ActivityInfo activityInfo = currentPlugin.findActivityByClassName(activity.getClass().getName());</span><br><span class="line">        <span class="keyword">if</span> (activityInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//根据AndroidManifest.xml中的参数设置Theme</span></span><br><span class="line">            <span class="keyword">int</span> resTheme = activityInfo.getThemeResource();</span><br><span class="line">            <span class="keyword">if</span> (resTheme != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> hasNotSetTheme = <span class="keyword">true</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Field mTheme = ContextThemeWrapper.class</span><br><span class="line">                            .getDeclaredField(<span class="string">"mTheme"</span>);</span><br><span class="line">                    mTheme.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">                    hasNotSetTheme = mTheme.get(activity) == <span class="keyword">null</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (hasNotSetTheme) &#123;</span><br><span class="line">                    changeActivityInfo(activityInfo, activity);</span><br><span class="line">                    activity.setTheme(resTheme);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是三星手机，则使用包装的LayoutInflater替换原LayoutInflater</span></span><br><span class="line">        <span class="comment">// 这款手机在解析内置的布局文件时有各种错误</span></span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.MODEL.startsWith(<span class="string">"GT"</span>)) &#123;</span><br><span class="line">            Window window = activity.getWindow();</span><br><span class="line">            Reflect windowRef = Reflect.on(window);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                LayoutInflater originInflater = window.getLayoutInflater();</span><br><span class="line">                <span class="keyword">if</span> (!(originInflater <span class="keyword">instanceof</span> LayoutInflaterWrapper)) &#123;</span><br><span class="line">                    windowRef.set(<span class="string">"mLayoutInflater"</span>, <span class="keyword">new</span> LayoutInflaterWrapper(originInflater));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.callActivityOnCreate(activity, icicle);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 检查跳转目标是不是来自插件</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> activity Activity</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">lookupActivityInPlugin</span><span class="params">(Activity activity)</span> </span>&#123;</span><br><span class="line">    ClassLoader classLoader = activity.getClass().getClassLoader();</span><br><span class="line">    <span class="keyword">if</span> (classLoader <span class="keyword">instanceof</span> PluginClassLoader) &#123;</span><br><span class="line">        currentPlugin = ((PluginClassLoader) classLoader).getPlugInfo();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        currentPlugin = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>callActivityOnCreate()</code> 中先去检查了创建的 Activity 是否来自于插件。如果是，那么会给 Activity 设置 Context 、 设置主题等；如果不是，则直接执行父类方法。在 <code>super.callActivityOnCreate(activity, icicle)</code> 中会去调用 <code>Activity.onCreate()</code>方法。其他的生命周期方法作者没有特殊处理，这里就不讲了。</p>
<p>分析到这，我们终于把 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 插件化实现的方案完整地梳理了一遍。当然，不同的插件化框架会有不同的实现方案，具体的仍然需要自己专心研究。另外我们发现该框架还没有实现启动插件 Service 的功能，如果想要了解，可以参考下其他插件化框架。</p>
<h1 id="0x04__u603B_u7ED3"><a href="#0x04__u603B_u7ED3" class="headerlink" title="0x04 总结"></a>0x04 总结</h1><p>上面乱七八糟的流程讲了一遍，可能还有一些童鞋不太懂，所以在这里给出一张 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 的流程图。不懂的童鞋可以根据这张图再好好看一下源码，相信你会恍然大悟的。</p>
<p><img src="/uploads/20161002/20161005183404.png" alt="android-pluginmgr流程图"></p>
<p>最后，如果对本文哪里有疑问的童鞋，欢迎留言，一起交流。</p>
<h1 id="0x05_References"><a href="#0x05_References" class="headerlink" title="0x05 References"></a>0x05 References</h1><ul>
<li><a href="https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650993300&amp;idx=1&amp;sn=797fa87ef528cff3a50e77806cf9f675&amp;scene=1&amp;srcid=07125lNtkiWhjbu4dp8GhoAf#rd" target="_blank" rel="external">包建强：为什么我说Android插件化从入门到放弃？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD"><a href="#0x00__u524D_u8A00_uFF1A_u63D2_u4EF6_u5316_u7684_u4ECB_u7ECD" ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[用Java实现Android多渠道打包工具]]></title>
    <link href="http://yuqirong.me/2016/09/25/%E7%94%A8Java%E5%AE%9E%E7%8E%B0Android%E5%A4%9A%E6%B8%A0%E9%81%93%E6%89%93%E5%8C%85%E5%B7%A5%E5%85%B7/"/>
    <id>http://yuqirong.me/2016/09/25/用Java实现Android多渠道打包工具/</id>
    <published>2016-09-25T11:52:14.000Z</published>
    <updated>2016-10-01T01:15:16.980Z</updated>
    <content type="html"><![CDATA[<h1 id="0001b"><a href="#0001b" class="headerlink" title="0001b"></a>0001b</h1><p>最近在公司做了一个多渠道打包的工具，趁今天有空就来讲讲 Android 多渠道打包这件小事。众所周知，随着业务的不断增长，APP 的渠道也会越来越多，如果用 Gradle 打多渠道包的话，可能会耗费几个小时的时间才能打出几百个渠道包。所以就必须有一种方法能够解决这种问题。</p>
<p>目前市面上比较好的解决方案就是在 apk 文件中“动手脚”，比如由一位360 Android 工程师提出的“在 apk 文件中添加 comments 多渠道打包方法”，具体的代码在GitHub 上可以找到：<a href="https://github.com/seven456/MultiChannelPackageTool" target="_blank" rel="external">MultiChannelPackageTool</a> 。除此之外，还有美团点评技术团队在博客上发表过一篇<a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">《美团Android自动化之旅—生成渠道包》</a>，里面讲叙了一种在 apk 文件中的 META-INF 目录下添加渠道信息的方法，之后再在程序启动时去动态读取，具体的实现原理可以去美团博客上看，这里就不说了。</p>
<p>我们解压多渠道打出来的 apk 包后，就会发现在 META-INF 目录下多了一个 channel_xxxxx 文件，而这个就是我们的渠道文件：</p>
<p><img src="/uploads/20160925/20160925221513.png" alt="channel文件"></p>
<p>本文所采用的方法就是根据美团提供的思路实现的，当然网上有很多使用 Python 语言实现美团思路的版本，经过测试发现 Python 版本比 Java 版本打渠道包的速度更快一些。但是，在这里只提供 Java 版本实现方案，Python 版本实现的方案会在文末以参考链接的方式给出。</p>
<h1 id="0010b"><a href="#0010b" class="headerlink" title="0010b"></a>0010b</h1><p>在这里先说明一下，Java 编写的多渠道打包工具依赖 commons-io.jar 和 zip4j.jar 。下面我们就开始进入正题吧。</p>
<p>我们先规定一下，渠道文件命名为 channel.txt ，并且要打包的 apk 文件和 channel.txt 与多渠道打包工具在同一目录下。</p>
<p>其中 channel.txt 的格式就是每个渠道独占一行，如下所示：</p>
<pre><code>wandoujia
googleplay
xiaomi
huawei
kumarket
anzhi
</code></pre><p>然后我们先定义几个常量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 渠道文件地址</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHANNEL_FILE_PATH = <span class="string">"./channel.txt"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET_NAME = <span class="string">"UTF-8"</span>;</span><br><span class="line"><span class="comment">// 当前要打包的apk的路径</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_PATH = <span class="string">"./"</span>;</span><br><span class="line"><span class="comment">// 渠道打包后输出的apk文件夹前缀</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_OUT_PATH_PREFIX = <span class="string">"./out_apk_"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String APK_SUFFIX = <span class="string">".apk"</span>;</span><br></pre></td></tr></table></figure>
<p>定义好之后，我们下一步就是编写方法去读取 channel.txt 中的渠道信息：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 从文件中读取channel</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getChannel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; channelList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	InputStream inputStream = <span class="keyword">null</span>;</span><br><span class="line">	BufferedReader reader = <span class="keyword">null</span>;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		inputStream = <span class="keyword">new</span> FileInputStream(CHANNEL_FILE_PATH);</span><br><span class="line">		reader = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(inputStream,</span><br><span class="line">				CHARSET_NAME));</span><br><span class="line">		String buffer;</span><br><span class="line">		<span class="keyword">while</span> ((buffer = reader.readLine()) != <span class="keyword">null</span> &amp;&amp; buffer.length() != <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"发现已有渠道 : "</span> + buffer);</span><br><span class="line">			channelList.add(buffer);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">		System.out.println(<span class="string">"当前目录下未找到channel.txt"</span>);</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (reader != <span class="keyword">null</span>) &#123;</span><br><span class="line">				reader.close();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">			e.printStackTrace();</span><br><span class="line">		&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">			<span class="keyword">if</span> (inputStream != <span class="keyword">null</span>) &#123;</span><br><span class="line">				<span class="keyword">try</span> &#123;</span><br><span class="line">					inputStream.close();</span><br><span class="line">				&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">					e.printStackTrace();</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> channelList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 <code>getChannel()</code> 方法中都是简单的 I/O 流操作，相信不需要解释大家都可以看得懂吧。之后我们要做的就是去当前路径下查找有无 apk 文件。在这里说明一下，我们这个多渠道打包小工具是支持多个 apk 文件一起打包的，所以我们要把当前目录下所有 apk 文件的路径存储起来。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 得到当前目录下的所有apk</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> file</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;String&gt; <span class="title">getApk</span><span class="params">(File file)</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; apkList = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">	File[] childFiles = file.listFiles();</span><br><span class="line">	<span class="keyword">for</span> (File childFile : childFiles) &#123;</span><br><span class="line">		<span class="keyword">if</span> (!childFile.isDirectory()</span><br><span class="line">				&amp;&amp; childFile.getName().endsWith(APK_SUFFIX)) &#123;</span><br><span class="line">			System.out.println(<span class="string">"发现已有apk : "</span> + childFile.getName());</span><br><span class="line">			apkList.add(childFile.getName());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> apkList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>做好上面的步骤后，最后就剩下打包的代码了，一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 打包apk</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">buildApk</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	List&lt;String&gt; apkList = getApk(<span class="keyword">new</span> File(APK_PATH));</span><br><span class="line">	<span class="keyword">int</span> count = apkList.size();</span><br><span class="line">	<span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">		System.out.println(<span class="string">"当前目录下没有发现apk文件"</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 遍历所有apk文件</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">		String name = apkList.get(i);</span><br><span class="line">		<span class="comment">// 得到文件名字</span></span><br><span class="line">		String baseName = apkList.get(i).substring(<span class="number">0</span>,</span><br><span class="line">				name.lastIndexOf(<span class="string">"."</span>));</span><br><span class="line">		<span class="comment">// apk输出目录</span></span><br><span class="line">		File dictionary = <span class="keyword">new</span> File(APK_OUT_PATH_PREFIX + baseName);</span><br><span class="line">		<span class="keyword">if</span> (!dictionary.exists()) &#123;</span><br><span class="line">			dictionary.mkdir();</span><br><span class="line">		&#125;</span><br><span class="line">		List&lt;String&gt; channelList = getChannel();</span><br><span class="line">		<span class="keyword">if</span> (channelList.size() == <span class="number">0</span>) &#123;</span><br><span class="line">			System.out.println(<span class="string">"channel.txt文件中没有多渠道信息"</span>);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">// 遍历所有渠道</span></span><br><span class="line">		<span class="keyword">for</span> (String channel : channelList) &#123;</span><br><span class="line">			<span class="keyword">try</span> &#123;</span><br><span class="line">				String sourceFileName = APK_PATH + name;</span><br><span class="line">				<span class="comment">// 输出的apk名字</span></span><br><span class="line">				String outApkName = baseName + <span class="string">"_"</span> + channel + APK_SUFFIX;</span><br><span class="line">				<span class="comment">// apk包的路径</span></span><br><span class="line">				String outApkFileName = dictionary.getName() + <span class="string">"/"</span> + outApkName;</span><br><span class="line">				<span class="comment">// 复制要打包的apk</span></span><br><span class="line">				copy(sourceFileName, outApkFileName);</span><br><span class="line">				System.out.println(<span class="string">"正在打 "</span> + channel + <span class="string">" 的渠道包 : "</span> + outApkName);</span><br><span class="line">				ZipFile zipFile = <span class="keyword">new</span> ZipFile(outApkFileName);</span><br><span class="line">				ZipParameters parameters = <span class="keyword">new</span> ZipParameters();</span><br><span class="line">				parameters</span><br><span class="line">						.setCompressionMethod(Zip4jConstants.COMP_DEFLATE);</span><br><span class="line">				parameters</span><br><span class="line">						.setCompressionLevel(Zip4jConstants.DEFLATE_LEVEL_NORMAL);</span><br><span class="line">				parameters.setRootFolderInZip(<span class="string">"META-INF/"</span>);</span><br><span class="line">				<span class="comment">// 当前目录下创建一个channel_xxxxx文件</span></span><br><span class="line">				File channelFile = <span class="keyword">new</span> File(dictionary.getName() + <span class="string">"/channel_"</span></span><br><span class="line">						+ channel);</span><br><span class="line">				<span class="keyword">if</span> (!channelFile.exists()) &#123;</span><br><span class="line">					channelFile.createNewFile();</span><br><span class="line">				&#125;</span><br><span class="line">				<span class="comment">// 在META-INF文件夹中添加channel_xxxxx文件</span></span><br><span class="line">				zipFile.addFile(channelFile, parameters);</span><br><span class="line">				<span class="comment">// 删除当前目录下的channel_xxxxx文件</span></span><br><span class="line">				channelFile.delete();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (ZipException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">				e.printStackTrace();</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 复制文件</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> sourceFilePath</span><br><span class="line"> * <span class="doctag">@param</span> copyFilePath</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">copy</span><span class="params">(String sourceFilePath, String copyFilePath)</span></span>&#123;</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 这里使用的是 common-io.jar 中的文件复制方法，比原生Java I/O API操作速度要快</span></span><br><span class="line">		FileUtils.copyFile(<span class="keyword">new</span> File(sourceFilePath), <span class="keyword">new</span> File(copyFilePath));</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">		e.printStackTrace();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">long</span> preTime = System.currentTimeMillis();</span><br><span class="line">	buildApk();</span><br><span class="line">	System.out.println(<span class="string">"多渠道打包完成，耗时 "</span> + (System.currentTimeMillis() - preTime)/<span class="number">1000</span> + <span class="string">" s"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buildApk()</code> 方法中主要做的就是两个 for 循环嵌套。遍历当前目录的 apk 文件，然后遍历渠道信息，最后打包。另外需要注意的是要复制出一个 apk 文件来进行多渠道打包，而不是在原文件的基础上。</p>
<p>在这里打包的部分就结束了，我们还有一个步骤需要完成。那就是在应用程序启动时去读取相应的渠道，可以通过以下方法去读取：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">getChannelFromMeta</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    ApplicationInfo appinfo = context.getApplicationInfo();</span><br><span class="line">    String sourceDir = appinfo.sourceDir;</span><br><span class="line">    String ret = <span class="string">""</span>;</span><br><span class="line">    ZipFile zipfile = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        zipfile = <span class="keyword">new</span> ZipFile(sourceDir);</span><br><span class="line">        Enumeration&lt;?&gt; entries = zipfile.entries();</span><br><span class="line">        <span class="keyword">while</span> (entries.hasMoreElements()) &#123;</span><br><span class="line">            ZipEntry entry = ((ZipEntry) entries.nextElement());</span><br><span class="line">            String entryName = entry.getName();</span><br><span class="line">            <span class="keyword">if</span> (entryName.startsWith(<span class="string">"META-INF/channel_"</span>)) &#123;</span><br><span class="line">                ret = entryName;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (zipfile != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                zipfile.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    String[] split = ret.split(<span class="string">"_"</span>);</span><br><span class="line">    <span class="keyword">if</span> (split != <span class="keyword">null</span> &amp;&amp; split.length &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> ret.substring(split[<span class="number">0</span>].length() + <span class="number">1</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"default"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读取渠道之后，我们 APP 可以把相应的渠道号发送给服务器或者第三方统计平台做统计。</p>
<h1 id="0011b"><a href="#0011b" class="headerlink" title="0011b"></a>0011b</h1><p>最后，我们可以把这个多渠道打包的 Java 项目打成一个 jar 包，然后写一个 bat 脚本，这样就通过鼠标双击就可以实现快速打渠道包了。以下是 bat 脚本的内容，要注意的是 bat 脚本要和 jar 包处于同一级目录下才可以哦：</p>
<pre><code>@echo off
echo 欢迎使用多渠道打包工具
echo 请确保当前目录下有要打包的apk文件和渠道信息channel.txt
java -jar AndroidBuildApkTool.jar
echo 按任意键退出
pause&gt;nul
exit
</code></pre><p>通过我们的努力 Java 版的多渠道打包工具就做好了。但是不足的是，测试后发现 Java 版打渠道包的速度没有 Python 版的快，主要是在 apk 文件中添加渠道信息文件这一步操作耗费的时间有点多。如果哪位小伙伴有更好的解决方案，欢迎联系我！</p>
<p>附上多渠道打包工具的源码：</p>
<p><a href="/uploads/20160925/MultiChannelBuildTool.rar">MultiChannelBuildTool.rar</a></p>
<h1 id="0100b"><a href="#0100b" class="headerlink" title="0100b"></a>0100b</h1><p>References：</p>
<ul>
<li><a href="http://www.jianshu.com/p/7236ceca2630" target="_blank" rel="external">Gradle 多渠道打包实践</a></li>
<li><a href="http://www.jianshu.com/p/e0783783d26d" target="_blank" rel="external">快速多渠道打包</a></li>
<li><a href="http://geek.csdn.net/news/detail/76488" target="_blank" rel="external">深入浅出Android打包</a></li>
<li><a href="http://tech.meituan.com/mt-apk-packaging.html" target="_blank" rel="external">美团Android自动化之旅—生成渠道包</a></li>
<li><a href="https://github.com/seven456/MultiChannelPackageTool" target="_blank" rel="external">MultiChannelPackageTool</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001b"><a href="#0001b" class="headerlink" title="0001b"></a>0001b</h1><p>最近在公司做了一个多渠道打包的工具，趁今天有空就来讲讲 Android 多渠道打包这件小事。众所周知，随着业务的不断]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对于Android日夜间模式实现的探讨]]></title>
    <link href="http://yuqirong.me/2016/09/08/%E5%AF%B9%E4%BA%8EAndroid%E6%97%A5%E5%A4%9C%E9%97%B4%E6%A8%A1%E5%BC%8F%E5%AE%9E%E7%8E%B0%E7%9A%84%E6%8E%A2%E8%AE%A8/"/>
    <id>http://yuqirong.me/2016/09/08/对于Android日夜间模式实现的探讨/</id>
    <published>2016-09-08T10:32:11.000Z</published>
    <updated>2016-09-10T04:23:11.372Z</updated>
    <content type="html"><![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有相关的模式切换。实现日间/夜间模式切换的方案也有许多种，趁着今天有空来讲一下日间/夜间模式切换的几种实现方案，也可以做一个横向的对比来看看哪种方案最好。</p>
<p>在本篇文章中给出了三种实现日间/夜间模式切换的方案：</p>
<ol>
<li>使用 setTheme 的方法让 Activity 重新设置主题；</li>
<li>设置 Android Support Library 中的 UiMode 来支持日间/夜间模式的切换；</li>
<li>通过资源 id 映射，回调自定义 ThemeChangeListener 接口来处理日间/夜间模式的切换。</li>
</ol>
<p>三种方案综合起来可能导致文章的篇幅过长，请耐心阅读。</p>
<h1 id="0x0002"><a href="#0x0002" class="headerlink" title="0x0002"></a>0x0002</h1><h2 id="u4F7F_u7528_setTheme__u65B9_u6CD5"><a href="#u4F7F_u7528_setTheme__u65B9_u6CD5" class="headerlink" title="使用 setTheme 方法"></a>使用 setTheme 方法</h2><p>我们先来看看使用 setTheme 方法来实现日间/夜间模式切换的方案。这种方案的思路很简单，就是在用户选择夜间模式时，Activity 设置成夜间模式的主题，之后再让 Activity 调用 recreate() 方法重新创建一遍就行了。</p>
<p>那就动手吧，在 colors.xml 中定义两组颜色，分别表示日间和夜间的主题色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"nightColorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后在 styles.xml 中定义两组主题，也就是日间主题和夜间主题：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/black&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"NightAppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"><span class="at_rule"></span><br><span class="line">        &lt;!-- Customize your theme here. --&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimary"</span>&gt;@color/nightColorPrimary&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/nightColorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@android:color/white&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/nightColorPrimaryDark&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在主题中的 <code>mainBackground</code> 属性是我们自定义的属性，用来表示背景色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"mainBackground"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>接下来就是看一下布局 activity_main.xml：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"?attr/mainBackground"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"com.yuqirong.themedemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">Button</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"切换日/夜间模式"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/btn_theme"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:gravity</span>=<span class="value">"center_horizontal"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"通过setTheme()的方法"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 <code>&lt;RelativeLayout&gt;</code> 的 <code>android:background</code> 属性中，我们使用 <code>&quot;?attr/mainBackground&quot;</code> 来表示，这样就代表着 <code>RelativeLayout</code> 的背景色会去引用在主题中事先定义好的 <code>mainBackground</code> 属性的值。这样就实现了日间/夜间模式切换的换色了。</p>
<p>最后就是 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> theme = R.style.AppTheme;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">		<span class="comment">// 判断是否有主题存储</span></span><br><span class="line">        <span class="keyword">if</span>(savedInstanceState != <span class="keyword">null</span>)&#123;</span><br><span class="line">            theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">            setTheme(theme);</span><br><span class="line">        &#125;</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                theme = (theme == R.style.AppTheme) ? R.style.NightAppTheme : R.style.AppTheme;</span><br><span class="line">                MainActivity.<span class="keyword">this</span>.recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSaveInstanceState</span><span class="params">(Bundle outState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onSaveInstanceState(outState);</span><br><span class="line">        outState.putInt(<span class="string">"theme"</span>, theme);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onRestoreInstanceState</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onRestoreInstanceState(savedInstanceState);</span><br><span class="line">        theme = savedInstanceState.getInt(<span class="string">"theme"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中有几点要注意一下：</p>
<ol>
<li><p>调用 <code>recreate()</code> 方法后 Activity 的生命周期会调用 <code>onSaveInstanceState(Bundle outState)</code> 来备份相关的数据，之后也会调用 <code>onRestoreInstanceState(Bundle savedInstanceState)</code> 来还原相关的数据，因此我们把 <code>theme</code> 的值保存进去，以便 Activity 重新创建后使用。</p>
</li>
<li><p>我们在 <code>onCreate(Bundle savedInstanceState)</code> 方法中还原得到了 <code>theme</code> 值后，<code>setTheme()</code> 方法一定要在 <code>setContentView()</code> 方法之前调用，否则的话就看不到效果了。</p>
</li>
<li><p><code>recreate()</code> 方法是在 API 11 中添加进来的，所以在 Android 2.X 中使用会抛异常。</p>
</li>
</ol>
<p>贴完上面的代码之后，我们来看一下该方案实现的效果图：</p>
<p><img src="/uploads/20160908/20160909103512.gif" alt="setTheme()效果图gif"></p>
<h2 id="u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5"><a href="#u4F7F_u7528_Android_Support_Library__u4E2D_u7684_UiMode__u65B9_u6CD5" class="headerlink" title="使用 Android Support Library 中的 UiMode 方法"></a>使用 Android Support Library 中的 UiMode 方法</h2><p>使用 UiMode 的方法也很简单，我们需要把 colors.xml 定义为日间/夜间两种。之后根据不同的模式会去选择不同的 colors.xml 。在 Activity 调用 recreate() 之后，就实现了切换日/夜间模式的功能。</p>
<p>说了这么多，直接上代码。下面是 values/colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>除了 values/colors.xml 之外，我们还要创建一个 values-night/colors.xml 文件，用来设置夜间模式的颜色，其中 <code>&lt;color&gt;</code> 的 name 必须要和 values/colors.xml 中的相对应：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>在 styles.xml 中去引用我们在 colors.xml 中定义好的颜色：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- Base application theme. --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">style</span> <span class="attribute">name</span>=<span class="value">"AppTheme"</span> <span class="attribute">parent</span>=<span class="value">"Theme.AppCompat.Light.DarkActionBar"</span>&gt;</span><span class="css"></span><br><span class="line">        &lt;!<span class="tag">--</span> <span class="tag">Customize</span> <span class="tag">your</span> <span class="tag">theme</span> <span class="tag">here</span>. <span class="tag">--</span>&gt;</span><br><span class="line">        &lt;<span class="tag">item</span> <span class="tag">name</span>="<span class="tag">colorPrimary</span>"&gt;<span class="at_rule">@<span class="keyword">color/colorPrimary&lt;/item&gt;</span></span><br><span class="line">        &lt;item name=<span class="string">"colorPrimaryDark"</span>&gt;@color/colorPrimaryDark&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"colorAccent"</span>&gt;@color/colorAccent&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"android:textColor"</span>&gt;@color/textColor&lt;/item&gt;</span><br><span class="line">        &lt;item name=<span class="string">"mainBackground"</span>&gt;@color/backgroundColor&lt;/item&gt;</span><br><span class="line">    </span></span><span class="tag">&lt;/<span class="title">style</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>activity_main.xml 布局的内容和上面 setTheme() 方法中的相差无几，这里就不贴出来了。之后的事情就变得很简单了，在 MyApplication 中先选择一个默认的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        <span class="comment">// 默认设置为日间模式</span></span><br><span class="line">        AppCompatDelegate.setDefaultNightMode(</span><br><span class="line">                AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要注意的是，这里的 Mode 有四种类型可以选择：</p>
<ul>
<li>MODE_NIGHT_NO： 使用亮色(light)主题，不使用夜间模式；</li>
<li>MODE_NIGHT_YES：使用暗色(dark)主题，使用夜间模式；</li>
<li>MODE_NIGHT_AUTO：根据当前时间自动切换 亮色(light)/暗色(dark)主题；</li>
<li>MODE_NIGHT_FOLLOW_SYSTEM(默认选项)：设置为跟随系统，通常为 MODE_NIGHT_NO</li>
</ul>
<p>当用户点击按钮切换日/夜间时，重新去设置相应的 Mode ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        Button btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">int</span> currentNightMode = getResources().getConfiguration().uiMode &amp; Configuration.UI_MODE_NIGHT_MASK;</span><br><span class="line">                getDelegate().setLocalNightMode(currentNightMode == Configuration.UI_MODE_NIGHT_NO</span><br><span class="line">                        ? AppCompatDelegate.MODE_NIGHT_YES : AppCompatDelegate.MODE_NIGHT_NO);</span><br><span class="line">                <span class="comment">// 同样需要调用recreate方法使之生效</span></span><br><span class="line">                recreate();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看一下 UiMode 方案实现的效果图：</p>
<p><img src="/uploads/20160908/20160910011353.gif" alt="UiMode的效果图gif"></p>
<p>就前两种方法而言，配置比较简单，最后的实现效果也都基本上是一样的。但是缺点就是需要调用 <code>recreate()</code> 使之生效。而让 Activity 重新创建就必须涉及到一些状态的保存。这就增加了一些难度。所以，我们一起来看看第三种解决方法。</p>
<h2 id="u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3"><a href="#u901A_u8FC7_u8D44_u6E90_id__u6620_u5C04_uFF0C_u56DE_u8C03_u63A5_u53E3" class="headerlink" title="通过资源 id 映射，回调接口"></a>通过资源 id 映射，回调接口</h2><p>第三种方法的思路就是根据设置的主题去动态地获取资源 id 的映射，然后使用回调接口的方式让 UI 去设置相关的属性值。我们在这里先规定一下：夜间模式的资源在命名上都要加上后缀 “_night” ，比如日间模式的背景色命名为 color_background ，那么相对应的夜间模式的背景资源就要命名为 color_background_night 。好了，下面就是我们的 Demo 所需要用到的 colors.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary"</span>&gt;</span>#3F51B5<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimary_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark"</span>&gt;</span>#303F9F<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorPrimaryDark_night"</span>&gt;</span>#383838<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent"</span>&gt;</span>#FF4081<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"colorAccent_night"</span>&gt;</span>#a72b55<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor"</span>&gt;</span>#FF000000<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"textColor_night"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor"</span>&gt;</span>#FFFFFF<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">color</span> <span class="attribute">name</span>=<span class="value">"backgroundColor_night"</span>&gt;</span>#3b3b3b<span class="tag">&lt;/<span class="title">color</span>&gt;</span></span><br><span class="line">    </span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>可以看到每一项 color 都会有对应的 “_night” 与之匹配。</p>
<p>看到这里，肯定有人会问，为什么要设置对应的 “_night” ？到底是通过什么方式来设置日/夜间模式的呢？下面就由 ThemeManager 来为你解答：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThemeManager</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 默认是日间模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ThemeMode mThemeMode = ThemeMode.DAY;</span><br><span class="line">    <span class="comment">// 主题模式监听器</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> List&lt;OnThemeChangeListener&gt; mThemeChangeListenerList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间资源的缓存，key : 资源类型, 值&lt;key:资源名称, value:int值&gt;</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> HashMap&lt;String, HashMap&lt;String, Integer&gt;&gt; sCachedNightResrouces = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 夜间模式资源的后缀，比如日件模式资源名为：R.color.activity_bg, 那么夜间模式就为 ：R.color.activity_bg_night</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String RESOURCE_SUFFIX = <span class="string">"_night"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式，分为日间模式和夜间模式</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">enum</span> ThemeMode &#123;</span><br><span class="line">        DAY, NIGHT</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 设置主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> themeMode</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setThemeMode</span><span class="params">(ThemeMode themeMode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeMode != themeMode) &#123;</span><br><span class="line">            mThemeMode = themeMode;</span><br><span class="line">            <span class="keyword">if</span> (mThemeChangeListenerList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (OnThemeChangeListener listener : mThemeChangeListenerList) &#123;</span><br><span class="line">                    listener.onThemeChanged();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的日间模式的resId得到相应主题的resId，注意：必须是日间模式的resId</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> dayResId 日间模式的resId</span><br><span class="line">     * <span class="doctag">@return</span> 相应主题的resId，若为日间模式，则得到dayResId；反之夜间模式得到nightResId</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getCurrentThemeRes</span><span class="params">(Context context, <span class="keyword">int</span> dayResId)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (getThemeMode() == ThemeMode.DAY) &#123;</span><br><span class="line">            <span class="keyword">return</span> dayResId;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 资源名</span></span><br><span class="line">        String entryName = context.getResources().getResourceEntryName(dayResId);</span><br><span class="line">        <span class="comment">// 资源类型</span></span><br><span class="line">        String typeName = context.getResources().getResourceTypeName(dayResId);</span><br><span class="line">        HashMap&lt;String, Integer&gt; cachedRes = sCachedNightResrouces.get(typeName);</span><br><span class="line">        <span class="comment">// 先从缓存中去取，如果有直接返回该id</span></span><br><span class="line">        <span class="keyword">if</span> (cachedRes == <span class="keyword">null</span>) &#123;</span><br><span class="line">            cachedRes = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        Integer resId = cachedRes.get(entryName + RESOURCE_SUFFIX);</span><br><span class="line">        <span class="keyword">if</span> (resId != <span class="keyword">null</span> &amp;&amp; resId != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> resId;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果缓存中没有再根据资源id去动态获取</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 通过资源名，资源类型，包名得到资源int值</span></span><br><span class="line">                <span class="keyword">int</span> nightResId = context.getResources().getIdentifier(entryName + RESOURCE_SUFFIX, typeName, context.getPackageName());</span><br><span class="line">                <span class="comment">// 放入缓存中</span></span><br><span class="line">                cachedRes.put(entryName + RESOURCE_SUFFIX, nightResId);</span><br><span class="line">                sCachedNightResrouces.put(typeName, cachedRes);</span><br><span class="line">                <span class="keyword">return</span> nightResId;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Resources.NotFoundException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.add(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 反注册ThemeChangeListener</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> listener</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">unregisterThemeChangeListener</span><span class="params">(OnThemeChangeListener listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mThemeChangeListenerList.contains(listener)) &#123;</span><br><span class="line">            mThemeChangeListenerList.remove(listener);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 得到主题模式</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span></span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThemeMode <span class="title">getThemeMode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mThemeMode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 主题模式切换监听器</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * 主题切换时回调</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面 ThemeManager 的代码基本上都有注释，想要看懂并不困难。其中最核心的就是 <code>getCurrentThemeRes</code> 方法了。在这里解释一下 <code>getCurrentThemeRes</code> 的逻辑。参数中的 dayResId 是日间模式的资源id，如果当前主题是日间模式的话，就直接返回 dayResId 。反之当前主题为夜间模式的话，先根据 dayResId 得到资源名称和资源类型。比如现在有一个资源为 R.color.colorPrimary ，那么资源名称就是 colorPrimary ，资源类型就是 color 。然后根据资源类型和资源名称去获取缓存。如果没有缓存，那么就要动态获取资源了。这里使用方法的是</p>
<pre><code>context.getResources().getIdentifier(String name, String defType, String defPackage)
</code></pre><ul>
<li><code>name</code> 参数就是资源名称，不过要注意的是这里的资源名称还要加上后缀 “_night” ，也就是上面在 colors.xml 中定义的名称；</li>
<li><code>defType</code> 参数就是资源的类型了。比如 color，drawable等；</li>
<li><code>defPackage</code> 就是资源文件的包名，也就是当前 APP 的包名。</li>
</ul>
<p>有了上面的这个方法，就可以通过 R.color.colorPrimary 资源找到对应的 R.color.colorPrimary_night 资源了。最后还要把找到的夜间模式资源加入到缓存中。这样的话以后就直接去缓存中读取，而不用再次去动态查找资源 id 了。</p>
<p>ThemeManager 中剩下的代码应该都是比较简单的，相信大家都可以看得懂了。</p>
<p>现在我们来看看 MainActivity 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> <span class="keyword">implements</span> <span class="title">ThemeManager</span>.<span class="title">OnThemeChangeListener</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> TextView tv;</span><br><span class="line">    <span class="keyword">private</span> Button btn_theme;</span><br><span class="line">    <span class="keyword">private</span> RelativeLayout relativeLayout;</span><br><span class="line">    <span class="keyword">private</span> ActionBar supportActionBar;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        ThemeManager.registerThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">        supportActionBar = getSupportActionBar();</span><br><span class="line">        btn_theme = (Button) findViewById(R.id.btn_theme);</span><br><span class="line">        relativeLayout = (RelativeLayout) findViewById(R.id.relativeLayout);</span><br><span class="line">        tv = (TextView) findViewById(R.id.tv);</span><br><span class="line">        btn_theme.setOnClickListener(<span class="keyword">new</span> View.OnClickListener() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">                ThemeManager.setThemeMode(ThemeManager.getThemeMode() == ThemeManager.ThemeMode.DAY</span><br><span class="line">                        ? ThemeManager.ThemeMode.NIGHT : ThemeManager.ThemeMode.DAY);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initTheme</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        tv.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        btn_theme.setTextColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.textColor)));</span><br><span class="line">        relativeLayout.setBackgroundColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.backgroundColor)));</span><br><span class="line">        <span class="comment">// 设置标题栏颜色</span></span><br><span class="line">        <span class="keyword">if</span>(supportActionBar != <span class="keyword">null</span>)&#123;</span><br><span class="line">            supportActionBar.setBackgroundDrawable(<span class="keyword">new</span> ColorDrawable(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary))));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 设置状态栏颜色</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">            Window window = getWindow();</span><br><span class="line">            window.setStatusBarColor(getResources().getColor(ThemeManager.getCurrentThemeRes(MainActivity.<span class="keyword">this</span>, R.color.colorPrimary)));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onThemeChanged</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        initTheme();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        ThemeManager.unregisterThemeChangeListener(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 MainActivity 中实现了 OnThemeChangeListener 接口，这样就可以在主题改变的时候执行回调方法。然后在 <code>initTheme()</code> 中去重新设置 UI 的相关颜色属性值。还有别忘了要在 <code>onDestroy()</code> 中移除 ThemeChangeListener 。</p>
<p>最后就来看看第三种方法的效果吧：</p>
<p><img src="/uploads/20160908/20160910114556.gif" alt="动态获取资源id的效果图gif"></p>
<p>也许有人会说和前两种方法的效果没什么差异啊，但是仔细看就会发现前面两种方法在切换模式的瞬间会有短暂黑屏现象存在，而第三种方法没有。这是因为前两种方法都要调用 <code>recreate()</code> 。而第三种方法不需要 Activity 重新创建，使用回调的方法来实现。</p>
<h1 id="0x0003"><a href="#0x0003" class="headerlink" title="0x0003"></a>0x0003</h1><p>到了这里，按照套路应该是要总结的时候了。那么就根据上面给的三种方法来一个简单的对比吧：</p>
<ol>
<li><p>setTheme 方法：可以配置多套主题，比较容易上手。除了日/夜间模式之外，还可以有其他五颜六色的主题。但是需要调用 recreate() ，切换瞬间会有黑屏闪现的现象；</p>
</li>
<li><p>UiMode 方法：优点就是 Android Support Library 中已经支持，简单规范。但是也需要调用 recreate() ，存在黑屏闪现的现象；</p>
</li>
<li><p>动态获取资源 id ，回调接口：该方法使用起来比前两个方法复杂，另外在回调的方法中需要设置每一项 UI 相关的属性值。但是不需要调用 recreate() ，没有黑屏闪现的现象。</p>
</li>
</ol>
<p>三种方法整体的对比就如上所示了。当然除了上面的三种方法实现日/夜间模式切换之外，还有比如动态换肤等也都可以实现。方法有很多种，重要的是要根据自身情况选择合适的方法去实现。在下面我会给出其他几种实现日/夜间模式切换方法的链接，可以参考一下。</p>
<p>好了，到了说再见的时候了。</p>
<p>Goodbye !</p>
<p><a href="/uploads/20160908/ThemeDemo_setTheme.rar">setTheme方法的Demo下载</a></p>
<p><a href="/uploads/20160908/ThemeDemo_UiMode.rar">UiMode方法的Demo下载</a></p>
<p><a href="/uploads/20160908/ThemeDemo_thememanager.rar">动态获取资源id方法的Demo下载</a></p>
<h1 id="0x0004"><a href="#0x0004" class="headerlink" title="0x0004"></a>0x0004</h1><p><a href="https://segmentfault.com/a/1190000005736047?f=tt&amp;hmsr=toutiao.io&amp;utm_medium=toutiao.io&amp;utm_source=toutiao.io" target="_blank" rel="external">android 实现【夜晚模式】的另外一种思路</a></p>
<p><a href="http://www.diycode.cc/topics/269" target="_blank" rel="external">知乎和简书的夜间模式实现套路</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x0001"><a href="#0x0001" class="headerlink" title="0x0001"></a>0x0001</h1><p>关于 Android 的日间/夜间模式切换相信大家在平时使用 APP 的过程中都遇到过，比如知乎、简书中就有]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/08/06/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/08/06/《Android开发艺术探索》笔记(下)/</id>
    <published>2016-08-05T16:12:02.000Z</published>
    <updated>2016-09-13T15:41:22.416Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager" class="headerlink" title="第八章：理解Window和WindowManager"></a>第八章：理解Window和WindowManager</h1><h2 id="8-1_Window_u548CWindowManager"><a href="#8-1_Window_u548CWindowManager" class="headerlink" title="8.1 Window和WindowManager"></a>8.1 Window和WindowManager</h2><p>Window是抽象类，具体实现是PhoneWindow，通过WindowManager就可以创建Window。WindowManager是外界访问Window的入口，但是Window的具体实现是在WindowManagerService中，WindowManager和WindowManagerService的交互是一个IPC过程。所有的视图例如Activity、Dialog、Toast都是附加在Window上的。因此，Window是实际上View的直接管理者。</p>
<p>WindowManager.LayoutParams中的flags参数解析：</p>
<ul>
<li>FLAG_NOT_FOCUSABLE：表示window不需要获取焦点，也不需要接收各种输入事件。此标记会同时启用FLAG_NOT_TOUCH_MODAL，最终事件会直接传递给下层的具有焦点的window；</li>
<li>FLAG_NOT_TOUCH_MODAL：在此模式下，系统会将window区域外的单击事件传递给底层的window，当前window区域内的单击事件则自己处理，一般都需要开启这个标记；</li>
<li>FLAG_SHOW_WHEN_LOCKED：开启此模式可以让Window显示在锁屏的界面上。</li>
</ul>
<p>type参数表示window的类型，window共有三种类型：应用window，子window和系统window。应用window对应着一个Activity，子window不能独立存在，需要附属在特定的父window之上，比如Dialog就是子window。系统window是需要声明权限才能创建的window，比如Toast和系统状态栏这些都是系统window，需要声明的权限是<code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;</code>。</p>
<p>window是分层的，每个window都对应着z-ordered，层级大的会覆盖在层级小的上面，应用window的层级范围是1~99，子window的层级范围是1000~1999，系统window的层级范围是2000~2999。</p>
<p>WindowManager继承自ViewManager，常用的只有三个方法：addView、updateView和removeView。</p>
<h2 id="8-2_Window_u7684_u5185_u90E8_u673A_u5236"><a href="#8-2_Window_u7684_u5185_u90E8_u673A_u5236" class="headerlink" title="8.2 Window的内部机制"></a>8.2 Window的内部机制</h2><p>Window是一个抽象的概念，不是实际存在的，它也是以View的形式存在。在实际使用中无法直接访问Window，只能通过WindowManager才能访问Window。每个Window都对应着一个View和一个ViewRootImpl，Window和View通过ViewRootImpl来建立联系。</p>
<p>Window的添加、删除和更新过程都是IPC过程。WindowManager的实现类(即：WindowManagerImpl)对于addView、updateView和removeView方法都是委托给WindowManagerGlobal类，该类保存了很多数据列表，例如所有window对应的view集合mViews、所有window对应的ViewRootImpl的集合mRoots，其他的还有mParams和mDyingViews等。</p>
<p><strong>Window的添加过程</strong>：</p>
<ol>
<li>WindowManagerGlobal中的addView；</li>
<li>检查参数是否合法，如果子Window还需要调节布局参数；</li>
<li>创建ViewRootImpl并将View添加到列表中；</li>
<li>通过ViewRootImpl的setView来更新界面并完成Window的添加过程。在setView内部会调用requestLayout来完成异步刷新请求。在requestLayout中的scheduleTraversals是View绘制的入口，最终通过WindowSession来完成Window的添加过程，注意其实这里是个IPC过程，最终会通过WindowManagerService的addWindow方法来实现Window的添加。 </li>
</ol>
<p><strong>Window的删除过程</strong>：</p>
<ol>
<li>WinodwManagerGlobal中的removeView；</li>
<li>findViewLocked来查找待删除待View的索引，再调用removeViewLocked来做进一步删除；</li>
<li>removeViewLocked通过ViewRootImpl的die方法来完成删除操作，包括同步和异步两种方式，同步方式可能会导致意外的错误，不推荐，一般使用异步的方式，其实就是通过handler发送了一个删除请求，将View添加到mDyingViews中；</li>
<li>die方法本质调用了doDie方法，真正删除View的逻辑在该方法的dispatchDetachedFromWindow方法中，主要做了四件事：垃圾回收，通过Session的remove方法删除Window，调用View的dispatchDetachedFromWindow方法同时会回调View的onDetachedFromWindow以及onDetachedFromWindowInternal，调用WindowManagerGlobal的doRemoveView刷新数据。 </li>
</ol>
<p><strong>Window的更新过程</strong>：</p>
<ol>
<li>WindowManagerGlobal的updateViewLayout；</li>
<li>更新View的LayoutParams；</li>
<li>更新ViewImple的LayoutParams，实现对View的重新测量，布局，重绘；</li>
<li>通过WindowSession更新Window的视图，WindowManagerService.relayoutWindow()。</li>
</ol>
<h2 id="8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B"><a href="#8-3_Window_u7684_u521B_u5EFA_u8FC7_u7A0B" class="headerlink" title="8.3 Window的创建过程"></a>8.3 Window的创建过程</h2><p><strong>Activity的window创建过程</strong>：</p>
<ol>
<li>Activity的启动过程很复杂，最终会由ActivityThread中的performLaunchActivity来完成整个启动过程，在这个方法内部会通过类加载器创建Activity的实例对象，并调用它的attach方法为其关联运行过程中所依赖的一系列上下文环境变量；</li>
<li>Activity实现了Window的Callback接口，当window接收到外界的状态变化时就会回调Activity的方法，例如onAttachedToWindow、onDetachedFromWindow、dispatchTouchEvent等；</li>
<li>Activity的Window是由PolicyManager来创建的，它的真正实现是Policy类，它会新建一个PhoneWindow对象，Activity的setContentView的实现是由PhoneWindow来实现的；</li>
<li>Activity的顶级View是DecorView，它本质上是一个FrameLayout。如果没有DecorView，那么PhoneWindow会先创建一个DecorView，然后加载具体的布局文件并将view添加到DecorView的mContentParent中，最后就是回调Activity的onContentChanged通知Activity视图已经发生了变化；</li>
<li>还有一个步骤是让WindowManager能够识别DecorView，在ActivityThread调用handleResumeActivity方法时，首先会调用Activity的onResume方法，然后会调用makeVisible方法，这个方法中DecorView真正地完成了添加和显示过程。</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ViewManager vm = getWindowManager();</span><br><span class="line">vm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">mWindowAdded = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure>
<p><strong>Dialog的Window创建过程</strong>：</p>
<p>过程与Activity的Window创建过程类似，普通的Dialog的有一个特别之处，即它必须采用Activity的Context，如果采用Application的Context会报错。原因是Application没有应用token，应用token一般是Activity拥有的。解决的方案就是通过<code>dialog.getWindow.setType</code>方法设置成系统级别的type，记得在manifest中设置权限。</p>
<p><strong>Toast的Window创建过程</strong>：</p>
<ol>
<li>Toast内部有两类IPC：Toast访问NotificationManagerService；NotificationManagerService（下文简称NMS）访问Toast的TN接口；</li>
<li>Toast属于系统Window，内部视图mNextView一种为系统默认样式，另一种通过setView方法来指定一个自定义View。</li>
<li>TN是一个Binder类，NMS处理Toast的显示隐藏请求时会跨进程回调TN中的方法，所以TN运行在Binder线程池中，所以需要handler切换到当前发送Toast请求的线程中，也就是说没有Looper的线程是无法弹出Toast的。</li>
<li>Toast的show方法调用了NMS的enqueueToast方法，该方法先将Toast请求封装成ToastRecord并丢入mToastQueue队列中（非系统应用最多塞50个）。</li>
<li>NMS通过showNextToastLocked方法来显示当前View，Toast显示由ToastRecord的callback方法中的show方法完成，callback其实就是TN对象的远程Binder，所以最终调用的是TN中的方法，并运行在发起Toast请求应用的Binder线程池中。</li>
<li>显示以后，NMS通过scheduleTimeoutLocked方法发送延时消息，延时后NMS通过cancelToastLocked方法来隐藏Toast并从队列中移除，隐藏依然通过ToastRecord的callback中的hide方法实现。</li>
<li>callback回调TN的show和hide方法后，会通过handler发送两个Runnable，里面的handleShow和handleHide方法是真正完成显示和隐藏Toast的地方。handleShow方法中将Toast的视图添加到Window中，handleHide方法将Toast视图从Window中移除。</li>
</ol>
<h1 id="u7B2C_u5341_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236"><a href="#u7B2C_u5341_u7AE0_Android_u7684_u6D88_u606F_u673A_u5236" class="headerlink" title="第十章 Android的消息机制"></a>第十章 Android的消息机制</h1><h2 id="10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0"><a href="#10-1_Android_u6D88_u606F_u673A_u5236_u6982_u8FF0" class="headerlink" title="10.1 Android消息机制概述"></a>10.1 Android消息机制概述</h2><p>Android的消息机制主要是指Handler的运行机制，其底层需要MessageQueue和Looper的支撑。MessageQueue是以单链表的数据结构存储消息列表但是以队列的形式对外提供插入和删除消息操作的消息队列。MessageQueue只是消息的存储单元，而Looper则是以无限循环的形式去查找是否有新消息，如果有的话就去处理消息，否则就一直等待着。</p>
<p>Handler的主要作用是将一个任务切换到某个指定的线程中去执行。</p>
<ul>
<li>为什么要提供这个功能呢？</li>
</ul>
<p>Android规定UI操作只能在主线程中进行，ViewRootImpl的checkThread方法会验证当前线程是否可以进行UI操作。</p>
<ul>
<li>为什么不允许子线程访问UI呢？</li>
</ul>
<p>这是因为UI组件不是线程安全的，如果在多线程中并发访问可能会导致UI组件处于不可预期的状态。另外，如果对UI组件的访问进行加锁机制的话又会降低UI访问的效率，所以还是采用单线程模型来处理UI事件。</p>
<p>Handler的创建会采用当前线程的Looper来构建内部的消息循环系统，如果当前线程中不存在Looper的话就会报错。Handler可以用post方法将一个Runnable投递到消息队列中，也可以用send方法发送一个消息投递到消息队列中，其实post最终还是调用了send方法。</p>
<h2 id="10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790"><a href="#10-2_Android_u7684_u6D88_u606F_u673A_u5236_u5206_u6790" class="headerlink" title="10.2 Android的消息机制分析"></a>10.2 Android的消息机制分析</h2><p>(1).ThreadLocal的工作原理</p>
<ol>
<li>ThreadLocal是一个线程内部的数据存储类，通过它可以在指定的线程中存储数据，数据存储以后，只有在指定线程中可以获取到存储的数据，对于其他线程来说则无法获取到数据。一般来说，当某些数据是以线程为作用域并且不同线程具有不同的数据副本的时候，可以考虑使用ThreadLocal。 对于Handler来说，它需要获取当前线程的Looper，而Looper的作用域就是线程并且不同线程具有不同的Looper，这个时候通过ThreadLocal就可以实现Looper在线程中的存取了。</li>
<li>ThreadLocal的原理：不同线程访问同一个ThreadLocal的get方法时，ThreadLocal内部会从各自的线程中取出一个数组，然后再从数组中根据当前ThreadLocal的索引去查找出对应的value值，不同线程中的数组是不同的，这就是为什么通过ThreadLocal可以在不同线程中维护一套数据的副本并且彼此互不干扰。</li>
<li><p>ThreadLocal是一个泛型类public class ThreadLocal<t>，下面是它的set方法</t></p>
<pre><code>public void set(T value) {
    Thread currentThread = Thread.currentThread();
    Values values = values(currentThread);
    if (values == null) {
        values = initializeValues(currentThread);
    }
    values.put(this, value);
}
</code></pre><p> Values是Thread类内部专门用来存储线程的ThreadLocal数据的，它内部有一个数组private Object[] table，ThreadLocal的值就存在这个table数组中。如果values的值为null，那么就需要对其进行初始化然后再将ThreadLocal的值进行存储。<br> ThreadLocal数据的存储规则：ThreadLocal的值在table数组中的存储位置总是ThreadLocal的索引+1的位置。</p>
</li>
</ol>
<p>(2).MessageQueue的工作原理</p>
<ol>
<li>MessageQueue其实是通过单链表来维护消息列表的，它包含两个主要操作enqueueMessage和next，前者是插入消息，后者是取出一条消息并移除。</li>
<li>next方法是一个无限循环的方法，如果消息队列中没有消息，那么next方法会一直阻塞在这里。当有新消息到来时，next方法会返回这条消息并将它从链表中移除。</li>
</ol>
<p>(3).Looper的工作原理</p>
<ol>
<li><p>为一个线程创建Looper的方法，代码如下所示</p>
<pre><code>new Thread(&quot;test&quot;){
    @Override
    public void run() {
        Looper.prepare();//创建looper
        Handler handler = new Handler();//可以创建handler了
        Looper.loop();//开始looper循环
    }
}.start();
</code></pre></li>
<li><p>Looper的prepareMainLooper方法主要是给主线程也就是ActivityThread创建Looper使用的，本质也是调用了prepare方法。</p>
</li>
<li>Looper的quit和quitSafely方法的区别是：前者会直接退出Looper，后者只是设定一个退出标记，然后把消息队列中的已有消息处理完毕后才安全地退出。Looper退出之后，通过Handler发送的消息就会失败，这个时候Handler的send方法会返回false。<br>在子线程中，如果手动为其创建了Looper，那么在所有的事情完成以后应该调用quit方法来终止消息循环，否则这个子线程就会一直处于等待的状态，而如果退出Looper以后，这个线程就会立刻终止，因此建议不需要的时候终止Looper。</li>
<li>当Looper的quit方法被调用时，Looper就会调用MessageQueue的quit或者quitSafely方法来通知消息队列退出，当消息队列被标记为退出状态时，它的next方法就会返回null。也就是说，Looper必须退出，否则loop方法就会无限循环下去。Looper的loop方法会调用MessageQueue的next方法来获取新消息，而next是一个阻塞操作，当没有消息时，next方法会一直阻塞着在那里，这也导致了loop方法一直阻塞在那里。如果MessageQueue的next方法返回了新消息，Looper就会处理这条消息：msg.target.dispatchMessage(msg)，其中的msg.target就是发送这条消息的Handler对象。</li>
</ol>
<p>(4).Handler的工作原理</p>
<ol>
<li>Handler就是处理消息的发送和接收之后的处理；</li>
<li><p>Handler处理消息的过程</p>
<pre><code>public void dispatchMessage(Message msg) {
    if (msg.callback != null) {
        handleCallback(msg);//当message是runnable的情况，也就是Handler的post方法传递的参数，这种情况下直接执行runnable的run方法
    } else {
        if (mCallback != null) {//如果创建Handler的时候是给Handler设置了Callback接口的实现，那么此时调用该实现的handleMessage方法
            if (mCallback.handleMessage(msg)) {
                return;
            }
        }
        handleMessage(msg);//如果是派生Handler的子类，就要重写handleMessage方法，那么此时就是调用子类实现的handleMessage方法
    }
}

private static void handleCallback(Message message) {
        message.callback.run();
}

/**
 * Subclasses must implement this to receive messages.
 */
public void handleMessage(Message msg) {
}
</code></pre></li>
<li><p>Handler还有一个特殊的构造方法，它可以通过特定的Looper来创建Handler。</p>
<pre><code>public Handler(Looper looper){
  this(looper, null, false);
}
</code></pre></li>
</ol>
<h2 id="10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF"><a href="#10-3__u4E3B_u7EBF_u7A0B_u7684_u6D88_u606F_u5FAA_u73AF" class="headerlink" title="10.3 主线程的消息循环"></a>10.3 主线程的消息循环</h2><p>Android的主线程就是ActivityThread，主线程的入口方法就是main，其中调用了Looper.prepareMainLooper()来创建主线程的Looper以及MessageQueue，并通过Looper.loop()方法来开启主线程的消息循环。主线程内有一个Handler，即ActivityThread.H，它定义了一组消息类型，主要包含了四大组件的启动和停止等过程，例如LAUNCH_ACTIVITY等。</p>
<p>ActivityThread通过ApplicationThread和AMS进行进程间通信，AMS以进程间通信的方法完成ActivityThread的请求后会回调ApplicationThread中的Binder方法，然后ApplicationThread会向H发送消息，H收到消息后会将ApplicationThread中的逻辑切换到ActivityThread中去执行，即切换到主线程中去执行，这个过程就是主线程的消息循环模型。</p>
<h1 id="u7B2C_u5341_u4E00_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60"><a href="#u7B2C_u5341_u4E00_u7AE0_Android_u7684_u7EBF_u7A0B_u548C_u7EBF_u7A0B_u6C60" class="headerlink" title="第十一章 Android的线程和线程池"></a>第十一章 Android的线程和线程池</h1><h2 id="11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B"><a href="#11-1__u4E3B_u7EBF_u7A0B_u548C_u5B50_u7EBF_u7A0B" class="headerlink" title="11.1 主线程和子线程"></a>11.1 主线程和子线程</h2><ol>
<li>在Java中默认情况下一个进程只有一个线程，也就是主线程，其他线程都是子线程，也叫工作线程。Android中的主线程主要处理和界面相关的事情，而子线程则往往用于执行耗时操作。线程的创建和销毁的开销较大，所以如果一个进程要频繁地创建和销毁线程的话，都会采用线程池的方式。</li>
<li>在Android中除了Thread，还有HandlerThread、AsyncTask以及IntentService等也都扮演着线程的角色，只是它们具有不同的特性和使用场景。AsyncTask封装了线程池和Handler，它主要是为了方便开发者在子线程中更新UI。HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。IntentService是一个服务，它内部采用HandlerThread来执行任务，当任务执行完毕后就会自动退出。因为它是服务的缘故，所以和后台线程相比，它比较不容易被系统杀死。</li>
<li>从Android 3.0开始，系统要求网络访问必须在子线程中进行，否则网络访问将会失败并抛出NetworkOnMainThreadException这个异常，这样做是为了避免主线程由于被耗时操作所阻塞从而出现ANR现象。</li>
<li>AsyncTask是一个抽象泛型类，它提供了Params、Progress、Result三个泛型参数，如果task确实不需要传递具体的参数，那么都可以设置为Void。下面是它的四个核心方法，其中doInBackground不是在主线程执行的。<br>onPreExecute、doInBackground、onProgressUpdate、onPostResult</li>
</ol>
<h2 id="11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001"><a href="#11-2_Android_u4E2D_u7684_u7EBF_u7A0B_u5F62_u6001" class="headerlink" title="11.2 Android中的线程形态"></a>11.2 Android中的线程形态</h2><ol>
<li><p>AsyncTask的使用过程中的条件限制：</p>
<p> (1).AsyncTask的类必须在主线程中加载，这个过程在Android 4.1及以上版本中已经被系统自动完成。</p>
<p> (2).AsyncTask对象必须在主线程中创建，execute方法必须在UI线程中调用。</p>
<p> (3).一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会报运行时异常。</p>
<p> (4).在Android 1.6之前，AsyncTask是串行执行任务的，Android 1.6的时候AsyncTask开始采用线程池并行处理任务，但是从Android 3.0开始，为了避免AsyncTask带来的并发错误，AsyncTask又采用一个线程来串行执行任务。尽管如此，在Android 3.0以及后续版本中，我们可以使用AsyncTask的executeOnExecutor方法来并行执行任务。但是这个方法是Android 3.0新添加的方法，并不能在低版本上使用。</p>
</li>
<li><p>AsyncTask的原理：</p>
<p> (1).AsyncTask中有两个线程池：SerialExecutor和THREAD_POOL_EXECUTOR。前者是用于任务的排队，默认是串行的线程池；后者用于真正执行任务。AsyncTask中还有一个Handler，即InternalHandler，用于将执行环境从线程池切换到主线程。AsyncTask内部就是通过InternalHandler来发送任务执行的进度以及执行结束等消息。</p>
<p> (2).AsyncTask排队执行过程：系统先把参数Params封装为FutureTask对象，它相当于Runnable；接着将FutureTask交给SerialExecutor的execute方法，它先把FutureTask插入到任务队列tasks中，如果这个时候没有正在活动的AsyncTask任务，那么就会执行下一个AsyncTask任务，同时当一个AsyncTask任务执行完毕之后，AsyncTask会继续执行其他任务直到所有任务都被执行为止。</p>
</li>
<li><p>HandlerThread就是一种可以使用Handler的Thread，它的实现就是在run方法中通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环，这样在实际的使用中就允许在HandlerThread中创建Handler了，外界可以通过Handler的消息方式通知HandlerThread执行一个具体的任务。HandlerThread的run方法是一个无限循环，因此当明确不需要再使用HandlerThread的时候，可以通过它的quit或者quitSafely方法来终止线程的执行。HandlerThread的最主要的应用场景就是用在IntentService中。</p>
</li>
<li><p>IntentService是一个继承自Service的抽象类，要使用它就要创建它的子类。IntentService适合执行一些高优先级的后台任务，这样不容易被系统杀死。IntentService的onCreate方法中会创建HandlerThread，并使用HandlerThread的Looper来构造一个Handler对象ServiceHandler，这样通过ServiceHandler对象发送的消息最终都会在HandlerThread中执行。IntentService会将Intent封装到Message中，通过ServiceHandler发送出去，在ServiceHandler的handleMessage方法中会调用IntentService的抽象方法onHandleIntent，所以IntentService的子类都要是实现这个方法。</p>
</li>
</ol>
<h2 id="11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60"><a href="#11-3_Android_u4E2D_u7684_u7EBF_u7A0B_u6C60" class="headerlink" title="11.3 Android中的线程池"></a>11.3 Android中的线程池</h2><p><strong>使用线程池的好处</strong>：</p>
<ol>
<li>重用线程，避免线程的创建和销毁带来的性能开销；</li>
<li>能有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致的阻塞现象；</li>
<li>能够对线程进行简单的管理，并提供定时执行以及指定间隔循环执行等功能。</li>
</ol>
<p>Executor只是一个接口，真正的线程池是ThreadPoolExecutor。ThreadPoolExecutor提供了一系列参数来配置线程池，通过不同的参数可以创建不同的线程池，Android的线程池都是通过Executors提供的工厂方法得到的。</p>
<p><strong>ThreadPoolExecutor的构造参数</strong>：</p>
<ol>
<li>corePoolSize：核心线程数，默认情况下，核心线程会在线程中一直存活；</li>
<li>maximumPoolSize：最大线程数，当活动线程数达到这个数值后，后续的任务将会被阻塞；</li>
<li>keepAliveTime：非核心线程闲置时的超时时长，超过这个时长，闲置的非核心线程就会被回收；</li>
<li>unit：用于指定keepAliveTime参数的时间单位，有TimeUnit.MILLISECONDS、TimeUnit.SECONDS、TimeUnit.MINUTES等；</li>
<li>workQueue：任务队列，通过线程池的execute方法提交的Runnable对象会存储在这个参数中；</li>
<li>threadFactory：线程工厂，为线程池提供创建新线程的功能。它是一个接口，它只有一个方法Thread newThread(Runnable r)；</li>
<li>RejectedExecutionHandler：当线程池无法执行新任务时，可能是由于任务队列已满或者是无法成功执行任务，这个时候就会调用这个Handler的rejectedExecution方法来通知调用者，默认情况下，rejectedExecution会直接抛出一个rejectedExecutionException。</li>
</ol>
<p><strong>ThreadPoolExecutor执行任务的规则</strong>：</p>
<ol>
<li>如果线程池中的线程数未达到核心线程的数量，那么会直接启动一个核心线程来执行任务；</li>
<li>如果线程池中的线程数量已经达到或者超过核心线程的数量，那么任务会被插入到任务队列中排队等待执行；</li>
<li>如果在步骤2中无法将任务插入到的任务队列中，可能是任务队列已满，这个时候如果线程数量没有达到规定的最大值，那么会立刻启动非核心线程来执行这个任务；</li>
<li>如果步骤3中线程数量已经达到线程池规定的最大值，那么就拒绝执行此任务，ThreadPoolExecutor会调用RejectedExecutionHandler的rejectedExecution方法来通知调用者。</li>
</ol>
<p><strong>AsyncTask的THREAD_POOL_EXECUTOR线程池的配置</strong>：</p>
<ol>
<li>corePoolSize=CPU核心数+1；</li>
<li>maximumPoolSize=2倍的CPU核心数+1；</li>
<li>核心线程无超时机制，非核心线程在闲置时间的超时时间为1s；</li>
<li>任务队列的容量为128。</li>
</ol>
<p><strong>Android中常见的4类具有不同功能特性的线程池</strong>：</p>
<ol>
<li>FixedThreadPool：线程数量固定的线程池，它只有核心线程；</li>
<li>CachedThreadPool：线程数量不固定的线程池，它只有非核心线程；</li>
<li>ScheduledThreadPool：核心线程数量固定，非核心线程数量没有限制的线程池，主要用于执行定时任务和具有固定周期的任务；</li>
<li>SingleThreadPool：只有一个核心线程的线程池，确保了所有的任务都在同一个线程中按顺序执行。</li>
</ol>
<h1 id="u7B2C_u5341_u4E8C_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache"><a href="#u7B2C_u5341_u4E8C_u7AE0_Bitmap_u7684_u52A0_u8F7D_u548CCache" class="headerlink" title="第十二章 Bitmap的加载和Cache"></a>第十二章 Bitmap的加载和Cache</h1><h2 id="12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D"><a href="#12-1_Bitmap_u7684_u9AD8_u901F_u52A0_u8F7D" class="headerlink" title="12.1 Bitmap的高速加载"></a>12.1 Bitmap的高速加载</h2><ol>
<li><p>Bitmap是如何加载的？</p>
<p> BitmapFactory类提供了四类方法：decodeFile、decodeResource、decodeStream和decodeByteArray从不同来源加载出一个Bitmap对象，最终的实现是在底层实现的。</p>
</li>
<li><p>如何高效加载Bitmap？</p>
<p> 采用BitmapFactory.Options按照一定的采样率来加载所需尺寸的图片，因为imageview所需的图片大小往往小于图片的原始尺寸。</p>
</li>
<li><p>BitmapFactory.Options的inSampleSize参数，即采样率<br>官方文档指出采样率的取值应该是2的指数，例如k，那么采样后的图片宽高均为原图片大小的 1/k。<br>如何获取采样率？</p>
<p> 下面是常用的获取采样率的代码片段：</p>
<pre><code>public Bitmap decodeSampledBitmapFromResource(Resources res, int resId, int reqWidth, int reqHeight) {
    // First decode with inJustDecodeBounds=true to check dimensions
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeResource(res, resId, options);

    // Calculate inSampleSize
    options.inSampleSize = calculateInSampleSize(options, reqWidth, reqHeight);

    // Decode bitmap with inSampleSize set
    options.inJustDecodeBounds = false;
    return BitmapFactory.decodeResource(res, resId, options);
}

public int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
    if (reqWidth == 0 || reqHeight == 0) {
        return 1;
    }

    // Raw height and width of image
    final int height = options.outHeight;
    final int width = options.outWidth;
    Log.d(TAG, &quot;origin, w= &quot; + width + &quot; h=&quot; + height);
    int inSampleSize = 1;

    if (height &gt; reqHeight || width &gt; reqWidth) {
        final int halfHeight = height / 2;
        final int halfWidth = width / 2;

        // Calculate the largest inSampleSize value that is a power of 2 and
        // keeps both height and width larger than the requested height and width.
        while ((halfHeight / inSampleSize) &gt;= reqHeight &amp;&amp; (halfWidth / inSampleSize) &gt;= reqWidth) {
            inSampleSize *= 2;
        }
    }

    Log.d(TAG, &quot;sampleSize:&quot; + inSampleSize);
    return inSampleSize;
}
</code></pre><p> 将inJustDecodeBounds设置为true的时候，BitmapFactory只会解析图片的原始宽高信息，并不会真正的加载图片，所以这个操作是轻量级的。需要注意的是，这个时候BitmapFactory获取的图片宽高信息和图片的位置以及程序运行的设备有关，这都会导致BitmapFactory获取到不同的结果。</p>
</li>
</ol>
<h2 id="12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565"><a href="#12-2_Android_u4E2D_u7684_u7F13_u5B58_u7B56_u7565" class="headerlink" title="12.2 Android中的缓存策略"></a>12.2 Android中的缓存策略</h2><ol>
<li>最常用的缓存算法是LRU，核心是当缓存满时，会优先淘汰那些近期最少使用的缓存对象，系统中采用LRU算法的缓存有两种：LruCache(内存缓存)和DiskLruCache(磁盘缓存)。</li>
<li>LruCache是Android 3.1才有的，通过support-v4兼容包可以兼容到早期的Android版本。LruCache类是一个线程安全的泛型类，它内部采用一个LinkedHashMap以强引用的方式存储外界的缓存对象，其提供了get和put方法来完成缓存的获取和添加操作，当缓存满时，LruCache会移除较早使用的缓存对象，然后再添加新的缓存对象。</li>
<li>DiskLruCache磁盘缓存，它不属于Android sdk的一部分，<a href="/uploads/20160826/DiskLruCache.java">它的源码可以在这里下载</a><br>DiskLruCache的创建、缓存查找和缓存添加操作</li>
<li>ImageLoader的实现 具体内容看源码，<a href="/uploads/20160826/ImageLoader.java">点击下载</a><br>功能：图片的同步/异步加载，图片压缩，内存缓存，磁盘缓存，网络拉取</li>
</ol>
<h2 id="12-3_ImageLoader_u7684_u4F7F_u7528"><a href="#12-3_ImageLoader_u7684_u4F7F_u7528" class="headerlink" title="12.3 ImageLoader的使用"></a>12.3 ImageLoader的使用</h2><p>避免发生列表item错位的解决方法：给显示图片的imageview添加tag属性，值为要加载的图片的目标url，显示的时候判断一下url是否匹配。<br>优化列表的卡顿现象</p>
<ol>
<li>不要在getView中执行耗时操作，不要在getView中直接加载图片，否则肯定会导致卡顿；</li>
<li>控制异步任务的执行频率：在列表滑动的时候停止加载图片，等列表停下来以后再加载图片；</li>
<li>使用硬件加速来解决莫名的卡顿问题，给Activity添加配置<code>android:hardwareAccelerated=&quot;true&quot;</code>。</li>
</ol>
<h1 id="u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F"><a href="#u7B2C_u5341_u4E09_u7AE0_uFF1A_u7EFC_u5408_u6280_u672F" class="headerlink" title="第十三章：综合技术"></a>第十三章：综合技术</h1><h2 id="13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F"><a href="#13-1__u4F7F_u7528CrashHandler_u6765_u83B7_u53D6_u5E94_u7528_u7684Crash_u4FE1_u606F" class="headerlink" title="13.1 使用CrashHandler来获取应用的Crash信息"></a>13.1 使用CrashHandler来获取应用的Crash信息</h2><p>应用发生Crash在所难免，但是如何采集crash信息以供后续开发处理这类问题呢？利用Thread类的setDefaultUncaughtExceptionHandler方法！defaultUncaughtHandler是Thread类的静态成员变量，所以如果我们将自定义的UncaughtExceptionHandler设置给Thread的话，那么当前进程内的所有线程都能使用这个UncaughtExceptionHandler来处理异常了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setDefaultUncaughtExceptionHandler</span><span class="params">(UncaughtExceptionHandler handler)</span> </span>&#123;</span><br><span class="line">    Thread.defaultUncaughtHandler = handler;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里实现了一个简易版本的UncaughtExceptionHandler类的子类<a href="/uploads/20160826/CrashHandler.java">CrashHandler，点击下载</a>。</p>
<p>CrashHandler的使用方式就是在Application的onCreate方法中设置一下即可</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在这里为应用设置异常处理程序，然后我们的程序才能捕获未处理的异常</span></span><br><span class="line">CrashHandler crashHandler = CrashHandler.getInstance();</span><br><span class="line">crashHandler.init(<span class="keyword">this</span>);</span><br></pre></td></tr></table></figure>
<h2 id="13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C"><a href="#13-2__u4F7F_u7528multidex_u6765_u89E3_u51B3_u65B9_u6CD5_u6570_u8D8A_u754C" class="headerlink" title="13.2 使用multidex来解决方法数越界"></a>13.2 使用multidex来解决方法数越界</h2><p>在Android中单个dex文件所能够包含的最大方法数是65536，这包含Android Framework、依赖的jar以及应用本身的代码中的所有方法。如果方法数超过了最大值，那么编译会报错<code>DexIndexOverflowException: method ID not in [0, 0xffff]:65536</code>。</p>
<p>有时方法数没有超过最大值，但是安装在低版本手机上时应用异常终止了，报错：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">E/<span class="string">dalvikvm :</span> Optimization failed</span><br><span class="line">E<span class="regexp">/installed : dexopt failed on '/</span>data<span class="regexp">/dalvik-cache/</span>data<span class="annotation">@app</span><span class="annotation">@com</span>.ryg.multidextest-<span class="number">2.</span>apk<span class="annotation">@classes</span>.dex<span class="string">' res=65280</span></span><br></pre></td></tr></table></figure>
<p>这是因为应用在安装的时候，系统会通过dexopt程序来优化dex文件，在优化的过程中dexopt采用一个固定大小的缓冲区来存储应用中所有方法的信息，这个缓冲区就是LinearAlloc。LinearAlloc缓冲区在新版本的Android系统中大小是8MB或者16MB，但是在Android 2.2和2.3中却只有5MB，当待安装的应用的方法数比较多的时候，尽管它还没有达到最大方法数，但是它的存储空间仍然有可能超过5MB，这种情况下dexopt就会报错导致安装失败。</p>
<p>如何解决方法数越界的问题呢？ Google在2014年提出了简单方便的multidex的解决方案。<br>在Android 5.0之前使用multidex需要引入android-support-multidex.jar包，从Android 5.0开始，系统默认支持了multidex，它可以从apk中加载多个dex。这里Multidex方案主要针对AndroidStudio和Gradle编译环境。</p>
<p>使用Multidex的步骤：</p>
<ol>
<li><p>在build.gradle文件中添加multiDexEnabled true</p>
<pre><code>android {
    ...

    defaultConfig {
        ...

        multiDexEnabled true // [添加的配置] enable multidex support
    }
    ...
}
</code></pre></li>
<li><p>添加对multidex的依赖</p>
<pre><code>compile &apos;com.android.support:multidex:1.0.0&apos;
</code></pre></li>
<li><p>在代码中添加对multidex的支持，这里有三种方案：</p>
<p> ① 在AndroidManifest文件中指定Application为MultiDexApplication；</p>
<pre><code>&lt;application android:name=&quot;android.support.multidex.MultiDexApplication&quot;
...
&lt;/application&gt;
</code></pre><p> ② 让应用的Application继承自MultiDexApplication；</p>
<p> ③ 重写Application的attachBaseContext方法，这个方法要先于onCreate方法执行；</p>
<pre><code>public class TestApplication extends Application {

    @Override
    protected void attachBaseContext(Context base) {
        super.attachBaseContext(base);
        MultiDex.install(this);
    }
}
</code></pre></li>
</ol>
<p>采用上面的配置之后，如果应用的方法数没有越界，那么Gradle并不会生成多个dex文件；如果方法数越界后，Gradle就会在apk中打包2个或者多个dex文件，具体会打包多少个dex文件要看当前项目的代码规模。在有些情况下，可能需要指定主dex文件中所要包含的类，这个可以通过–main-dex-list选项来实现这个功能。</p>
<p>build.gradle：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">afterEvaluate &#123;</span><br><span class="line">    <span class="keyword">println</span> <span class="string">"afterEvaluate"</span></span><br><span class="line">    tasks.matching &#123;</span><br><span class="line">        it.name.startsWith(<span class="string">'dex'</span>)</span><br><span class="line">    &#125;.<span class="keyword">each</span> &#123; dx -&gt;</span><br><span class="line">        <span class="keyword">def</span> listFile = <span class="keyword">project</span>.rootDir.absolutePath + <span class="string">'/app/maindexlist.txt'</span></span><br><span class="line">        <span class="keyword">println</span> <span class="string">"root dir:"</span> + <span class="keyword">project</span>.rootDir.absolutePath</span><br><span class="line">        <span class="keyword">println</span> <span class="string">"dex task found: "</span> + dx.name</span><br><span class="line">        <span class="keyword">if</span> (dx.additionalParameters == <span class="keyword">null</span>) &#123;</span><br><span class="line">            dx.additionalParameters = []</span><br><span class="line">        &#125;</span><br><span class="line">        dx.additionalParameters += <span class="string">'--multi-dex'</span></span><br><span class="line">        dx.additionalParameters += <span class="string">'--main-dex-list='</span> + listFile</span><br><span class="line">        dx.additionalParameters += <span class="string">'--minimal-main-dex'</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>maindexlist.txt：</p>
<pre><code>com/ryg/multidextest/TestApplication.class
com/ryg/multidextest/MainActivity.class

// multidex
android/support/multidex/MultiDex.class
android/support/multidex/MultiDexApplication.class
android/support/multidex/MultiDexExtractor.class
android/support/multidex/MultiDexExtractor$1.class
android/support/multidex/MultiDex$V4.class
android/support/multidex/MultiDex$V14.class
android/support/multidex/MultiDex$V19.class
android/support/multidex/ZipUtil.class
android/support/multidex/ZipUtil$CentralDirectory.class
</code></pre><p>–multi-dex表明当方法数越界时生成多个dex文件，–main-dex-list指定了要在主dex中打包的类的列表，–minimal-main-dex表明只有–main-dex-list所指定的类才能打包到主dex中。multidex的jar包中的9个类必须要打包到主dex中，其次不能在Application中成员以及代码块中访问其他dex中的类，否个程序会因为无法加载对应的类而中止执行。</p>
<p>Multidex方案可能带来的问题：</p>
<ol>
<li>应用启动速度会降低，因为应用启动的时候会加载额外的dex文件，甚至可能出现ANR现象。所以要避免生成较大的dex文件；</li>
<li>需要做大量的兼容性测试，因为Dalvik LinearAlloc的bug，可能导致使用multidex的应用无法在Android 4.0以前的手机上运行。同时由于Dalvik linearAlloc的bug，有可能会出现应用在运行中由于采用了multidex方案从而产生大量的内存消耗的情况，这会导致奔溃。</li>
</ol>
<p>在实际项目中，1.中的现象是客观存在的，但是2.中的现象目前极少遇到。</p>
<h2 id="13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F"><a href="#13-3_Android_u7684_u52A8_u6001_u52A0_u8F7D_u6280_u672F" class="headerlink" title="13.3 Android的动态加载技术"></a>13.3 Android的动态加载技术</h2><p>动态加载技术又称插件化技术，将应用插件化可以减轻应用的内存和CPU占用，还可以在不发布新版本的情况下更新某些模块。不同的插件化方案各有特色，但是都需要解决三个基础性问题：资源访问，Activity生命周期管理和插件ClassLoader的管理。</p>
<p>宿主和插件：宿主是指普通的apk，插件是经过处理的dex或者apk。在主流的插件化框架中多采用特殊处理的apk作为插件，处理方式往往和编译以及打包环节有关，另外很多插件化框架都需要用到代理Activity的概念，插件Activity的启动大多数是借助一个代理Activity来实现的。</p>
<p>三个基础性问题的解决方案：</p>
<ol>
<li>资源访问：宿主程序调起未安装的插件apk，插件中凡是R开头的资源都不能访问了，因为宿主程序中并没有插件的资源，通过R来访问插件的资源是行不通的。<br>Activity的资源访问是通过ContextImpl来完成的，它有两个方法getAssets()和getResources()方法是用来加载资源的。<br>具体实现方式是通过反射，调用AssetManager的addAssetPath方法添加插件的路径，然后将插件apk中的资源加载到Resources对象中即可。</li>
<li>Activity生命周期管理：有两种常见的方式，反射方式和接口方式。反射方式就是通过反射去获取Activity的各个生命周期方法，然后在代理Activity中去调用插件Activity对应的生命周期方法即可。<br>反射方式代码繁琐，性能开销大。接口方式将Activity的生命周期方法提取出来作为一个接口，然后通过代理Activity去调用插件Activity的生命周期方法，这样就完成了插件Activity的生命周期管理。</li>
<li>插件ClassLoader的管理：为了更好地对多插件进行支持，需要合理地去管理各个插件的DexClassLoader，这样同一个插件就可以采用同一个ClassLoader去加载类，从而避免了多个ClassLoader加载同一个类时所引起的类型转换错误。</li>
</ol>
<p>其他详细信息看作者插件化框架 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">singwhatiwanna/dynamic-load-apk</a></p>
<h2 id="13-4__u53CD_u7F16_u8BD1_u521D_u6B65"><a href="#13-4__u53CD_u7F16_u8BD1_u521D_u6B65" class="headerlink" title="13.4 反编译初步"></a>13.4 反编译初步</h2><p>反编译可查看<a href="/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/">Android安全机制之反编译</a></p>
<p>二次打包：</p>
<pre><code>apktool.bat b [解包后文件所在的位置] [二次打包之后的文件名]
</code></pre><p>签名：</p>
<pre><code>java -jar signapk.jar testkey.x509.pem testkey.pk8 [未签名apk] [已签名apk]
</code></pre><h1 id="u7B2C_u5341_u4E94_u7AE0_Android_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u4E94_u7AE0_Android_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十五章 Android性能优化"></a>第十五章 Android性能优化</h1><p>2015年Google关于Android性能优化典范的专题视频：</p>
<p><a href="https://www.youtube.com/playlist?list=PLWz5rJ2EKKc9CBxr3BVjPTPoDPLdPIFCE" target="_blank" rel="external">Youtube视频地址</a></p>
<h2 id="15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5"><a href="#15-1_Android_u7684_u6027_u80FD_u4F18_u5316_u65B9_u6CD5" class="headerlink" title="15.1 Android的性能优化方法"></a>15.1 Android的性能优化方法</h2><ol>
<li><p>布局优化</p>
<p> (1).删除布局中无用的组件和层级，有选择地使用性能较低的ViewGroup；</p>
<p> (2).使用<include>、<merge>、<viewstub>等标签：<include>标签主要用于布局重用，<merge>标签一般和<include>配合使用，它可以减少布局中的层级；<viewstub>标签则提供了按需加载的功能，当需要的时候才会将ViewStub中的布局加载到内存，提供了程序的初始化效率。</viewstub></include></merge></include></viewstub></merge></include></p>
<p> (3).<include>标签只支持android:layout_开头的属性，android:id属性例外。</include></p>
<p> (4).ViewStub继承自View，它非常轻量级且宽高都为0，它本身不参与任何的布局和绘制过程。实际开发中，很多布局文件在正常情况下不会显示，例如网络异常时的界面，这个时候就没有必要在整个界面初始化的时候加载进行，通过ViewStub可以做到在需要的时候再加载。<br> 如下面示例，android:id是ViewStub的id，而android:inflatedId是布局的根元素的id。</p>
<pre><code>&lt;ViewStub android:id=&quot;@+id/xxx&quot;
  android:inflatedId=&quot;@+id/yyy&quot;
  android:layout=&quot;@layout/zzz&quot;
  ...
&lt;/ViewStub&gt;
</code></pre></li>
<li><p>绘制优化</p>
<p> (1).在onDraw中不要创建新的布局对象，因为onDraw会被频繁调用；<br> (2).onDraw方法中不要指定耗时任务，也不能执行成千上万次的循环操作。</p>
</li>
<li><p>内存泄露优化</p>
<p> 可能导致内存泄露的场景很多，例如静态变量、单例模式、属性动画、AsyncTask、Handler等等</p>
</li>
<li><p>响应速度优化和ANR日志分析</p>
<p> (1).ANR出现的情况：Activity如果5s内没有响应屏幕触摸事件或者键盘输入事件就会ANR，而BroadcastReceiver如果10s内没有执行完操作也会出现ANR。</p>
<p> (2).当一个进程发生了ANR之后，系统会在/data/anr目录下创建一个文件traces.txt，通过分析这个文件就能定位ANR的原因。</p>
</li>
<li><p>ListView和Bitmap优化</p>
<p> (1).ListView优化：采用ViewHolder并避免在getView方法中执行耗时操作；根据列表的滑动状态来绘制任务的执行频率；可以尝试开启硬件加速来使ListView的滑动更加流畅。</p>
<p> (2).Bitmap优化：根据需要对图片进行采样，详情请看第12章 Bitmap的加载和Cache。</p>
</li>
<li><p>线程优化</p>
<p> 采用线程池，详情请看第11章 Android的线程和线程池。</p>
</li>
<li><p>一些性能优化建议</p>
<p> (1).不要过多使用枚举，枚举占用的内存空间要比整型大；</p>
<p> (2).常量请使用static final来修饰；</p>
<p> (3).使用一些Android特有的数据结构，比如SparseArray和Pair等，他们都具有更好的性能；</p>
<p> (4).适当使用软引用和弱引用；</p>
<p> (5).采用内存缓存和磁盘缓存；</p>
<p> (6).尽量采用静态内部类，这样可以避免潜在的由于内部类而导致的内存泄露。</p>
</li>
</ol>
<h2 id="15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177"><a href="#15-2__u5185_u5B58_u6CC4_u9732_u5206_u6790_u4E4BMAT_u5DE5_u5177" class="headerlink" title="15.2 内存泄露分析之MAT工具"></a>15.2 内存泄露分析之MAT工具</h2><p>MAT是功能强大的内存分析工具，主要有Histograms和Dominator Tree等功能。</p>
<p>详细的可以查看 <a href="http://gold.xitu.io/entry/563b341e60b20bd506b55592" target="_blank" rel="external">内存泄露从入门到精通三部曲</a>。</p>
<h2 id="15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027"><a href="#15-3__u63D0_u9AD8_u7A0B_u5E8F_u7684_u53EF_u7EF4_u62A4_u6027" class="headerlink" title="15.3 提高程序的可维护性"></a>15.3 提高程序的可维护性</h2><ol>
<li>命名规范。比如私有成员变量以m开头，静态成员变量以s开头，常量全部以大写字母表示；</li>
<li>代码的排版上需要留出合理的空白来区分不同的代码块；</li>
<li>仅为非常关键的代码添加注释，其他地方不用注释。</li>
</ol>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager"><a href="#u7B2C_u516B_u7AE0_uFF1A_u7406_u89E3Window_u548CWindowManager]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一步步深入解析AIDL]]></title>
    <link href="http://yuqirong.me/2016/07/28/%E4%B8%80%E6%AD%A5%E6%AD%A5%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90AIDL/"/>
    <id>http://yuqirong.me/2016/07/28/一步步深入解析AIDL/</id>
    <published>2016-07-28T14:55:37.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需要在两个进程之间进行一些数据的交换。而在深入学习 Android 的过程中难免会遇到 IPC 的相关问题，比如常见的有在自己的应用程序中读取手机联系人的信息，这就涉及到 IPC 了。因为自己的应用程序是一个进程，通讯录也是一个进程，只不过获取通讯录的数据信息是通过 Content Provider 的方式来实现的。</p>
<p>对于初学者来说，在一开始接触 IPC 时可能会摸不着头脑，因为网上很多博客在讲 Android IPC 时通常都是长篇大论，没有从例子着手。基于以上种种原因以及希望对 AIDL 有一个更深入的理解，本篇博文就诞生了。在 Android 系统中，IPC 的方式有很多种，比如有 Messenger 、AIDL 和 ContentProvider 等。我们今天就来讲讲其中的 AIDL ，AIDL 也是比较常见和经常使用的一种 IPC 方式。希望读者在看完本篇之后对于 AIDL 有一个比较深入的理解。</p>
<h1 id="u4EC0_u4E48_u662F_AIDL"><a href="#u4EC0_u4E48_u662F_AIDL" class="headerlink" title="什么是 AIDL"></a>什么是 AIDL</h1><p>首先我们对于新的事物都会有一个疑问，那就是什么是 AIDL？</p>
<p>AIDL 的全称是 Android Interface Definition Language(即 Android 接口定义语言)。通常对于 AIDL 的使用有三步流程：</p>
<ol>
<li>定义 AIDL 接口；</li>
<li>在 Service 中创建对应的 Stub 对象；</li>
<li>将该服务暴露给其他进程调用；</li>
</ol>
<p>讲完了流程，我们就又有一个疑问了，Android系统中实现 IPC 有这么多方式，到底应该在什么情况下使用 AIDL 呢？</p>
<p>Android 官方文档给出的答案是：</p>
<p>Note: Using AIDL is necessary only if you allow clients from different applications to access your service for IPC and want to handle multithreading in your service. If you do not need to perform concurrent IPC across different applications, you should create your interface by implementing a Binder or, if you want to perform IPC, but do not need to handle multithreading, implement your interface using a Messenger. Regardless, be sure that you understand Bound Services before implementing an AIDL.</p>
<p>使用AIDL只有在你允许来自不同应用的客户端跨进程通信访问你的Service，并且想要在你的Service种处理多线程的时候才是必要的。 简单地来说，就是多个客户端，多个线程并发的情况下要使用 AIDL 。官方文档还指出，如果你的 IPC 不需要适用于多个客户端的，那就使用 Binder ；如果你的想要 IPC ，但是不需要多线程，那就选择 Messenger 。</p>
<p>相信大家到这里对于 AIDL 有一个初步的概念了，那么下面我们就来举个例子讲解一下 AIDL 。</p>
<h1 id="AIDL_u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#AIDL_u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="AIDL的使用方法"></a>AIDL的使用方法</h1><p>我们来模拟一下需要进行 IPC 的情况，现在有客户端和服务端，客户端通过 AIDL 来和服务端进行 IPC 。我们假定现在客户端需要传一个 Person 类的对象给服务端，之后服务端回传给客户端一个 Person 类的集合。</p>
<p>先来看看服务端的相关代码，以下 Person.aidl 文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Person.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"></span><br><span class="line">parcelable Person;</span><br></pre></td></tr></table></figure>
<p>注意在 IPC 机制中传递的自定义对象需要序列化，所以要实现 Parcelable 接口。在 AIDL 文件中使用 <code>parcelable</code> 关键字声明。有了 Person.aidl 之后，我们就要创建 AIDL 接口了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IMyAidlInterface.aidl</span></span><br><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Declare any non-default types here with import statements</span></span><br><span class="line"><span class="keyword">import</span> com.yuqirong.aidldemo.Person;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(in Person person)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 IMyAidlInterface.aidl 里，主要声明一个用于添加 Person 对象的抽象方法。另外，需要注意以下几点：</p>
<ol>
<li>Person 类需要手动去 import ，在 AIDL 文件中不能自动导包；</li>
<li>在 <code>addPerson</code> 方法里需要声明参数是 in 的，用来表示该参数是传入的。除了 in 之外，还有 out 和 inout ；</li>
</ol>
<p>下面我们要创建一个 Service 用于和客户端进行 IPC 。这里还要把该 Service 运行在一个新的进程里。我们只要在 AndroidManifest.xml 中声明 <code>android:process=&quot;:remote&quot;</code> 就行了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyService</span> <span class="keyword">extends</span> <span class="title">Service</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MyService"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;Person&gt; persons = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Nullable</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> IBinder <span class="title">onBind</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line">        Log.i(TAG,<span class="string">"bind success"</span>);</span><br><span class="line">        <span class="keyword">return</span> mBinder;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IBinder mBinder = <span class="keyword">new</span> IMyAidlInterface.Stub() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> List&lt;Person&gt; <span class="title">addPerson</span><span class="params">(Person person)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line">            <span class="comment">// 需要同步</span></span><br><span class="line">            <span class="keyword">synchronized</span> (persons)&#123;</span><br><span class="line">                persons.add(person);</span><br><span class="line">                <span class="keyword">return</span> persons;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中我们可以看到在 <code>onBind(Intent intent)</code> 方法中返回了 mBinder ，而客户端正是通过这个 mBinder 来和服务端进行 IPC 的。mBinder 是 IMyAidlInterface.Stub 匿名类的对象，IMyAidlInterface.Stub 其实是一个抽象类，继承自 Binder ，实现 <code>addPerson</code> 方法。这里要注意以下，在 <code>addPerson</code> 的方法中需要将 persons 同步，这是因为在服务端 AIDL 是运行在 Binder 线程池中的，有可能会有多个客户端同时连接，这时候就需要同步以防止数据出错。</p>
<p>服务端的代码差不多就这些，下面我们来看看客户端的，客户端也是需要 AIDL 文件的，可以从服务端中复制过来。需要注意的是包名和 AIDL 文件都要和服务端保持一致，否则在客户端反序列化的时候会出错。以下只截取了客户端部分关键代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 客户端用来和服务端IPC的接口</span></span><br><span class="line"><span class="keyword">private</span> IMyAidlInterface aidlInterface;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动服务端的服务，并进行绑定</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent();</span><br><span class="line">intent.setComponent(<span class="keyword">new</span> ComponentName(<span class="string">"com.yuqirong.aidldemo"</span>, <span class="string">"com.yuqirong.aidldemo.MyService"</span>));</span><br><span class="line">bindService(intent, conn, Context.BIND_AUTO_CREATE);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> ServiceConnection conn = <span class="keyword">new</span> ServiceConnection() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceConnected</span><span class="params">(ComponentName name, IBinder service)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在这里得到了和服务端进行通信的接口</span></span><br><span class="line">        aidlInterface = IMyAidlInterface.Stub.asInterface(service);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onServiceDisconnected</span><span class="params">(ComponentName name)</span> </span>&#123;</span><br><span class="line">        aidlInterface = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>客户端通过 Intent 启动并绑定服务端的 Service ，在 <code>onServiceConnected</code> 中通过 binder 对象得到了 aidlInterface 。之后客户端就可以使用 aidlInterface 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            List&lt;Person&gt; list = aidlInterface.addPerson(<span class="keyword">new</span> Person(<span class="string">"yuqirong"</span>, <span class="number">21</span>, <span class="string">"13567891023"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<p>我们注意到，在客户端调用 AIDL 接口方法时是新创建了一个子线程去执行的，这是因为在服务端在处理 AIDL 时有可能是很耗时的。如果在主线程中去执行，那么就有可能出现 ANR 的问题。所以为了避免 ANR ，在客户端调用 AIDL 的代码最好在子线程去执行。</p>
<p>整套 AIDL 的流程基本上就是这样的。通过这个简单的例子，相信对于 AIDL 有了一个初步的了解。下面我们就要去揭开 AIDL 是如何实现 IPC 的神秘面纱。</p>
<h1 id="u89E3_u6790AIDL"><a href="#u89E3_u6790AIDL" class="headerlink" title="解析AIDL"></a>解析AIDL</h1><p>现在我们终于要来看看 AIDL 是如何工作的？我们可以在工程中的 gen 目录下找到对应 AIDL 编译后的文件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.yuqirong.aidldemo;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IMyAidlInterface</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">IInterface</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="comment">/** Local-side IPC implementation stub class. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Stub</span> <span class="keyword">extends</span> <span class="title">android</span>.<span class="title">os</span>.<span class="title">Binder</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">    </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> java.lang.String DESCRIPTOR = <span class="string">"com.yuqirong.aidldemo.IMyAidlInterface"</span>;</span><br><span class="line">        <span class="comment">/** Construct the stub at attach it to the interface. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Stub</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.attachInterface(<span class="keyword">this</span>, DESCRIPTOR);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Cast an IBinder object into an com.yuqirong.aidldemo.IMyAidlInterface interface,</span><br><span class="line">         * generating a proxy if needed.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">static</span> com.yuqirong.aidldemo.<span class="function">IMyAidlInterface <span class="title">asInterface</span><span class="params">(android.os.IBinder obj)</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> ((obj==<span class="keyword">null</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            android.os.IInterface iin = obj.queryLocalInterface(DESCRIPTOR);</span><br><span class="line">            <span class="keyword">if</span> (((iin!=<span class="keyword">null</span>)&amp;&amp;(iin <span class="keyword">instanceof</span> com.yuqirong.aidldemo.IMyAidlInterface))) &#123;</span><br><span class="line">                <span class="keyword">return</span> ((com.yuqirong.aidldemo.IMyAidlInterface)iin);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> com.yuqirong.aidldemo.IMyAidlInterface.Stub.Proxy(obj);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTransact</span><span class="params">(<span class="keyword">int</span> code, android.os.Parcel data, android.os.Parcel reply, <span class="keyword">int</span> flags)</span> <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (code)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">case</span> INTERFACE_TRANSACTION:</span><br><span class="line">                &#123;</span><br><span class="line">                    reply.writeString(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">case</span> TRANSACTION_addPerson:</span><br><span class="line">                &#123;</span><br><span class="line">                    data.enforceInterface(DESCRIPTOR);</span><br><span class="line">                    com.yuqirong.aidldemo.Person _arg0;</span><br><span class="line">                    <span class="keyword">if</span> ((<span class="number">0</span>!=data.readInt())) &#123;</span><br><span class="line">                        _arg0 = com.yuqirong.aidldemo.Person.CREATOR.createFromParcel(data);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _arg0 = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result = <span class="keyword">this</span>.addPerson(_arg0);</span><br><span class="line">                    reply.writeNoException();</span><br><span class="line">                    reply.writeTypedList(_result);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.onTransact(code, data, reply, flags);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">com</span>.<span class="title">yuqirong</span>.<span class="title">aidldemo</span>.<span class="title">IMyAidlInterface</span></span><br><span class="line">        </span>&#123;</span><br><span class="line">            <span class="keyword">private</span> android.os.IBinder mRemote;</span><br><span class="line">            Proxy(android.os.IBinder remote)</span><br><span class="line">            &#123;</span><br><span class="line">                mRemote = remote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> android.os.<span class="function">IBinder <span class="title">asBinder</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> mRemote;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">public</span> java.lang.<span class="function">String <span class="title">getInterfaceDescriptor</span><span class="params">()</span></span><br><span class="line">            </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> DESCRIPTOR;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span><br><span class="line">             * Demonstrates some basic types that you can use as parameters</span><br><span class="line">             * and return values in AIDL.</span><br><span class="line">             */</span></span><br><span class="line">            <span class="annotation">@Override</span> <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException</span><br><span class="line">            &#123;</span><br><span class="line">                android.os.Parcel _data = android.os.Parcel.obtain();</span><br><span class="line">                android.os.Parcel _reply = android.os.Parcel.obtain();</span><br><span class="line">                java.util.List&lt;com.yuqirong.aidldemo.Person&gt; _result;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    _data.writeInterfaceToken(DESCRIPTOR);</span><br><span class="line">                    <span class="keyword">if</span> ((person!=<span class="keyword">null</span>)) &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">1</span>);</span><br><span class="line">                        person.writeToParcel(_data, <span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> &#123;</span><br><span class="line">                        _data.writeInt(<span class="number">0</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    mRemote.transact(Stub.TRANSACTION_addPerson, _data, _reply, <span class="number">0</span>);</span><br><span class="line">                    _reply.readException();</span><br><span class="line">                    _result = _reply.createTypedArrayList(com.yuqirong.aidldemo.Person.CREATOR);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">finally</span> &#123;</span><br><span class="line">                    _reply.recycle();</span><br><span class="line">                    _data.recycle();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> _result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TRANSACTION_addPerson = (android.os.IBinder.FIRST_CALL_TRANSACTION + <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Demonstrates some basic types that you can use as parameters</span><br><span class="line">     * and return values in AIDL.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> java.util.List&lt;com.yuqirong.aidldemo.Person&gt; addPerson(com.yuqirong.aidldemo.Person person) <span class="keyword">throws</span> android.os.RemoteException;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到编译后的 IMyAidlInterface.aidl 变成了一个接口，继承自 IInterface 。在 IMyAidlInterface 接口中我们发现主要分成两部分结构：抽象类 Stub 和原来 aidl 中声明的 <code>addPerson</code> 方法。</p>
<p>重点在于 Stub 类，下面我们来分析一下。从 Stub 类中我们可以看到是继承自 Binder 并且实现了 IMyAidlInterface 接口。 Stub 类的基本结构如下：</p>
<ul>
<li><code>asInterface(android.os.IBinder obj)</code> 方法；</li>
<li><code>asBinder()</code> 方法；</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法；</li>
<li>静态类 <code>Proxy</code>，主要方法是 <code>addPerson(com.yuqirong.aidldemo.Person person)</code> ；</li>
<li>静态常量 <code>TRANSACTION_addPerson</code> ；</li>
</ul>
<p><strong>asInterface(android.os.IBinder obj)</strong></p>
<p>我们先从 <code>asInterface(android.os.IBinder obj)</code> 方法入手，在上面的代码中可以看到，主要的作用就是根据传入的Binder对象转换成客户端需要的 IMyAidlInterface 接口。如果服务端和客户端处于同一个进程，那么该方法得到的就是服务端 Stub 对象本身，也就是上面 AIDL 例子 MyService 中的 mBinder 对象；否则返回的是系统封装后的 Stub.Proxy ，也就是一个代理类，在这个代理中实现跨进程通信。</p>
<p><strong>asBinder()</strong></p>
<p>该方法就是返回当前的 Binder 对象。</p>
<p><strong>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</strong></p>
<p>在 <code>onTransact</code> 方法中，根据传入的 code 值会去执行服务端相对应的方法。其中静态变量 <code>TRANSACTION_addPerson</code> 就是其中的 code 值之一(在 AIDL 文件中声明的方法有多少个就有多少个对应的 code )。其中 data 就是服务端方法中所需要的参数，执行完后，最后把方法的返回结果放入 reply 中传递给客户端。若该方法返回 false ，那么客户端请求失败。</p>
<p><strong>Proxy中的addPerson(com.yuqirong.aidldemo.Person person)</strong></p>
<p>Proxy 类是实现了 IMyAidlInterface 接口，把其中的 <code>addPerson</code> 方法进行了重写。在方法中一开始创建了两个 Parcel 对象，其中一个用来把方法的参数装入，然后调用 <code>transact</code> 方法执行服务端的代码，执行完后把返回的结果装入另外一个 Parcel 对象中返回。</p>
<p>看完上面方法的介绍，我们回过头来看看 AIDL 例子中实现的流程。在客户端中通过 Intent 去绑定一个服务端的 Service 。在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 方法中通过返回的 service 可以得到对应的 AIDL 接口的实例。这是调用了 <code>asInterface(android.os.IBinder obj)</code> 方法来完成的。</p>
<p>客户端在 <code>onServiceConnected(ComponentName name, IBinder service)</code> 中得到的 service 正是服务端中的 mBinder 。当客户端调用 AIDL 接口时，AIDL 通过 Proxy 类中的 <code>addPerson</code> 来调用 <code>transact</code> 方法，<code>transact</code> 方法又会去调用服务端的 <code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code> 方法。 <code>onTransact</code> 方法是运行在服务端的 Binder 线程池中的。在 <code>onTransact</code> 中根据 code 执行相关 AIDL 接口的方法，方法的参数从 data 中获取。执行完毕之后把结果装入 reply 中返回给客户端。 AIDL 的流程基本上就是这样子了。</p>
<p>到了这里，大家就会发现 AIDL 底层的实现就是依靠 Binder 来完成的。为了方便大家的理解，这里给出一张 AIDL 机制的原理图( PS :该图来自于《Android开发艺术探索》，感谢任主席)：</p>
<p><img src="/uploads/20160728/20160728201234.png" alt="AIDL机制原理图"></p>
<h1 id="u7ED3_u5C3E"><a href="#u7ED3_u5C3E" class="headerlink" title="结尾"></a>结尾</h1><p>写到这里本篇博文就临近末尾了。 AIDL 在 Android IPC 机制中算得上是很重要的一部分，AIDL 主要是通过 Binder 来实现进程通信的。其实另一种 IPC 的方式 Messenger 底层也是通过 AIDL 来实现的。所以 AIDL 的重要性就不言而喻了。如果有兴趣的同学可以在理解 AIDL 的基础上去看看 Messenger 的源码。当然在上面的 AIDL 例子中的代码是很简单的，没有涉及到死亡代理、权限验证等功能，童鞋们可以自己去把这些相关的去学习下。</p>
<p>好了，最后附上 AIDL 例子的源码：</p>
<p><a href="/uploads/20160728/AIDLDemo.rar">AIDLDemo.rar</a></p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><p><a href="/2016/03/31/《Android开发艺术探索》笔记(上)/">《Android开发艺术探索》笔记(上) —— 第二章：IPC机制</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在 Android 系统中，进程间通信 (IPC) 是一种很重要的机制。IPC 产生的原因是某些情况下需]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="IPC" scheme="http://yuqirong.me/tags/IPC/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现炫酷的滑动返回效果]]></title>
    <link href="http://yuqirong.me/2016/07/07/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84%E6%BB%91%E5%8A%A8%E8%BF%94%E5%9B%9E%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/07/07/简单实现炫酷的滑动返回效果/</id>
    <published>2016-07-06T16:25:04.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功能，那就是滑动返回。比如知乎、百度贴吧等，用户在使用这一类的 app 都可以滑动返回上一个页面。不得不说这个设计很赞，是不是心动了呢？那就继续往下看吧！</p>
<p>在GitHub上有实现该效果的开源库 <a href="https://github.com/ikew0ng/SwipeBackLayout" target="_blank" rel="external">SwipeBackLayout</a> ，可以看到该库发展得已经非常成熟了。仔细看源码你会惊奇地发现其中的奥秘，没错，正是借助了 ViewDragHelper 来实现滑动返回的效果。ViewDragHelper 我想不必多说了，在我的博客中有很多的效果都是通过它来实现的。那么，下面我们就使用 ViewDragHelper 来实现这个效果吧。</p>
<h1 id="u81EA_u5B9A_u4E49_u5C5E_u6027"><a href="#u81EA_u5B9A_u4E49_u5C5E_u6027" class="headerlink" title="自定义属性"></a>自定义属性</h1><p>首先，我们应该先定义几个自定义属性，比如说支持用户从左边或者右边滑动返回，丰富用户的选择性。所以现在 attrs.xml 中定义如下属性：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SwipeBackLayout"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"swipe_mode"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"left"</span> <span class="attribute">value</span>=<span class="value">"0"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"right"</span> <span class="attribute">value</span>=<span class="value">"1"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>从上面的 xml 中可知，定义了一个枚举属性，左边为0，右边为1。</p>
<p>然后主角 SwipeBackLayout 就要登场了。</p>
<pre><code>public class SwipeBackLayout extends FrameLayout {

    private ViewDragHelper mViewDragHelper;
    // 主界面
    private View mainView;
    // 主界面的宽度
    private int mainViewWidth;
    // 模式，默认是左滑
    private int mode = MODE_LEFT;
    // 监听器
    private SwipeBackListener listener;
    // 是否支持边缘滑动返回, 默认是支持
    private boolean isEdge = true;

    private int mEdge;
    // 阴影Drawable
    private Drawable shadowDrawable;
    // 阴影Drawable固有宽度
    private int shadowDrawbleWidth;
    // 已经滑动的百分比
    private float movePercent;
    // 滑动的总长度
    private int totalWidth;
    // 默认的遮罩透明度
    private static final int DEFAULT_SCRIM_COLOR = 0x99000000;
    // 遮罩颜色
    private int scrimColor = DEFAULT_SCRIM_COLOR;
    // 透明度
    private static final int ALPHA = 255;

    private Paint mPaint;
    /**
     * 滑动的模式，左滑
     */
    public static final int MODE_LEFT = 0;
    /**
     * 滑动的模式，右滑
     */
    public static final int MODE_RIGHT = 1;
    // 最小滑动速度
    private static final int MINIMUM_FLING_VELOCITY = 400;

    private static final String TAG = &quot;SwipeBackLayout&quot;;

    public SwipeBackLayout(Context context) {
        this(context, null);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SwipeBackLayout(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.SwipeBackLayout);
        // 得到滑动模式，默认左滑
        mode = a.getInt(R.styleable.SwipeBackLayout_swipe_mode, MODE_LEFT);
        a.recycle();
        initView();
    }

    ...

}
</code></pre><h1 id="initView"><a href="#initView" class="headerlink" title="initView"></a>initView</h1><p>在构造器主要做的就是得到滑动模式，默认是左边滑动。之后调用 <code>initView()</code> 。那么我们来看看 <code>initView()</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化阴影Drawable</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initShadowView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">21</span>) &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right, getContext().getTheme());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shadowDrawable = getResources().getDrawable(mode == MODE_LEFT ? R.drawable.shadow_left : R.drawable.shadow_right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (shadowDrawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        shadowDrawbleWidth = shadowDrawable.getIntrinsicWidth();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> density = getResources().getDisplayMetrics().density;</span><br><span class="line">	<span class="comment">// 最小滑动速度</span></span><br><span class="line">    <span class="keyword">float</span> minVel = density * MINIMUM_FLING_VELOCITY;</span><br><span class="line">    initShadowView();</span><br><span class="line">    mViewDragHelper = ViewDragHelper.create(<span class="keyword">this</span>, <span class="keyword">new</span> ViewDragHelper.Callback() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryCaptureView</span><span class="params">(View child, <span class="keyword">int</span> pointerId)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> mainView == child; <span class="comment">// 只有是主界面时才可以被滑动</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">clampViewPositionHorizontal</span><span class="params">(View child, <span class="keyword">int</span> left, <span class="keyword">int</span> dx)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 根据模式区分</span></span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:  <span class="comment">// 左边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:  <span class="comment">// 右边</span></span><br><span class="line">                    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Math.abs(left) &gt; totalWidth) &#123;</span><br><span class="line">                        <span class="keyword">return</span> -totalWidth;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">return</span> left;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">return</span> left;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewPositionChanged</span><span class="params">(View changedView, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    movePercent = left * <span class="number">1f</span> / totalWidth;  <span class="comment">// 滑动的进度</span></span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    movePercent = Math.abs(left) * <span class="number">1f</span> / totalWidth;</span><br><span class="line">                    Log.i(TAG, <span class="string">"movePercent = "</span> + movePercent);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getViewHorizontalDragRange</span><span class="params">(View child)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (mode == MODE_LEFT) &#123;</span><br><span class="line">                <span class="keyword">return</span> Math.abs(totalWidth);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> -totalWidth;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onViewReleased</span><span class="params">(View releasedChild, <span class="keyword">float</span> xvel, <span class="keyword">float</span> yvel)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">switch</span> (mode) &#123;</span><br><span class="line">                <span class="keyword">case</span> MODE_LEFT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &gt; -mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;  <span class="comment">// 如果当前已经滑动超过子View宽度的一半，并且速度符合预期设置</span></span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);  <span class="comment">// 把当前界面finish</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &gt; mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();  <span class="comment">// 当前界面回到原位</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> MODE_RIGHT:</span><br><span class="line">                    <span class="keyword">if</span> (xvel &lt; mViewDragHelper.getMinVelocity() &amp;&amp; Math.abs(releasedChild.getLeft()) &gt; mainViewWidth / <span class="number">2.0f</span>) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (xvel &lt; -mViewDragHelper.getMinVelocity()) &#123;</span><br><span class="line">                        swipeBackToFinish(-totalWidth, <span class="number">0</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        swipeBackToRestore();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// 设置最小滑动速度</span></span><br><span class="line">    mViewDragHelper.setMinVelocity(minVel);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onFinishInflate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onFinishInflate();</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// 子View只能有一个</span></span><br><span class="line">        <span class="comment">// 获取子view</span></span><br><span class="line">        mainView = getChildAt(<span class="number">0</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the child of swipebacklayout can not be empty and must be the one"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 得到主界面的宽度</span></span><br><span class="line">    mainViewWidth = w;</span><br><span class="line">    <span class="comment">//总长度，包含了mainView的宽度以及阴影图片的宽度</span></span><br><span class="line">    totalWidth = mainViewWidth + shadowDrawbleWidth;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initView()</code> 中，设置了 mViewDragHelper 的最小滑动速度，并且设置了 mViewDragHelper 回调的接口。回调接口中的方法都有注释，相信大家应该都能看懂。另外在 <code>initView()</code> 中初始化了阴影图片，以备下面中使用。</p>
<h1 id="drawChild"><a href="#drawChild" class="headerlink" title="drawChild"></a>drawChild</h1><p>想要阴影在滑动中绘制出来，我们必须重写 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法，并且在 <code>onTouchEvent(MotionEvent event)</code> 里 <code>invalidate()</code> ,保证用户滑动过程中调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    Log.i(TAG, <span class="string">""</span> + (mViewDragHelper.getViewDragState() == ViewDragHelper.STATE_IDLE));</span><br><span class="line">    <span class="keyword">if</span> (child == mainView &amp;&amp; mViewDragHelper.getViewDragState() != ViewDragHelper.STATE_IDLE) &#123;</span><br><span class="line">        <span class="comment">// 绘制阴影</span></span><br><span class="line">        drawShadowDrawable(canvas, child);</span><br><span class="line">        <span class="comment">// 绘制遮罩层</span></span><br><span class="line">        drawScrimColor(canvas, child);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.drawChild(canvas, child, drawingTime);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    mViewDragHelper.processTouchEvent(event);</span><br><span class="line">    <span class="comment">// 重绘，保证在滑动的时候可以绘制阴影</span></span><br><span class="line">    invalidate();</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中调用 <code>drawShadowDrawable(Canvas canvas, View child)</code> 来绘制阴影以及 <code>drawScrimColor(Canvas canvas, View child)</code> 来绘制遮罩层。下面分别是两个方法的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 绘制阴影</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawShadowDrawable</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">    Rect drawableRect = <span class="keyword">new</span> Rect();</span><br><span class="line">    <span class="comment">// 得到mainView的矩形</span></span><br><span class="line">    child.getHitRect(drawableRect);</span><br><span class="line">    <span class="comment">// 设置shadowDrawable绘制的矩形</span></span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.left - shadowDrawbleWidth, drawableRect.top, drawableRect.left, drawableRect.bottom);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        shadowDrawable.setBounds(drawableRect.right, drawableRect.top, drawableRect.right + shadowDrawbleWidth, drawableRect.bottom);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置shadowDrawable的透明度,最低为0.3</span></span><br><span class="line">    shadowDrawable.setAlpha((<span class="keyword">int</span>) ((<span class="number">1</span> - movePercent &gt; <span class="number">0.3</span> ? <span class="number">1</span> - movePercent : <span class="number">0.3</span>) * ALPHA));</span><br><span class="line">    <span class="comment">// 将shadowDrawable绘制在canvas上</span></span><br><span class="line">    shadowDrawable.draw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制遮罩层</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawScrimColor</span><span class="params">(Canvas canvas, View child)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 根据滑动进度动态设置透明度</span></span><br><span class="line">    <span class="keyword">int</span> baseAlpha = (scrimColor &amp; <span class="number">0xFF000000</span>) &gt;&gt;&gt; <span class="number">24</span>;</span><br><span class="line">    <span class="keyword">int</span> alpha = (<span class="keyword">int</span>) (baseAlpha * (<span class="number">1</span> - movePercent));</span><br><span class="line">    <span class="keyword">int</span> color = alpha &lt;&lt; <span class="number">24</span> | (scrimColor &amp; <span class="number">0xffffff</span>);</span><br><span class="line">    <span class="comment">// 设置绘制矩形区域</span></span><br><span class="line">    Rect rect;</span><br><span class="line">    <span class="keyword">if</span> (mode == MODE_LEFT) &#123; <span class="comment">// 左滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(<span class="number">0</span>, <span class="number">0</span>, child.getLeft(), getHeight());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 右滑</span></span><br><span class="line">        rect = <span class="keyword">new</span> Rect(child.getRight(), <span class="number">0</span>, getWidth(), getHeight());</span><br><span class="line">    &#125;</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(color);</span><br><span class="line">    canvas.drawRect(rect, mPaint);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mainView 、阴影、遮罩层的关系示意图如下：</p>
<p><img src="/uploads/20160707/20160707211516.png" alt="relatives_pic"></p>
<h1 id="onViewReleased"><a href="#onViewReleased" class="headerlink" title="onViewReleased"></a>onViewReleased</h1><p>看完了上面的两个方法的代码，最后就是当用户手指抬起时判断逻辑的代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动返回，结束该View</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToFinish</span><span class="params">(<span class="keyword">int</span> finalLeft, <span class="keyword">int</span> finalTop)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, finalLeft, finalTop)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        listener.onSwipeBackFinish();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 滑动回归到原位</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swipeBackToRestore</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.smoothSlideViewTo(mainView, <span class="number">0</span>, <span class="number">0</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mViewDragHelper.continueSettling(<span class="keyword">true</span>)) &#123;</span><br><span class="line">        ViewCompat.postInvalidateOnAnimation(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SwipeBackListener</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 该方法会在滑动返回完成的时候回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipeBackFinish</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置滑动返回监听器</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> listener</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setSwipeBackListener</span><span class="params">(SwipeBackListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相应的代码还是比较简单的，主要使用了 <code>smoothSlideViewTo(View view, int left, int top)</code> 的方法来滑动到指定位置。若是结束当前界面的话，回调监听器的接口。</p>
<p>啰嗦了这么多，我们来看看运行时的效果图吧：</p>
<p><img src="/uploads/20160707/20160707212521.gif" alt="SwipeBackDemo Screenshot"></p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>好了，SwipeBackLayout 大致的逻辑就是上面这样子的。整体来说还是比较通俗易懂的，而且对 ViewDragHelper 熟悉的人会发现，使用 ViewDragHelper 自定义一些 ViewGroup 的套路都是大同小异的。以后想要自定义一些 ViewGroup 都是得心应手了。</p>
<p>如果对此有疑问的话可以在下面留言。</p>
<p>最后，国际惯例，附上 SwipeBackLayout Demo 的源码：</p>
<p><a href="/uploads/20160707/SwipeBackDemo.rar">SwipeBackDemo.rar</a></p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在如今 app 泛滥的年代里，越来越多的开发者注重用户体验这个方面了。其中，有很多的 app 都有一种功]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[详解CursorAdapter中的filter机制]]></title>
    <link href="http://yuqirong.me/2016/07/03/%E8%AF%A6%E8%A7%A3CursorAdapter%E4%B8%AD%E7%9A%84filter%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2016/07/03/详解CursorAdapter中的filter机制/</id>
    <published>2016-07-03T12:35:51.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天为什么讲 CursorAdapter 的原因，是因为之前在工作的时候有遇到 CursorAdapter 中 filter 的相关问题，于是就想把 CursorAdapter 中的 filter 机制流程好好梳理一下。出于这样的目的，本篇博文就诞生了。</p>
<p>在阅读本文之前，最好已经有写过 CursorAdapter 中 filter 相关代码的经历，这样可以帮助你更好地理解其中的原理。如果你准备好了，那么接下来就一起来看看吧。</p>
<h1 id="CursorAdapter__u7C7B"><a href="#CursorAdapter__u7C7B" class="headerlink" title="CursorAdapter 类"></a>CursorAdapter 类</h1><p>首先我们来看一下 CursorAdapter 的继承以及实现关系：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">CursorAdapter</span> <span class="keyword">extends</span> <span class="title">BaseAdapter</span> <span class="keyword">implements</span> <span class="title">Filterable</span>, <span class="title">CursorFilter</span>.<span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CursorAdapter 继承自 BaseAdapter ，相信大家都可以理解。之后又实现了 Filterable 和 CursorFilter.CursorFilterClient 接口。</p>
<p>Filterable 的接口很简单，只有一个 <code>getFilter()</code> 方法，用来返回 filter 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Filterable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Returns a filter that can be used to constrain data with a filtering</span><br><span class="line">     * pattern.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * &lt;p&gt;This method is usually implemented by &#123;<span class="doctag">@link</span> android.widget.Adapter&#125;</span><br><span class="line">     * classes.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@return</span> a filter used to constrain data</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function">Filter <span class="title">getFilter</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而 CursorFilter.CursorFilterClient 的接口是定义在 CursorFilter 类里面的。而 CursorFilter 类是默认修饰符，也就是说我们在外部无法访问到它。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">CursorFilterClient</span> </span>&#123;</span><br><span class="line">    <span class="function">CharSequence <span class="title">convertToString</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span></span>;</span><br><span class="line">    <span class="function">Cursor <span class="title">getCursor</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看 CursorFilterClient 接口中的抽象方法。根据方法名我们大概都能猜出该方法需要做的事情。 <code>convertToString(Cursor cursor)</code> 方法主要的功能就是根据传入的 cursor 参数返回某个字段；<code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法的意思就是根据传入的 constraint 字符序列去搜索得到 cursor；而 <code>getCursor()</code>就是返回 cursor；<code>changeCursor(Cursor cursor)</code> 就是根据传入的新的 cursor 去替换旧的 cursor 。</p>
<h1 id="filter__u7684_u7528_u6CD5"><a href="#filter__u7684_u7528_u6CD5" class="headerlink" title="filter 的用法"></a>filter 的用法</h1><p>好了，我们来想想平时我们是怎么样使用 CursorAdapter 中的 filter ？</p>
<p>第一步，我们会使用自定义的 adapter 继承自 CursorAdapter ，并且实现 FilterQueryProvider 和 FilterListener 接口。最后别忘了调用 <code>setFilterQueryProvider(FilterQueryProvider filterQueryProvider)</code> 方法。</p>
<p>然后，第二步我们会使用CursorAdapter的 <code>getFilter()</code> 方法来得到 filter 。对，没错，就是实现 Filterable 接口的那个 <code>getFilter</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Filter <span class="title">getFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCursorFilter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCursorFilter = <span class="keyword">new</span> CursorFilter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mCursorFilter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 CursorAdapter 的源码中，判断了 mCursorFilter 是否为空。若为空，则创建一个新的 CursorFilter 对象。否则直接返回 mCursorFilter 。在这里要说明一下 CursorFilter 是 Filter 的子类。</p>
<p>而在 CursorFilter 的构造器中，主要是设置了 client (CursorAdapter 实现了 CursorFilterClient 接口)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CursorFilter(CursorFilterClient client) &#123;</span><br><span class="line">    mClient = client;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在第二步得到了 filter 之后，第三步就可以使用 <code>filter.filter(CharSequence constraint)</code> 或者 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法了。constraint 参数就是要过滤的关键词；而 FilterListener 是一个 Filter 类的内部接口，会在过滤完成之后回调其中的 <code>onFilterComplete(int count)</code> 方法。</p>
<h1 id="filter__u7684_u539F_u7406"><a href="#filter__u7684_u539F_u7406" class="headerlink" title="filter 的原理"></a>filter 的原理</h1><p>大致使用 filter 的步骤就是像上面这样的了。下面我们就来揭开这其中神秘的面纱吧！</p>
<p>我们的入手点就是 Filter 的 filter 方法了。其中的 <code>filter.filter(CharSequence constraint)</code> 方法内部会调用 <code>filter.filter(CharSequence constraint, FilterListener listener)</code> 方法。所以我们只需要看下<code>filter.filter(CharSequence constraint, FilterListener listener)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Starts an asynchronous filtering operation. Calling this method</span><br><span class="line"> * cancels all previous non-executed filtering requests and posts a new</span><br><span class="line"> * filtering request that will be executed later.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * &lt;p&gt;Upon completion, the listener is notified.&lt;/p&gt;</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint used to filter the data</span><br><span class="line"> * <span class="doctag">@param</span> listener a listener notified upon completion of the operation</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #filter(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #performFiltering(CharSequence)</span><br><span class="line"> * <span class="doctag">@see</span> #publishResults(CharSequence, android.widget.Filter.FilterResults)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">filter</span><span class="params">(CharSequence constraint, FilterListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mThreadHandler == <span class="keyword">null</span>) &#123;</span><br><span class="line">            HandlerThread thread = <span class="keyword">new</span> HandlerThread(</span><br><span class="line">                    THREAD_NAME, android.os.Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">            thread.start();</span><br><span class="line">            mThreadHandler = <span class="keyword">new</span> RequestHandler(thread.getLooper());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">long</span> delay = (mDelayer == <span class="keyword">null</span>) ? <span class="number">0</span> : mDelayer.getPostingDelay(constraint);</span><br><span class="line">        </span><br><span class="line">        Message message = mThreadHandler.obtainMessage(FILTER_TOKEN);</span><br><span class="line"></span><br><span class="line">        RequestArguments args = <span class="keyword">new</span> RequestArguments();</span><br><span class="line">        <span class="comment">// make sure we use an immutable copy of the constraint, so that</span></span><br><span class="line">        <span class="comment">// it doesn't change while the filter operation is in progress</span></span><br><span class="line">        args.constraint = constraint != <span class="keyword">null</span> ? constraint.toString() : <span class="keyword">null</span>;</span><br><span class="line">        args.listener = listener;</span><br><span class="line">        message.obj = args;</span><br><span class="line"></span><br><span class="line">        mThreadHandler.removeMessages(FILTER_TOKEN);</span><br><span class="line">        mThreadHandler.removeMessages(FINISH_TOKEN);</span><br><span class="line">        mThreadHandler.sendMessageDelayed(message, delay);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从源码中我们可以看到，主要做的就是在一开始创建一个 HandlerThread 线程，并且创建了一个 RequestHandler 的对象 mThreadHandler 。之后创建了一个 RequestArguments 的对象 args，然后把 constraint 和 listener 传到 args 中去，而 RequestArguments 类还有一个成员变量就是 results ，主要用于存储 filter 过滤之后的结果，这会在下面的代码中用到。然后用 mThreadHandler 将该消息发送出去。</p>
<p>那么我们接下来就要来看看 RequestHandler 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Worker thread handler. When a new filtering request is posted from</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.Filter#filter(CharSequence, android.widget.Filter.FilterListener)&#125;,</span><br><span class="line"> * it is sent to this handler.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RequestHandler</span><span class="params">(Looper looper)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(looper);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Handles filtering requests by calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#performFiltering&#125; and then sending a message</span><br><span class="line">     * with the results to the results handler.&lt;/p&gt;</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering request</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> what = msg.what;</span><br><span class="line">        Message message;</span><br><span class="line">        <span class="keyword">switch</span> (what) &#123;</span><br><span class="line">            <span class="keyword">case</span> FILTER_TOKEN:</span><br><span class="line">                RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    args.results = performFiltering(args.constraint);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">                    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    message = mResultHandler.obtainMessage(what);</span><br><span class="line">                    message.obj = args;</span><br><span class="line">                    message.sendToTarget();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        Message finishMessage = mThreadHandler.obtainMessage(FINISH_TOKEN);</span><br><span class="line">                        mThreadHandler.sendMessageDelayed(finishMessage, <span class="number">3000</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> FINISH_TOKEN:</span><br><span class="line">                <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (mThreadHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        mThreadHandler.getLooper().quit();</span><br><span class="line">                        mThreadHandler = <span class="keyword">null</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 case FILTER_TOKEN 中我们可以看到，会先去调用 <code>performFiltering(CharSequence constraint)</code> 方法。而该方法在 Filter 类中是抽象方法，需要在子类中去实现。那么我们就来看看 CursorFilter 的 <code>performFiltering(CharSequence constraint)</code> 方法吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> FilterResults <span class="title">performFiltering</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    Cursor cursor = mClient.runQueryOnBackgroundThread(constraint);</span><br><span class="line"></span><br><span class="line">    FilterResults results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    <span class="keyword">if</span> (cursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        results.count = cursor.getCount();</span><br><span class="line">        results.values = cursor;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        results.count = <span class="number">0</span>;</span><br><span class="line">        results.values = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> results;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performFiltering(CharSequence constraint)</code> 方法中又会去调用  mClient 的 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，而 mClient 就是之前的 CursorAdapter ，所以我们又要跳到 CursorAdapter 类去看相关的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Runs a query with the specified constraint. This query is requested</span><br><span class="line"> * by the filter attached to this adapter.</span><br><span class="line"> *</span><br><span class="line"> * The query is provided by a</span><br><span class="line"> * &#123;<span class="doctag">@link</span> android.widget.FilterQueryProvider&#125;.</span><br><span class="line"> * If no provider is specified, the current cursor is not filtered and returned.</span><br><span class="line"> *</span><br><span class="line"> * After this method returns the resulting cursor is passed to &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;</span><br><span class="line"> * and the previous cursor is closed.</span><br><span class="line"> *</span><br><span class="line"> * This method is always executed on a background thread, not on the</span><br><span class="line"> * application's main thread (or UI thread.)</span><br><span class="line"> * </span><br><span class="line"> * Contract: when constraint is null or empty, the original results,</span><br><span class="line"> * prior to any filtering, must be returned.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> constraint the constraint with which the query must be filtered</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span> a Cursor representing the results of the new query</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@see</span> #getFilter()</span><br><span class="line"> * <span class="doctag">@see</span> #getFilterQueryProvider()</span><br><span class="line"> * <span class="doctag">@see</span> #setFilterQueryProvider(android.widget.FilterQueryProvider)</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">runQueryOnBackgroundThread</span><span class="params">(CharSequence constraint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFilterQueryProvider != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> mFilterQueryProvider.runQuery(constraint);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> mCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们可以看到会去调用 mFilterQueryProvider 的 <code>runQuery(CharSequence constraint)</code> 方法。 FilterQueryProvider 其实就是一个接口而已，当我们需要使用 filter 时就要实现该接口。在上面的 filter 用法中已经提到过了。其中的 <code>runQuery(CharSequence constraint)</code> 方法就是需要我们自己去实现的。当然，这里还有另外一种方法，就是不用实现 FilterQueryProvider 接口。而是在子类中去重写 <code>runQueryOnBackgroundThread(CharSequence constraint)</code> 方法，也是达到了一样的效果。</p>
<p>假定我们已经在 <code>runQuery(CharSequence constraint)</code> 实现了相关的操作，并且返回了查询出来的 cursor 。那样我们又要跳回到 RequestHandler 的源码中了(这里只截取部分代码，完整代码请查看上面)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    args.results = performFiltering(args.constraint);</span><br><span class="line">&#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">    args.results = <span class="keyword">new</span> FilterResults();</span><br><span class="line">    Log.w(LOG_TAG, <span class="string">"An exception occured during performFiltering()!"</span>, e);</span><br><span class="line">&#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">    message = mResultHandler.obtainMessage(what);</span><br><span class="line">    message.obj = args;</span><br><span class="line">    message.sendToTarget();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，这里把返回的 cursor 传给了 args.results 。并且又使用了 mResultHandler 发送了消息。这样我们又要来看一下 ResultHandler 的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * &lt;p&gt;Handles the results of a filtering operation. The results are</span><br><span class="line"> * handled in the UI thread.&lt;/p&gt;</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResultsHandler</span> <span class="keyword">extends</span> <span class="title">Handler</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * &lt;p&gt;Messages received from the request handler are processed in the</span><br><span class="line">     * UI thread. The processing involves calling</span><br><span class="line">     * &#123;<span class="doctag">@link</span> Filter#publishResults(CharSequence,</span><br><span class="line">     * android.widget.Filter.FilterResults)&#125;</span><br><span class="line">     * to post the results back in the UI and then notifying the listener,</span><br><span class="line">     * if any.&lt;/p&gt; </span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> msg the filtering results</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        RequestArguments args = (RequestArguments) msg.obj;</span><br><span class="line"></span><br><span class="line">        publishResults(args.constraint, args.results);</span><br><span class="line">        <span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">            args.listener.onFilterComplete(count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>handleMessage(Message msg)</code> 中，调用了 <code>publishResults(CharSequence constraint, FilterResults results)</code> 方法。在 Filter 类中 <code>publishResults(CharSequence constraint, FilterResults results)</code> 又是抽象的，所以还得去 CursorFilter 类中查看相关的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">publishResults</span><span class="params">(CharSequence constraint, FilterResults results)</span> </span>&#123;</span><br><span class="line">    Cursor oldCursor = mClient.getCursor();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (results.values != <span class="keyword">null</span> &amp;&amp; results.values != oldCursor) &#123;</span><br><span class="line">        mClient.changeCursor((Cursor) results.values);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>源码里表示了会去调用 CursorAdapter 的 <code>changeCursor(Cursor cursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Change the underlying cursor to a new cursor. If there is an existing cursor it will be</span><br><span class="line"> * closed.</span><br><span class="line"> * </span><br><span class="line"> * <span class="doctag">@param</span> cursor The new cursor to be used</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">changeCursor</span><span class="params">(Cursor cursor)</span> </span>&#123;</span><br><span class="line">    Cursor old = swapCursor(cursor);</span><br><span class="line">    <span class="keyword">if</span> (old != <span class="keyword">null</span>) &#123;</span><br><span class="line">        old.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>changeCursor(Cursor cursor)</code> 中，又调用了 <code>swapCursor(Cursor newCursor)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Swap in a new Cursor, returning the old Cursor.  Unlike</span><br><span class="line"> * &#123;<span class="doctag">@link</span> #changeCursor(Cursor)&#125;, the returned old Cursor is &lt;em&gt;not&lt;/em&gt;</span><br><span class="line"> * closed.</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> newCursor The new cursor to be used.</span><br><span class="line"> * <span class="doctag">@return</span> Returns the previously set Cursor, or null if there wasa not one.</span><br><span class="line"> * If the given new Cursor is the same instance is the previously set</span><br><span class="line"> * Cursor, null is also returned.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Cursor <span class="title">swapCursor</span><span class="params">(Cursor newCursor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (newCursor == mCursor) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Cursor oldCursor = mCursor;</span><br><span class="line">    <span class="keyword">if</span> (oldCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) oldCursor.unregisterContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) oldCursor.unregisterDataSetObserver(mDataSetObserver);</span><br><span class="line">    &#125;</span><br><span class="line">    mCursor = newCursor;</span><br><span class="line">    <span class="keyword">if</span> (newCursor != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mChangeObserver != <span class="keyword">null</span>) newCursor.registerContentObserver(mChangeObserver);</span><br><span class="line">        <span class="keyword">if</span> (mDataSetObserver != <span class="keyword">null</span>) newCursor.registerDataSetObserver(mDataSetObserver);</span><br><span class="line">        mRowIDColumn = newCursor.getColumnIndexOrThrow(<span class="string">"_id"</span>);</span><br><span class="line">        mDataValid = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the new cursor</span></span><br><span class="line">        notifyDataSetChanged();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRowIDColumn = -<span class="number">1</span>;</span><br><span class="line">        mDataValid = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// notify the observers about the lack of a data set</span></span><br><span class="line">        notifyDataSetInvalidated();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> oldCursor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>swapCursor(Cursor newCursor)</code> 中主要的工作就是把 oldCursor 替换成 newCursor ，并且调用了 <code>notifyDataSetChanged();</code> 来更新 ListView 。从上面的源码中还可以看到， <code>swapCursor(Cursor newCursor)</code> 方法中返回的 oldCursor 是没有关闭的。</p>
<p>完成了替换 Cursor 的工作后，我们还要回过头来看看 ResultsHandler 剩余部分的代码(只截取了部分代码)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (args.listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">int</span> count = args.results != <span class="keyword">null</span> ? args.results.count : -<span class="number">1</span>;</span><br><span class="line">    args.listener.onFilterComplete(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，在最后回调了 FilterListener 的 <code>onFilterComplete(int count)</code> 方法。其中的 count 参数是查询出来结果的总数。</p>
<p>至此，一个完整的 filter 流程终于走完了。这其中虽然看似很绕，其实原理还是比较简单的。</p>
<h1 id="u5C3E_u8BED"><a href="#u5C3E_u8BED" class="headerlink" title="尾语"></a>尾语</h1><p>看完上面分析，相信大家对 CursorAdapter 的 filter 机制已经有了一个大致的了解了吧。主要原理基本上还是 Handler 异步消息机制以及各个接口回调等。从中可以发现其实源码并不难，只要有耐心慢慢分析，一定会有所突破的。如果对这整个流程有问题的童鞋可以在下面留言。</p>
<p>那么，今天就到这了。Goodbye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>目前在公司中仍处于认知状态，因此没有什么时间写博客了，趁今天是周末就来更新一发。</p>
<p>关于今天]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Pro Git》笔记]]></title>
    <link href="http://yuqirong.me/2016/06/18/%E3%80%8APro%20Git%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/06/18/《Pro Git》笔记/</id>
    <published>2016-06-17T16:29:14.000Z</published>
    <updated>2016-08-18T15:09:33.879Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E"><a href="#1-5__u521D_u6B21_u8FD0_u884C_Git__u524D_u7684_u914D_u7F6E" class="headerlink" title="1.5 初次运行 Git 前的配置"></a>1.5 初次运行 Git 前的配置</h2><ul>
<li><p>Git 配置用户名：</p>
<p>  git config –global user.name “yuqirong”</p>
</li>
<li><p>Git 配置电子邮箱：</p>
<p>  git config –global user.email “yuqirong@myhexin.com”</p>
</li>
<li><p>查看 Git 配置情况：</p>
<p>  git config –list</p>
</li>
<li><p>设置默认使用的文本编辑器：</p>
<p>  git config –global core.editor emacs</p>
</li>
<li><p>设置默认使用的差异分析工具</p>
<p>  git config –global merge.tool vimdiff</p>
</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_Git__u57FA_u7840"><a href="#u7B2C_u4E8C_u7AE0_Git__u57FA_u7840" class="headerlink" title="第二章 Git 基础"></a>第二章 Git 基础</h1><h2 id="2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93"><a href="#2-1__u53D6_u5F97_u9879_u76EE_u7684_Git__u4ED3_u5E93" class="headerlink" title="2.1 取得项目的 Git 仓库"></a>2.1 取得项目的 Git 仓库</h2><ul>
<li><p>对某个项目进行 Git 管理：</p>
<p>  git init</p>
</li>
<li><p>对某个仓库进行克隆：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“</p>
</li>
<li><p>或者对克隆下来的仓库进行改名：</p>
<p>  git clone “<a href="https://github.com/yuqirong/yuqirong.github.io.git" target="_blank" rel="external">https://github.com/yuqirong/yuqirong.github.io.git</a>“ yuqirong</p>
</li>
<li><p>Git 添加某个文件：</p>
<p>  git add src/com/yuqirong/Test/a.java</p>
</li>
</ul>
<h2 id="2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93"><a href="#2-2__u8BB0_u5F55_u6BCF_u6B21_u66F4_u65B0_u5230_u4ED3_u5E93" class="headerlink" title="2.2 记录每次更新到仓库"></a>2.2 记录每次更新到仓库</h2><ul>
<li><p>检查当前文件状态：</p>
<p>  git status</p>
</li>
<li><p>查看已暂存的更新：</p>
<p>  git diff –cached</p>
</li>
<li><p>查看未暂存的更新：</p>
<p>  git diff</p>
</li>
<li><p>提交更新：</p>
<p>  git commit<br>  或<br>  git commit -m “add new file”</p>
</li>
<li><p>跳过使用暂存区域的提交更新：</p>
<p>  git commit -a -m “add new file”</p>
</li>
<li><p>移除文件：</p>
<p>  git rm abc.txt</p>
</li>
<li><p>强制移除文件：</p>
<p>  git rm -f abc.txt</p>
</li>
<li><p>文件保存在当前目录中但从跟踪清单中移除：</p>
<p>  git rm –cached abc.txt</p>
</li>
<li><p>移动文件：</p>
<p>  git mv file_from file_to</p>
</li>
</ul>
<h2 id="2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2"><a href="#2-3__u67E5_u770B_u63D0_u4EA4_u5386_u53F2" class="headerlink" title="2.3 查看提交历史"></a>2.3 查看提交历史</h2><ul>
<li><p>查看提交历史：</p>
<p>  git log</p>
</li>
<li><p>查看提交历史中每次提交的内容差异：</p>
<p>  git log -patch</p>
</li>
<li><p>查看提交历史但仅显示简要的增改行数统计：</p>
<p>  git log –stat</p>
</li>
<li><p>查看提交历史并限制输出长度：</p>
<p>  git log -2<br>  或<br>  git log –since=2.weeks</p>
</li>
</ul>
<h2 id="2-4__u64A4_u6D88_u64CD_u4F5C"><a href="#2-4__u64A4_u6D88_u64CD_u4F5C" class="headerlink" title="2.4 撤消操作"></a>2.4 撤消操作</h2><ul>
<li><p>修改最后一次提交：</p>
<p>  git commit –amend</p>
</li>
<li><p>取消已经暂存的文件：</p>
<p>  git reset HEAD abc.txt</p>
</li>
<li><p>取消对文件的修改：</p>
<p>  git checkout – abc.txt (ps:该命令对已经add的文件无效)</p>
</li>
</ul>
<h2 id="2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528"><a href="#2-5__u8FDC_u7A0B_u4ED3_u5E93_u7684_u4F7F_u7528" class="headerlink" title="2.5 远程仓库的使用"></a>2.5 远程仓库的使用</h2><ul>
<li><p>查看当前的远程库：</p>
<p>  git remote</p>
</li>
<li><p>查看当前远程库对应的克隆地址：</p>
<p>  git remote -v</p>
</li>
<li><p>添加远程仓库：</p>
<p>  git remote add [short-name] [url]</p>
</li>
<li><p>从远程仓库抓取数据：</p>
<p>  git fetch [remote-name] (fetch 命令只是将远端的数据拉到本地仓库，并不自动合并到当前工作分支，只有当你确实准备好了，才能手工合并。)</p>
</li>
<li><p>从远程仓库抓取数据，自动合并到本地仓库中：</p>
<p>  git pull [remote-name]</p>
</li>
<li><p>推送数据到远程仓库中：</p>
<p>  git push [remote-name] [branch-name]</p>
</li>
<li><p>查看远程仓库信息:</p>
<p>  git remote show [remote-name]</p>
</li>
<li><p>远程仓库的重命名:</p>
<p>  git remote rename [old-name] [new-name]</p>
</li>
<li><p>远程仓库的删除:</p>
<p>  git remote rm [remote-name]</p>
</li>
</ul>
<h2 id="2-6__u6253_u6807_u7B7E"><a href="#2-6__u6253_u6807_u7B7E" class="headerlink" title="2.6 打标签"></a>2.6 打标签</h2><ul>
<li><p>列出现有的标签：</p>
<p>  git tag</p>
</li>
<li><p>新建标签：</p>
<p>  git tag -a v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>查看相应标签的版本信息：</p>
<p>  git show v1.0</p>
</li>
<li><p>签署标签：</p>
<p>  git tag -s v1.0 -m “qirong yu’s blog”</p>
</li>
<li><p>轻量级标签：</p>
<p>  git tag v1.0</p>
</li>
<li><p>验证标签：</p>
<p>  git tag -v [tag-name]</p>
</li>
<li><p>分享标签:</p>
<p>  git push origin v1.0</p>
</li>
<li><p>推送所有的标签：</p>
<p>  git push origin –tags</p>
</li>
</ul>
<h2 id="2-7__u6280_u5DE7_u548C_u7A8D_u95E8"><a href="#2-7__u6280_u5DE7_u548C_u7A8D_u95E8" class="headerlink" title="2.7 技巧和窍门"></a>2.7 技巧和窍门</h2><ul>
<li><p>设置 Git 命令别名：</p>
<p>  git config –global alias.co checkout</p>
</li>
</ul>
<h1 id="u7B2C_u4E09_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E09_u7AE0__u8D77_u6B65" class="headerlink" title="第三章 起步"></a>第三章 起步</h1><h2 id="3-1__u4F55_u8C13_u5206_u652F"><a href="#3-1__u4F55_u8C13_u5206_u652F" class="headerlink" title="3.1 何谓分支"></a>3.1 何谓分支</h2><ul>
<li><p>创建一个新的分支：</p>
<p>  git branch [branch-name]</p>
</li>
<li><p>克隆一个远程服务器上的分支：</p>
<p>  git clone -b [branch-name] [remote-url]</p>
</li>
<li><p>切换分支：</p>
<p>  git checkout [branch-name]</p>
</li>
</ul>
<h2 id="3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76"><a href="#3-2__u57FA_u672C_u7684_u5206_u652F_u4E0E_u5408_u5E76" class="headerlink" title="3.2 基本的分支与合并"></a>3.2 基本的分支与合并</h2><ul>
<li><p>新建一个分支并切换到该分支上：</p>
<p>  git checkout -b [branch-name]</p>
</li>
<li><p>合并分支：</p>
<p>  git merge [branch-name]</p>
</li>
<li><p>删除分支：</p>
<p>  git branch -d [branch-name]</p>
</li>
<li><p>调用可视化的合并工具来解决冲突：</p>
<p>  git mergetool</p>
</li>
</ul>
<h2 id="3-3__u5206_u652F_u7BA1_u7406"><a href="#3-3__u5206_u652F_u7BA1_u7406" class="headerlink" title="3.3 分支管理"></a>3.3 分支管理</h2><ul>
<li><p>列出所有分支：</p>
<p>  git branch</p>
</li>
<li><p>查看分支最后一次 commit 信息：</p>
<p>  git branch -v</p>
</li>
<li><p>查看哪些分支已经被并入：</p>
<p>  git branch –merged</p>
</li>
<li><p>查看哪些分支没有被并入：</p>
<p>  git branch –no-merged</p>
</li>
</ul>
<h2 id="3-5__u8FDC_u7A0B_u5206_u652F"><a href="#3-5__u8FDC_u7A0B_u5206_u652F" class="headerlink" title="3.5 远程分支"></a>3.5 远程分支</h2><ul>
<li><p>跟踪分支</p>
<p>  git checkout -b [local-branch-name] [remote-name]/[remote-branch-name]</p>
</li>
<li><p>删除远程分支：</p>
<p>  git push [remote-name] :[remote-branch-name]</p>
</li>
</ul>
<h2 id="3-6__u884D_u5408"><a href="#3-6__u884D_u5408" class="headerlink" title="3.6 衍合"></a>3.6 衍合</h2><ul>
<li><p>衍合分支：</p>
<p>  git rebase [branch-name]</p>
</li>
</ul>
<h1 id="u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git"><a href="#u7B2C4_u7AE0__u670D_u52A1_u5668_u4E0A_u7684_Git" class="headerlink" title="第4章 服务器上的 Git"></a>第4章 服务器上的 Git </h1><h1 id="u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git"><a href="#u7B2C5_u7AE0__u5206_u5E03_u5F0F_Git" class="headerlink" title="第5章 分布式 Git"></a>第5章 分布式 Git</h1>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0__u8D77_u6B65"><a href="#u7B2C_u4E00_u7AE0__u8D77_u6B65" class="headerlink" title="第一章 起步"></a>第一章 起步</h1><h2 id="1]]>
    </summary>
    
      <category term="Git" scheme="http://yuqirong.me/tags/Git/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Android 6.0的运行时权限处理]]></title>
    <link href="http://yuqirong.me/2016/06/08/%E5%85%B3%E4%BA%8EAndroid%20M%E7%9A%84%E8%BF%90%E8%A1%8C%E6%9D%83%E9%99%90%E5%A4%84%E7%90%86/"/>
    <id>http://yuqirong.me/2016/06/08/关于Android M的运行权限处理/</id>
    <published>2016-06-08T14:12:20.000Z</published>
    <updated>2016-08-18T15:09:33.911Z</updated>
    <content type="html"><![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问题的原因大家都知道，是 Android 6.0 新引入了在运行时权限申请(Runtime Permissions)的功能。那么这所谓的运行时申请权限究竟是怎么一回事呢，一起来看看吧！</p>
<p>在 Android 6.0 中，app 如果想要获得某些权限，会在应用中弹出一个对话框，让用户确认是否授予该权限。具体的截图如下：</p>
<p><img src="/uploads/20160608/20160608161439.png" alt="Runtime Permissions screenshot"></p>
<p>这要做的好处就是运行一个 app 时可以拒绝其中的某些权限，防止 app 触及到你的隐私(比如说通讯录、短信之类的)。而在 Android 6.0 之前，若同意安装 app ，就意味着该 app 可以获取权限列表中的所有权限。(注：这里所指的都是原生 Android 系统，比如 MIUI 之类的第三方 ROM 很早就具备了这种功能。)</p>
<p>接下来就来看看相关的 API 吧，首先我们来看看 <code>Context.checkSelfPermission(String permission)</code> 方法，该方法主要用于检测该 app 是否已经被赋予了某权限，传入的参数有。如果已被赋予，则返回 <code>PERMISSION_GRANTED</code> ，否则返回 <code>PERMISSION_DENIED</code> 。</p>
<p>若返回了 <code>PERMISSION_DENIED</code> ，那么我们就要去申请该权限了。这时就要用到  <code>Activity.requestPermissions(String[] permissions, int requestCode)</code> 这个方法了。顾名思义，该方法的作用就是申请某些权限了。第一个参数就是要申请的权限，可以看到参数形式是一个数组，也就是说可以一次申请多个权限。而第二个参数就是申请权限的代号，主要用于在之后的回调中选择。</p>
<p>当用户在权限申请的对话框中作出选择后，就会回调 <code>onRequestPermissionsResult (int requestCode, String[] permissions, int[] grantResults)</code> 方法。第一个参数就是上面的权限代号；第二个参数是申请的权限数组；第三个参数就是权限申请的结果。</p>
<p>结合上面的几个方法，可以写出如下所示的权限申请代码模版：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> READ_CONTACTS_REQUEST_CODE = <span class="number">101</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果权限没有被授予</span></span><br><span class="line"><span class="keyword">if</span> (ContextCompat.checkSelfPermission(<span class="keyword">this</span>, android.Manifest.permission.READ_CONTACTS) !=</span><br><span class="line">        PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">    <span class="comment">// 申请权限</span></span><br><span class="line">    ActivityCompat.requestPermissions(<span class="keyword">this</span>, <span class="keyword">new</span> String[]&#123;Manifest.permission.READ_CONTACTS&#125;, READ_CONTACTS_REQUEST_CODE);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// TODO 权限已经被授予</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">    <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> READ_CONTACTS_REQUEST_CODE:</span><br><span class="line">            <span class="keyword">if</span> (grantResults.length &gt; <span class="number">0</span> &amp;&amp; grantResults[<span class="number">0</span>] == PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                <span class="comment">// TODO 用户已经授予了权限</span></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// TODO 用户拒绝授予权限</span></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，还有一个方法需要注意下，那就是 <code>shouldShowRequestPermissionRationale (Activity activity, String permission)</code> 方法。这个方法的作用就是当用户拒绝了某个权限之后，下一次就会显示出需要该权限的说明。</p>
<p>关于运行时申请权限基本就这样了，值得提醒的是，并不是所有的权限都需要运行时申请，只有“危险”的权限才通过运行时来申请。比如说读取联系人、获取位置信息、读写SD卡等等都为“危险权限”，而比如振动、联网、蓝牙等就是普通权限了，就不需要运行时申请了。</p>
<p>说完了运行时申请权限后，另外还有一点需要注意的是，在 Android 6.0 显示悬浮窗也有一个“坑”。如果调用平常的显示悬浮窗的方法，会抛出 “permission denied for this window type” 异常。解决的方案就是在显示悬浮窗之前，需要调用一下 <code>Settings.canDrawOverlays(context)</code> 这个方法。若该方法返回 true ，则说明用户同意创建悬浮窗；否则可以跳转到相关的设置页面。具体的代码模版如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">23</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span> (Settings.canDrawOverlays(context)) &#123;</span><br><span class="line">        <span class="comment">// 显示悬浮窗</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 跳转到相关的设置页面</span></span><br><span class="line">        Intent intent = <span class="keyword">new</span> Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// 版本低于Android 6.0，直接显示悬浮窗</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，就到这里吧。</p>
<p>GoodBye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前有人在 Android 6.0 的机型上运行了 <a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a> 结果出异常奔溃了。想必问]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简易实现Android九宫格解锁]]></title>
    <link href="http://yuqirong.me/2016/05/10/%E7%AE%80%E6%98%93%E5%AE%9E%E7%8E%B0Android%E4%B9%9D%E5%AE%AB%E6%A0%BC%E8%A7%A3%E9%94%81/"/>
    <id>http://yuqirong.me/2016/05/10/简易实现Android九宫格解锁/</id>
    <published>2016-05-10T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.082Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等。因为九宫格可以保护用户的隐私，所以它的应用面很广泛。那么今天我们就来自定义一个属于自己的九宫格吧！</p>
<p>首先我们来分析一下实现九宫格解锁的思路：当用户的手指触摸到某一个点时，先判断该点是否在九宫格的某一格范围之内，若在范围内，则该格变成选中的状态；之后用户手指滑动的时候，以该格的圆心为中心，用户手指为终点，两点连线。最后当用户手指抬起时，判断划过的九宫格密码是否和原先的密码匹配。</p>
<p>大致的思路流程就是上面这样的了，下面我们可以来实践一下。</p>
<h1 id="Point__u7C7B"><a href="#Point__u7C7B" class="headerlink" title="Point 类"></a>Point 类</h1><p>我们先来创建一个 <code>Point</code> 类，用来表示九宫格锁的九个格子。除了坐标 <code>x</code> ，<code>y</code> 之外，还有三种模式：正常模式、按下模式和错误模式。根据模式不同该格子的颜色会有所不同，这会在下面中说明。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> x;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> y;</span><br><span class="line">    <span class="comment">// 正常模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NORMAL_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 按下模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PRESSED_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 错误模式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> ERROR_MODE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> state = NORMAL_MODE;</span><br><span class="line">    <span class="comment">// 表示该格的密码，比如“1”、“2”等</span></span><br><span class="line">    <span class="keyword">private</span> String mark;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getMark</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMark</span><span class="params">(String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Point</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y, String mark)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">        <span class="keyword">this</span>.mark = mark;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setState</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.state = state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getX</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setX</span><span class="params">(<span class="keyword">float</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">float</span> <span class="title">getY</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setY</span><span class="params">(<span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="RotateDegrees_u7C7B"><a href="#RotateDegrees_u7C7B" class="headerlink" title="RotateDegrees类"></a>RotateDegrees类</h1><p>有了上面的 <code>Point</code> 类之后，我们还要创建一个 <code>RotateDegrees</code> 类，主要作用是计算两个 <code>Point</code> 坐标之间的角度：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> RotateDegrees &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据传入的point计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param b</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, Point b)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">float</span> degrees = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">float</span> aX = a.getX();</span><br><span class="line">        <span class="keyword">float</span> aY = a.getY();</span><br><span class="line">        <span class="keyword">float</span> bX = b.getX();</span><br><span class="line">        <span class="keyword">float</span> bY = b.getY();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (aX == bX) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aY &lt; bY) &#123;</span><br><span class="line">                degrees = <span class="number">90</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">270</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (bY == aY) &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &lt; bX) &#123;</span><br><span class="line">                degrees = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                degrees = <span class="number">180</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (aX &gt; bX) &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第三象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> + (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第二象限</span></span><br><span class="line">                    degrees = <span class="number">180</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, aX - bX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (aY &gt; bY) &#123; <span class="comment">// 第四象限</span></span><br><span class="line">                    degrees = <span class="number">360</span> - (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(aY - bY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// 第一象限</span></span><br><span class="line">                    degrees = (<span class="keyword">float</span>) (Math.<span class="built_in">atan2</span>(bY - aY, bX - aX) * <span class="number">180</span> / Math.PI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> degrees;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 根据point和(x,y)计算出它们之间的角度</span><br><span class="line">     * @param a</span><br><span class="line">     * @param bX</span><br><span class="line">     * @param bY</span><br><span class="line">     * @return</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">float</span> <span class="title">getDegrees</span><span class="params">(Point a, <span class="keyword">float</span> bX, <span class="keyword">float</span> bY)</span> </span>&#123;</span><br><span class="line">        Point b = <span class="keyword">new</span> Point(bX, bY, null);</span><br><span class="line">        <span class="keyword">return</span> getDegrees(a, b);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="ScreenLockView__u7C7B"><a href="#ScreenLockView__u7C7B" class="headerlink" title="ScreenLockView 类"></a>ScreenLockView 类</h1><p>然后我们要先准备好关于九宫格的几张图片，比如在九宫格的格子中，<code>NORMAL_MODE</code> 模式下是蓝色的，被手指按住时九宫格的格子是绿色的，也就是对应着上面 Point 类的中 <code>PRESSED_MODE</code> 模式，还有 <code>ERROR_MODE</code> 模式下是红色的。另外还有圆点之间的连线，也是根据模式不同颜色也会不同。在这里我就不把图片贴出来了，想要的童鞋可以下载源码从中获取。</p>
<p>有了图片资源之后，我们要做的就是先在构造器中加载图片：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScreenLockView</span> <span class="keyword">extends</span> <span class="title">View</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ScreenLockView"</span>;</span><br><span class="line">    <span class="comment">// 错误格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap errorBitmap;</span><br><span class="line">    <span class="comment">// 正常格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap normalBitmap;</span><br><span class="line">    <span class="comment">// 手指按下时格子的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap pressedBitmap;</span><br><span class="line">    <span class="comment">// 错误时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap lineErrorBitmap;</span><br><span class="line">    <span class="comment">// 手指按住时连线的图片</span></span><br><span class="line">    <span class="keyword">private</span> Bitmap linePressedBitmap;</span><br><span class="line">    <span class="comment">// 偏移量，使九宫格在屏幕中央</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> offset;</span><br><span class="line">    <span class="comment">// 九宫格的九个格子是否已经初始化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> init;</span><br><span class="line">    <span class="comment">// 格子的半径</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> radius;</span><br><span class="line">    <span class="comment">// 密码</span></span><br><span class="line">    <span class="keyword">private</span> String password = <span class="string">"123456"</span>;</span><br><span class="line">    <span class="comment">// 九个格子</span></span><br><span class="line">    <span class="keyword">private</span> Point[][] points = <span class="keyword">new</span> Point[<span class="number">3</span>][<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> width;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="keyword">private</span> Matrix matrix = <span class="keyword">new</span> Matrix();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveX = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> moveY = -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 是否手指在移动</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isMove;</span><br><span class="line">    <span class="comment">// 是否可以触摸，当用户抬起手指，划出九宫格的密码不正确时为不可触摸</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isTouch = <span class="keyword">true</span>;</span><br><span class="line">    <span class="comment">// 用来存储记录被按下的点</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Point&gt; pressedPoint = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="comment">// 屏幕解锁监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnScreenLockListener listener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScreenLockView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        errorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_error);</span><br><span class="line">        normalBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_normal);</span><br><span class="line">        pressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.bitmap_pressed);</span><br><span class="line">        lineErrorBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_error);</span><br><span class="line">        linePressedBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.line_pressed);</span><br><span class="line">        radius = normalBitmap.getWidth() / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中我们主要就是把图片加载完成，并且得到了格子的半径，即图片宽度的一半。</p>
<p>之后我们来看看 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthSize &gt; heightSize) &#123;</span><br><span class="line">        offset = (widthSize - heightSize) / <span class="number">2</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        offset = (heightSize - widthSize) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(widthSize, heightSize);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> 方法中，主要得到对应的偏移量，以便在下面的 <code>onDraw(Canvas canvas)</code> 把九宫格绘制在屏幕中央。</p>
<p>下面就是 <code>onDraw(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!init) &#123;</span><br><span class="line">        width = getWidth();</span><br><span class="line">        height = getHeight();</span><br><span class="line">        initPoint();</span><br><span class="line">        init = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 画九宫格的格子</span></span><br><span class="line">    drawPoint(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (moveX != -<span class="number">1</span> &amp;&amp; moveY != -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// 画直线</span></span><br><span class="line">        drawLine(canvas);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先判断了是否为第一次调用 <code>onDraw(Canvas canvas)</code> 方法，若为第一次则对 points 进行初始化：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"0"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">4</span>, <span class="string">"1"</span>);</span><br><span class="line">    points[<span class="number">0</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">4</span>, <span class="string">"2"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">1</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"3"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width / <span class="number">2</span>, <span class="string">"4"</span>);</span><br><span class="line">    points[<span class="number">1</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width / <span class="number">2</span>, <span class="string">"5"</span>);</span><br><span class="line"></span><br><span class="line">    points[<span class="number">2</span>][<span class="number">0</span>] = <span class="keyword">new</span> Point(width / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"6"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">1</span>] = <span class="keyword">new</span> Point(width / <span class="number">2</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"7"</span>);</span><br><span class="line">    points[<span class="number">2</span>][<span class="number">2</span>] = <span class="keyword">new</span> Point(width * <span class="number">3</span> / <span class="number">4</span>, offset + width * <span class="number">3</span> / <span class="number">4</span>, <span class="string">"8"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>initPoint()</code> 方法中主要创建了九个格子，并设置了相应的位置和密码。初始化完成之后把 init 置为 false ,下次不会再调用。</p>
<p>回过头再看看 <code>onDraw(Canvas canvas)</code> 中其他的逻辑，接下来调用了 <code>drawPoint(canvas)</code> 来绘制格子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画九宫格的格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawPoint</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            <span class="keyword">int</span> state = points[i][j].getState();</span><br><span class="line">            <span class="keyword">if</span> (state == Point.NORMAL_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(normalBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (state == Point.PRESSED_MODE) &#123;</span><br><span class="line">                canvas.drawBitmap(pressedBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                canvas.drawBitmap(errorBitmap, points[i][j].getX() - radius, points[i][j].getY() - radius, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在绘制格子还是很简单的，主要分为了三种：普通模式下的格子、按下模式下的格子以及错误模式下的格子。</p>
<h1 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent"></a>onTouchEvent</h1><p>在绘制好了格子之后，我们先不看最后的 <code>drawLine(canvas)</code> 方法，因为绘制直线是和用户手指的触摸事件息息相关的，所以我们先把目光转向 <code>onTouchEvent(MotionEvent event)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isTouch) &#123;</span><br><span class="line">        <span class="keyword">float</span> x = event.getX();</span><br><span class="line">        <span class="keyword">float</span> y = event.getY();</span><br><span class="line">        Point point;</span><br><span class="line">        <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 判断用户触摸的点是否在九宫格的任意一个格子之内</span></span><br><span class="line">                point = isPoint(x, y);</span><br><span class="line">                <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    point.setState(Point.PRESSED_MODE);  <span class="comment">// 切换为按下模式</span></span><br><span class="line">                    pressedPoint.add(point);  </span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">                <span class="keyword">if</span> (pressedPoint.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    point = isPoint(x, y);</span><br><span class="line">                    <span class="keyword">if</span> (point != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (!crossPoint(point)) &#123;</span><br><span class="line">                            point.setState(Point.PRESSED_MODE);</span><br><span class="line">                            pressedPoint.add(point);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    moveX = x;</span><br><span class="line">                    moveY = y;</span><br><span class="line">                    isMove = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                isMove = <span class="keyword">false</span>;</span><br><span class="line">                String tempPwd = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                    tempPwd += p.getMark();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    listener.getStringPassword(tempPwd);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (tempPwd.equals(password)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">true</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">for</span> (Point p : pressedPoint) &#123;</span><br><span class="line">                        p.setState(Point.ERROR_MODE);</span><br><span class="line">                    &#125;</span><br><span class="line">                    isTouch = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">this</span>.postDelayed(runnable, <span class="number">1000</span>);</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.isPassword(<span class="keyword">false</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnScreenLockListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getStringPassword</span><span class="params">(String password)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isPassword</span><span class="params">(<span class="keyword">boolean</span> flag)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnScreenLockListener</span><span class="params">(OnScreenLockListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>MotionEvent.ACTION_DOWN</code> 中，先在 <code>isPoint(float x, float y)</code> 方法内判断了用户触摸事件的坐标点是否在九宫格的任意一格之内。如果是，则需要把该九宫格的格子添加到 <code>pressedPoint</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 该触摸点是否为格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Point <span class="title">isPoint</span><span class="params">(<span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    Point point;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            point = points[i][j];</span><br><span class="line">            <span class="keyword">if</span> (isContain(point, x, y)) &#123;</span><br><span class="line">                <span class="keyword">return</span> point;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 该点(x，y)是否被包含</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isContain</span><span class="params">(Point point, <span class="keyword">float</span> x, <span class="keyword">float</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 该点的(x,y)与格子圆心的距离若小于半径就是被包含了</span></span><br><span class="line">    <span class="keyword">return</span> Math.sqrt(Math.pow(x - point.getX(), <span class="number">2f</span>) + Math.pow(y - point.getY(), <span class="number">2f</span>)) &lt;= radius;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来就是要看 <code>MotionEvent.ACTION_MOVE</code> 的逻辑了。一开始判断了用户触摸的点是否为九宫格的某个格子。但是比 <code>MotionEvent.ACTION_DOWN</code> 还多了一个步骤：若用户触摸了某个格子，还要判断该格子是否已经被包含在 <code>pressedPoint</code> 里面了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 是否该格子已经被包含在pressedPoint里面了</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">crossPoint</span><span class="params">(Point point)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (pressedPoint.contains(point)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后来看看 <code>MotionEvent.ACTION_UP</code> ，把 <code>pressedPoint</code> 里保存的格子遍历后得到用户划出的密码，再和预先设置的密码比较，若相同则回调 <code>OnScreenLockListener</code> 监听器；不相同则把 <code>pressedPoint</code> 中的所有格子的模式设置为错误模式，并在 <code>runnable</code> 中调用 <code>reset()</code> 清空 <code>pressedPoint</code> ，重绘视图，再回调监听器。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Runnable runnable = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        isTouch = <span class="keyword">true</span>;</span><br><span class="line">        reset();</span><br><span class="line">        invalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重置格子</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; points.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; points[i].length; j++) &#123;</span><br><span class="line">            points[i][j].setState(Point.NORMAL_MODE);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pressedPoint.clear();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们回过头来看看之前在 <code>onDraw(Canvas canvas)</code> 里面的 <code>drawLine(Canvas canvas)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 画直线</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">drawLine</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将pressedPoint中的所有格子依次遍历，互相连线</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; pressedPoint.size() - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 得到当前格子</span></span><br><span class="line">        Point point = pressedPoint.get(i);</span><br><span class="line">        <span class="comment">// 得到下一个格子</span></span><br><span class="line">        Point nextPoint = pressedPoint.get(i + <span class="number">1</span>);</span><br><span class="line">        <span class="comment">// 旋转画布</span></span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        <span class="comment">// 根据距离设置拉伸的长度</span></span><br><span class="line">        matrix.setScale(getDistance(point, nextPoint) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        <span class="comment">// 进行平移</span></span><br><span class="line">        matrix.postTranslate(point.getX(), point.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (point.getState() == Point.PRESSED_MODE) &#123;</span><br><span class="line">            canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            canvas.drawBitmap(lineErrorBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 把画布旋转回来</span></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(point, nextPoint), point.getX(), point.getY());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是手指在移动的情况</span></span><br><span class="line">    <span class="keyword">if</span> (isMove) &#123;</span><br><span class="line">        Point lastPoint = pressedPoint.get(pressedPoint.size() - <span class="number">1</span>);</span><br><span class="line">        canvas.rotate(RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line"></span><br><span class="line">        matrix.reset();</span><br><span class="line">        Log.i(TAG, <span class="string">"the distance : "</span> + getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth());</span><br><span class="line">        matrix.setScale(getDistance(lastPoint, moveX, moveY) / linePressedBitmap.getWidth(), <span class="number">1f</span>);</span><br><span class="line">        matrix.postTranslate(lastPoint.getX(), lastPoint.getY() - linePressedBitmap.getWidth() / <span class="number">2</span>);</span><br><span class="line">        canvas.drawBitmap(linePressedBitmap, matrix, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">        canvas.rotate(-RotateDegrees.getDegrees(lastPoint, moveX, moveY), lastPoint.getX(), lastPoint.getY());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据point和坐标点计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, <span class="keyword">float</span> moveX, <span class="keyword">float</span> moveY)</span> </span>&#123;</span><br><span class="line">    Point b = <span class="keyword">new</span> Point(moveX,moveY,<span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">return</span> getDistance(point,b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 根据两个point计算出之间的距离</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getDistance</span><span class="params">(Point point, Point nextPoint)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="keyword">float</span>) Math.sqrt(Math.pow(nextPoint.getX() - point.getX(), <span class="number">2f</span>) + Math.pow(nextPoint.getY() - point.getY(), <span class="number">2f</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>drawLine(Canvas canvas)</code> 整体的逻辑并不复杂，首先将 <code>pressedPoint</code> 中的所有格子依次遍历，将它们连线。之后若是用户的手指还有滑动的话，把最后一个格子和用户手指触摸的点连线。</p>
<h1 id="u6587_u672B"><a href="#u6587_u672B" class="headerlink" title="文末"></a>文末</h1><p><code>ScreenLockView</code> 中的代码差不多就是这些了，既然讲解完了那就一起来看看效果吧：</p>
<p><img src="/uploads/20160510/20160510151253.gif" alt="ScreenShot"></p>
<p>效果还算不错吧，当然你也可以自己设置喜欢的九宫格图片，只要替换一下就可以了。如果对本篇文章有问题，可以留言。</p>
<p>老规矩，附上源码下载链接：</p>
<p><a href="/uploads/20160510/ScreenLockView.rar">ScreenLockView.rar</a></p>
<p>Goodbye ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>在平常使用手机的过程中，九宫格解锁是我们经常接触到的。常见的比如有锁屏中的九宫格，还有支付宝中的九宫格等]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现ViewPager指示器]]></title>
    <link href="http://yuqirong.me/2016/04/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0ViewPager%E6%8C%87%E7%A4%BA%E5%99%A8/"/>
    <id>http://yuqirong.me/2016/04/27/自定义实现ViewPager指示器/</id>
    <published>2016-04-27T12:09:19.000Z</published>
    <updated>2016-08-18T15:09:34.098Z</updated>
    <content type="html"><![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blank" rel="external">ViewPagerIndicator</a> ，到现在 Material Design 中的 TabLayout 。GitHub 上还有其他形形色色的指示器。那么肯定有人会问：既然有了这么多的指示器可以用，那为什么还要自己自定义呢？其实，我们学习了自定义指示器之后，可以知道 ViewPager 指示器的原理，还可以提高我们代码的水平哦！那还等什么，一起来学习吧。</p>
<p>首先放上一张效果图，亮亮眼：</p>
<p><img src="/uploads/20160427/20160427152924.gif" alt="这里写图片描述"></p>
<p>接下来我们来大致地分析一下思路： ViewPager 指示器我们可以看作是一个横向的 LinearLayout ，相对应的 Tab 可以直接使用 TextView 来实现。而 LinearLayout 中有许多个 TextView ，当我们点击其中的 TextView 时， ViewPager 就切换到对应的 item 上。而当我们手动滑动 ViewPager 时，根据 OnPageChangeListener 来动态地改变指示器。好了，基本上思路就是这样了，下面就来看看代码了。</p>
<p>自定义的属性 attrs.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ViewPagerIndicator"</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab可见的数量 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"visible_tab_num"</span> <span class="attribute">format</span>=<span class="value">"integer"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"selected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab未选中时的颜色 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"unselected_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab中字体的大小 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">	<span class="comment">&lt;!-- tab选中时横线的高度 --&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"indicator_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>自定义的属性基本上就以上几种，如果自己有其他的需求，可以另外添加。</p>
<p>之后我们就创建一个类，名字就叫 ViewPagerIndicator 了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ViewPagerIndicator</span> <span class="keyword">extends</span> <span class="title">LinearLayout</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// tab可见数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> visibleTabNum;</span><br><span class="line">    <span class="comment">// 选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> selectedColor;</span><br><span class="line">    <span class="comment">// 未选中的颜色</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> unselectedColor;</span><br><span class="line">    <span class="comment">// 屏幕宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> screenWidth;</span><br><span class="line">    <span class="comment">// tab的宽度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tabWidth;</span><br><span class="line">    <span class="comment">// 横线的偏移</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> offset;</span><br><span class="line">    <span class="comment">// 画笔</span></span><br><span class="line">    <span class="keyword">private</span> Paint mPaint;</span><br><span class="line">    <span class="comment">// 高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> height;</span><br><span class="line">    <span class="comment">// 横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> indicatorHeight;</span><br><span class="line">    <span class="comment">// 默认横线的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultIndicatorHeight;</span><br><span class="line">    <span class="comment">// viewpager当前页数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mCurrentItem;</span><br><span class="line">    <span class="comment">// 字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> textSize;</span><br><span class="line">    <span class="comment">// 默认字体大小</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultTextSize;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ViewPager mViewPager;</span><br><span class="line">    <span class="comment">// 滑动的最小距离</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> touchSlop;</span><br><span class="line">    <span class="comment">// 上次触摸的x轴坐标</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> lastX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"ViewPagerIndicator"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ViewPagerIndicator</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        <span class="comment">// 设置横向</span></span><br><span class="line">        setOrientation(LinearLayout.HORIZONTAL);</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ViewPagerIndicator);</span><br><span class="line">        selectedColor = a.getColor(R.styleable.ViewPagerIndicator_selected_color, Color.BLUE);</span><br><span class="line">        unselectedColor = a.getColor(R.styleable.ViewPagerIndicator_unselected_color, Color.WHITE);</span><br><span class="line">        visibleTabNum = a.getInt(R.styleable.ViewPagerIndicator_visible_tab_num, <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 默认字体大小</span></span><br><span class="line">        defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, <span class="number">10</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        textSize = a.getDimension(R.styleable.ViewPagerIndicator_text_size, defaultTextSize);</span><br><span class="line">        <span class="comment">// 默认下划横线高度</span></span><br><span class="line">        defaultIndicatorHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">4</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        indicatorHeight = a.getDimension(R.styleable.ViewPagerIndicator_indicator_height, defaultIndicatorHeight);</span><br><span class="line">        a.recycle();</span><br><span class="line">        screenWidth = context.getResources().getDisplayMetrics().widthPixels;</span><br><span class="line">        tabWidth = screenWidth / visibleTabNum;</span><br><span class="line">        mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">        mPaint.setColor(selectedColor);</span><br><span class="line">        mPaint.setStrokeWidth(indicatorHeight);</span><br><span class="line">        mPaint.setStyle(Paint.Style.FILL);</span><br><span class="line">        <span class="comment">// 得到touchSlop</span></span><br><span class="line">        touchSlop = ViewConfiguration.get(getContext()).getScaledTouchSlop();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码主要是初始化了自定义属性，还有得到了 tabWidth 以便后面使用。</p>
<p>当然，如果用户旋转了屏幕，那么 tabWidth 是会改变的。所以我们应该在 <code>onSizeChanged</code> 里重新赋值：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onSizeChanged</span><span class="params">(<span class="keyword">int</span> w, <span class="keyword">int</span> h, <span class="keyword">int</span> oldw, <span class="keyword">int</span> oldh)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSizeChanged(w, h, oldw, oldh);</span><br><span class="line">    <span class="comment">// 当大小改变时，得到一个tab的宽度</span></span><br><span class="line">    tabWidth = w / visibleTabNum;</span><br><span class="line">    height = h;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，无论是横屏还是竖屏，在屏幕上可见的 Tab 数量永远是固定的(即 visibleTabNum 的值)。之后，我们先来“画”出 Tab 被选中时底下的那条横线。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">        canvas.save();</span><br><span class="line">        <span class="comment">// 绘制横线</span></span><br><span class="line">        canvas.drawLine(offset, height - indicatorHeight, offset + tabWidth, height - indicatorHeight, mPaint);</span><br><span class="line">        canvas.restore();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">super</span>.dispatchDraw(canvas);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置offset</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setOffset</span><span class="params">(<span class="keyword">float</span> offset)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.offset = offset;</span><br><span class="line">    invalidate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>mViewPager 的赋值是在<code>setViewPager(ViewPager viewPager)</code>方法中完成的，这个方法放在下面去讲。而其中的 offset 是偏移量。当用户滑动切换 ViewPager 时，Tab 底下的横线应该也要做相应的位移，而这就是由 offset 来完成的。调用 <code>setOffset(float offset)</code> 方法，可以引起视图重绘。另外横线的高度 indicatorHeight 可以由用户自定义的，这里的代码还是比较简单的，相信大家都可以看懂的。</p>
<p>到这就来讲讲 setViewPager 方法了。当我们想要把 ViewPager 和 ViewPagerIndicator 关联起来时，可以给外部设置一个 <code>setViewPager(ViewPager viewPager)</code> 方法，那下面就是该方法的源码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 设置ViewPager， 请确保在设置了adapter之后调用该方法</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@param</span> viewPager</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setViewPager</span><span class="params">(ViewPager viewPager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (viewPager == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.mViewPager = viewPager;</span><br><span class="line">    <span class="comment">// 得到适配器</span></span><br><span class="line">    PagerAdapter adapter = viewPager.getAdapter();</span><br><span class="line">    <span class="comment">// adapter不能为空</span></span><br><span class="line">    <span class="keyword">if</span> (adapter == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"the adapter of viewpager must be not null.."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 先移除所有的子view</span></span><br><span class="line">    <span class="keyword">this</span>.removeAllViews();</span><br><span class="line">    <span class="comment">// 添加Textview</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; adapter.getCount(); i++) &#123;</span><br><span class="line">        createTextView(adapter.getPageTitle(i).toString(), i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mCurrentItem = viewPager.getCurrentItem();</span><br><span class="line">    ((TextView) getChildAt(mCurrentItem)).setTextColor(selectedColor);</span><br><span class="line">    viewPager.addOnPageChangeListener(<span class="keyword">new</span> ViewPager.OnPageChangeListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrolled</span><span class="params">(<span class="keyword">int</span> position, <span class="keyword">float</span> positionOffset, <span class="keyword">int</span> positionOffsetPixels)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 设置了横线的偏移，并引起重绘</span></span><br><span class="line">            setOffset((position + positionOffset) * tabWidth);</span><br><span class="line">            <span class="comment">// tab也要进行相应的移动，若当前的tab是倒数第二个，则不移动。</span></span><br><span class="line">            <span class="keyword">if</span> (position + positionOffset + <span class="number">1</span> &gt; visibleTabNum - <span class="number">1</span> &amp;&amp; position + positionOffset + <span class="number">1</span> &lt;= getChildCount() - <span class="number">1</span>) &#123;</span><br><span class="line">                scrollTo((<span class="keyword">int</span>) ((position + positionOffset - visibleTabNum + <span class="number">2</span>) * tabWidth), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageSelected</span><span class="params">(<span class="keyword">int</span> position)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 字体颜色改变</span></span><br><span class="line">            ((TextView) getChildAt(mCurrentItem)).setTextColor(unselectedColor);</span><br><span class="line">            ((TextView) getChildAt(position)).setTextColor(selectedColor);</span><br><span class="line">            mCurrentItem = position;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPageScrollStateChanged</span><span class="params">(<span class="keyword">int</span> state)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从方法内部可以看出，我们要得到 ViewPager 的 adapter 。如果 adapter 为空则抛出异常。之后根据 adapter 的 count 数量去创建相对应的 TextView 作为 Tab 。下面为 <code>createTextView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 添加textview到ViewPagerIndicator中</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createTextView</span><span class="params">(String title, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    TextView tv = <span class="keyword">new</span> TextView(getContext());</span><br><span class="line">    LinearLayout.LayoutParams params = <span class="keyword">new</span> LayoutParams(tabWidth, LayoutParams.MATCH_PARENT);</span><br><span class="line">    tv.setLayoutParams(params);</span><br><span class="line">    tv.setText(title);</span><br><span class="line">    tv.setGravity(Gravity.CENTER);</span><br><span class="line">    tv.setTextColor(unselectedColor);</span><br><span class="line">    tv.setTag(i);</span><br><span class="line">    tv.setTextSize(textSize);</span><br><span class="line">    tv.setOnClickListener(tvClickListener);</span><br><span class="line">    <span class="keyword">this</span>.addView(tv);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// textview的点击监听器</span></span><br><span class="line">OnClickListener tvClickListener = <span class="keyword">new</span> OnClickListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = (<span class="keyword">int</span>) v.getTag();</span><br><span class="line">        <span class="keyword">if</span> (mViewPager != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mViewPager.setCurrentItem(i, <span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在 <code>createTextView</code> 方法中，使用了addView 来动态地添加 Tab 。这里有一处比较巧妙的地方：我们把当前 TextView 的索引 i 存储到了 Tag 中。而当用户点击 Tab 时，在监听器中我们取出那个 Tag 值，这样就知道了用户点击的是哪个 Tab 了，并且让 ViewPager 切换到那个页面下。</p>
<p>好了，我们再回过头继续看之前的 <code>setViewPager(ViewPager viewPager)</code> 方法，我们看到给 viewPager 设置了 OnPageChangeListener 。在 OnPageChangeListener 的 onPageScrolled 方法中，根据当前的 position 和 positionOffset 就可以完成选中时那条横线的移动。并且为了选中的 Tab 出现在屏幕中，ViewPagerIndicator 也要用 scrollTo 方法来做相应地移动。而在 onPageSelected 方法中，我们把选中的 Tab 中的字体颜色更改为已选中的颜色，之前选中的改成未选中颜色。</p>
<p>到这里，整体完成得差不多了。但是如果我们想让 ViewPagerIndicator 可以滑动的话，还要重写 <code>onInterceptTouchEvent(MotionEvent ev)</code> 和 <code>onTouchEvent(MotionEvent event)</code> 两个方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onInterceptTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = ev.getX();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = ev.getX() - lastX;</span><br><span class="line">            <span class="comment">// 当移动大于touchSlop时，拦截该触摸事件</span></span><br><span class="line">            <span class="keyword">if</span> (Math.abs(offsetX) &gt;= touchSlop) &#123;</span><br><span class="line">                result = <span class="keyword">true</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Log.i(TAG, <span class="string">"onInterceptTouchEvent result = "</span> + result);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">float</span> x = event.getX();</span><br><span class="line">    <span class="keyword">switch</span> (event.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">float</span> offsetX = x - lastX;</span><br><span class="line">            <span class="comment">// 滑动相应的距离</span></span><br><span class="line">            scrollBy(-(<span class="keyword">int</span>) offsetX, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// 最左边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                scrollTo(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 最右边界值检查</span></span><br><span class="line">            <span class="keyword">if</span> (getScrollX() &gt; tabWidth * (getChildCount() - visibleTabNum)) &#123;</span><br><span class="line">                scrollTo(tabWidth * (getChildCount() - visibleTabNum), <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            lastX = x;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            lastX = <span class="number">0f</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onInterceptTouchEvent(MotionEvent ev)</code> 中，若滑动的距离超过 touchSlop ，则拦截该触摸事件自己处理，否则传递给子View。而在 <code>onTouchEvent(MotionEvent event)</code> 中，使用了 scrollBy 来处理滑动，并且设置了边界值的检查。</p>
<p>在这里，整体代码讲解完成了。其实 ViewPagerIndicator 本质就是使用了 OnPageChangeListener 以及当用户点击时切换 ViewPager 到指定页面，并没有太难的地方。以后我们自己也可以实现各种炫酷的 ViewPagerIndicator 了！</p>
<p>下面提供源码的下载链接：</p>
<p><a href="/uploads/20160427/ViewPagerIndicator.rar">ViewPagerIndicator.rar</a></p>
<p>have a nice day !~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天来更新一发“自定义实现 ViewPager 指示器”。 ViewPager 指示器相信大家都用过吧，从一开始 JW 大神的 <a href="https://github.com/JakeWharton/ViewPagerIndicator" target="_blan]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造带有视差效果的ListView]]></title>
    <link href="http://yuqirong.me/2016/04/19/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E5%B8%A6%E6%9C%89%E8%A7%86%E5%B7%AE%E6%95%88%E6%9E%9C%E7%9A%84ListView/"/>
    <id>http://yuqirong.me/2016/04/19/快速打造带有视差效果的ListView/</id>
    <published>2016-04-19T05:35:32.000Z</published>
    <updated>2016-08-18T15:09:33.989Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/20160419141952.gif" alt="这里写图片描述"></p>
<p>我们可以看到 ListView 的 HeaderView 会跟随 ListView 的滑动而变大，HeaderView里的图片会有缩放效果。这些可以使用属性动画来实现。接下来我们就来动手吧！</p>
<p>首先自定义几个属性，在之后可以用到：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"ZoomListView"</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView的高度 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- headerView的最大高度 --&gt;</span></span><br><span class="line">		<span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_height"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">		<span class="comment">&lt;!-- headerView里面的图片最大的伸缩量 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"header_max_scale"</span> <span class="attribute">format</span>=<span class="value">"float"</span>&gt;</span><span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>之后创建 ZoomListView 类，继承自 ListView ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZoomListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// 最大的伸缩量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">float</span> defaultHeaderMaxScale = <span class="number">1.2f</span>;</span><br><span class="line">    <span class="comment">// 头部最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxHeight;</span><br><span class="line">    <span class="comment">// 头部初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerHeight;</span><br><span class="line">    <span class="comment">// 头部默认初始高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderHeight;</span><br><span class="line">    <span class="comment">// 头部默认最大的高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> defaultHeaderMaxHeight;</span><br><span class="line">    <span class="keyword">private</span> ImageView headerView;</span><br><span class="line">    <span class="keyword">private</span> ViewGroup.LayoutParams layoutParams;</span><br><span class="line">    <span class="keyword">private</span> LinearLayout linearLayout;</span><br><span class="line">    <span class="comment">// 最大的缩放值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> headerMaxScale;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ZoomListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        defaultHeaderHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">160</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        defaultHeaderMaxHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, <span class="number">240</span>, context.getResources().getDisplayMetrics());</span><br><span class="line">        TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ZoomListView);</span><br><span class="line">        headerHeight = a.getDimension(R.styleable.ZoomListView_header_height, defaultHeaderHeight);</span><br><span class="line">        headerMaxHeight = a.getDimension(R.styleable.ZoomListView_header_max_height, defaultHeaderMaxHeight);</span><br><span class="line">        headerMaxScale = a.getFloat(R.styleable.ZoomListView_header_max_scale, defaultHeaderMaxScale);</span><br><span class="line">        a.recycle();</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到这里都是按部就班式的，设置好自定义属性的初始值，之后调用 <code>initView()</code> ，那就来看看 <code>initView()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    headerView = <span class="keyword">new</span> ImageView(getContext());</span><br><span class="line">    headerView.setScaleType(ImageView.ScaleType.CENTER_CROP);</span><br><span class="line">    linearLayout = <span class="keyword">new</span> LinearLayout(getContext());</span><br><span class="line">    linearLayout.addView(headerView);</span><br><span class="line">    layoutParams = headerView.getLayoutParams();</span><br><span class="line">    <span class="keyword">if</span> (layoutParams == <span class="keyword">null</span>) &#123;</span><br><span class="line">        layoutParams = <span class="keyword">new</span> ViewGroup.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (<span class="keyword">int</span>) headerHeight);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        layoutParams.width = ViewGroup.LayoutParams.MATCH_PARENT;</span><br><span class="line">        layoutParams.height = (<span class="keyword">int</span>) headerHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    headerView.setLayoutParams(layoutParams);</span><br><span class="line">    addHeaderView(linearLayout);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDrawableId</span><span class="params">(<span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">    headerView.setImageResource(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出在 <code>initView()</code> 里我们创建了 headerView ，并添加到了ListView的头部。而 <code>setDrawableId(int id)</code> 就是给 headerView 设置相关图片的。</p>
<p>下面就是视差效果的主要实现代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">overScrollBy</span><span class="params">(<span class="keyword">int</span> deltaX, <span class="keyword">int</span> deltaY, <span class="keyword">int</span> scrollX, <span class="keyword">int</span> scrollY, <span class="keyword">int</span> scrollRangeX, <span class="keyword">int</span> scrollRangeY, <span class="keyword">int</span> maxOverScrollX, <span class="keyword">int</span> maxOverScrollY, <span class="keyword">boolean</span> isTouchEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (deltaY &lt; <span class="number">0</span> &amp;&amp; isTouchEvent) &#123;</span><br><span class="line">        <span class="keyword">if</span> (headerView.getHeight() &lt; headerMaxHeight) &#123;</span><br><span class="line">            <span class="keyword">int</span> newHeight = headerView.getHeight()</span><br><span class="line">                    + Math.abs(deltaY / <span class="number">3</span>);</span><br><span class="line">            headerView.getLayoutParams().height = newHeight;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">            <span class="keyword">float</span> temp = <span class="number">1</span> + (headerMaxScale - <span class="number">1f</span>) * (headerView.getHeight() - headerHeight) / (headerMaxHeight - headerHeight);</span><br><span class="line">            headerView.animate().scaleX(temp)</span><br><span class="line">                    .scaleY(temp).setDuration(<span class="number">0</span>).start();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们重写了 <code>overScrollBy()</code> 方法，当 deltaY 小于0时(即 ListView 已经到顶端，但是用户手势还是向下拉)，去动态地设置 headerView 的高度以及 headerView 的 scale 值。这样就可以产生 headerView 变高以及图片放大的效果了。</p>
<p>接下来要考虑的问题就是当用户松开手指时，要恢复回原来的样子。所以我们应该在 <code>onTouchEvent(MotionEvent ev)</code> 里去实现相关操作：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">                startAnim();</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 开始执行动画</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startAnim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ValueAnimator animator = ValueAnimator.ofFloat(headerView.getHeight(), headerHeight);</span><br><span class="line">    animator.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.getLayoutParams().height = (<span class="keyword">int</span>) fraction;</span><br><span class="line">            headerView.requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line"></span><br><span class="line">    ValueAnimator animator2 = ValueAnimator.ofFloat(headerView.getScaleX(), <span class="number">1f</span>);</span><br><span class="line">    animator2.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">float</span> fraction = (<span class="keyword">float</span>) animation.getAnimatedValue();</span><br><span class="line">            headerView.setScaleX(fraction);</span><br><span class="line">            headerView.setScaleY(fraction);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    animator2.setDuration(<span class="number">500</span>);</span><br><span class="line">    animator2.setInterpolator(<span class="keyword">new</span> LinearInterpolator());</span><br><span class="line">    animator.start();</span><br><span class="line">    animator2.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码简单点来说，就是在 ACTION_UP 时，去开始两个属性动画，一个属性动画是将 headerView 的高度恢复成原来的值，另一个属性动画就是把 headerView 的 scale 重新恢复为1f。相信大家都可以看懂的。</p>
<p>ZoomListView 整体的代码就这些了，很简短。下面附上下载的链接：</p>
<p><a href="/uploads/20160419/ZoomListView.rar">ZoomListView.rar</a></p>
<p>good luck ! ~~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们实现了仿美团的下拉刷新。而今天的主题还是与 ListView 有关，这次是来实现具有视差效果的 ListView 。</p>
<p>那么到底什么是视差效果呢？一起来看效果图就知道了：</p>
<p><img src="/uploads/20160419/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你实现仿美团的下拉刷新]]></title>
    <link href="http://yuqirong.me/2016/04/18/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BB%BF%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://yuqirong.me/2016/04/18/带你实现仿美团的下拉刷新/</id>
    <published>2016-04-18T07:34:03.000Z</published>
    <updated>2016-08-18T15:09:33.973Z</updated>
    <content type="html"><![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="这里写图片描述"></p>
<p>我们可以大致地分析一下：首先根据下拉改变的 paddingTop 来动态地缩放“绿色椭圆物”,然后当 headerView 的 paddingTop 大于0时，播放美团小人出现的帧动画，最后就是手指松开时播放刷新中的帧动画了。</p>
<p>基本上思路就是上面分析的那样了，那么我们下面一步就是要获取帧动画的素材了。我们先下载好美团的 apk ，解压后在 res/drawable-xhdpi-v4 里，我们可以得到相关的图片了。如果嫌麻烦，文末有本 Demo 的下载链接，里面就有素材图片。</p>
<p>有了图片后我们先写个帧动画的 drawable.xml ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">animation-list</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_01"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_02"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_03"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_04"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">item</span> <span class="attribute">android:drawable</span>=<span class="value">"@drawable/pull_end_image_frame_05"</span> <span class="attribute">android:duration</span>=<span class="value">"100"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">animation-list</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>一共有两个 drawable.xml ，另外一个和这个类似，就不贴出来了。</p>
<p>现在开始编写代码了，创建一个 MeiTuanListView ，继承自 ListView :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MeiTuanListView</span> <span class="keyword">extends</span> <span class="title">ListView</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 普通状态模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> NONE_MODE = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PULL_DOWN_MODE = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 可松开刷新模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RELEASE_REFRESH_MODE = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">// 刷新中模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> REFRESHING_MODE = <span class="number">3</span>;</span><br><span class="line">	<span class="comment">// 模式</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> mode = NONE_MODE;</span><br><span class="line">	<span class="comment">// 阻值</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RATIO = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">// 下拉刷新头部</span></span><br><span class="line">    <span class="keyword">private</span> View headerRefreshView;</span><br><span class="line">    <span class="comment">// 头部高度</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> refreshViewHeight;</span><br><span class="line">    <span class="comment">// 手指按下的Y值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">float</span> downY;</span><br><span class="line">    <span class="comment">// 刷新监听器</span></span><br><span class="line">    <span class="keyword">private</span> OnRefreshListener listener;</span><br><span class="line">    <span class="comment">// “绿色椭圆物”的自定义View</span></span><br><span class="line">    <span class="keyword">private</span> MeiTuanOvalView mtOvalView;</span><br><span class="line">    <span class="comment">// 帧动画的ImageView</span></span><br><span class="line">    <span class="keyword">private</span> ImageView aniImageView;</span><br><span class="line">    <span class="comment">// 动画是否已经开始</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isStart;</span><br><span class="line">    <span class="comment">// 只有在listview顶端时下拉才可以刷新</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> canRefresh;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String TAG = <span class="string">"MeiTuanListView"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MeiTuanListView</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">        initView();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        setOverScrollMode(View.OVER_SCROLL_NEVER);</span><br><span class="line">        headerRefreshView = LayoutInflater.from(getContext()).inflate(R.layout.layout_header, <span class="keyword">null</span>);</span><br><span class="line">        mtOvalView = (MeiTuanOvalView) headerRefreshView.findViewById(R.id.mtFirstView);</span><br><span class="line">        aniImageView = (ImageView) headerRefreshView.findViewById(R.id.iv);</span><br><span class="line">        <span class="comment">// 去测量</span></span><br><span class="line">        headerRefreshView.measure(<span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        refreshViewHeight = headerRefreshView.getMeasuredHeight();</span><br><span class="line">        headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">        addHeaderView(headerRefreshView, <span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在<code>initView()</code>中，初始化了下拉刷新的头部，并且设置了 setPadding (关于 ListView 下拉刷新的原理大家应该都懂吧？！)。</p>
<p>layout_header.xml 的布局如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:gravity</span>=<span class="value">"center"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">com.yuqirong.meituanlistview.view.MeiTuanOvalView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/mtFirstView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_anim"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"45dp"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:visibility</span>=<span class="value">"gone"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>MeiTuanOvalView 这个是关于“绿色椭圆物”的自定义View，会根据 <code>headerView.getPaddingTop()</code> 的值自动缩放，这里就不讲解了，源码还是比较简单的，相关代码可以下载 Demo 查看。而 <code>iv_anim</code> 主要是用来播放帧动画的 ImageView 。</p>
<p>下拉刷新的主要代码都在 <code>onTouchEvent(MotionEvent ev)</code> 里：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span> (ev.getAction()) &#123;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_DOWN:</span><br><span class="line">            <span class="comment">// 在listview顶端时才可下拉刷新</span></span><br><span class="line">            <span class="keyword">if</span> (getFirstVisiblePosition() == <span class="number">0</span>) &#123;</span><br><span class="line">                Log.i(TAG, <span class="string">"canRefresh : "</span> + canRefresh);</span><br><span class="line">				<span class="comment">// 记录手指按下的Y坐标</span></span><br><span class="line">                downY = ev.getY();</span><br><span class="line">                canRefresh = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_MOVE:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">float</span> moveY = ev.getY();</span><br><span class="line">                <span class="keyword">float</span> offsetY = moveY - downY;</span><br><span class="line">				<span class="comment">// 动态改变paddingTop值</span></span><br><span class="line">                headerRefreshView.setPadding(<span class="number">0</span>, (<span class="keyword">int</span>) (headerRefreshView.getPaddingTop() + offsetY / RATIO), <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = PULL_DOWN_MODE;</span><br><span class="line">                    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">                    aniImageView.setVisibility(GONE);</span><br><span class="line">                    mtOvalView.setScale((refreshViewHeight + headerRefreshView.getPaddingTop()) * <span class="number">1f</span> / refreshViewHeight);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = RELEASE_REFRESH_MODE;</span><br><span class="line">                    <span class="keyword">if</span> (!isStart) &#123;</span><br><span class="line">                        mtOvalView.setVisibility(GONE);</span><br><span class="line">                        aniImageView.setVisibility(VISIBLE);</span><br><span class="line">                        aniImageView.setImageResource(R.drawable.pull_end_imag_frame);</span><br><span class="line">                        AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                        <span class="comment">// 只执行一次动画</span></span><br><span class="line">                        animationDrawable.setOneShot(<span class="keyword">true</span>);</span><br><span class="line">                        animationDrawable.start();</span><br><span class="line">                        isStart = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                downY = moveY;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MotionEvent.ACTION_UP:</span><br><span class="line">            <span class="keyword">if</span> (mode != REFRESHING_MODE &amp;&amp; canRefresh) &#123;</span><br><span class="line">                <span class="keyword">if</span> (headerRefreshView.getPaddingTop() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    mode = REFRESHING_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    aniImageView.setImageResource(R.drawable.refreshing_image_frame);</span><br><span class="line">                    AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();</span><br><span class="line">                    animationDrawable.start();</span><br><span class="line">                    <span class="keyword">if</span> (listener != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        listener.refreshing();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    mode = NONE_MODE;</span><br><span class="line">                    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">                    mtOvalView.setScale(<span class="number">0f</span>);</span><br><span class="line">                    isStart = <span class="keyword">false</span>;</span><br><span class="line">                    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>里面的代码逻辑还是比较简单的：</p>
<ul>
<li>ACTION_DOWN ：首先判断了当 ListView 在顶端时才可以下拉刷新，并且记录了手指按下的Y坐标；</li>
<li>ACTION_MOVE ：根据滑动的 offsetY 来动态地设置 headerView 的 paddingTop 。我们可以看到在 <code>if (headerRefreshView.getPaddingTop() &lt;= 0)</code> 里面根据 paddingTop 的值来动态地设置 <code>mtOvalView</code> 的 scale ，并且在 <code>setScale()</code> 方法里面会调用 <code>invalidate()</code> ，从而让 <code>mtOvalView</code> 去重绘。不然 <code>headerRefreshView.getPaddingTop()</code> 大于0时就播放了美团小人出场的动画。</li>
<li>ACTION_UP ：当手指松开的时候，还是判断了 <code>headerRefreshView.getPaddingTop()</code> 的值。若大于0则把 headerView 全部显示出来，播放刷新中的动画，并且回调了刷新监听器的接口；小于0则把 headerView 重新隐藏起来。并重置相关的值。</li>
</ul>
<p>要注意的一点是，在 <code>onTouchEvent(MotionEvent ev)</code> 里要返回 <code>super.onTouchEvent(ev)</code> 。不能是直接返回 <code>true</code> 。因为在 <code>super.onTouchEvent(ev)</code> 里处理了 ListView 滑动的相关逻辑。</p>
<p>当获取到最新数据后，可以调用<code>notifyRefreshFinished()</code>方法完成下拉刷新：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnRefreshListener</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">refreshing</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOnRefreshListener</span><span class="params">(OnRefreshListener listener)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.listener = listener;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 刷新完成后调用</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">notifyRefreshFinished</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mode = NONE_MODE;</span><br><span class="line">    headerRefreshView.setPadding(<span class="number">0</span>, -refreshViewHeight, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    aniImageView.setVisibility(GONE);</span><br><span class="line">    mtOvalView.setVisibility(VISIBLE);</span><br><span class="line">    isStart = <span class="keyword">false</span>;</span><br><span class="line">    canRefresh = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后就是附上效果图了：</p>
<p><img src="/uploads/20160418/20160418165251.gif" alt="这里写图片描述"></p>
<p>到这里整体就讲解得差不多了，至于 MeiTuanListView 的使用示例以及 MeiTuanOvalView 的源码可以在 Demo 里查看。</p>
<p>Demo下载链接：</p>
<p><a href="/uploads/20160418/MeiTuanListView.rar">MeiTuanListView.rar</a></p>
<p>good bye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FloatingActionButton在滚动时显示或隐藏]]></title>
    <link href="http://yuqirong.me/2016/04/10/FloatingActionButton%E5%9C%A8%E6%BB%9A%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F/"/>
    <id>http://yuqirong.me/2016/04/10/FloatingActionButton在滚动时显示或隐藏/</id>
    <published>2016-04-10T11:51:22.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>其实关于FAB的显示和隐藏，Google官方就提供了其中一种方案：<code>fab.hidden()</code>和<code>fab.show()</code>。但是自带的是FAB缩放的效果。并不是上下移动的效果。</p>
<p>那么我们就来看看如何实现FAB上下移动的效果吧！</p>
<p>首先在你想要滑动的View(比如说RecyclerView等)的布局上加上：</p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>然后再附上FAB的xml：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">android.support.design.widget.FloatingActionButton</span></span><br><span class="line">   <span class="attribute">android:id</span>=<span class="value">"@+id/fab"</span></span><br><span class="line">   <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">   <span class="attribute">android:layout_gravity</span>=<span class="value">"bottom|end"</span></span><br><span class="line">   <span class="attribute">android:layout_margin</span>=<span class="value">"@dimen/fab_margin"</span></span><br><span class="line">   <span class="attribute">app:layout_behavior</span>=<span class="value">"com.yuqirong.rxnews.ui.view.ScrollAwareFABBehavior"</span></span><br><span class="line">   <span class="attribute">android:src</span>=<span class="value">"@android:drawable/ic_dialog_email"</span> /&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注意其中的layout_behavior，是我们自己实现的一个类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScrollAwareFABBehavior</span> <span class="keyword">extends</span> <span class="title">FloatingActionButton</span>.<span class="title">Behavior</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Interpolator INTERPOLATOR = <span class="keyword">new</span> FastOutSlowInInterpolator();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ScrollAwareFABBehavior</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onStartNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                                       <span class="keyword">final</span> View directTargetChild, <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> nestedScrollAxes)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Ensure we react to vertical scrolling</span></span><br><span class="line">        <span class="keyword">return</span> nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL</span><br><span class="line">                || <span class="keyword">super</span>.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNestedScroll</span><span class="params">(<span class="keyword">final</span> CoordinatorLayout coordinatorLayout, <span class="keyword">final</span> FloatingActionButton child,</span><br><span class="line">                               <span class="keyword">final</span> View target, <span class="keyword">final</span> <span class="keyword">int</span> dxConsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyConsumed,</span><br><span class="line">                               <span class="keyword">final</span> <span class="keyword">int</span> dxUnconsumed, <span class="keyword">final</span> <span class="keyword">int</span> dyUnconsumed)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);</span><br><span class="line">        <span class="keyword">if</span> (dyConsumed &gt; <span class="number">0</span> &amp;&amp; !<span class="keyword">this</span>.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled down and the FAB is currently visible -&gt; hide the FAB</span></span><br><span class="line">            animateOut(child);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (dyConsumed &lt; <span class="number">0</span> &amp;&amp; child.getVisibility() != View.VISIBLE) &#123;</span><br><span class="line">            <span class="comment">// User scrolled up and the FAB is currently not visible -&gt; show the FAB</span></span><br><span class="line">            animateIn(child);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateOut</span><span class="params">(<span class="keyword">final</span> FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer()</span><br><span class="line">                    .setListener(<span class="keyword">new</span> ViewPropertyAnimatorListener() &#123;</span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationCancel</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">                            ScrollAwareFABBehavior.<span class="keyword">this</span>.mIsAnimatingOut = <span class="keyword">false</span>;</span><br><span class="line">                            view.setVisibility(View.GONE);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;).start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.hide();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">animateIn</span><span class="params">(FloatingActionButton button)</span> </span>&#123;</span><br><span class="line">        button.setVisibility(View.VISIBLE);</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">14</span>) &#123;</span><br><span class="line">            ViewCompat.animate(button).translationY(<span class="number">0</span>)</span><br><span class="line">                    .setInterpolator(INTERPOLATOR).withLayer().setListener(<span class="keyword">null</span>)</span><br><span class="line">                    .start();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            button.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">getMarginBottom</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> marginBottom = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">final</span> ViewGroup.LayoutParams layoutParams = v.getLayoutParams();</span><br><span class="line">        <span class="keyword">if</span> (layoutParams <span class="keyword">instanceof</span> ViewGroup.MarginLayoutParams) &#123;</span><br><span class="line">            marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> marginBottom;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们主要看<code>onNestedScroll()</code>这个方法，在方法里主要判断了一下是向上滑还是向下滑。再分别去调用<code>animateOut()</code>和<code>animateIn()</code>。那我们就来看看<code>animateOut()</code>。(<code>animateIn()</code>和<code>animateOut()</code>的原理一样的，我们只看<code>animateOut()</code>吧)</p>
<p>在<code>animateOut()</code>根据SDK的版本判断，若大于或等于14使用属性动画；不然就是使用了自带的<code>hide()</code>方法。代码还是比较简单的，相信大家都能看得懂。当然如下想在SDK 14以下使用上下移动的效果，那就要用NineOldAndroids这个库了。</p>
<p>效果就是如下所示了：</p>
<p><img src="/uploads/20160413/20160413202356.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这了。bye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入解析Scroller滚动原理]]></title>
    <link href="http://yuqirong.me/2016/04/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Scroller%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2016/04/05/深入解析Scroller滚动原理/</id>
    <published>2016-04-05T12:21:10.000Z</published>
    <updated>2016-08-18T15:09:34.051Z</updated>
    <content type="html"><![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括为“三部曲”：</p>
<ol>
<li><p>创建一个Scroller对象，一般在View的构造器中创建：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(context, attrs, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScrollViewGroup</span><span class="params">(Context context, AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    mScroller = <span class="keyword">new</span> Scroller(context);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>重写View的computeScroll()方法，下面的代码基本是不会变化的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.computeScroll();</span><br><span class="line">    <span class="keyword">if</span> (mScroller.computeScrollOffset()) &#123;</span><br><span class="line">        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());</span><br><span class="line">        postInvalidate();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>调用startScroll()方法，startX和startY为开始滚动的坐标点，dx和dy为对应的偏移量：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mScroller.startScroll (<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy);</span><br><span class="line">invalidate();</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面的三步就是Scroller的基本用法了。那接下来的任务就是解析Scroller的滚动原理了。</p>
<p>而在这之前，我们还有一件事要办，那就是搞清楚scrollTo()和scrollBy()的原理。scrollTo()和scrollBy()的区别我这里就不重复叙述了，不懂的可以自行google或百度。下面贴出scrollTo()的源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollTo</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mScrollX != x || mScrollY != y) &#123;</span><br><span class="line">        <span class="keyword">int</span> oldX = mScrollX;</span><br><span class="line">        <span class="keyword">int</span> oldY = mScrollY;</span><br><span class="line">        mScrollX = x;</span><br><span class="line">        mScrollY = y;</span><br><span class="line">        invalidateParentCaches();</span><br><span class="line">        onScrollChanged(mScrollX, mScrollY, oldX, oldY);</span><br><span class="line">        <span class="keyword">if</span> (!awakenScrollBars()) &#123;</span><br><span class="line">            postInvalidateOnAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>设置好mScrollX和mScrollY之后，调用了<code>onScrollChanged(mScrollX, mScrollY, oldX, oldY);</code>，View就会被重新绘制。这样就达到了滑动的效果。</p>
<p>下面我们再来看看scrollBy()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scrollBy</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    scrollTo(mScrollX + x, mScrollY + y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这样简短的代码相信大家都懂了，原来scrollBy()内部是调用了scrollTo()的。但是scrollTo()/scrollBy()的滚动都是瞬间完成的，怎么样才能实现平滑滚动呢。</p>
<p>不知道大家有没有这样一种想法：如果我们把要滚动的偏移量分成若干份小的偏移量，当然这份量要大。然后用scrollTo()/scrollBy()每次都滚动小份的偏移量。在一定的时间内，不就成了平滑滚动了吗？没错，Scroller正是借助这一原理来实现平滑滚动的。下面我们就来看看源码吧！</p>
<p>根据“三部曲”中第一部，先来看看Scroller的构造器：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Scroller</span><span class="params">(Context context, Interpolator interpolator, <span class="keyword">boolean</span> flywheel)</span> </span>&#123;</span><br><span class="line">    mFinished = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (interpolator == <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInterpolator = <span class="keyword">new</span> ViscousFluidInterpolator();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mInterpolator = interpolator;</span><br><span class="line">    &#125;</span><br><span class="line">    mPpi = context.getResources().getDisplayMetrics().density * <span class="number">160.0f</span>;</span><br><span class="line">    mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());</span><br><span class="line">    mFlywheel = flywheel;</span><br><span class="line"></span><br><span class="line">    mPhysicalCoeff = computeDeceleration(<span class="number">0.84f</span>); <span class="comment">// look and feel tuning</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在构造器中做的主要就是指定了插补器，如果没有指定插补器，那么就用默认的ViscousFluidInterpolator。</p>
<p>我们再来看看Scroller的startScroll()：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startScroll</span><span class="params">(<span class="keyword">int</span> startX, <span class="keyword">int</span> startY, <span class="keyword">int</span> dx, <span class="keyword">int</span> dy, <span class="keyword">int</span> duration)</span> </span>&#123;</span><br><span class="line">    mMode = SCROLL_MODE;</span><br><span class="line">    mFinished = <span class="keyword">false</span>;</span><br><span class="line">    mDuration = duration;</span><br><span class="line">    mStartTime = AnimationUtils.currentAnimationTimeMillis();</span><br><span class="line">    mStartX = startX;</span><br><span class="line">    mStartY = startY;</span><br><span class="line">    mFinalX = startX + dx;</span><br><span class="line">    mFinalY = startY + dy;</span><br><span class="line">    mDeltaX = dx;</span><br><span class="line">    mDeltaY = dy;</span><br><span class="line">    mDurationReciprocal = <span class="number">1.0f</span> / (<span class="keyword">float</span>) mDuration;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们发现，在startScroll()里面并没有开始滚动，而是设置了一堆变量的初始值，那么到底是什么让View开始滚动的？我们应该把目标集中在startScroll()的下一句<code>invalidate();</code>身上。我们可以这样理解：首先在startScroll()设置好了一堆初始值，之后调用了<code>invalidate();</code>让View重新绘制，这里又有一个很重要的点，在draw()中会调用<code>computeScroll()</code>这个方法！</p>
<p>源码太长了，在这里就不贴出来了。想看的童鞋在View类里面搜<code>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>这个方法就能看到了。通过ViewGroup.drawChild()方法就会调用子View的draw()方法。而在View类里面的<code>computeScroll()</code>是一个空的方法，需要我们去实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Called by a parent to request that a child update its values for mScrollX</span><br><span class="line"> * and mScrollY if necessary. This will typically be done if the child is</span><br><span class="line"> * animating a scroll using a &#123;<span class="doctag">@link</span> android.widget.Scroller Scroller&#125;</span><br><span class="line"> * object.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">computeScroll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而在上面“三部曲”的第二部中，我们就已经实现了<code>computeScroll()</code>。首先判断了<code>computeScrollOffset()</code>，我们来看看相关源码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Call this when you want to know the new location.  If it returns true,</span><br><span class="line"> * the animation is not yet finished.</span><br><span class="line"> */</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">computeScrollOffset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mFinished) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> timePassed = (<span class="keyword">int</span>)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (timePassed &lt; mDuration) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (mMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> SCROLL_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);</span><br><span class="line">            mCurrX = mStartX + Math.round(x * mDeltaX);</span><br><span class="line">            mCurrY = mStartY + Math.round(x * mDeltaY);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> FLING_MODE:</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> t = (<span class="keyword">float</span>) timePassed / mDuration;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = (<span class="keyword">int</span>) (NB_SAMPLES * t);</span><br><span class="line">            <span class="keyword">float</span> distanceCoef = <span class="number">1</span>.f;</span><br><span class="line">            <span class="keyword">float</span> velocityCoef = <span class="number">0</span>.f;</span><br><span class="line">            <span class="keyword">if</span> (index &lt; NB_SAMPLES) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_inf = (<span class="keyword">float</span>) index / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> t_sup = (<span class="keyword">float</span>) (index + <span class="number">1</span>) / NB_SAMPLES;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_inf = SPLINE_POSITION[index];</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">float</span> d_sup = SPLINE_POSITION[index + <span class="number">1</span>];</span><br><span class="line">                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);</span><br><span class="line">                distanceCoef = d_inf + (t - t_inf) * velocityCoef;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            mCurrVelocity = velocityCoef * mDistance / mDuration * <span class="number">1000.0f</span>;</span><br><span class="line">            </span><br><span class="line">            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));</span><br><span class="line">            <span class="comment">// Pin to mMinX &lt;= mCurrX &lt;= mMaxX</span></span><br><span class="line">            mCurrX = Math.min(mCurrX, mMaxX);</span><br><span class="line">            mCurrX = Math.max(mCurrX, mMinX);</span><br><span class="line">            </span><br><span class="line">            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));</span><br><span class="line">            <span class="comment">// Pin to mMinY &lt;= mCurrY &lt;= mMaxY</span></span><br><span class="line">            mCurrY = Math.min(mCurrY, mMaxY);</span><br><span class="line">            mCurrY = Math.max(mCurrY, mMinY);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) &#123;</span><br><span class="line">                mFinished = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        mCurrX = mFinalX;</span><br><span class="line">        mCurrY = mFinalY;</span><br><span class="line">        mFinished = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>这个方法的返回值有讲究，若返回true则说明Scroller的滑动没有结束；若返回false说明Scroller的滑动结束了。再来看看内部的代码：先是计算出了已经滑动的时间，若已经滑动的时间小于总滑动的时间，则说明滑动没有结束；不然就说明滑动结束了，设置标记<code>mFinished = true;</code>。而在滑动未结束里面又分为了两个mode，不过这两个mode都干了差不多的事，大致就是根据刚才的时间<code>timePassed</code>和插补器来计算出该时间点滚动的距离<code>mCurrX</code>和<code>mCurrY</code>。也就是上面“三部曲”中第二部的mScroller.getCurrX(), mScroller.getCurrY()的值。</p>
<p>然后在第二部曲中调用scrollTo()方法滚动到指定点(即上面的<code>mCurrX</code>, <code>mCurrY</code>)。之后又调用了<code>postInvalidate();</code>，让View重绘并重新调用<code>computeScroll()</code>以此循环下去，一直到View滚动到指定位置为止，至此Scroller滚动结束。</p>
<p>其实Scroller的原理还是比较通俗易懂的。我们再来理清一下思路，以一张图的形式来终结今天的Scroller解析：</p>
<p><img src="/uploads/20160405/20160405235023.png" alt="这里写图片描述"></p>
<p>好了，如果有什么问题可以在下面留言。</p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android安全机制之反编译]]></title>
    <link href="http://yuqirong.me/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://yuqirong.me/2016/04/03/Android安全机制之反编译/</id>
    <published>2016-04-02T16:59:11.000Z</published>
    <updated>2016-08-18T15:09:33.801Z</updated>
    <content type="html"><![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米修斯方法”以及“宙斯类”(不得不感慨开发小哥的智商)。之后就是在阅读《Android群英传》时也有相关反编译的内容，觉得有必要记录一下。所以这就是本片写博文的起源了。</p>
<p>首先关于反编译，我们先要准备几个工具：</p>
<ul>
<li>apktool：aoktool主要是用来反编译资源文件的，也就是XML了。</li>
<li>Dex2jar：Dex2jar就是反编译源代码的，会把源代码反编译成一个jar包。</li>
<li>jd-gui ：在上面Dex2jar反编译出来的jar包，放入jd-gui中，就可以查看源代码了。</li>
</ul>
<p>关于上面的三个工具，我会在文末放出下载链接，大家可以去下载。</p>
<p>好了，那接下来我们就开始反编译之旅吧！</p>
<p>至于要反编译的apk，我只能选择自己的<a href="https://github.com/yuqirong/Koku" target="_blank" rel="external">Koku</a>了，<a href="http://www.wandoujia.com/apps/com.yuqirong.koku/download" target="_blank" rel="external">点击此处下载</a>。</p>
<p>我们把上面下载下来的apk用winrar打开(当然你也可以用其他的解压工具)，我们可以看到里面的文件内容如下图所示：</p>
<p><img src="/uploads/20160403/20160403112646.png" alt="这里写图片描述"></p>
<p>我们发现classes.dex这个文件，其实classes.dex反编译出来就是源代码。然后我们把Dex2jar解压出来，发现里面有d2j-dex2jar.bat，这就是主角了。</p>
<p><img src="/uploads/20160403/20160403124449.png" alt="这里写图片描述"></p>
<p>在Dex2jar解压出来的目录下，打开命令提示符输入：</p>
<pre><code>d2j-dex2jar.bat classes.dex所在的路径
</code></pre><p>比如：</p>
<p><img src="/uploads/20160403/20160403124911.png" alt="这里写图片描述"></p>
<p>运行后，我们发现在Dex2jar解压出来的目录下多了一个classes-dex2jar.jar。</p>
<p><img src="/uploads/20160403/20160403125136.png" alt="这里写图片描述"></p>
<p>然后我们把下载下来的jd-gui.zip解压，里面会有jd-gui.exe。相信大家都懂吧。用jd-gui.exe打开上面的classes-dex2jar.jar，你会惊喜地发现源代码就在你眼前！</p>
<p><img src="/uploads/20160403/20160403125619.png" alt="这里写图片描述"></p>
<p>看上面的代码截图，我们会发现比如说<code>setContentView()</code>里面是一串数字。不过别怕，我们都知道R文件是用来关联资源文件的，把上面的那串数字复制下来，再打开R.class，查找一下：</p>
<p><img src="/uploads/20160403/20160403130002.png" alt="这里写图片描述"></p>
<p>原来那串数字就代表了activity_my_favorite.xml这个layout。那么问题来了，我们如何反编译XML文件呢？那就要用到上面的apktool了。</p>
<p>打开apktool的所在目录，把koku.apk移动到apktool的同一目录下，输入命令符：</p>
<pre><code>java -jar apktool_2.1.0.jar d koku.apk
</code></pre><p>如果你配置了Java环境变量，则可以直接输入：</p>
<pre><code>apktool_2.1.0.jar d koku.apk
</code></pre><p>运行完成之后，我们可以发现在目录下多了一个名字叫koku的文件夹，而这就是我们反编译出来的XML文件了。</p>
<p><img src="/uploads/20160403/20160403131154.png" alt="这里写图片描述"></p>
<p>我们打开里面的AndroidManifest.xml：</p>
<p><img src="/uploads/20160403/20160403131326.png" alt="这里写图片描述"></p>
<p>里面真的有<uses-permission\>、<activity\>等信息！然后我们打开res里面的layout文件夹，会发现里面有我们上面提到的activity_my_favorite.xml：</activity\></uses-permission\></p>
<p><img src="/uploads/20160403/20160403131658.png" alt="这里写图片描述"></p>
<p>里面的布局一目了然。到这里，这样一个apk的基本的源代码我们都可以看得到。当然，反编译别人的apk应该是以学习为主，而不是恶意地二次打包以及破坏。</p>
<p>在这里额外多说一句，如果要反编译的apk经过了代码混淆，那么反编译出来的就变成了a.class、b.class、c.class等等，所以代码混淆可以有效地阻止apk反编译。</p>
<p>而如果你想要将代码混淆，只要打开项目中的build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能。proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><p>好了，差不多该讲的都讲完了，今天就到这里了。</p>
<p>下面给出反编译工具的下载链接：</p>
<p><a href="/uploads/20160403/apktool_2.1.0.jar">apktool_2.1.0.jar</a></p>
<p><a href="/uploads/20160403/dex2jar-2.0.zip">dex2jar-2.0.zip</a></p>
<p><a href="/uploads/20160403/jd-gui-0.3.5.windows.zip">jd-gui-0.3.5.windows.zip</a></p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/03/31/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/03/31/《Android开发艺术探索》笔记(上)/</id>
    <published>2016-03-31T11:49:28.000Z</published>
    <updated>2016-09-13T15:41:55.505Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="第一章：Activity的生命周期和启动模式"></a>第一章：Activity的生命周期和启动模式</h1><h2 id="1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790"><a href="#1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790" class="headerlink" title="1.1 Activity的生命周期全面分析"></a>1.1 Activity的生命周期全面分析</h2><p><strong>典型情况下的生命周期分析</strong></p>
<p>onStart()和onStop()是从Activity是否可见这个角度来回调的，而onResume()和onPause()是从Activity是否位于前台这个角度来回调的。</p>
<p>Activity A打开Activity B时，为了不影响B的显示，最好不要在Activity A的onPause()里执行一些耗时操作，可以考虑将这些操作放到onStop()里，这时B已经可见了。</p>
<p><strong>异常情况下的生命周期分析</strong></p>
<p>由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用时机是在onStop()之前，但它和onPause()没有既定的时序关系，它既可能在onPause()之前调用，也可能在onPause()之后调用。需要强调的一点是，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会调用onSaveInstanceState()这个方法。</p>
<p>当Activity被重新创建后，系统会调用onRestoreInstanceState()，并且把Activity销毁时onSaveInstanceState()方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState()和onCreate()方法。因此我们可以通过onRestoreInstanceState()和onCreate()方法来判断Activity是否重建了。如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart()之后。</p>
<p>和Activity一样，每个View都有onSaveInstanceState()和onRestoreInstanceState()这两个方法。关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorWindow。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父层委托子元素去处理一件事情。至于数据恢复过程也是类似的，这里就不再重复介绍了。</p>
<p>Activity按照优先级从高到低，可以分为如下三种：</p>
<ul>
<li>前台Activity——正在和用户交互的Activity，优先级最高。</li>
<li>可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。</li>
<li>后台Activity——已经被暂停的Activity，比如说执行了onStop，优先级最低。</li>
</ul>
<p>如果不想Activity在屏幕旋转的时候重新创建，则：</p>
<pre><code>android:configChanges=&quot;orientation&quot;
</code></pre><p>另外，若minSdkVersion和targetSdkVersion其中有一个低于13，则要在上面的基础上，加上screenSize，即：</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre><h2 id="1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F"><a href="#1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h2><p><strong>Activity的launchMode</strong></p>
<ul>
<li><p>standard 标准模式。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity就运行在启动仪它的那个Activity所在的栈里。另外要注意的是，当我们用ApplicationContext去启动standard模式的Activity的时候会报错，错误如下</p>
<pre><code>E/AndroidRuntime(674):andriod.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.Is this really what you want?
</code></pre><p>  这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈，所以这就有问题了。解决这个问题的方法是为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动Activity实际上是以singleTask模式启动的。</p>
</li>
<li><p>singleTop 栈顶复用模式。若该Activity已经位于任务栈的栈顶，那么该Activity不会被重新创建，同时它的onNewIntent()方法会被回调，通过此方法的参数我们可以取出当前请求的信息。而且它的onCreate()和onStart()并不会被调用。执行的是onPause() –&gt; onNewIntent() –&gt; onResume()。 如果该Activity已存在但不是位于栈顶，则该Activity仍然会被重新创建。</p>
</li>
<li><p>singleTask 栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewsIntent()。具体一点，当一个具有singleTask模式的Activity请求启动后，比如说Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在把A所需的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶(会把在栈中所有处于A之上的Activity全部出栈)并调用它的onNewsIntent()方法，如果实例不存在，就创建A的实例并把A压入栈中。</p>
<p>  设ActivityA的 android:launchMode=”singleTask” 方式，且ActivityA正处于栈中，但不是栈顶，栈顶为ActivityB，点击按钮启动ActivityA，则：<br>  B: onPause() -&gt; A: onNewIntent() -&gt; A:onRestart() -&gt; A: onStart() -&gt; A:onResume() -&gt; B: onStop() -&gt; B: onDestroy()</p>
</li>
<li><p>singleInstance 单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity。除非这个独特的任务栈被系统销毁了。</p>
</li>
</ul>
<p><code>android:taskAffinity</code>：可以翻译为任务相关性。这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为报名。当然，我们可以为每个Activity都单独制定TaskAffinity属性，这个属性必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>
<ul>
<li><p>当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。</p>
</li>
<li><p>当TaskAffinity和allowTaskReparenting结合的时候，这种情况比较复杂，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。</p>
</li>
</ul>
<p><strong>Activity的Flags</strong></p>
<ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性<code>android:excludeFromRecents=&quot;true&quot;</code>。</p>
</li>
</ul>
<h2 id="1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219"><a href="#1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219" class="headerlink" title="1.3 IntentFilter的匹配规则"></a>1.3 IntentFilter的匹配规则</h2><ul>
<li>action匹配规则：要求intent中的action 存在 且 必须和过滤规则中的其中一个相同 区分大小写；</li>
<li>category匹配规则：系统会默认加上一个android.intent.category.DEAFAULT，所以intent中可以不存在category，但如果存在就必须匹配其中一个；</li>
<li>data匹配规则：data由两部分组成，mimeType和URI，要求和action相似。如果没有指定URI，URI但默认值为content和file（schema）。如果要为intent指定完整的data，必须要调用setDataAndType方法。</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236"><a href="#u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236" class="headerlink" title="第二章：IPC机制"></a>第二章：IPC机制</h1><h2 id="2-1_Android_IPC_u7B80_u4ECB"><a href="#2-1_Android_IPC_u7B80_u4ECB" class="headerlink" title="2.1 Android IPC简介"></a>2.1 Android IPC简介</h2><h2 id="2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="2.2 Android中的多进程模式"></a>2.2 Android中的多进程模式</h2><p><strong>开启多进程模式</strong></p>
<p>在Android中使用多进程只有一个办法，那就是给四大组件(Activity、Service、Receiver、ContentProvider)在AndroidMenifest中指定android:process属性。另外还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程。</p>
<p>进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局过程，其他应用可以通过ShareUID方式和它跑在同一个进程中。</p>
<p>我们知道Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。这里要说明的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说他们看起来就像是一个应用的两个部分。</p>
<p><strong>多进程模式的运行机制</strong></p>
<p>Android会为每一个应用分配一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。</p>
<p>一般来说，使用多进程会造成如下几方面的问题：</p>
<ol>
<li>静态成员和单例模式完全失效；</li>
<li>线程同步机制完全失效；</li>
<li>SharedPreferences的可靠性下降；</li>
<li>Application会多次创建。</li>
</ol>
<h2 id="2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD"><a href="#2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD" class="headerlink" title="2.3 IPC基础概念介绍"></a>2.3 IPC基础概念介绍</h2><p><strong>Serializable接口</strong></p>
<p>Serializable接口是Java中为对象提供标准的序列化和反序列化操作的接口，通过Serializable来实现对象的序列化和反序列化(User类实现了Serializable接口)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 序列化过程</span></span><br><span class="line">User user = <span class="keyword">new</span> User(<span class="number">0</span>,<span class="string">"jake"</span>,<span class="keyword">true</span>);</span><br><span class="line">ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"cache.txt"</span>));</span><br><span class="line">out.writeObject(user);</span><br><span class="line">out.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反序列化过程</span></span><br><span class="line">ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"cache.txt"</span>))；</span><br><span class="line">User newUser = (User)in.readObject();</span><br><span class="line">in.close();</span><br></pre></td></tr></table></figure>
<p>恢复的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>原则上序列化后的数据中的serialVerionUID只有和当前类的serialVersionUID相同才能够正常地被反序列化。</p>
<p>serialVersionUID的详细工作机制：序列化的时候系统会把当前类的serialVersionUID写入序列化的文件中，当反序列化的时候系统会去检测文件中的serialVersionUID，看它是否和当前类的serialVersionUID一致，如果一致就说明序列化的类的版本和当前类的版本是相同的，这个时候可以成功反序列化；否则说明版本不一致无法正常反序列化。一般来说，我们应该手动指定serialVersionUID的值。</p>
<p>有两个需要注意一下：</p>
<ul>
<li>静态成员变量属于类不属于对像，所以不会参与序列化过程；</li>
<li>用transient关键字标记的成员变量不参与序列化过程。</li>
</ul>
<p><strong>Parcelable接口</strong></p>
<p>Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，因此推荐使用Parcelable。Parcelable接口可以在Binder中自由传输，Parcelable主要用在内存序列化上，可以直接序列化的有Intent、Bundle、Bitmap以及List和Map等等，下面是一个实现了Parcelable接口的示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Book</span> <span class="keyword">implements</span> <span class="title">Parcelable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> bookId;</span><br><span class="line">    <span class="keyword">public</span> String bookName;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Book</span><span class="params">(<span class="keyword">int</span> bookId, String bookName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.bookId = bookId;</span><br><span class="line">        <span class="keyword">this</span>.bookName = bookName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//“内容描述”，如果含有文件描述符返回1，否则返回0，几乎所有情况下都是返回0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">describeContents</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现序列化操作，flags标识只有0和1，1表示标识当前对象需要作为返回值返回，不能立即释放资源，几乎所有情况都为0</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeToParcel</span><span class="params">(Parcel out, <span class="keyword">int</span> flags)</span> </span>&#123;</span><br><span class="line">        out.writeInt(bookId);</span><br><span class="line">        out.writeString(bookName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//实现反序列化操作</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Parcelable.Creator&lt;Book&gt; CREATOR = <span class="keyword">new</span> Parcelable.Creator&lt;Book&gt;() &#123;</span><br><span class="line">        <span class="comment">//从序列化后的对象中创建原始对象</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Book <span class="title">createFromParcel</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book(in);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">public</span> Book[] newArray(<span class="keyword">int</span> size) &#123;<span class="comment">//创建指定长度的原始对象数组</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> Book[size];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Book</span><span class="params">(Parcel in)</span> </span>&#123;</span><br><span class="line">        bookId = in.readInt();</span><br><span class="line">        bookName = in.readString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Binder</strong></p>
<p>Binder是Android的一个类，它继承了IBinder接口。从IPC的角度来说，Binder是Android中的一种跨进程通信方式，Binder还可以理解为一种虚拟的物理设备，它的设备驱动是/dev/binder，该通信方式在Linux中没有；从Android Framework角度来说，Binder是ServiceManager连接各种Manager(ActivityManager、WindowManager等等)和相应ManagerService的桥梁；从Android应用层来说，Binder是客户端和服务端进行通信的媒介，当bindService的时候，服务端会返回一个包含了服务端业务调用的Binder对象，通过这个Binder对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包含普通服务和基于AIDL的服务。</p>
<p>在Android开发中，Binder主要用在Service中，包括AIDL和Messenger，其中普通Service中的Binder不涉及进程间通信，较为简单；而Messenger的底层其实是AIDL，正是Binder的核心工作机制。</p>
<p>AIDL工具根据AIDL文件自动生成的Java接口的解析：首先，它声明了几个接口方法，同时还声明了几个整型的id用于标识这些方法，id用于标识在transact过程中客户端所请求的到底是哪个方法；接着，它声明了一个内部类Stub，这个Stub就是一个Binder类，当客户端和服务端都位于同一个进程时，方法调用不会走跨进程的transact过程，而当两者位于不同进程时，方法调用需要走transact过程，这个逻辑由Stub内部的代理类Proxy来完成。</p>
<p>AIDL接口的核心就是它的内部类Stub和Stub内部的代理类Proxy。 下面分析其中的方法：</p>
<ul>
<li><code>DESCRIPTOR</code>:Binder的唯一标识，一般用当前Binder的类名表示，比如“com.example.android.MyAIDLInterface”。</li>
<li><code>asInterface(android.os.IBinder obj)</code>：用于将服务端的Binder对象转换成客户端所需的AIDL接口类型的对象，这种转换过程是区分进程的，如果客户端和服务端是在同一个进程中，那么这个方法返回的是服务端的Stub对象本身，否则返回的是系统封装的Stub.Proxy对象。</li>
<li><code>asBinder()</code>：返回当前Binder对象。</li>
<li><code>onTransact(int code, android.os.Parcel data, android.os.Parcel reply, int flags)</code>：这个方法运行在服务端中的Binder线程池中，当客户端发起跨进程请求时，远程请求会通过系统底层封装后交由此方法来处理。这个方法的原型是<code>public Boolean onTransact(int code, Parcelable data, Parcelable reply, int flags)</code>服务端通过code可以知道客户端请求的目标方法，接着从data中取出所需的参数，然后执行目标方法，执行完毕之后，将结果写入到reply中。如果此方法返回false，说明客户端的请求失败，利用这个特性可以做权限验证(即验证是否有权限调用该服务)。</li>
<li><code>Proxy#[Method]</code>：代理类中的接口方法，这些方法运行在客户端，当客户端远程调用此方法时，它的内部实现是：首先创建该方法所需要的参数，然后把方法的参数信息写入到_data中，接着调用transact方法来发起RPC请求，同时当前线程挂起；然后服务端的onTransact方法会被调用，直到RPC过程返回后，当前线程继续执行，并从_reply中取出RPC过程的返回结果，最后返回_reply中的数据。</li>
</ul>
<p>Binder的工作机制原理图：</p>
<p><img src="/uploads/20160809/20160814201234.png" alt="Binder的工作机制原理图"></p>
<p>Binder的两个重要方法linkToDeath和unlinkToDeath：<br>Binder运行在服务端，如果由于某种原因服务端异常终止了的话会导致客户端的远程调用失败，所以Binder提供了两个配对的方法linkToDeath和unlinkToDeath，通过linkToDeath方法可以给Binder设置一个死亡代理，当Binder死亡的时候客户端就会收到通知，然后就可以重新发起连接请求从而恢复连接了。<br>如何给Binder设置死亡代理呢？</p>
<p>(一). 声明一个DeathRecipient对象，DeathRecipient是一个接口，其内部只有一个方法bindeDied，实现这个方法就可以在Binder死亡的时候收到通知了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> IBinder.DeathRecipient mDeathRecipient = <span class="keyword">new</span> IBinder.DeathRecipient() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">binderDied</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoteBookManager == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        mRemoteBookManager.asBinder().unlinkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br><span class="line">        mRemoteBookManager = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span>这里重新绑定远程Service</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>(二). 在客户端绑定远程服务成功之后，给binder设置死亡代理：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mRemoteBookManager.asBinder().linkToDeath(mDeathRecipient, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<h2 id="2-4_IPC_u65B9_u5F0F"><a href="#2-4_IPC_u65B9_u5F0F" class="headerlink" title="2.4 IPC方式"></a>2.4 IPC方式</h2><ol>
<li><p>使用Bundle：Bundle实现了Parcelable接口，Activity、Service和Receiver都支持在Intent中传递Bundle数据。</p>
</li>
<li><p>使用文件共享：这种方式简单，适合在对数据同步要求不高的进程之间进行通信，并且要妥善处理并发读写的问题。</p>
<p> SharedPreferences是一个特例，虽然它也是文件的一种，但是由于系统对它的读写有一定的缓存策略，即在内存中会有一份SharedPreferences文件的缓存，因此在多进程模式下，系统对它的读写就变得不可靠，当面对高并发读写访问的时候，有很大几率会丢失数据，因此，不建议在进程间通信中使用SharedPreferences。</p>
</li>
<li><p>使用Messenger：Messenger是一种轻量级的IPC方案，它的底层实现就是AIDL。Messenger是以串行的方式处理请求的，即服务端只能一个个处理，不存在并发执行的情形。</p>
<p> Messenger的工作原理：</p>
<p> <img src="/uploads/20160809/20160809234757.png" alt="Messenger的工作原理图"></p>
</li>
<li><p>使用AIDL:首先建一个Service和一个AIDL接口，接着创建一个类继承自AIDL接口中的Stub类并实现Stub类中的抽象方法，在Service的onBind方法中返回这个类的对象，然后客户端就可以绑定服务端Service，建立连接后就可以访问远程服务端的方法了。</p>
<p> AIDL使用的注意点：</p>
<p> (1). AIDL支持的数据类型：基本数据类型、String和CharSequence、ArrayList、HashMap、Parcelable以及AIDL；<br> (2). 某些类即使和AIDL文件在同一个包中也要显式import进来；<br> (3). AIDL中除了基本数据类，其他类型的参数都要标上方向：in、out或者inout；<br> (4). AIDL接口中支持方法，不支持声明静态变量；<br> (5). 为了方便AIDL的开发，建议把所有和AIDL相关的类和文件全部放入同一个包中，这样做的好处是，当客户端是另一个应用的时候，可以直接把整个包复制到客户端工程中。<br> (6). AIDL方法是在服务端的Binder线程池中执行的，因此当多个客户端同时连接的时候，会存在多个线程同时访问的情形，所以要在AIDL方法中处理线程同步。<br> (7). RemoteCallbackList是系统专门提供的用于删除跨进程Listener的接口。RemoteCallbackList是一个泛型，支持管理任意的AIDL接口，因为所有的AIDL接口都继承自IInterface接口。<br> (8). 客户端调用远程服务方法时，因为远程方法运行在服务端的binder线程池中，同时客户端线程会被挂起，所以如果该方法过于耗时，而客户端又是UI线程，会导致ANR，所以当确认该远程方法是耗时操作时，应避免客户端在UI线程中调用该方法。同理，当服务器调用客户端的listener方法时，该方法也运行在客户端的binder线程池中，所以如果该方法也是耗时操作，请确认运行在服务端的非UI线程中。另外，因为客户端的回调listener运行在binder线程池中，所以更新UI需要用到handler。<br> (9). 客户端通过IBinder.DeathRecipient来监听Binder死亡，也可以在onServiceDisconnected中监听并重连服务端。区别在于前者是在binder线程池中，访问UI需要用Handler，后者则是UI线程。<br> (10). AIDL可通过自定义权限在onBind或者onTransact中进行权限验证。</p>
</li>
<li><p>使用ContentProvider<br>1.ContentProvider主要以表格的形式来组织数据，并且可以包含多个表；<br>2.ContentProvider还支持文件数据，比如图片、视频等，系统提供的MediaStore就是文件类型的ContentProvider；<br>3.ContentProvider对底层的数据存储方式没有任何要求，可以是SQLite、文件，甚至是内存中的一个对象都行；<br>4.要观察ContentProvider中的数据变化情况，可以通过ContentResolver的registerContentObserver方法来注册观察者；</p>
</li>
<li><p>使用Socket<br>Socket是网络通信中“套接字”的概念，分为流式套接字和用户数据包套接字两种，分别对应网络的传输控制层的TCP和UDP协议。</p>
</li>
</ol>
<h2 id="2-5_Binder_u8FDE_u63A5_u6C60"><a href="#2-5_Binder_u8FDE_u63A5_u6C60" class="headerlink" title="2.5 Binder连接池"></a>2.5 Binder连接池</h2><p>(1). 当项目规模很大的时候，创建很多个Service是不对的做法，因为service是系统资源，太多的service会使得应用看起来很重，所以最好是将所有的AIDL放在同一个Service中去管理。整个工作机制是：每个业务模块创建自己的AIDL接口并实现此接口，这个时候不同业务模块之间是不能有耦合的，所有实现细节我们要单独开来，然后向服务端提供自己的唯一标识和其对应的Binder对象；对于服务端来说，只需要一个Service，服务端提供一个queryBinder接口，这个接口能够根据业务模块的特征来返回相应的Binder对象给它们，不同的业务模块拿到所需的Binder对象后就可以进行远程方法调用了。<br>Binder连接池的主要作用就是将每个业务模块的Binder请求统一转发到远程Service去执行，从而避免了重复创建Service的过程。</p>
<p>(2). 作者实现的Binder连接池BinderPool的<a href="https://github.com/singwhatiwanna/android-art-res/blob/master/Chapter_2/src/com/ryg/chapter_2/binderpool/BinderPool.java" target="_blank" rel="external">实现源码</a>，建议在AIDL开发工作中引入BinderPool机制。</p>
<h2 id="2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F"><a href="#2-6__u9009_u7528_u5408_u9002_u7684IPC_u65B9_u5F0F" class="headerlink" title="2.6 选用合适的IPC方式"></a>2.6 选用合适的IPC方式</h2><p><img src="/uploads/20160809/20160814191325.png" alt="选用合适的IPC方式"></p>
<p>// TODO</p>
<h1 id="u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB"><a href="#u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h1><h2 id="3-1_View_u57FA_u7840_u77E5_u8BC6"><a href="#3-1_View_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="3.1 View基础知识"></a>3.1 View基础知识</h2><p><strong>View的位置参数</strong></p>
<ul>
<li>View的宽高和坐标关系：width = right - left，height = top - bottom。</li>
<li>View在平移过程中，top和left表示的是原始左上角的位置信息，其值不会改变，发生改变的是x、y、translationX、translationY这四个参数。x是View左上角的坐标，translation是view移动后相对于父容器的偏移量，所以有x = left + translationX。y的原理相同。</li>
</ul>
<p><strong>MotionEvent和TouchSlop</strong></p>
<p>TouchSlop是系统所能识别出的被认为是滑动的最小距离。这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>。当两次滑动事件的滑动距离小于TouchSlop时就可以认为不是滑动。</p>
<p><strong>VelocityTracker、GestureDetector和Scroller</strong></p>
<p>1.VelocityTracker</p>
<p>速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。首先，在View的onTouchEvent方法中追踪当前单击事件的速度。</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></pre><p>获取当前的速度：</p>
<pre><code>velocityTracker.computeCurrentVelocity(1000); //表示的是一个时间单元或者说时间间隔
int xVelocity = (int) velocityTracker.getXVelocity();
int yVelocity = (int) velocityTracker.getYVelocity();
</code></pre><p>当不用它的时候，需要调用clear()方法来重置并回收内存：</p>
<pre><code>velocityTracker.clear();
velocityTracker.recycle();
</code></pre><p>2.GestureDetector</p>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行动。</p>
<p>首先，需要创建一个GestureDetector对象并实现OnGestureListener接口，根据需要我们还可以实现OnDoubleTapListener从而能够监听双击行为：</p>
<pre><code>GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false)；
</code></pre><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加如下实现：</p>
<pre><code>boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre><p>做完了上面两步，我们就可以有选择地实现OnGestureListener和OnDoubleTapListener中的方法了。</p>
<p>3.Scroller</p>
<p>在3.2节中详细介绍。</p>
<h2 id="3-2_View_u7684_u6ED1_u52A8"><a href="#3-2_View_u7684_u6ED1_u52A8" class="headerlink" title="3.2 View的滑动"></a>3.2 View的滑动</h2><ul>
<li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p>
</li>
<li><p>使用动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</p>
</li>
<li><p>改变布局参数：操作稍微复杂，使用于有交互的View</p>
</li>
</ul>
<h2 id="3-3__u5F39_u6027_u6ED1_u52A8"><a href="#3-3__u5F39_u6027_u6ED1_u52A8" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><ul>
<li><p>使用Scroller</p>
</li>
<li><p>通过动画</p>
</li>
<li><p>使用Handler延时策略</p>
</li>
</ul>
<h2 id="3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236"><a href="#3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236" class="headerlink" title="3.4 View的事件分发机制"></a>3.4 View的事件分发机制</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View。即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>主要过程：Activity的dispatchTouchEvent–&gt;Window的superDispatchTouchEvent(Window实际上是一个抽象类，而它的实现类为PhoneWindow)–&gt;DecorView的superDispatchTouchEvent(DecorView是继承自FrameLayout，是Activity的根View)–&gt;分发到子View中(即分发到contentView中)。</p>
<p>注意点：</p>
<ul>
<li><p>如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
</li>
<li><p>某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。</p>
</li>
<li><p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</p>
</li>
<li><p>通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
<li><p>ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</p>
</li>
</ul>
<h2 id="3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81"><a href="#3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81" class="headerlink" title="3.5 View的滑动冲突"></a>3.5 View的滑动冲突</h2><p><strong>常见的滑动冲突场景</strong></p>
<p>常见的滑动冲突场景可以简单分为如下三种：</p>
<ul>
<li>场景1——外部滑动方向和内部滑动方向不一致</li>
<li>场景2——外部滑动方向和内部滑动方向一致</li>
<li>场景3——上面两种情况的嵌套</li>
</ul>
<p><strong>滑动冲突处理规则</strong></p>
<p>可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等</p>
<p><strong>滑动冲突的解决方式</strong></p>
<p>外部拦截法：点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。</p>
<p>伪代码如下：</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastXIntercept;
        int deltaY = y - mLastYIntercept;
        if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }

    mLastXIntercept = x;
    mLastYIntercept = y;

    return intercepted;
}
</code></pre><p>内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。</p>
<p>伪代码如下：</p>
<p>子元素：</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            getParent().requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre><p>父元素：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    int action = event.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        return false;
    }else{
        return true;
    }
}
</code></pre><h1 id="u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406"><a href="#u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="第四章：View的工作原理"></a>第四章：View的工作原理</h1><h2 id="4-1__u521D_u8BC6ViewRoot_u548CDecorView"><a href="#4-1__u521D_u8BC6ViewRoot_u548CDecorView" class="headerlink" title="4.1 初识ViewRoot和DecorView"></a>4.1 初识ViewRoot和DecorView</h2><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，这个过程可参看如下源码：</p>
<pre><code>root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
</code></pre><p>View的绘制流程从ViewRoot的performTraversals方法开始，经过measure、layout和draw三大流程。</p>
<p>performMeasure方法中会调用measure方法，在measure方法中又会调用onMeasure方法，在onMeasure方法中会对所有的子元素进行measure过程，这个时候measure流程就从父容器传递到子元素了，这样就完成了一次measure过程，layout和draw的过程类似。 (书中175页画出详细的图示)</p>
<p>measure过程决定了view的宽高，在几乎所有的情况下这个宽高都等同于view最终的宽高。layout过程决定了view的四个顶点的坐标和view实际的宽高，通过getWidth和getHeight方法可以得到最终的宽高。draw过程决定了view的显示。</p>
<p>DecorView其实是一个FrameLayout，其中包含了一个竖直方向的LinearLayout，上面是标题栏，下面是内容栏(id为android.R.id.content)。内容栏也是一个FrameLayout。</p>
<h2 id="4-2__u7406_u89E3MeasureSpec"><a href="#4-2__u7406_u89E3MeasureSpec" class="headerlink" title="4.2 理解MeasureSpec"></a>4.2 理解MeasureSpec</h2><ol>
<li><p><strong>MeasureSpec和LayoutParams的对应关系</strong></p>
<p> 在view测量的时候，系统会将LayoutParams在父容器的约束下转换成对应的MeasureSpec，然后再根据这个MeasureSpec来确定View测量后的宽高。<br> MeasureSpec不是唯一由LayoutParams决定的，LayoutParams需要和父容器一起才能决定view的MeasureSpec，从而进一步确定view的宽高。对于DecorView，它的MeasureSpec由窗口的尺寸和其自身的LayoutParams来决定；对于普通view，它的MeasureSpec由父容器的MeasureSpec和自身的LayoutParams来共同决定。</p>
</li>
<li><p><strong>普通view的MeasureSpec的创建规则</strong></p>
<p> 当view采用固定宽高时，不管父容器的MeasureSpec是什么，view的MeasureSpec都是精确模式，并且大小是LayoutParams中的大小。<br> 当view的宽高是match_parent时，如果父容器的模式是精确模式，那么view也是精确模式，并且大小是父容器的剩余空间；如果父容器是最大模式，那么view也是最大模式，并且大小是不会超过父容器的剩余空间。<br> 当view的宽高是wrap_content时，不管父容器的模式是精确模式还是最大模式，view的模式总是最大模式，并且大小不超过父容器的剩余空间。</p>
</li>
</ol>
<h2 id="4-3_view_u7684_u5DE5_u4F5C_u6D41_u7A0B"><a href="#4-3_view_u7684_u5DE5_u4F5C_u6D41_u7A0B" class="headerlink" title="4.3 view的工作流程"></a>4.3 view的工作流程</h2><p><strong>measure过程</strong></p>
<p>getSuggestedMinimumWidth的逻辑：View如果没有背景，那么返回android:minWidth这个属性指定的值，这个值可以为0；如果设置了背景，则返回背景的最小宽度和minWidth中的较大值。</p>
<p>view的measure过程和Activity的生命周期方法不是同步执行的，因此无法保证Activity执行了onCreate、onStart、onResume时某个view已经测量完毕了。如果view还没有测量完毕，那么获得的宽高就都是0。下面是四种解决该问题的方法：</p>
<ol>
<li><p>Activity/View # onWindowFocusChanged<br>onWindowFocusChanged方法表示view已经初始化完毕了，宽高已经准备好了，这个时候去获取宽高是没问题的。这个方法会被调用多次，当Activity继续执行或者暂停执行的时候，这个方法都会被调用。</p>
</li>
<li><p>view.post(runnable)<br>通过post将一个runnable投递到消息队列的尾部，然后等待Looper调用此runnable的时候，view也已经初始化好了。</p>
</li>
<li><p>ViewTreeObserver<br>使用ViewTreeObserver的众多回调方法可以完成这个功能，比如使用onGlobalLayoutListener接口，当view树的状态发生改变或者view树内部的view的可见性发生改变时，onGlobalLayout方法将被回调。伴随着view树的状态改变，这个方法也会被多次调用。</p>
</li>
<li><p>view.measure(int widthMeasureSpec, int heightMeasureSpec)<br>通过手动对view进行measure来得到view的宽高，这个要根据view的LayoutParams来处理：<br>match_parent：无法measure出具体的宽高；</p>
<p> 精确值：例如100px</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec(<span class="number">100</span>, MeasureSpec.EXACTLY);</span><br><span class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure>
<p> wrap_content：如下measure，设置最大值</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> widthMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</span><br><span class="line"><span class="keyword">int</span> heightMeasureSpec = MeasureSpec.makeMeasureSpec((<span class="number">1</span> &lt;&lt; <span class="number">30</span>) - <span class="number">1</span>, MeasureSpec.AT_MOST);</span><br><span class="line">view.measure(widthMeasureSpec, heightMeasureSpec);</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>layout过程</strong></p>
<p>在view的默认实现中，view的测量宽高和最终宽高是相等的，只不过测量宽高形成于measure过程，而最终宽高形成于layout过程。</p>
<p><strong>draw过程</strong></p>
<p>draw过程大概有下面几步：</p>
<ol>
<li>绘制背景：background.draw(canvas)；</li>
<li>绘制自己：onDraw()；</li>
<li>绘制children：dispatchDraw；</li>
<li>绘制装饰：onDrawScrollBars。</li>
</ol>
<p>setWillNotDraw方法用于在一个View不需要绘制时的优化（设置为true时）。</p>
<h2 id="4-4__u81EA_u5B9A_u4E49view"><a href="#4-4__u81EA_u5B9A_u4E49view" class="headerlink" title="4.4 自定义view"></a>4.4 自定义view</h2><ol>
<li>直接继承View或ViewGroup的需要自己处理wrap_content。 </li>
<li>View要在onDraw方法中要处理padding，而ViewGroup要在onMeasure和onLayout中处理padding和margin。 </li>
<li>尽量不要在View中使用Handler，因为view内部本身已经提供了post系列的方法，完全可以替代Handler的作用。</li>
<li>view中如果有线程或者动画，需要在onDetachedFromWindow方法中及时停止。</li>
<li>处理好view的滑动冲突情况。</li>
</ol>
<h1 id="u7B2C_u516D_u7AE0_Android_u7684Drawable"><a href="#u7B2C_u516D_u7AE0_Android_u7684Drawable" class="headerlink" title="第六章 Android的Drawable"></a>第六章 Android的Drawable</h1><h2 id="6-1_Drawable_u7B80_u4ECB"><a href="#6-1_Drawable_u7B80_u4ECB" class="headerlink" title="6.1 Drawable简介"></a>6.1 Drawable简介</h2><ol>
<li>Android的Drawable表示的是一种可以在Canvas上进行绘制的概念，它的种类很多，最常见的就是图片和颜色了。它有两个重要的优点：一是比自定义view要简单；二是非图片类型的drawable占用空间小，利于减小apk大小。</li>
<li>Drawable是抽象类，是所有Drawable对象的基类。</li>
<li>Drawable的内部宽/高可以通过getIntrinsicWidth和getIntrinsicHeight方法获取，但是并不是所有Drawable都有内部宽/高。图片Drawable的内部宽高就是图片的宽高，但是颜色Drawable就没有宽高的概念，它一般是作为view的背景，所以会去适应view的大小，这两个方法都是返回-1。</li>
</ol>
<h2 id="6-2_Drawable_u5206_u7C7B"><a href="#6-2_Drawable_u5206_u7C7B" class="headerlink" title="6.2 Drawable分类"></a>6.2 Drawable分类</h2><ol>
<li><p>BitmapDrawable和NinePatchDrawable</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;bitmap / nine-patch
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:src=&quot;@[package:]drawable/drawable_resource&quot;
    android:antialias=[&quot;true&quot; | &quot;false&quot;]
    android:dither=[&quot;true&quot; | &quot;false&quot;]
    android:filter=[&quot;true&quot; | &quot;false&quot;]
    android:gravity=[&quot;top&quot; | &quot;bottom&quot; | &quot;left&quot; | &quot;right&quot; | &quot;center_vertical&quot; |
                      &quot;fill_vertical&quot; | &quot;center_horizontal&quot; | &quot;fill_horizontal&quot; |
                      &quot;center&quot; | &quot;fill&quot; | &quot;clip_vertical&quot; | &quot;clip_horizontal&quot;]
    android:tileMode=[&quot;disabled&quot; | &quot;clamp&quot; | &quot;repeat&quot; | &quot;mirror&quot;] /&gt;
</code></pre><p> 属性分析：<br> android:antialias：是否开启图片抗锯齿功能。开启后会让图片变得平滑，同时也会一定程度上降低图片的清晰度，建议开启；<br> android:dither：是否开启抖动效果。当图片的像素配置和手机屏幕像素配置不一致时，开启这个选项可以让高质量的图片在低质量的屏幕上还能保持较好的显示效果，建议开启。<br> android:filter：是否开启过滤效果。当图片尺寸被拉伸或压缩时，开启过滤效果可以保持较好的显示效果，建议开启；<br> android:gravity：当图片小于容器的尺寸时，设置此选项可以对图片进行定位。<br> android:tileMode：平铺模式，有四种选项[“disabled” | “clamp” | “repeat” | “mirror”]。当开启平铺模式后，gravity属性会被忽略。repeat是指水平和竖直方向上的平铺效果；mirror是指在水平和竖直方向上的镜面投影效果；clamp是指图片四周的像素会扩展到周围区域，这个比较特别。</p>
</li>
<li><p>ShapeDrawable</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;shape    
    xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;    
    android:shape=[&quot;rectangle&quot; | &quot;oval&quot; | &quot;line&quot; | &quot;ring&quot;] &gt;    
    &lt;corners        //当shape为rectangle时使用
        android:radius=&quot;integer&quot;        //半径值会被后面的单个半径属性覆盖，默认为1dp
        android:topLeftRadius=&quot;integer&quot;        
        android:topRightRadius=&quot;integer&quot;        
        android:bottomLeftRadius=&quot;integer&quot;        
        android:bottomRightRadius=&quot;integer&quot; /&gt;    
    &lt;gradient       //渐变
        android:angle=&quot;integer&quot;        
        android:centerX=&quot;integer&quot;        
        android:centerY=&quot;integer&quot;        
        android:centerColor=&quot;integer&quot;        
        android:endColor=&quot;color&quot;        
        android:gradientRadius=&quot;integer&quot;        
        android:startColor=&quot;color&quot;        
        android:type=[&quot;linear&quot; | &quot;radial&quot; | &quot;sweep&quot;]        
        android:useLevel=[&quot;true&quot; | &quot;false&quot;] /&gt;    
    &lt;padding        //内边距
        android:left=&quot;integer&quot;        
        android:top=&quot;integer&quot;        
        android:right=&quot;integer&quot;        
        android:bottom=&quot;integer&quot; /&gt;    
    &lt;size           //指定大小，一般用在imageview配合scaleType属性使用
        android:width=&quot;integer&quot;        
        android:height=&quot;integer&quot; /&gt;    
    &lt;solid          //填充颜色
        android:color=&quot;color&quot; /&gt;    
       &lt;stroke         //边框
          android:width=&quot;integer&quot;        
        android:color=&quot;color&quot;        
        android:dashWidth=&quot;integer&quot;        
        android:dashGap=&quot;integer&quot; /&gt;
&lt;/shape&gt;
</code></pre><p> android:shape：默认的shape是矩形，line和ring这两种形状需要通过<stroke>来制定线的宽度和颜色，否则看不到效果。<br> gradient：solid表示纯色填充，而gradient表示渐变效果。andoid:angle指渐变的角度，默认为0，其值必须是45的倍数，0表示从左到右，90表示从下到上，其他类推。<br> padding：这个表示的是包含它的view的空白，四个属性分别表示四个方向上的padding值。<br> size：ShapeDrawable默认情况下是没有宽高的概念的，但是可以如果指定了size，那么这个时候shape就有了所谓的固有宽高，但是作为view的背景时，shape还是会被拉伸或者缩小为view的大小。</stroke></p>
</li>
<li><p>LayerDrawble<br>对应标签<layer-list>，表示层次化的Drawable集合，实现一种叠加后的效果。<br>属性android:top/left/right/bottom表示drawable相对于view的上下左右的偏移量，单位为像素。</layer-list></p>
</li>
<li><p>StateListDrawable<br>对应标签<selector>，也是表示Drawable集合，每个drawable对应着view的一种状态。<br>一般来说，默认的item都应该放在selector的最后一条并且不附带任何的状态。</selector></p>
</li>
<li><p>LevelListDrawable<br>对应标签<level-list>，同样是Drawable集合，每个drawable还有一个level值，根据不同的level，LevelListDrawable会切换不同的Drawable，level值范围从0到100000。</level-list></p>
</li>
<li><p>TransitionDrawable<br>对应标签<transition>，它用于是吸纳两个Drawable之间的淡入淡出效果。</transition></p>
<pre><code>&lt;transition xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; &gt;
    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_linear&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/shape_drawable_gradient_radius&quot;/&gt;
&lt;/transition&gt;

TransitionDrawable drawable = (TransitionDrawable) v.getBackground();
drawable.startTransition(5000);
</code></pre></li>
<li><p>InsetDrawable<br>对应标签<inset>，它可以将其他drawable内嵌到自己当中，并可以在四周留出一定的间距。当一个view希望自己的背景比自己的实际区域小的时候，可以采用InsetDrawable来实现。</inset></p>
<pre><code>&lt;inset xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:insetBottom=&quot;15dp&quot;
    android:insetLeft=&quot;15dp&quot;
    android:insetRight=&quot;15dp&quot;
    android:insetTop=&quot;15dp&quot; &gt;

    &lt;shape android:shape=&quot;rectangle&quot; &gt;
        &lt;solid android:color=&quot;#ff0000&quot; /&gt;
    &lt;/shape&gt;

&lt;/inset&gt;
</code></pre></li>
<li><p>ScaleDrawable<br>对应标签<scale>，它可以根据自己的level将指定的Drawable缩放到一定比例。如果level越大，那么内部的drawable看起来就越大。</scale></p>
</li>
<li><p>ClipDrawable<br>对应标签<clip>，它可以根据自己当前的level来裁剪另一个drawable，裁剪方向由android:clipOrientation和andoid:gravity属性来共同控制。level越大，表示裁剪的区域越小。</clip></p>
<pre><code>&lt;clip xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:clipOrientation=&quot;vertical&quot;
    android:drawable=&quot;@drawable/image1&quot;
    android:gravity=&quot;bottom&quot; /&gt;
</code></pre></li>
</ol>
<h2 id="6-3__u81EA_u5B9A_u4E49Drawable"><a href="#6-3__u81EA_u5B9A_u4E49Drawable" class="headerlink" title="6.3 自定义Drawable"></a>6.3 自定义Drawable</h2><ol>
<li>Drawable的工作核心就是draw方法，所以自定义drawable就是重写draw方法，当然还有setAlpha、setColorFilter和getOpacity这几个方法。当自定义Drawable有固有大小的时候最好重写getIntrinsicWidth和getIntrinsicHeight方法。</li>
<li>Drawable的内部大小不等于Drawable的实际区域大小，Drawable的实际区域大小可以通过它的getBounds方法来得到，一般来说它和view的尺寸相同。</li>
</ol>
<h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u6DF1_u5165_u5206_u6790" class="headerlink" title="第七章：Android动画深入分析"></a>第七章：Android动画深入分析</h1><h2 id="7-1_View_u52A8_u753B"><a href="#7-1_View_u52A8_u753B" class="headerlink" title="7.1 View动画"></a>7.1 View动画</h2><p>(1)Android动画可分为三大类：view动画、帧动画和属性动画，属性动画是API 11(Android 3.0)的新特性，帧动画一般也认为是view动画。<br>(2)AnimationSet的属性android:shareInterpolator表示集合中的动画是否共享同一个插值器，如果集合不指定插值器，那么子动画需要单独指定所需的插值器或者使用默认值。<br>(3)自定义动画需要继承Animation抽象类，并重新它的initialize和applyTransformation方法，在initialize方法中做一些初始化工作，在applyTransformation方法中进行相应的矩阵变换，很多时候需要采用Camera类来简化矩阵变换的过程。<br>(4)帧动画使用比较简单，但是容易引起OOM，所以在使用的时候应尽量避免使用过多尺寸较大的图片。</p>
<h2 id="7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F"><a href="#7-2_View_u52A8_u753B_u7684_u7279_u6B8A_u4F7F_u7528_u573A_u666F" class="headerlink" title="7.2 View动画的特殊使用场景"></a>7.2 View动画的特殊使用场景</h2><p><strong>Activity的切换效果</strong></p>
<p><code>overridePendingTransition(int enterAnim, int exitAnim)</code>这个方法必须在<code>startActivity(Intent)</code>或者<code>finish()</code>之后被调用才能生效。</p>
<p>Fragment也可以添加切换动画，可以通过FragmentTransaction中的setCustomAnimations()方法来添加切换动画，这个切换动画需要是View动画。</p>
<h2 id="7-3__u5C5E_u6027_u52A8_u753B"><a href="#7-3__u5C5E_u6027_u52A8_u753B" class="headerlink" title="7.3 属性动画"></a>7.3 属性动画</h2><p><strong>使用属性动画</strong></p>
<p>动画默认时间间隔为300ms，默认帧率为10ms/帧。</p>
<p>nineoldandroids对属性动画做了兼容，在API 11以前的版本其内部是通过代理View动画来实现的，因此在Android低版本上，他的本质还是View动画，尽管使用方法看起来是属性动画。</p>
<p><strong>对任意属性做动画</strong></p>
<p>属性动画的原理：属性动画要求动画作用的对象提供该属性的get和set方法，属性动画根据外界传递的该属性的初始值和最终值，以动画的效果多次去调用set方法，每次传递给set方法的值都不一样，确切来说是随着时间的推移，所传递的值越来越接近最终值。总结一下，我们对object的属性abc做动画，如果想让动画生效，要同时满足两个条件：</p>
<p>(1). object必须提供setAbc方法，如果动画的时候没有传递初始值，那么还要提供getAbc方法，因为系统要去取abc属性的初始值(如果这条不满足，程序直接Crash)</p>
<p>(2). object的setAbc对属性abc所做的改变必须能够通过某种方法反映出来，比如会带来UI的改变之类(如果这条不满足，动画无效果但不会Crash)</p>
<p>如果有时动画不生效的原因只满足条件1而未满足条件2，官方文档上告诉我们有3种解决方法：</p>
<ul>
<li>给你的对象加上get和set方法，如果你有权限的话；</li>
<li>用一个类来包装原始对象，间接为其提供get和set方法；</li>
<li>采用ValueAnimator，监听动画过程，自己实现属性的改变。</li>
</ul>
<p><strong>属性动画的工作原理</strong></p>
<p>// TODO</p>
<h2 id="7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879"><a href="#7-4__u4F7F_u7528_u52A8_u753B_u7684_u6CE8_u610F_u4E8B_u9879" class="headerlink" title="7.4 使用动画的注意事项"></a>7.4 使用动画的注意事项</h2><ul>
<li>OOM：尽量避免使用帧动画，使用的话应尽量避免使用过多尺寸较大的图片；</li>
<li>内存泄露：属性动画中的无限循环动画需要在Activity退出的时候及时停止，否则将导致Activity无法释放而造成内存泄露。view动画不存在这个问题；</li>
<li>兼容性问题：某些动画在3.0以下系统上有兼容性问题；</li>
<li>view动画的问题：view动画是对view的影像做动画，并不是真正的改变view的状态，因此有时候动画完成之后view无法隐藏，即setVisibility(View.GONE)失效了，此时需要调用view.clearAnimation()清除view动画才行。</li>
<li>不要使用px；</li>
<li>动画元素的交互：在android3.0以前的系统上，view动画和属性动画，新位置均无法触发点击事件，同时，老位置仍然可以触发单击事件。从3.0开始，属性动画的单击事件触发位置为移动后的位置，view动画仍然在原位置；</li>
<li>硬件加速：使用动画的过程中，建议开启硬件加速，这样会提高动画的流畅性。</li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探MD式转场动画]]></title>
    <link href="http://yuqirong.me/2016/03/23/%E5%88%9D%E6%8E%A2MD%E5%BC%8F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yuqirong.me/2016/03/23/初探MD式转场动画/</id>
    <published>2016-03-23T08:44:22.000Z</published>
    <updated>2016-08-18T15:09:33.926Z</updated>
    <content type="html"><![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是Google在SDK中已经给我们提供了。<code>ActivityOptions</code>是 Android 5.0 及以上使用的，但是也提供了<code>ActivityOptionsCompat</code>向下兼容。</p>
<p>下面我们就来看看吧：</p>
<p>layout_item.xml(ListView的item布局)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">    <span class="attribute">android:background</span>=<span class="value">"@android:color/white"</span></span><br><span class="line">    <span class="attribute">android:padding</span>=<span class="value">"10dp"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"90dip"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"65dip"</span></span><br><span class="line">        <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">        <span class="attribute">android:padding</span>=<span class="value">"1dp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"2dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:singleLine</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Subhead"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@id/tv_title"</span></span><br><span class="line">        <span class="attribute">android:layout_marginLeft</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_marginTop</span>=<span class="value">"8dp"</span></span><br><span class="line">        <span class="attribute">android:layout_toRightOf</span>=<span class="value">"@id/iv_img"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"2"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorPrimary"</span></span><br><span class="line">        <span class="attribute">tools:text</span>=<span class="value">"标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/tv_time"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_alignParentRight</span>=<span class="value">"true"</span></span><br><span class="line">        <span class="attribute">android:layout_below</span>=<span class="value">"@+id/tv_content"</span></span><br><span class="line">        <span class="attribute">android:maxLines</span>=<span class="value">"1"</span></span><br><span class="line">        <span class="attribute">android:text</span>=<span class="value">"2016-02-25 11:22:23"</span></span><br><span class="line">        <span class="attribute">android:textAppearance</span>=<span class="value">"@style/TextAppearance.AppCompat.Small"</span></span><br><span class="line">        <span class="attribute">android:textColor</span>=<span class="value">"?android:attr/textColorSecondary"</span></span><br><span class="line">        <span class="attribute">android:textSize</span>=<span class="value">"12sp"</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们会注意到在ImageView里有<code>android:transitionName=&quot;photos&quot;</code>，这正是后面需要用到的。在这里的<code>photos</code>可以任意取名。也就是说你想让哪个View在转场时表现出动画，就在哪个View的xml中添加<code>android:transitionName</code>。</p>
<p>之后就是我们点击Item时应该跳转到另一个Activity中(这里就跳转到NewsDetailActivity了)，这其中的逻辑如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Android 5.0 使用转场动画</span></span><br><span class="line"><span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">    ActivityOptions options = ActivityOptions</span><br><span class="line">            .makeSceneTransitionAnimation(getActivity(),</span><br><span class="line">                    itemView.findViewById(R.id.iv_img), <span class="string">"photos"</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//让新的Activity从一个小的范围扩大到全屏</span></span><br><span class="line">    ActivityOptionsCompat options = ActivityOptionsCompat</span><br><span class="line">            .makeScaleUpAnimation(itemView, itemView.getWidth() / <span class="number">2</span>,</span><br><span class="line">                    itemView.getHeight() / <span class="number">2</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    startActivity(NewsDetailActivity.class, bundle, options.toBundle());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在Android 5.0时使用的<code>makeSceneTransitionAnimation()</code>方法中的第三个参数正是上面的<code>&quot;photos&quot;</code>。当然在5.0版本以下我们只能使用兼容的<code>ActivityOptionsCompat</code>了。</p>
<p>最后在要跳转的Activity的布局中也添加<code>android:transitionName=&quot;photos&quot;</code>，这样就形成了一个MD式转场动画了。</p>
<p>以下是NewsDetailActivity的布局xml(只截取了部分)：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">ImageView</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/iv_album"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"256dp"</span></span><br><span class="line">    <span class="attribute">android:scaleType</span>=<span class="value">"centerCrop"</span></span><br><span class="line">    <span class="attribute">android:src</span>=<span class="value">"@drawable/thumbnail_default"</span></span><br><span class="line">    <span class="attribute">android:transitionName</span>=<span class="value">"photos"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseMode</span>=<span class="value">"parallax"</span></span><br><span class="line">    <span class="attribute">app:layout_collapseParallaxMultiplier</span>=<span class="value">"0.7"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>好了，这样就完成了，如果你需要在NewsDetailActivity执行finish时也出现转场动画，你只需要这样做(这里只给出了<code>onBackPressed()</code>的样例)：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBackPressed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onBackPressed();</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        finishAfterTransition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实关于<code>ActivityOptions</code>和<code>ActivityOptionsCompat</code>转场动画还有更多选择，可以深入研究一下。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.lxway.com/895445426.htm" target="_blank" rel="external">你所不知道的Activity转场动画——ActivityOptions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
</feed>
