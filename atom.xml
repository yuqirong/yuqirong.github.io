<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[blog for yuqirong]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-03-22T13:24:29.627Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[快速打造仿Android联系人界面]]></title>
    <link href="http://yuqirong.me/2016/03/22/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E4%BB%BFAndroid%E8%81%94%E7%B3%BB%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <id>http://yuqirong.me/2016/03/22/快速打造仿Android联系人界面/</id>
    <published>2016-03-22T07:53:24.000Z</published>
    <updated>2016-03-22T13:24:29.627Z</updated>
    <content type="html"><![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这里写图片描述"></p>
<p>我们可以看到在右侧有一个支持快速索引的栏。接下来，我们就要实现这种索引栏。</p>
<p>首先是<code>attrs.xml</code>，定义了三个自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;QuickIndexBar&quot;&gt;
        // 字体的颜色
        &lt;attr name=&quot;font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 选中时字体的颜色
        &lt;attr name=&quot;selected_font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 字体的大小
        &lt;attr name=&quot;font_size&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们创建一个类继承自<code>View</code>，类名就叫<code>QuickIndexBar</code>：</p>
<pre><code>// 默认字体颜色
private int defaultFontColor = Color.WHITE;
// 默认选中字体颜色
private int defaultSelectedFontColor = Color.GRAY;
// 字体颜色
private int fontColor;
// 选中字体颜色
private int selectedFontColor;
 // 字体大小
private float fontSize;
// 默认字体大小
private float defaultfontSize = 12;
// 上次触摸的字母单元格
int lastSelected = -1;
// 这次触摸的字母单元格
int selected = -1;

public QuickIndexBar(Context context) {
    this(context, null);
}

public QuickIndexBar(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public QuickIndexBar(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.QuickIndexBar);
    fontColor = a.getColor(R.styleable.QuickIndexBar_font_color, defaultFontColor);
    selectedFontColor = a.getColor(R.styleable.QuickIndexBar_selected_font_color, defaultSelectedFontColor);
    fontSize = a.getDimension(R.styleable.QuickIndexBar_font_size,
            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, defaultfontSize,
                    getContext().getResources().getDisplayMetrics()));
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    mPaint.setColor(fontColor);
    mPaint.setTypeface(Typeface.DEFAULT_BOLD);
    mPaint.setTextSize(fontSize);

}
</code></pre><p>上面的代码就是在构造器中初始化了自定义属性，大家应该都能看懂。</p>
<pre><code>// 快速索引的字母
public static final String[] INDEX_ARRAYS = new String[]{&quot;#&quot;, &quot;A&quot;, &quot;B&quot;,
        &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;,
        &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};
// 控件的宽度
private int width;
// 控件的高度
private int height;
// 字母单元格的宽度
private float cellHeight;

/**
 * 得到控件的大小
 */
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    width = getMeasuredWidth();
    height = getMeasuredHeight();
    //  得到字母单元格的高度
    cellHeight = height * 1.0f / INDEX_ARRAYS.length;
}
</code></pre><p>然后在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>中获取<code>width</code>和<code>height</code>。还要计算<code>cellHeight</code>,也就是<code>INDEX_ARRAYS</code>中每个字符串所占用的高度，以便在<code>onDraw(Canvas canvas)</code>中使用。</p>
<p>我们来看看<code>onDraw(Canvas canvas)</code>：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 遍历画出index
    for (int i = 0; i &lt; INDEX_ARRAYS.length; i++) {
        // 测出字体的宽度
        float x = width / 2 - mPaint.measureText(INDEX_ARRAYS[i]) / 2;
        // 得到字体的高度
        Paint.FontMetrics fm = mPaint.getFontMetrics();
        double fontHeight = Math.ceil(fm.descent - fm.ascent);

        float y = (float) ((i + 1) * cellHeight - cellHeight / 2 + fontHeight / 2);
        if (i == selected) {
            mPaint.setColor(lastSelected == -1 ? fontColor : selectedFontColor);
        } else {
            mPaint.setColor(fontColor);
        }
        // 绘制索引的字母 (x,y)为字母左下角的坐标
        canvas.drawText(INDEX_ARRAYS[i], x, y, mPaint);
    }

}
</code></pre><p>在代码中去遍历<code>INDEX_ARRAYS</code>，测量出字母的宽度和高度。这里要注意的是，<code>canvas.drawText(String text, float x, float y, Paint paint)</code>中的 x,y 指的是字母左下角的坐标，并不是“原点”。</p>
<p>别忘了我们还要对<code>QuickIndexBar</code>的触摸事件作出处理。所以我们要重写onTouchEvent(MotionEvent event)：</p>
<pre><code>/**
 * 设置当索引改变的监听器
 */
public interface OnIndexChangeListener {
    /**
     * 当索引改变
     *
     * @param selectIndex 索引值
     */
    void onIndexChange(int selectIndex);

    /**
     * 当手指抬起
     */
    void onActionUp();
}

public void setOnIndexChangeListener(OnIndexChangeListener listener) {
    this.listener = listener;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    float y;
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            y = event.getY();
            // 计算出触摸的是哪个字母单元格
            selected = (int) (y / cellHeight);
            if (selected &gt;= 0 &amp;&amp; selected &lt; INDEX_ARRAYS.length) {
                if (selected != lastSelected) {
                    if (listener != null) {
                        listener.onIndexChange(selected); // 回调监听器的方法
                    }
                    Log.i(TAG, INDEX_ARRAYS[selected]);
                }
                lastSelected = selected;
            }
            break;
        case MotionEvent.ACTION_UP:
            // 把上次的字母单元格重置
            lastSelected = -1;
            listener.onActionUp();
            break;
    }
    invalidate(); // 重绘视图
    return true;
}
</code></pre><p>在<code>ACTION_DOWN</code>和<code>ACTION_MOVE</code>计算出了触摸的y值对应的是索引中的哪个字母，然后回调了监听器；而在<code>ACTION_UP</code>中重置了<code>lastSelected</code>，回调了监听器。</p>
<p>这样，我们就把<code>QuickIndexBar</code>写好了，关于<code>QuickIndexBar</code>使用的代码就不贴出来了，太长了。如果有需要，可以下载下面的Demo，里面都有注释。Demo的效果图如下：</p>
<p><img src="/uploads/20160322/20160322211942.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这里了。have fun!</p>
<p>源码下载：</p>
<p><a href="/uploads/20160322/ContactPicker.rar">ContactPicker.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/ContactPicker" target="_blank" rel="external">ContactPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[夜半一忆]]></title>
    <link href="http://yuqirong.me/2016/03/17/%E5%A4%9C%E5%8D%8A%E4%B8%80%E5%BF%86/"/>
    <id>http://yuqirong.me/2016/03/17/夜半一忆/</id>
    <published>2016-03-17T15:13:58.000Z</published>
    <updated>2016-03-18T05:15:53.169Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈何岁月，流于昨日。雁过一鸣，惊于何人？花开花谢，润土无声。</p>
<p>繁华落尽，只道是人间凄凉。穷极一生，只为还清一世业障。</p>
<p>高山流水，静谧成寂。秋风落叶，随风飘散。</p>
<p>别时易，相逢难，烈酒灼心，忆似水年华。</p>
<p>乍暖还寒，大梦初醒，此夜无眠。</p>
<p>仰天大笑，岂是蓬蒿人？</p>
<p>————记于开题答辩之日</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=1&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记]]></title>
    <link href="http://yuqirong.me/2016/03/08/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/03/08/《Android群英传》笔记/</id>
    <published>2016-03-08T12:22:27.000Z</published>
    <updated>2016-03-18T05:17:29.869Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7" class="headerlink" title="第六章：Android绘图机制与处理技巧"></a>第六章：Android绘图机制与处理技巧</h1><h2 id="6-4_Android_u7ED8_u56FE_u6280_u5DE7"><a href="#6-4_Android_u7ED8_u56FE_u6280_u5DE7" class="headerlink" title="6.4 Android绘图技巧"></a>6.4 Android绘图技巧</h2><ul>
<li><p>Canvas.save():保存画布。它的作用就是将之前的所有已绘制图像保存起来，让后续的操作就好像在一个新的图层上操作一样。</p>
</li>
<li><p>Canvas.restore():合并图层操作。它的作用就是将我们在save()之后绘制的所有图像与save()之前的图像进行合并。</p>
</li>
<li><p>Canvas.translate():画布平移，可理解为坐标系的平移。如在之前绘制的坐标系原点在(0,0)。在translate(x,y)之后，坐标原点在(x,y)。</p>
</li>
<li><p>Canvas.rotate():画布翻转，可理解为坐标系的翻转。canvas.rotate(30);为按照坐标系的原点顺时针旋转30度。canvas.rotate(30,x,y);为按照坐标系的(x,y)点顺时针旋转30度。</p>
</li>
<li><p>Canvas.saveLayer()、Canvas.saveLayerAlpha():将一个图层入栈。</p>
</li>
<li><p>Canvas.restore()、Canvas.restoreToCount():将一个图层出栈。</p>
</li>
</ul>
<h2 id="6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406"><a href="#6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406" class="headerlink" title="6.5 Android图像处理之色彩特效处理"></a>6.5 Android图像处理之色彩特效处理</h2><ul>
<li><p>色调：<code>setRotate(int axis,float degree)</code>设置颜色的色调。第一个参数，系统分别使用0、1、2来代表Red、Green、Blue三种颜色的处理。而第二个参数就是需要处理的值。</p>
<pre><code>ColorMatrix hueMatrix = new ColorMatrix();
hueMatrix.setRotate(0, hue0);
hueMatrix.setRotate(1, hue1);
hueMatrix.setRotate(2, hue2);
</code></pre></li>
</ul>
<p>通过上面的方法，可以为RGB三种颜色分量分别重新设置了不同的色调值。</p>
<ul>
<li><p>饱和度：<code>setSaturation(float sat)</code>方法来设置颜色的饱和度，参数即代表设置颜色饱和度的值，代码如下所示。当饱和度为0时，图像就变成灰色图像了。</p>
<pre><code>ColorMatrix saturationMatrix = new ColorMatrix();
saturationMatrix.setSaturation(saturation);
</code></pre></li>
<li><p>亮度：当三原色以相同的比例进行混合的时候，就会显示出白色。系统也正是使用这个原理来改变一个图像的亮度的，代码如下所示。当亮度为0时，图像就变成全黑了。</p>
<pre><code>ColorMatrix lumMatrix = new ColorMatrix();
lumMatrix.setScale(lum,lum,lum,1);
</code></pre></li>
<li><p><code>postConcat()</code>方法将矩阵的作用效果混合，从而叠加处理效果，代码如下：</p>
<pre><code>ColorMatrix imageMatrix = new ColorMatrix();
imageMatrix.postConcat(hueMatrix);
imageMatrix.postConcat(saturationMatrix);
imageMatrix.postConcat(lumMatrix);
</code></pre></li>
</ul>
<h2 id="6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406"><a href="#6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h2><ul>
<li>matrix.setRotate()——旋转变换</li>
<li>matrix.setTranslate()——平移变换</li>
<li>matrix.setScale()——缩放变换</li>
<li>matrix.setSkew()——错切变换</li>
<li>pre()和post()——提供矩阵的前乘和后乘运算</li>
</ul>
<h2 id="6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406"><a href="#6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406" class="headerlink" title="6.7 Android图像处理之画笔特效处理"></a>6.7 Android图像处理之画笔特效处理</h2><pre><code>mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
</code></pre><p>可以实现圆形ImageView。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现WebView中JS和App之间的交互]]></title>
    <link href="http://yuqirong.me/2016/03/07/%E5%AE%9E%E7%8E%B0WebView%E4%B8%ADJS%E5%92%8CApp%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yuqirong.me/2016/03/07/实现WebView中JS和App之间的交互/</id>
    <published>2016-03-07T11:53:12.000Z</published>
    <updated>2016-03-07T15:04:30.507Z</updated>
    <content type="html"><![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img src="/uploads/20160307/20160307200816.png" alt="这里写图片的描述"></p>
<p>之后在脑海中回想到 WebView 中的JS可以和app产生交互，于是搜索了一下，果然网上有类似的实现效果。看了一下，在这里就做一个简单的笔记了以便之后查看。</p>
<p>在 WebView 中想要JS和app产生交互，就不得不提一个方法，那就是<code>addJavascriptInterface(Object object, String name)</code>：</p>
<ul>
<li>第一个参数：绑定到 JavaScript 的类实例。</li>
<li>第二个参数：用来显示 JavaScript 中的实例的名称。</li>
</ul>
<p>这里只是给出了参数的解释，如果你没看懂，那接下来就告诉你答案。</p>
<p>那就开始吧，在创建新的 project 之前，我们先把要加载的 test.html 写好，放在 assets 目录下：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebView Test&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
        function btnShowToast(){
            window.testJS.showToast();
        }

        function btnGoActivity(){
            window.testJS.goActivity();
        }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;This is a website&lt;/p&gt;
        &lt;br&gt;
        &lt;button onclick=&apos;btnShowToast();&apos;&gt;show Toast&lt;/button&gt;
        &lt;button onclick=&apos;btnGoActivity();&apos;&gt;go Activity&lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>上面的 html 很简单，相信有点基础的同学都能看得懂。要注意的是在JS函数中的 testJS 是要和 WebView 约定好的，这里就取名叫 testJS 吧，在下面会用到。还有<code>showToast()</code>和<code>goActivity()</code>也是约定好的函数名。我们预期的效果是点击 show Toast 按钮会显示Toast，而点击 go Activity 按钮会跳转到另外一个 Activity 上。</p>
<p>下面创建了一个 project ，名叫 WebViewDemo ，工程中 MainActivity 的 layout.xml 就只有一个 WebView 了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.yuqirong.webviewdemo.MainActivity&quot;&gt;

    &lt;WebView
        android:id=&quot;@+id/mWebView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>MainActivity 的代码很短，就直接贴出来了：</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mWebView = (WebView) findViewById(R.id.mWebView);
        // 设置支持JS
        mWebView.getSettings().setJavaScriptEnabled(true);
        // 增加JS交互的接口
        mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);
        mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                return false;
            }
        });
        String url = &quot;file:///android_asset/test.html&quot;;
        mWebView.loadUrl(url);
    }
}
</code></pre><p>我们可以看到，如果想要和JS交互，那么<code>mWebView.getSettings().setJavaScriptEnabled(true);</code>这句是必不可少的，再看到下面一行代码：<code>mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);</code>，这里注意一下第二个参数，没错，就是在 html 中的 testJS ！</p>
<p>再看回第一个参数，发现 new 了一个 AndroidJSInterface 类，下面就是 AndroidJSInterface 的代码：</p>
<pre><code>public class AndroidJSInterface {

    private Context context;

    public AndroidJSInterface(Context context) {
        this.context = context;
    }

    @JavascriptInterface
    public void goActivity() {
        context.startActivity(new Intent(context, SecondActivity.class));
    }

    @JavascriptInterface
    public void showToast() {
        Toast.makeText(context, &quot;hello js&quot;, Toast.LENGTH_SHORT).show();
    }

}
</code></pre><p>我们可以看到上面的<code>showToast()</code>和<code>goActivity()</code>方法名和 html 里面的一定要一样，不然无法触发了。然后在方法的内部实现你想要的逻辑。</p>
<p>经过上面的步骤，就可以实现和JS交互了，一起来看看效果吧：</p>
<p><img src="/uploads/20160307/20160307225743.gif" alt="这里写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160307/WebViewDemo.rar">WebViewDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="WebView" scheme="http://yuqirong.me/tags/WebView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用RecyclerView实现仿喵街效果]]></title>
    <link href="http://yuqirong.me/2016/02/26/%E4%BD%BF%E7%94%A8RecyclerView%E5%AE%9E%E7%8E%B0%E4%BB%BF%E5%96%B5%E8%A1%97%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/02/26/使用RecyclerView实现仿喵街效果/</id>
    <published>2016-02-26T11:50:18.000Z</published>
    <updated>2016-03-05T09:45:43.291Z</updated>
    <content type="html"><![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></p>
<p>值得一提的是，这是旧版本的特效，新版本的喵街已经去掉了这种效果。</p>
<p>看完了效果，接下来就是动手的时间了。</p>
<p>我们先来分析一下思路：我们先给RecyclerView添加一个OnScrollListener，然后分别去获得firstVisiblePosition和firstCompletelyVisiblePosition。这里要注意一下，firstVisiblePosition是第一个在屏幕中<strong>可见</strong>的itemView对应的position，而firstCompletelyVisiblePosition是是第一个在屏幕中<strong>完全可见</strong>的itemView对应的position。之后在滚动中去动态地设置itemView的高度。整体的思路就这样了，下面我们直接来看代码。</p>
<p>创建几个自定义的属性，以便后面备用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ExpandRecyclerView&quot;&gt;
        &lt;!-- item最大的高度 --&gt;
        &lt;attr name=&quot;max_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- item普通的高度 --&gt;
        &lt;attr name=&quot;normal_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们新建一个类继承自RecyclerView，类名就叫ExpandRecyclerView。</p>
<pre><code>//最大item的高度
private float maxItemHeight;
//普通item的高度
private float normalItemHeight;
// 默认最大的item高度
private float defaultMaxItemHeight;
// 默认普通的item高度
private float defaultNormalItemHeight;

public ExpandRecyclerView(Context context) {
    this(context, null);
}

public ExpandRecyclerView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public ExpandRecyclerView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ExpandRecyclerView);
    defaultMaxItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 256, context.getResources().getDisplayMetrics());
    defaultNormalItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 120, context.getResources().getDisplayMetrics());
    maxItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_max_item_height, defaultMaxItemHeight);
    normalItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_normal_item_height, defaultNormalItemHeight);
    a.recycle();

    setHasFixedSize(true);
    setLayoutManager(new LinearLayoutManager(context));
    setItemAnimator(new DefaultItemAnimator());
    this.addOnScrollListener(listener);
}
</code></pre><p>在构造器中我们得到了<code>maxItemHeight</code>和<code>normalItemHeight</code>，之后设置了OnScrollListener。</p>
<pre><code>OnScrollListener listener = new RecyclerView.OnScrollListener() {

    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        Log.i(TAG,&quot;dy : &quot; + dy);
        LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
        // 在屏幕中第一个可见的position
        int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();
        // 得到第一个可见的ViewHolder
        RecyclerView.ViewHolder firstVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstVisiblePosition);
        // 在屏幕中第一个完全可见的position
        int firstCompletelyVisiblePosition = mLinearLayoutManager.findFirstCompletelyVisibleItemPosition();
        // 得到第一个完全可见的ViewHolder
        RecyclerView.ViewHolder firstCompletelyVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstCompletelyVisiblePosition);

        Log.i(TAG, &quot;firstVisiblePosition : &quot; + firstVisiblePosition + &quot; , firstCompletelyVisiblePosition : &quot; + firstCompletelyVisiblePosition);
        // 当firstVisibleViewHolder被滑出屏幕时
        if (firstVisibleViewHolder.itemView.getLayoutParams().height - dy &lt; maxItemHeight
                &amp;&amp; firstVisibleViewHolder.itemView.getLayoutParams().height - dy &gt;= normalItemHeight) {
            // 高度减小
            firstVisibleViewHolder.itemView.getLayoutParams().height -= dy;
            firstVisibleViewHolder.itemView.setLayoutParams(firstVisibleViewHolder.itemView.getLayoutParams());
        }
        // 当firstCompletelyVisibleViewHolder慢慢滑到屏幕顶部时
        if (firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &lt;= maxItemHeight
                &amp;&amp; firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &gt;= normalItemHeight) {
            // 高度增加
            firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height += dy;
            firstCompletelyVisibleViewHolder.itemView.setLayoutParams(firstCompletelyVisibleViewHolder.itemView.getLayoutParams());
        }

    }

};
</code></pre><p>在<code>onScrolled(RecyclerView recyclerView, int dx, int dy)</code>里大部分的代码都加上注释了，就是根据<code>dy</code>去动态地改变了<code>firstVisibleViewHolder</code>和<code>firstCompletelyVisibleViewHolder</code>的高度。</p>
<p>上面的搞定了之后，别忘了要在Adapter里去初始化设置Item的高度。</p>
<pre><code>/**
 * 设置适配器
 *
 * @param adapter
 */
@Override
public void setAdapter(Adapter adapter) {
    super.setAdapter(adapter);
    if (adapter instanceof ExpandRecyclerViewAdapter) {
        ExpandRecyclerViewAdapter mAdapter = (ExpandRecyclerViewAdapter) adapter;
        //设置最大的item高度
        mAdapter.setMaxItemHeight(maxItemHeight);
        //设置普通的item高度
        mAdapter.setNormalItemHeight(normalItemHeight);
    }
}
</code></pre><p>ExpandRecyclerViewAdapter的代码，重写<code>onBindViewHolder(RecyclerView.ViewHolder holder, int position)</code>：</p>
<pre><code>@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if(position == 0){
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) maxItemHeight));
        }else{
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) normalItemHeight));
        }
        bindCustomViewHolder(holder, position);
}

public abstract void bindCustomViewHolder(RecyclerView.ViewHolder holder, int position);
</code></pre><p>好了，整体的代码就这些了，下面贴出运行效果：</p>
<p><img src="/uploads/20160226/20160226210235.gif" alt="这里写图片描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160226/ExpandRecyclerView.rar">ExpandRecyclerView.rar</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.jianshu.com/p/a2c3c21e3b99" target="_blank" rel="external">android版高仿喵街主页滑动效果</a></p>
<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><ul>
<li><a href="https://github.com/dongjunkun/miaojiedemo" target="_blank" rel="external">miaojiedemo</a> created by <a href="https://github.com/dongjunkun" target="_blank" rel="external">dongjunkun</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你一步步实现可拖拽的GridView控件]]></title>
    <link href="http://yuqirong.me/2016/02/15/%E5%B8%A6%E4%BD%A0%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84GridView%E6%8E%A7%E4%BB%B6/"/>
    <id>http://yuqirong.me/2016/02/15/带你一步步实现可拖拽的GridView控件/</id>
    <published>2016-02-15T12:46:17.000Z</published>
    <updated>2016-03-03T04:52:45.299Z</updated>
    <content type="html"><![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述"></p>
<p>是不是也想自己也想实现出相同的效果呢？那就一起来往下看吧。</p>
<p>首先我们来梳理一下思路：</p>
<ol>
<li>当用户长按选择一个item时，将该item隐藏，然后用WindowManager添加一个新的window，该window与所选择item一模一样，并且跟随用户手指滑动而不断改变位置。</li>
<li>当window的位置坐标在GridView里面时，使用<code>pointToPosition (int x, int y)</code>方法来判断对应的应该是哪个item，在adapter中作出数据集相应的变化，然后做出平移的动画。</li>
<li>当用户手指抬起时，把window移除，使用<code>notifyDataSetChanged()</code>做出GridView更新。</li>
</ol>
<p>讲完了思路后，我们就来实践一下吧，把这个控件取名为DragGridView。</p>
<pre><code>public DragGridView(Context context) {
    this(context, null);
}

public DragGridView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public DragGridView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    setOnItemLongClickListener(this);
}
</code></pre><h1 id="u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6"><a href="#u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6" class="headerlink" title="手指在Item上长按时"></a>手指在Item上长按时</h1><p>首先在构造器中得到WindowManager对象以及设置长按监听器，所以只有长按item才能拖拽。</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mWindowX = ev.getRawX();
            mWindowY = ev.getRawY();
            break;
        case MotionEvent.ACTION_MOVE:
            break;
        case MotionEvent.ACTION_UP:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre><p>然后在<code>onInterceptTouchEvent(MotionEvent ev)</code>中得到手指下落时的<code>ev.getRawX()</code>和<code>ev.getRawY()</code>，以备后面的计算使用。至于<code>getRawX()</code>和<code>getX()</code>的区别这里就不再讲述了，如果有不懂的可以自行百度。</p>
<p>下面就是<code>onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id)</code>方法了，我们在DragGridView中定义了两种模式：<code>MODE_DRAG</code>和<code>MODE_NORMAL</code>，分别对应着item拖拽和item不拖拽：</p>
<pre><code>@Override
public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
    if (mode == MODE_DRAG) {
        return false;
    }
    this.view = view;
    this.position = position;
    this.tempPosition = position;
    mX = mWindowX - view.getLeft() - this.getLeft();
    mY = mWindowY - view.getTop() - this.getTop();
    initWindow();
    return true;
}
</code></pre><p>在onItemLongClick()中先判断了一下模式，只有在<code>MODE_NORMAL</code>的情况下才会添加window。然后计算出mX和mY。可能有些童鞋在mX和mY的计算上看不懂，我给出了一个图示：</p>
<p><img src="/uploads/20160215/20160215210800.png" alt="这里写图片描述"></p>
<p>其中红点是手指按下的坐标，也就是(mWindowX,mWindowY)这个点；绿边框为DragGridView，因为DragGridView有可能会有margin值；所以this.getLeft()就是绿边框到屏幕的距离，而view.getLeft()就是长按的Item的左边到绿边框的距离。这几个值相减就得到了mX。同理，mY也是这样得到的。</p>
<p>然后来看看<code>initWindow();</code>这个方法：</p>
<pre><code>/**
 * 初始化window
 */
private void initWindow() {
    if (dragView == null) {
        dragView = View.inflate(getContext(), R.layout.drag_item, null);
        TextView tv_text = (TextView) dragView.findViewById(R.id.tv_text);
        tv_text.setText(((TextView) view.findViewById(R.id.tv_text)).getText());
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.width = view.getWidth();
        layoutParams.height = view.getHeight();
        layoutParams.x = view.getLeft() + this.getLeft();  //悬浮窗X的位置
        layoutParams.y = view.getTop() + this.getTop();  //悬浮窗Y的位置
        view.setVisibility(INVISIBLE);
    }

    mWindowManager.addView(dragView, layoutParams);
    mode = MODE_DRAG;
}
</code></pre><p>在<code>initWindow()</code>中，我们先创建了一个dragView，而dragView里面的内容与长按的Item的内容完全一致。然后创建<code>WindowManager.LayoutParams</code>的对象，把dragView添加到window上去。同时，也要把长按的Item隐藏了。在这里别忘了需要申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;
</code></pre><h1 id="u624B_u6307_u6ED1_u52A8_u65F6"><a href="#u624B_u6307_u6ED1_u52A8_u65F6" class="headerlink" title="手指滑动时"></a>手指滑动时</h1><p>在<code>initWindow()</code>之后，我们就要考虑当手指滑动时window也要跟着动了，我们重写<code>onTouchEvent(MotionEvent ev)</code>来监听滑动事件，可以看到下面的<code>updateWindow(ev)</code>方法。</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            break;
        case MotionEvent.ACTION_MOVE:
            if (mode == MODE_DRAG) {
                updateWindow(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mode == MODE_DRAG) {
                closeWindow(ev.getX(), ev.getY());
            }
            break;
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>这里贴出<code>updateWindow(ev)</code>方法：</p>
<pre><code>/**
 * 触摸移动时，window更新
 *
 * @param ev
 */
private void updateWindow(MotionEvent ev) {
    if (mode == MODE_DRAG) {
        float x = ev.getRawX() - mX;
        float y = ev.getRawY() - mY;
        if (layoutParams != null) {
            layoutParams.x = (int) x;
            layoutParams.y = (int) y;
            mWindowManager.updateViewLayout(dragView, layoutParams);
        }
        float mx = ev.getX();
        float my = ev.getY();
        int dropPosition = pointToPosition((int) mx, (int) my);
        Log.i(TAG, &quot;dropPosition : &quot; + dropPosition + &quot; , tempPosition : &quot; + tempPosition);
        if (dropPosition == tempPosition || dropPosition == GridView.INVALID_POSITION) {
            return;
        }
        itemMove(dropPosition);
    }
}
</code></pre><p>在这里，mX和mY就派上用场了。根据<code>ev.getRawX()</code>和<code>ev.getRawY()</code>分别减去<code>mX</code>和<code>mY</code>就得到了移动中layoutParams.x和layoutParams.y。再调用<code>updateViewLayout (View view, ViewGroup.LayoutParams params)</code>就出现了window跟随手指滑动而滑动的效果。最后根据 <code>pointToPosition(int x, int y)</code>返回的值来执行<code>itemMove(dropPosition);</code>。</p>
<pre><code>/**
 * 判断item移动，作出移动动画
 *
 * @param dropPosition
 */
private void itemMove(int dropPosition) {
    TranslateAnimation translateAnimation;
    // 移动的位置在原位置前面时
    if (dropPosition &lt; tempPosition) {
        for (int i = dropPosition; i &lt; tempPosition; i++) {
            View view = getChildAt(i);
            View nextView = getChildAt(i + 1);
            float xValue = (nextView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (nextView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == tempPosition - 1) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    } else {
        // 移动的位置在原位置后面时
        for (int i = tempPosition + 1; i &lt;= dropPosition; i++) {
            View view = getChildAt(i);
            View prevView = getChildAt(i - 1);
            float xValue = (prevView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (prevView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == dropPosition) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    }
    tempPosition = dropPosition;
}

/**
 * 动画监听器
 */
Animation.AnimationListener animationListener = new Animation.AnimationListener() {
    @Override
    public void onAnimationStart(Animation animation) {

    }

    @Override
    public void onAnimationEnd(Animation animation) {
        // 在动画完成时将adapter里的数据交换位置
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, true);
        }
        position = tempPosition;
    }

    @Override
    public void onAnimationRepeat(Animation animation) {

    }
};
</code></pre><p>上面的代码主要是根据dropPosition使要改变位置的Item来做出平移动画，当最后一个要改变位置的Item平移动画完成之后，在adapter中完成数据集的交换。</p>
<pre><code>/**
 * 给item交换位置
 *
 * @param originalPosition item原先位置
 * @param nowPosition      item现在位置
 */
public void exchangePosition(int originalPosition, int nowPosition, boolean isMove) {
    T t = list.get(originalPosition);
    list.remove(originalPosition);
    list.add(nowPosition, t);
    movePosition = nowPosition;
    this.isMove = isMove;
    notifyDataSetChanged();
}

@Override
public View getView(int position, View convertView, ViewGroup parent) {
    Log.i(TAG, &quot;-------------------------------&quot;);
    for (T t : list){
        Log.i(TAG, t.toString());
    }
    View view = getItemView(position, convertView, parent);
    if (position == movePosition &amp;&amp; isMove) {
        view.setVisibility(View.INVISIBLE);
    }
    return view;
}
</code></pre><h1 id="u624B_u6307_u62AC_u8D77_u65F6"><a href="#u624B_u6307_u62AC_u8D77_u65F6" class="headerlink" title="手指抬起时"></a>手指抬起时</h1><p>在上面<code>onTouchEvent(MotionEvent ev)</code>方法中，可以看到手指抬起时调用了<code>closeWindow(ev.getX(), ev.getY());</code>，那就一起来看看：</p>
<pre><code> /**
 * 关闭window
 *
 * @param x
 * @param y
 */
private void closeWindow(float x, float y) {
    if (dragView != null) {
        mWindowManager.removeView(dragView);
        dragView = null;
        layoutParams = null;
    }
    itemDrop();
    mode = MODE_NORMAL;
}

/**
 * 手指抬起时，item下落
 */
private void itemDrop() {
    if (tempPosition == position || tempPosition == GridView.INVALID_POSITION) {
        getChildAt(position).setVisibility(VISIBLE);
    } else {
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, false);
        }
    }
}
</code></pre><p>可以看出主要做的事情就是移除了window，并且也是调用了<code>exchangePosition(int originalPosition, int nowPosition, boolean isMove)</code>，不同的是第三个参数isMove传入了false，这样所有的Item都显示出来了。</p>
<p>讲了这么多，来看看最后的效果吧：</p>
<p><img src="/uploads/20160215/20160215212234.gif" alt="这里写图片描述"></p>
<p>和网易新闻的效果不相上下吧，完整的源码太长就不贴出了，下面提供源码下载：</p>
<p><a href="/uploads/20160215/DragGridView-master.rar">DragGridView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述">]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在AlertDialog中EditText无法弹出键盘的解决方案]]></title>
    <link href="http://yuqirong.me/2016/02/06/%E5%9C%A8AlertDialog%E4%B8%ADEditText%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yuqirong.me/2016/02/06/在AlertDialog中EditText无法弹出键盘的解决方案/</id>
    <published>2016-02-06T06:54:11.000Z</published>
    <updated>2016-03-02T11:34:38.470Z</updated>
    <content type="html"><![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这个问题。这次算是填了一个隐藏的坑。</p>
<p>例如下面给出了一个例子，首先贴上AlertDialog的<code>layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;200dp&quot;
    android:background=&quot;@android:color/white&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello friend!&quot;/&gt;

    &lt;EditText
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:hint=&quot;input content&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;submit&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>AlertDialog的效果图是这样的：</p>
<p><img src="/uploads/20160206/20160206160310.png" alt="这里填写图片的描述"></p>
<p>我们会发现无论怎么点击EditText也无法弹出键盘，其实我们只要加上<code>alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</code>这一句，就可以让键盘弹出了。</p>
<p><img src="/uploads/20160206/20160206161311.png" alt="这里填写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160206/AlertDialogDemo.rar">AlertDialogDemo.rar</a></p>
<p>StackOverFlow：</p>
<p><a href="http://stackoverflow.com/questions/9102074/android-edittext-in-dialog-doesnt-pull-up-soft-keyboard" target="_blank" rel="external">Android: EditText in Dialog doesn’t pull up soft keyboard</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对LayoutInflater的深入解析]]></title>
    <link href="http://yuqirong.me/2016/02/03/%E5%AF%B9LayoutInflater%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/02/03/对LayoutInflater的深入解析/</id>
    <published>2016-02-03T11:19:12.000Z</published>
    <updated>2016-03-02T11:28:20.568Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身影。比如说在Fragment的<code>onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</code>方法里，就需要我们返回Fragment的View。这时就可以用<code>inflater.inflate(R.layout.fragment_view, container, false)</code>来加载视图。那么下面就来探究一下LayoutInflater的真面目吧。</p>
<h1 id="from_28Context_context_29"><a href="#from_28Context_context_29" class="headerlink" title="from(Context context)"></a>from(Context context)</h1><p>首先我们在使用LayoutInflater时，通常用<code>LayoutInflater.from(Context context)</code>这个方法来得到其对象：</p>
<pre><code>/**
 * Obtains the LayoutInflater from the given context.
 */
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre><p>我们可以看到原来<code>from(Context context)</code>这个方法只不过把<code>context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</code>进行简单地封装了一下，方便开发者调用。相信大家都看得懂。</p>
<h1 id="inflate_28_u2026_29"><a href="#inflate_28_u2026_29" class="headerlink" title="inflate(…)"></a>inflate(…)</h1><p>在得到了LayoutInflater的对象之后，我们就要使用它的inflate()方法了。</p>
<p><img src="/uploads/20160203/20160203183605.png" alt="这里填写图片的描述"></p>
<p>可以看到inflate()有四个重载的方法。我们先来看看前三个的源码：</p>
<pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
    return inflate(resource, root, root != null);
}

public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}

public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre><p>看到这里，我们都明白了，前三个inflate()方法到最后都是调用了<code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>这个方法。原来第四个inflate()方法才是“幕后黑手”。那让我们来揭开它的黑纱吧：</p>
<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }

            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription()
                        + &quot;: No start tag found!&quot;);
            }

            final String name = parser.getName();

            if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot;
                        + name);
                System.out.println(&quot;**************************&quot;);
            }

            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                            + &quot;ViewGroup root and attachToRoot=true&quot;);
                }

                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(
                    parser.getPositionDescription()
                            + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don&apos;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return result;
    }
}
</code></pre><p>这段代码有点长，不过别担心，我们慢慢来看。首先把传入的<code>parser</code>进行解析，创建视图。其中我们可以注意到在Android的源码中是用Pull方式来解析xml得到视图的。接下来判断了传入的<code>root</code>是否为null，如果<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，<code>temp.setLayoutParams(params);</code>。也就是说把创建出来的视图的LayoutParams设置为params。那么params又是从哪里来的呢？可以在上面一行可以找到<code>params = root.generateLayoutParams(attrs);</code>我们来看看源码：</p>
<pre><code> public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new LayoutParams(getContext(), attrs);
}
</code></pre><p>也就是说，在<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，把<code>root</code>的LayoutParams设置给了新创建出来的View。</p>
<p>好了，再往下看，我们注意到了<code>root</code>不为null并且<code>attachToRoot</code>为true的情况。调用了<code>root.addView(temp, params);</code>，在其内部就是将temp添加进了root中。即最后得到的View的父布局就是root。</p>
<p>最后一个情况就是<code>(root == null || !attachToRoot)</code>时，直接返回了temp。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>到这里，关于LayoutInflater的讲解就差不多了，最后我们就来总结一下：</p>
<ul>
<li>在root!=null并且attachToRoot为false：将root的LayoutParams设置给了View。</li>
<li>在root!=null并且attachToRoot为true：把root作为View的父布局。</li>
<li>在root==null时：直接返回View，无视attachToRoot的状态。</li>
</ul>
<p>今天就到这，如有问题可以在下面留言。</p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义ViewGroup打造流式布局]]></title>
    <link href="http://yuqirong.me/2016/01/22/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%89%93%E9%80%A0%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yuqirong.me/2016/01/22/自定义ViewGroup打造流式布局/</id>
    <published>2016-01-22T12:31:37.000Z</published>
    <updated>2016-02-24T14:15:31.817Z</updated>
    <content type="html"><![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/38352503" target="_blank" rel="external">《Android 自定义ViewGroup 实战篇 -&gt; 实现FlowLayout》</a>，觉得文中的FlowLayout很多地方都可以用到。于是自己按照思路实现了一遍，这就是本片博文诞生的原因了。</p>
<p>首先流式布局相信大家都见到过，比如说下图中的京东热搜就是流式布局的应用。还有更多应用的地方在这里就不一一举例了。</p>
<p><img src="/uploads/20160222/20160222205447.png" alt="这里写图片描述"></p>
<p>下面我们就来看看是如何实现的。首先新建一个class，继承自ViewGroup。在<code>generateLayoutParams(AttributeSet attrs)</code>里直接返回MarginLayoutParams就行了。</p>
<pre><code> @Override
public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new MarginLayoutParams(getContext(), attrs);
}
</code></pre><p>然后就是<code>onLayout(boolean changed, int l, int t, int r, int b)</code>了，大部分的代码都添加了注释，相信大家都能看懂。</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int count = getChildCount();
    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    // 用来统计总宽度，初始值设为paddingLeft
    int lastWidth = getPaddingLeft();
    int lastHeight = getPaddingTop();

    for (int i = 0; i &lt; count; i++) {
        // 得到当前View
        View childView = getChildAt(i);
        // 测量得到当前View的宽度
        cWidth = childView.getMeasuredWidth();
        // 测量得到当前View的高度
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();
        // 宽度加上margin
        int width = cWidth + params.leftMargin + params.rightMargin;
        // 高度加上margin
        int height = cHeight + params.topMargin + params.bottomMargin;
        // 判断流式布局里的item总长度是否超过FlowLayout的宽度，如果是则需要换行  
        if (width + lastWidth &gt; r - getPaddingRight()) {
            // 如果超过，重置lastWidth
            lastWidth = getPaddingLeft();
            // lastHeight加上一个item的高度
            lastHeight += height;
        }
        // 给View布局
        childView.layout(lastWidth, lastHeight, lastWidth + cWidth, lastHeight + cHeight);
        //累加总宽度
        lastWidth += width;
    }
}
</code></pre><p>之后就是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);

    int totalWidth = getPaddingLeft() + getPaddingRight();
    int maxWidth = getPaddingLeft() + getPaddingRight();
    int maxHeight = getPaddingBottom() + getPaddingTop();
    int count = getChildCount();
    // 测量子view
    measureChildren(widthMeasureSpec, heightMeasureSpec);

    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    int width;
    int height;
    for (int i = 0; i &lt; count; i++) {
        View childView = getChildAt(i);
        cWidth = childView.getMeasuredWidth();
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();

        width = cWidth + params.leftMargin + params.rightMargin;
        height = cHeight + params.topMargin + params.bottomMargin;

        if (i == 0) {
            // 第一行时最大高度设为height
            maxHeight += height;
        }

        // 如果需要换行
        if (width + totalWidth &gt; widthSize) {
            // 得到最大的值作为setMeasuredDimension()的宽度
            maxWidth = Math.max(maxWidth, totalWidth);
            totalWidth = getPaddingLeft() + getPaddingRight();
            totalWidth += width;
            // 高度就是累加到最后
            maxHeight += height;
        } else {
            // 不换行就总长度累加
            totalWidth += width;
        }
        Log.i(TAG, &quot;i = &quot; + i + &quot;, width = &quot; + width + &quot;, totalWidth = &quot; + totalWidth + &quot;, widthSize = &quot; + widthSize + ((TextView) childView).getText());
        Log.i(TAG, &quot;height = &quot; + height);
        Log.i(TAG, &quot;i = &quot; + i + &quot;, maxHeight = &quot; + maxHeight);

    }
    // 设置宽高度
    setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? widthSize : maxWidth,
            heightMode == MeasureSpec.EXACTLY ? heightSize : maxHeight);

}
</code></pre><p>在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>中，如果测量模式是MeasureSpec.EXACTLY，则直接设置测量出来的宽和高；否则需要测量每个子View，根据item的行数来得到宽和高。</p>
<p>这样，FlowLayout就写好了，那就让我们来看看效果吧。当<code>android:layout_width=&quot;wrap_content&quot;</code>时</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220305.png" alt="这里写图片描述"></p>
<p>当<code>android:layout_width=&quot;300dp&quot;</code>时：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;哈尔滨&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;呼和浩特&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220718.png" alt="这里写图片描述"></p>
<p>最后，提供源码下载：</p>
<p><a href="/uploads/20160222/FlowLayout.rar">FlowLayout.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现导航Tab栏悬浮功能之改进版]]></title>
    <link href="http://yuqirong.me/2016/01/14/%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>http://yuqirong.me/2016/01/14/实现导航Tab栏悬浮功能之改进版/</id>
    <published>2016-01-14T12:34:25.000Z</published>
    <updated>2016-02-24T14:16:17.719Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/">《轻松实现app中的导航Tab栏悬浮功能》</a>。</p>
<p>当然，用WindowManager来实现由一个缺点就是当没有显示悬浮窗的权限时，该功能就无法体现出来。而在本篇博文中，我们用第二种方法，也就是不断地重新设置Tab栏的布局位置来实现悬浮功能，弥补了第一种方法的缺点。效果图这里就不放了，相信大家都看过啦。</p>
<p>不废话了，直接上代码。</p>
<p>activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;55dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>我们发现在activity_main.xml里Tab栏悬浮窗的布局放在了最后，这是因为当悬浮窗悬浮在顶部时，应该在所有的UI控件上方，所以在xml里放在了最后。</p>
<p>接下来看看MainActivity：</p>
<pre><code>public class MainActivity extends AppCompatActivity implements MyScrollView.OnScrollListener {

    private static final String TAG = &quot;MainActivity&quot;;
    private MyScrollView mScrollView;
    private LinearLayout ll_tab;
    private ImageView iv_pic;
    private int picBottom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getSupportActionBar().hide();
        mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
        mScrollView.setOnScrollListener(this);
        ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
        iv_pic = (ImageView) findViewById(R.id.iv_pic);
        findViewById(R.id.ll_main).getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                onScroll(mScrollView.getScrollY());
            }
        });
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            picBottom = iv_pic.getBottom();
        }
    }

    @Override
    public void onScroll(int scrollY) {
        int top = Math.max(scrollY, picBottom);
        ll_tab.layout(0, top, ll_tab.getWidth(), top + ll_tab.getHeight());
    }

}
</code></pre><p>我们惊奇地发现在Activity里的代码竟然这么短！但是这是这么短，实现了一模一样的功能。</p>
<p>首先在父布局中添加了OnGlobalLayoutListener，以便当布局的状态或者控件的可见性改变时去重新设置Tab栏的布局。之后在<code>onWindowFocusChanged(boolean hasFocus)</code>里得到<code>iv_pic.getBottom()</code>的值，也就是<code>iv_pic</code>的高度。也就是说你一开始想把<code>ll_tab</code>布局在<code>iv_pic</code>的下面。因此可以当作Tab栏距离ScrollView顶部的距离。</p>
<p>最后在<code>onScroll(int scrollY)</code>中比较scrollY，picBottom的最大值。当<code>scrollY&lt;picBottom</code>时，<code>ll_tab</code>会跟随ScrollView的滑动而滑动；当<code>scrollY&gt;picBottom</code>时，<code>ll_tab</code>布局的顶部的坐标始终是ScrollView的滑动距离，这样就造成了<code>ll_tab</code>悬浮在顶部的“假象”。</p>
<p>好了，一起来看看效果吧：</p>
<p><img src="/uploads/20160114/20160114223247.gif" alt="这里填写图片的描述"></p>
<p>是不是和第一种方法的效果一样呢，相信大家都学会了。如果有问题可以在下面留言。</p>
<p>最后，放出源码：</p>
<p><a href="/uploads/20160114/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻松实现app中的导航Tab栏悬浮功能]]></title>
    <link href="http://yuqirong.me/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/"/>
    <id>http://yuqirong.me/2016/01/12/轻松实现app中的导航Tab栏悬浮功能/</id>
    <published>2016-01-12T13:59:29.000Z</published>
    <updated>2016-02-22T12:45:22.651Z</updated>
    <content type="html"><![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160112/20160112210653.gif" alt="这里填写图片的描述"></p>
<p>可以看到上图中的“分类”、“排序”、“筛选”会悬浮在app的顶部，状态随着ScrollView(也可能不是ScrollView，在这里姑且把这滑动的UI控件当作ScrollView吧)的滚动而变化。像这种导航Tab栏悬浮的作用相信大家都能体会到，Tab栏不会随着ScrollView等的滚动而被滑出屏幕外，增加了与用户之间的交互性和方便性。</p>
<p>看到上面的效果，相信大家都跃跃欲试了，那就让我们开始吧。</p>
<p>首先大家要明白一点：Tab栏的状态变化是要监听ScrollView滑动距离的。至于如何得到ScrollView的滑动距离？可以看看我的一篇Tip：<a href="/2015/10/19/给你的ScrollView设置滑动距离监听器/">《给你的ScrollView设置滑动距离监听器》</a>，这里就不过多叙述了。</p>
<p>好了，根据上面的就得到了对ScrollView滑动的监听了。接下来要思考的问题就是如何让Tab栏实现悬浮的效果呢？这里给出的方法有两种，第一种就是使用WindowManager来动态地添加一个View悬浮在顶部；第二种就是随着ScrollView的滑动不断重新设置Tab栏的布局位置。</p>
<p>我们先来看看第一种实现方法，首先是xml布局了。</p>
<p>Activity的布局，activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>Tab栏的布局，tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面布局中的很多空白LinearLayout主要是拉长ScrollView，效果图就是这样的：</p>
<p><img src="/uploads/20160112/20160112201753.png" alt="这里填写图片的描述"></p>
<p>然后我们来看看<code>onCreate(Bundle savedInstanceState)</code>：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    setContentView(R.layout.activity_main);
    mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
    mScrollView.setOnScrollListener(this);
    ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
    windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
}
</code></pre><p>我们先在<code>onCreate(Bundle savedInstanceState)</code>中给ScrollView添加了滑动距离监听器以及得到了一个windowManager的对象。还有一点需要注意的是：我们调用了<code>getSupportActionBar().hide();</code>去掉了标题栏(MainActivity继承了AppCompatActivity)。这是因为标题栏的存在导致了在计算悬浮窗y轴的值时要额外加上标题栏的高度(当然你也可以保留标题栏，然后计算时再加上标题栏的高度^_^!)。</p>
<p>然后在onWindowFocusChanged(boolean hasFocus)得到Tab栏的高度、getTop()值等，以便下面备用。如果你对getLeft()、getTop()、getRight()和getBottom()还不了解的话，可以看看我的另一篇Tip： <a href="/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/">《对view的getLeft()、getTop()等的笔记》</a>。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        tabHeight = ll_tab.getHeight();
        tabTop = ll_tab.getTop();
        scrollTop = mScrollView.getTop();
    }
}
</code></pre><p>之后在滑动监听器的回调方法<code>onScroll(int scrollY)</code>中来控制显示还是隐藏悬浮窗。</p>
<pre><code> @Override
public void onScroll(int scrollY) {
    Log.i(TAG, &quot;scrollY = &quot; + scrollY + &quot;, tabTop = &quot; + tabTop);
    if (scrollY &gt; tabTop) {
        // 如果没显示
        if (!isShowWindow) {
            showWindow();
        }
    } else {
        // 如果显示了
        if (isShowWindow) {
            removeWindow();
        }
    }
}
</code></pre><p>上面的代码比较简单，不用我过多叙述了。下面是removeWindow()、showWindow()两个方法：</p>
<pre><code>// 显示window
private void removeWindow() {
    if (ll_tab_temp != null)
        windowManager.removeView(ll_tab_temp);
    isShowWindow = false;
}

// 移除window
private void showWindow() {
    if (ll_tab_temp == null) {
        ll_tab_temp = LayoutInflater.from(this).inflate(R.layout.tab_layout, null);
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE; //悬浮窗的类型，一般设为2002，表示在所有应用程序之上，但在状态栏之下
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.gravity = Gravity.TOP;  //悬浮窗的对齐方式
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.height = tabHeight;
        layoutParams.x = 0;  //悬浮窗X的位置
        layoutParams.y = scrollTop;  //悬浮窗Y的位置
    }
    windowManager.addView(ll_tab_temp, layoutParams);
    isShowWindow = true;
}
</code></pre><p>这两个方法也很简单，而且有注释，相信大家可以看懂。</p>
<p>最后，不要忘了在AndroidManifest.xml里申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
</code></pre><p>到这里，整体的代码就这些了。一起来看看效果吧：</p>
<p><img src="/uploads/20160112/20160112204356.gif" alt="这里填写图片的描述"></p>
<p>但是用这种方法来实现Tab栏悬浮功能有一个缺点，那就是如果该app没有被赋予显示悬浮窗的权限，那么该功能就变成鸡肋了。当然还有第二种方法来实现，不过只能等到下一篇博文再讲了。</p>
<p>本Demo源码下载：</p>
<p><a href="/uploads/20160112/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对view的getLeft()、getTop()等的笔记]]></title>
    <link href="http://yuqirong.me/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/01/05/对view的getLeft()、getTop()等的笔记/</id>
    <published>2016-01-05T12:01:48.000Z</published>
    <updated>2016-02-19T14:24:47.890Z</updated>
    <content type="html"><![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;


    &lt;LinearLayout
        android:id=&quot;@+id/ll_01&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_green_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_01&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第一行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/ll_02&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_blue_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_02&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第二行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面是一个很简单的布局，UI效果图如下：</p>
<p><img src="/uploads/20160105/20160105202531.png" alt="这里填写图片的描述"></p>
<p>当我们用<code>tv_01.getTop()</code>的时候，得到的返回值是0，符合我的想象。但是用<code>tv_02.getTop()</code>，得到的值也为0。而我原以为<code>tv_02.getTop()</code>的值为<code>ll_01</code>的高度，也就是<code>tv_02</code>距离屏幕顶部的长度。但是结果和我的想象不一致。</p>
<p>后来我才知道原来<code>getTop()</code>方法返回的是该view距离<strong>父容器顶部</strong>的距离，所以理所应当<code>tv_02.getTop()</code>距离<code>ll_02</code>顶部的距离也为0了，同样的<code>getLeft()</code>、<code>getBottom()</code>、<code>getRight()</code>也是一个道理，以此类推。</p>
<p>那么问题来了，如何按我之前的想法一样，得到<code>tv_02</code>距离<strong>屏幕顶部</strong>的值呢？很简单，我们只要<code>tv_02.getTop() + ll_02.getTop()</code>就好了。相信聪明的你已经懂了。</p>
<p>看来在开发中还有不少的细节需要我们注意，特此一记。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml versi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[再见2015，你好2016]]></title>
    <link href="http://yuqirong.me/2016/01/01/%E5%86%8D%E8%A7%812015%EF%BC%8C%E4%BD%A0%E5%A5%BD2016/"/>
    <id>http://yuqirong.me/2016/01/01/再见2015，你好2016/</id>
    <published>2016-01-01T12:54:54.000Z</published>
    <updated>2016-02-19T14:15:29.787Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>转眼间2015年悄然流走，而2016年已经来临。蓦然回首，在2015年里经历了太多。</p>
<p>在这短短的一年里，得到了很多，同时也失去了很多。</p>
<h1 id="u518D_u89C12015"><a href="#u518D_u89C12015" class="headerlink" title="再见2015"></a>再见2015</h1><p>2015，完成了我从大三到大四的转变，同时也是抉择人生道路的重要时刻。和其他人一样，在考研和就业的分叉路上也纠结了很久。但是在2015年里，努力地学习编程，幻想着有一天能够成为大牛，这似乎离考研的路越走越远。</p>
<p>细细回想似乎写程序也已经满一年多了，从一开始的Java到现在的Android，这中间也弯弯曲曲地走了不少的弯路。还记得刚开始学习Android时，对于一切知识都急于求成，但却似乎忘了基础；以为自己什么都懂，其实只是一只“纸老虎”。最关键的是，把心慢下来，一点一滴积累才是正道，学习的路上没有捷径。</p>
<h1 id="u4F60_u597D2016"><a href="#u4F60_u597D2016" class="headerlink" title="你好2016"></a>你好2016</h1><p>至于2016的到来，真的是“手足无措”。时间总是在不经意间流逝，而当你幡然醒悟时，只能扼腕叹息。其实更重要的是，在2016年的6月，我们要毕业了。离开同学，离开老师，离开校园。这其中纵然有千万缕不舍，但是人终究要面临着成长。之前从没想象过毕业，总以为离我们很遥远，但其实却很近。我们都已经习惯了在校园里慵懒的生活，闲暇之余可以和同学之间玩玩游戏，在草地上晒晒太阳，在图书馆安静地看看书。而这一切在2016都要发生重大的转变，这似乎就是我不愿意2016到来的原因了。</p>
<p>人们总是在展望未来，却忘了把握当下。最无厘头的一句话“我在2016年的新年目标就是完成2015年那些本该在2014年完成的我在2013年就信誓旦旦要完成的2012年制定的目标…”。当然希望每个人都要脚踏实地，认认真真地完成自己订下的目标。也希望自己在新的一年里积累更多的知识，技术节节高升，早日走向人生的巅峰。</p>
<p>最后，献上一首《同学的你》，纪念即将告别的校园生活。</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=28387594&auto=1&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>夕阳下的奔跑，那是我逝去的青春</p>
</blockquote>
<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" ti]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义实现水波纹动画，让你的app不再单调]]></title>
    <link href="http://yuqirong.me/2015/12/27/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%AE%9E%E7%8E%B0%E6%B0%B4%E6%B3%A2%E7%BA%B9%E5%8A%A8%E7%94%BB%EF%BC%8C%E8%AE%A9%E4%BD%A0%E7%9A%84app%E4%B8%8D%E5%86%8D%E5%8D%95%E8%B0%83/"/>
    <id>http://yuqirong.me/2015/12/27/自定义实现水波纹动画，让你的app不再单调/</id>
    <published>2015-12-27T15:05:17.000Z</published>
    <updated>2016-02-21T14:21:00.308Z</updated>
    <content type="html"><![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效果怎样，我们一起来看看：</p>
<p><img src="/uploads/20151227/20151227231546.gif" alt="这里填写图片描述"></p>
<p>是不是觉得有新意多了呢？那就一起来看看吧，先简单讲述一下思路：首先波浪的形状主要是根据三角函数决定的。三角函数相信大家在中学的课程中学习过吧。通用公式就是f(x)=Asin(ωx+φ) + b。其中A就是波浪的振幅，ω与时间周期有关，x就是屏幕宽度的像素点，φ是初相，可以让波浪产生偏移，最后的b就是水位的高度了。最后根据这公式算出y坐标，用<code>canvas.drawLine(startX, startY, stopX, stopY, paint);</code>来画出竖直的线条，这样就形成了波浪。</p>
<p>整体的思路就如下面示意图所示，当红色的线条间距越来越小，密度越来越大时就形成了波浪：</p>
<p><img src="/uploads/20151227/20151227230103.png" alt="这里填写图片描述"></p>
<p>讲完了思路，那下面我们就来分析一下代码吧。</p>
<p>首先看一下“自定义View三部曲”中的第一部，自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;

    &lt;declare-styleable name=&quot;WaveView&quot;&gt;
        &lt;attr name=&quot;waveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;secondWaveColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;attr name=&quot;waveHeight&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;

&lt;/resources&gt;
</code></pre><p>我们先定义了三个属性，分别是前波浪颜色、后波浪颜色以及波浪的振幅高度。</p>
<p>然后就是在构造器中初始化自定义的属性。</p>
<pre><code>public WaveView(Context context) {
    this(context, null);
}

public WaveView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public WaveView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.WaveView);
    defaultWaveColor = getResources().getColor(R.color.indigo_color);
    waveColor = a.getColor(R.styleable.WaveView_waveColor, defaultWaveColor);
    defaultSecondWaveColor = getResources().getColor(R.color.second_indigo_color);
    secondWaveColor = a.getColor(R.styleable.WaveView_secondWaveColor, defaultSecondWaveColor);
    defaultWaveHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 10, getResources().getDisplayMetrics());
    waveHeight = a.getDimension(R.styleable.WaveView_waveHeight, defaultWaveHeight);
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
}
</code></pre><p>前面的代码很简单，接下来要重写<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>:</p>
<pre><code>@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    this.w = (float) (Math.PI * 2 / w);
}
</code></pre><p>这里的w就是上面f(x)=Asin(ωx+φ) + b公式中的ω，而ω=2π/T。也就是说周期就是屏幕宽度。所以在一个屏幕内正好可以显示出正弦函数的一个周期。</p>
<p>下面就是三部曲的第二部：重写<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 200;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 200;
    }
    setMeasuredDimension(mWidth, mHeight);
}
</code></pre><p>onMeasure()中就是测量了View的宽高度，如果不是MeasureSpec.EXACTLY的模式就直接赋值200(这里没有把200px转化为200dp,偷懒了ㄟ(▔ ,▔)ㄏ)。相信大家都会了。</p>
<p>最后就是<code>onDraw(Canvas canvas)</code>，也就是三部曲中的最后一部：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 水位的高度
    waterHeight = waterHeight + 10;
    // 正弦函数y的坐标
    float startY;
    canvas.save();

    if (System.currentTimeMillis() - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - System.currentTimeMillis());
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
    double temp = Math.toDegrees(speed);
    speed++;

    // 先绘制第二条波浪
    mPaint.setColor(secondWaveColor);
    // 遍历每个像素点，并在竖直上画线
    for (int i = 0; i &lt; mWidth; i++) {
        // 和第一条波浪相比产生的偏移量为8,至于偏移量大小可以自己决定
        startY = (float) (waveHeight * Math.sin(w * i + temp + 8) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }

    // 再绘制第一条波浪
    mPaint.setColor(waveColor);
    for (int i = 0; i &lt; mWidth; i++) {
        startY = (float) (waveHeight * Math.sin(w * i + temp) + mHeight - waveHeight - waterHeight);
        canvas.drawLine(i, startY, i, mHeight, mPaint);
    }
    Log.i(TAG, &quot;waterHeight : &quot; + waterHeight);
    canvas.restore();
    // 不断重绘
    invalidate();
    startTime = System.currentTimeMillis();
}
</code></pre><p>在<code>onDraw(Canvas canvas)</code>的一开始waterHeight不断自增，以此来实现水位不断上涨的效果，然后就是线程的休眠来控制绘制的频率。之后在绘制第二条波浪时初相加上一个偏移量，这样就可以与第一条波浪形成交错的效果。整体代码并不复杂，主要是坐标上的计算。</p>
<p>到这里基本就讲得差不多了，以下是本案例的源码：</p>
<p><a href="/uploads/20151227/WaveView.rar">WaveView.rar</a></p>
<p>最后，预祝大家元旦快乐！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在开发Android应用的过程中，动画是一个很重要的点。好的动画可以给用户一种耳目一新的感觉。比如说京东app里下拉刷新中的动画是一个奔跑的快递员，这样用户会有一种耳目一新的感觉。所以我们何尝不提供一种新的动画方式呢？而今天给大家带来的就是水波纹动画。</p>
<p>至于效]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[让你的ListView更炫酷，实现侧滑删除效果]]></title>
    <link href="http://yuqirong.me/2015/12/13/%E8%AE%A9%E4%BD%A0%E7%9A%84ListView%E6%9B%B4%E7%82%AB%E9%85%B7%EF%BC%8C%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2015/12/13/让你的ListView更炫酷，实现侧滑删除效果/</id>
    <published>2015-12-13T15:54:48.000Z</published>
    <updated>2016-03-02T08:51:02.245Z</updated>
    <content type="html"><![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接一下之前写的博文使用ViewDragHelper来实现侧滑菜单的，<a href="/2015/11/04/史上最简单粗暴实现侧滑菜单/">点击此处跳转</a>。如果你对ViewDragHelper不熟悉，你可以去看看<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">《Android ViewDragHelper完全解析 自定义ViewGroup神器》</a>。</p>
<p>好了，话说的那么多，先来看看我们实现的效果图吧：</p>
<p><img src="/uploads/20151213/20151213140251.gif" alt="这里填写图片描述"></p>
<p>可以看出来，我们实现的和QQ的效果相差无几。下面就是源码时间了。</p>
<p>先来看一下ListView的item的<code>slip_item_layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.swipelistview.view.SwipeListLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:id=&quot;@+id/sll_main&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;wrap_content&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;TextView
            android:id=&quot;@+id/tv_top&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#66ff0000&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;置顶&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_delete&quot;
            android:layout_width=&quot;80dp&quot;
            android:layout_height=&quot;match_parent&quot;
            android:background=&quot;#330000ff&quot;
            android:gravity=&quot;center&quot;
            android:text=&quot;删除&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_gravity=&quot;center_vertical&quot;
        android:background=&quot;#66ffffff&quot;
        android:orientation=&quot;horizontal&quot; &gt;

        &lt;ImageView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_margin=&quot;10dp&quot;
            android:src=&quot;@drawable/head_1&quot; /&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_name&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;match_parent&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:gravity=&quot;center_vertical&quot;
            android:text=&quot;hello&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/com.yuqirong.swipelistview.view.SwipeListLayout&gt;
</code></pre><p>我们可以看出，要先把侧滑出的按钮布局放在SwipeListLayout的第一层，而item的布局放在第二层。还有一点要注意的是，侧滑出的按钮如果有两个或两个以上，那么必须用ViewGroup作为父布局。要整体保持SwipeListLayout的直接子View为2个。</p>
<p>而activity的布局文件里就是一个ListView，这里就不再给出了。</p>
<p>下面我们直接来看看SwipeListLayout的内容：</p>
<pre><code>public SwipeListLayout(Context context) {
    this(context, null);
}

public SwipeListLayout(Context context, AttributeSet attrs) {
    super(context, attrs);
    mDragHelper = ViewDragHelper.create(this, callback);
}

// ViewDragHelper的回调
Callback callback = new Callback() {

    @Override
    public boolean tryCaptureView(View view, int arg1) {
        return view == itemView;
    }

    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == itemView) {
            if (left &gt; 0) {
                return 0;
            } else {
                left = Math.max(left, -hiddenViewWidth);
                return left;
            }
        }
        return 0;
    }

    @Override
    public int getViewHorizontalDragRange(View child) {
        return hiddenViewWidth;
    }

    @Override
    public void onViewPositionChanged(View changedView, int left, int top,
            int dx, int dy) {
        if (itemView == changedView) {
            hiddenView.offsetLeftAndRight(dx);
        }
        // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
        // 为了确保绘制成功 调用 invalidate
        invalidate();
    }

    public void onViewReleased(View releasedChild, float xvel, float yvel) {
        // 向右滑xvel为正 向左滑xvel为负
        if (releasedChild == itemView) {
            if (xvel == 0
                    &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                open(smooth);
            } else if (xvel &lt; 0) {
                open(smooth);
            } else {
                close(smooth);
            }
        }
    }

};
</code></pre><p>我们主要来看callback，首先在<code>tryCaptureView(View view, int arg1)</code>里设置了只有是itemView的时候才能被捕获，也就是说当你去滑动“删除”、“置顶”等按钮的时候，侧滑按钮是不会被关闭的，因为根本就没捕获。(当然你也可以设置都捕获，那样的话下面的逻辑要调整了)，剩余的几个函数中的逻辑较为简单，在<code>onView
Released(View releasedChild, float xvel, float yvel)</code>也是判断了当手指抬起时itemView所处的位置。如果向左滑或者停止滑动时按钮已经显示出1/2的宽度，则打开；其余情况下都将关闭按钮。</p>
<p>以下分别是close()和open()的方法：</p>
<pre><code>/**
 * 侧滑关闭
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void close(boolean smooth) {
    preStatus = status;
    status = Status.Close;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start close animation&quot;);
                listener.onStartCloseAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Open) {
        Log.i(TAG, &quot;close&quot;);
        listener.onStatusChanged(status);
    }
}

/**
 * 侧滑打开
 * 
 * @param smooth
 *            为true则有平滑的过渡动画
 */
private void open(boolean smooth) {
    preStatus = status;
    status = Status.Open;
    if (smooth) {
        if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
            if (listener != null) {
                Log.i(TAG, &quot;start open animation&quot;);
                listener.onStartOpenAnimation();
            }
            ViewCompat.postInvalidateOnAnimation(this);
        }
    } else {
        layout(status);
    }
    if (listener != null &amp;&amp; preStatus == Status.Close) {
        Log.i(TAG, &quot;open&quot;);
        listener.onStatusChanged(status);
    }
}
</code></pre><p>SwipeListLayout大致的代码就这些，相信对于熟悉ViewDragHelper的同学们来说应该是不成问题的。其实整体的逻辑和之前用ViewDragHelper来实现侧滑菜单大同小异。</p>
<p>顺便下面贴出SwipeListLayout的全部代码：</p>
<pre><code>/**
 * 侧滑Layout
 */
public class SwipeListLayout extends FrameLayout {

    private View hiddenView;
    private View itemView;
    private int hiddenViewWidth;
    private ViewDragHelper mDragHelper;
    private int hiddenViewHeight;
    private int itemWidth;
    private int itemHeight;
    private OnSwipeStatusListener listener;
    private Status status = Status.Close;
    private boolean smooth = true;

    public static final String TAG = &quot;SlipListLayout&quot;;

    // 状态
    public enum Status {
        Open, Close
    }

    /**
     * 设置侧滑状态
     * 
     * @param status
     *            状态 Open or Close
     * @param smooth
     *            若为true则有过渡动画，否则没有
     */
    public void setStatus(Status status, boolean smooth) {
        this.status = status;
        if (status == Status.Open) {
            open(smooth);
        } else {
            close(smooth);
        }
    }

    public void setOnSwipeStatusListener(OnSwipeStatusListener listener) {
        this.listener = listener;
    }

    /**
     * 是否设置过渡动画
     * 
     * @param smooth
     */
    public void setSmooth(boolean smooth) {
        this.smooth = smooth;
    }

    public interface OnSwipeStatusListener {

        /**
         * 当状态改变时回调
         * 
         * @param status
         */
        void onStatusChanged(Status status);

        /**
         * 开始执行Open动画
         */
        void onStartCloseAnimation();

        /**
         * 开始执行Close动画
         */
        void onStartOpenAnimation();

    }

    public SwipeListLayout(Context context) {
        this(context, null);
    }

    public SwipeListLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        mDragHelper = ViewDragHelper.create(this, callback);
    }

    // ViewDragHelper的回调
    Callback callback = new Callback() {

        @Override
        public boolean tryCaptureView(View view, int arg1) {
            return view == itemView;
        }

        @Override
        public int clampViewPositionHorizontal(View child, int left, int dx) {
            if (child == itemView) {
                if (left &gt; 0) {
                    return 0;
                } else {
                    left = Math.max(left, -hiddenViewWidth);
                    return left;
                }
            }
            return 0;
        }

        @Override
        public int getViewHorizontalDragRange(View child) {
            return hiddenViewWidth;
        }

        @Override
        public void onViewPositionChanged(View changedView, int left, int top,
                int dx, int dy) {
            if (itemView == changedView) {
                hiddenView.offsetLeftAndRight(dx);
            }
            // 有时候滑动很快的话 会出现隐藏按钮的linearlayout没有绘制的问题
            // 为了确保绘制成功 调用 invalidate
            invalidate();
        }

        public void onViewReleased(View releasedChild, float xvel, float yvel) {
            // 向右滑xvel为正 向左滑xvel为负
            if (releasedChild == itemView) {
                if (xvel == 0
                        &amp;&amp; Math.abs(itemView.getLeft()) &gt; hiddenViewWidth / 2.0f) {
                    open(smooth);
                } else if (xvel &lt; 0) {
                    open(smooth);
                } else {
                    close(smooth);
                }
            }
        }

    };
    private Status preStatus = Status.Close;

    /**
     * 侧滑关闭
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void close(boolean smooth) {
        preStatus = status;
        status = Status.Close;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, 0, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start close animation&quot;);
                    listener.onStartCloseAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Open) {
            Log.i(TAG, &quot;close&quot;);
            listener.onStatusChanged(status);
        }
    }

    /**
     * 
     * @param status
     */
    private void layout(Status status) {
        if (status == Status.Close) {
            hiddenView.layout(itemWidth, 0, itemWidth + hiddenViewWidth,
                    itemHeight);
            itemView.layout(0, 0, itemWidth, itemHeight);
        } else {
            hiddenView.layout(itemWidth - hiddenViewWidth, 0, itemWidth,
                    itemHeight);
            itemView.layout(-hiddenViewWidth, 0, itemWidth - hiddenViewWidth,
                    itemHeight);
        }
    }

    /**
     * 侧滑打开
     * 
     * @param smooth
     *            为true则有平滑的过渡动画
     */
    private void open(boolean smooth) {
        preStatus = status;
        status = Status.Open;
        if (smooth) {
            if (mDragHelper.smoothSlideViewTo(itemView, -hiddenViewWidth, 0)) {
                if (listener != null) {
                    Log.i(TAG, &quot;start open animation&quot;);
                    listener.onStartOpenAnimation();
                }
                ViewCompat.postInvalidateOnAnimation(this);
            }
        } else {
            layout(status);
        }
        if (listener != null &amp;&amp; preStatus == Status.Close) {
            Log.i(TAG, &quot;open&quot;);
            listener.onStatusChanged(status);
        }
    }

    @Override
    public void computeScroll() {
        super.computeScroll();
        // 开始执行动画
        if (mDragHelper.continueSettling(true)) {
            ViewCompat.postInvalidateOnAnimation(this);
        }
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onInterceptTouchEvent(MotionEvent ev) {
        final int action = ev.getAction();
        if (action == MotionEvent.ACTION_CANCEL) {
            mDragHelper.cancel();
            return false;
        }
        return mDragHelper.shouldInterceptTouchEvent(ev);
    }

    // 让ViewDragHelper来处理触摸事件
    public boolean onTouchEvent(MotionEvent event) {
        mDragHelper.processTouchEvent(event);
        return true;
    };

    @Override
    protected void onFinishInflate() {
        super.onFinishInflate();
        hiddenView = getChildAt(0); // 得到隐藏按钮的linearlayout
        itemView = getChildAt(1); // 得到最上层的linearlayout
    }

    @Override
    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
        super.onSizeChanged(w, h, oldw, oldh);
        // 测量子View的长和宽
        itemWidth = itemView.getMeasuredWidth();
        itemHeight = itemView.getMeasuredHeight();
        hiddenViewWidth = hiddenView.getMeasuredWidth();
        hiddenViewHeight = hiddenView.getMeasuredHeight();
    }

    @Override
    protected void onLayout(boolean changed, int left, int top, int right,
            int bottom) {
        layout(Status.Close);
    }

}
</code></pre><p>最后，提供SwipeListLayout的源码下载：</p>
<p><a href="/uploads/20151213/SwipeListView.rar">SwipeListView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/SwipeListView" target="_blank" rel="external">SwipeListView</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更新博客的时间了，今天给大家带来的是ListView侧滑出现删除等按钮的效果。相信大家在平时玩app的时候都接触过这种效果吧。比如说QQ聊天列表侧滑就会出现“置顶”、“标为已读”、“删除”等按钮。这篇博文将用ViewDragHelper这个神器来实现侧滑效果。友情链接]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现炫酷的CheckBox，就这么简单]]></title>
    <link href="http://yuqirong.me/2015/12/05/%E5%AE%9E%E7%8E%B0%E7%82%AB%E9%85%B7%E7%9A%84CheckBox%EF%BC%8C%E5%B0%B1%E8%BF%99%E4%B9%88%E7%AE%80%E5%8D%95/"/>
    <id>http://yuqirong.me/2015/12/05/实现炫酷的CheckBox，就这么简单/</id>
    <published>2015-12-05T15:10:32.000Z</published>
    <updated>2016-03-02T08:52:24.219Z</updated>
    <content type="html"><![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andyxialm/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a>，它的效果预览触动到我了，于是趁着今天有空就试着自己写一写。尽管效果可能不如SmoothCheckBox那样动感，但是基本的效果还是实现了。按照惯例，下面就贴出我写的CheckBox的gif： </p>
<p><img src="/uploads/20151205/20151205234652.gif" alt="这里写图片描述"></p>
<p>gif的效果可能有点过快，在真机上运行的效果会更好一些。我们主要的思路就是利用属性动画来动态地画出选中状态以及对勾的绘制过程。看到上面的效果图，相信大家都迫不及待地要跃跃欲试了，那就让我们开始吧。</p>
<p>自定义View的第一步：自定义属性。</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;SmoothCheckBox&quot;&gt;
        &lt;!-- 动画持续时间 --&gt;
        &lt;attr name=&quot;duration&quot; format=&quot;integer&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框宽度 --&gt;
        &lt;attr name=&quot;strikeWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 边框颜色 --&gt;
        &lt;attr name=&quot;borderColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 选中状态的颜色 --&gt;
        &lt;attr name=&quot;trimColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾颜色 --&gt;
        &lt;attr name=&quot;tickColor&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        &lt;!-- 对勾宽度 --&gt;
        &lt;attr name=&quot;tickWidth&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>我们把CheckBox取名为SmoothCheckBox(没办法(⊙﹏⊙)，这名字挺好听的)，定义了几个等等要用到的属性。这一步很简单，相信大家都熟练了。</p>
<p>接下来看一看<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>:</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = 40;
    }

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = 40;
    }
    setMeasuredDimension(mWidth, mHeight);
    int size = Math.min(mWidth, mHeight);
    center = size / 2;
    mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
    startPoint.set(center * 14 / 30, center * 28 / 30);
    breakPoint.set(center * 26 / 30, center * 40 / 30);
    endPoint.set(center * 44 / 30, center * 20 / 30);

    downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
    upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
    totalLength = downLength + upLength;
}
</code></pre><p>一开始是测量了SmoothCheckBox的宽、高度，默认的宽高度随便定义了一个，当然你们可以自己去修改和完善它。然后就是设置半径之类的，最后的startPoint、breakPoint、endPoint分别对应着选中时对勾的三个点(至于为何是这几个数字，那完全是经验值);downLength就是startPoint和breakPoint的距离，而相对应的upLength就是breakPoint和endPoint的距离。即以下图示：</p>
<p><img src="/uploads/20151205/20151205000130.png" alt="这里写图片描述"></p>
<p>在看<code>onDraw(Canvas canvas)</code>之前我们先来看两组动画，分别是选中状态时的动画以及未选中状态的动画：</p>
<pre><code> // 由未选中到选中的动画
private void checkedAnimation() {
    animatedValue = 0f;
    tickValue = 0f;
    // 选中时底色的动画
    mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
    // 对勾的动画
    mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
    mTickValueAnimator.setInterpolator(new LinearInterpolator());
    mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            tickValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            // 得到动画执行进度
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.addListener(new AnimatorListenerAdapter() {
        @Override
        public void onAnimationEnd(Animator animation) {
            //当底色的动画完成后再开始对勾的动画
            mTickValueAnimator.start();
            Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
        }
    });
    mValueAnimator.start();
}

// 由选中到未选中的动画
private void uncheckedAnimation() {
    animatedValue = 0f;
    mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
    mValueAnimator.setInterpolator(new AccelerateInterpolator());
    mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
        @Override
        public void onAnimationUpdate(ValueAnimator valueAnimator) {
            animatedValue = (float) valueAnimator.getAnimatedValue();
            postInvalidate();
        }
    });
    mValueAnimator.start();
}
</code></pre><p>这两组动画在点击SmoothCheckBox的时候会调用。相似的，都是在动画执行中得到动画执行的进度，再来调用<code>postInvalidate();</code>让SmoothCheckBox重绘。看完这个之后就是终极大招<code>onDraw(Canvas canvas)</code>了:</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    drawBorder(canvas);
    drawTrim(canvas);
    if (isChecked) {
        drawTick(canvas);
    }
    canvas.restore();
}

// 画对勾
private void drawTick(Canvas canvas) {
    // 得到画对勾的进度
    float temp = tickValue * totalLength;
    Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
    //判断是否是刚开始画对勾的时候,即等于startPoint
    if (Float.compare(tickValue, 0f) == 0) {
        Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
        path.reset();
        path.moveTo(startPoint.x, startPoint.y);
    }
    // 如果画对勾的进度已经超过breakPoint的时候,即(breakPoint,endPoint]
    if (temp &gt; downLength) {
        path.moveTo(startPoint.x, startPoint.y);
        path.lineTo(breakPoint.x, breakPoint.y);
        Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
        path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
    } else {
        //画对勾的进度介于startPoinit和breakPoint之间，即(startPoint,breakPoint]
        Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
        path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
    }
    canvas.drawPath(path, tickPaint);
}

// 画边框
private void drawBorder(Canvas canvas) {
    float temp;
    // 通过animatedValue让边框产生一个“OverShooting”的动画
    if (animatedValue &gt; 1f) {
        temp = animatedValue * mRadius;
    } else {
        temp = mRadius;
    }
    canvas.drawCircle(center, center, temp, borderPaint);
}

// 画checkbox内部
private void drawTrim(Canvas canvas) {
    canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
}
</code></pre><p><code>onDraw(Canvas canvas)</code>代码中的逻辑基本都加了注释，主要就是原理搞懂了就比较简单了。在绘制对勾时要区分当前处于绘制对勾的哪种状态，然后对应做处理画出线条，剩下的就简单了。关于SmoothCheckBox的讲解到这里就差不多了。</p>
<p>下面就贴出SmoothCheckBox的完整代码：</p>
<pre><code>public class SmoothCheckBox extends View implements View.OnClickListener {

    // 动画持续时间
    private long duration;
    // 边框宽度
    private float mStrokeWidth;
    // 对勾宽度
    private float mTickWidth;
    // 内饰画笔
    private Paint trimPaint;
    // 边框画笔
    private Paint borderPaint;
    // 对勾画笔
    private Paint tickPaint;
    // 默认边框宽度
    private float defaultStrikeWidth;
    // 默认对勾宽度
    private float defaultTickWidth;
    // 宽度
    private int mWidth;
    // 高度
    private int mHeight;
    // 边框颜色
    private int borderColor;
    // 内饰颜色
    private int trimColor;
    // 对勾颜色
    private int tickColor;
    // 半径
    private int mRadius;
    // 中心点
    private int center;
    // 是否是选中
    private boolean isChecked;
    //对勾向下的长度
    private float downLength;
    //对勾向上的长度
    private float upLength;
    // 对勾的总长度
    private float totalLength;
    // 监听器
    private OnCheckedChangeListener listener;

    private ValueAnimator mValueAnimator;

    private ValueAnimator mTickValueAnimator;

    private float animatedValue;

    private float tickValue;
    // 对勾开始点
    private Point startPoint = new Point();
    // 对勾转折点
    private Point breakPoint = new Point();
    // 对勾结束点
    private Point endPoint = new Point();

    private static final String TAG = &quot;SmoothCheckBox&quot;;

    private static final String KEY_INSTANCE_STATE = &quot;InstanceState&quot;;

    private Path path = new Path();

    public void setOnCheckedChangeListener(OnCheckedChangeListener listener) {
        this.listener = listener;
    }

    public SmoothCheckBox(Context context) {
        this(context, null);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SmoothCheckBox(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.SmoothCheckBox);
        duration = a.getInt(R.styleable.SmoothCheckBox_duration, 600);

        defaultStrikeWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 1, getResources().getDisplayMetrics());
        mStrokeWidth = a.getDimension(R.styleable.SmoothCheckBox_strikeWidth, defaultStrikeWidth);
        defaultTickWidth = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, getResources().getDisplayMetrics());
        mTickWidth = a.getDimension(R.styleable.SmoothCheckBox_tickWidth, defaultTickWidth);
        borderColor = a.getColor(R.styleable.SmoothCheckBox_borderColor, getResources().getColor(android.R.color.darker_gray));
        trimColor = a.getColor(R.styleable.SmoothCheckBox_trimColor, getResources().getColor(android.R.color.holo_green_light));
        tickColor = a.getColor(R.styleable.SmoothCheckBox_tickColor, getResources().getColor(android.R.color.white));
        a.recycle();

        trimPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        trimPaint.setStyle(Paint.Style.FILL);
        trimPaint.setColor(trimColor);

        borderPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        borderPaint.setStrokeWidth(mStrokeWidth);
        borderPaint.setColor(borderColor);
        borderPaint.setStyle(Paint.Style.STROKE);

        tickPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
        tickPaint.setColor(tickColor);
        tickPaint.setStyle(Paint.Style.STROKE);
        tickPaint.setStrokeCap(Paint.Cap.ROUND);
        tickPaint.setStrokeWidth(mTickWidth);

        setOnClickListener(this);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = 40;
        }

        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = 40;
        }
        setMeasuredDimension(mWidth, mHeight);
        int size = Math.min(mWidth, mHeight);
        center = size / 2;
        mRadius = (int) ((size - mStrokeWidth) / 2 / 1.2f);
        startPoint.set(center * 14 / 30, center * 28 / 30);
        breakPoint.set(center * 26 / 30, center * 40 / 30);
        endPoint.set(center * 44 / 30, center * 20 / 30);

        downLength = (float) Math.sqrt(Math.pow(startPoint.x - breakPoint.x, 2f) + Math.pow(startPoint.y - breakPoint.y, 2f));
        upLength = (float) Math.sqrt(Math.pow(endPoint.x - breakPoint.x, 2f) + Math.pow(endPoint.y - breakPoint.y, 2f));
        totalLength = downLength + upLength;
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        drawBorder(canvas);
        drawTrim(canvas);
        if (isChecked) {
            drawTick(canvas);
        }
        canvas.restore();
    }

    @Override
    protected Parcelable onSaveInstanceState() {
        Bundle bundle = new Bundle();
        bundle.putParcelable(KEY_INSTANCE_STATE, super.onSaveInstanceState());
        bundle.putBoolean(KEY_INSTANCE_STATE, isChecked);
        return bundle;
    }

    @Override
    protected void onRestoreInstanceState(Parcelable state) {
        if (state instanceof Bundle) {
            Bundle bundle = (Bundle) state;
            boolean isChecked = bundle.getBoolean(KEY_INSTANCE_STATE);
            setChecked(isChecked);
            super.onRestoreInstanceState(bundle.getParcelable(KEY_INSTANCE_STATE));
            return;
        }
        super.onRestoreInstanceState(state);
    }

    // 切换状态
    private void toggle() {
        isChecked = !isChecked;
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
        if (isChecked) {
            checkedAnimation();
        } else {
            uncheckedAnimation();
        }
    }

    // 由未选中到选中的动画
    private void checkedAnimation() {
        animatedValue = 0f;
        tickValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(0f, 1.2f, 1f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateDecelerateInterpolator());
        mTickValueAnimator = ValueAnimator.ofFloat(0f, 1f).setDuration(3 * duration / 5);
        mTickValueAnimator.setInterpolator(new LinearInterpolator());
        mTickValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                tickValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.addListener(new AnimatorListenerAdapter() {
            @Override
            public void onAnimationEnd(Animator animation) {
                mTickValueAnimator.start();
                Log.i(TAG,&quot; mTickValueAnimator.start();&quot;);
            }
        });
        mValueAnimator.start();
    }

    // 由选中到未选中的动画
    private void uncheckedAnimation() {
        animatedValue = 0f;
        mValueAnimator = ValueAnimator.ofFloat(1f, 0f).setDuration(2 * duration / 5);
        mValueAnimator.setInterpolator(new AccelerateInterpolator());
        mValueAnimator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
            @Override
            public void onAnimationUpdate(ValueAnimator valueAnimator) {
                animatedValue = (float) valueAnimator.getAnimatedValue();
                postInvalidate();
            }
        });
        mValueAnimator.start();
    }

    // 画对勾
    private void drawTick(Canvas canvas) {
        float temp = tickValue * totalLength;
        Log.i(TAG, &quot;temp:&quot; + temp + &quot;downlength :&quot; + downLength);
        if (Float.compare(tickValue, 0f) == 0) {
            Log.i(TAG, &quot;startPoint : &quot; + startPoint.x + &quot;, &quot; + startPoint.y);
            path.reset();
            path.moveTo(startPoint.x, startPoint.y);
        }
        if (temp &gt; downLength) {
            path.moveTo(startPoint.x, startPoint.y);
            path.lineTo(breakPoint.x, breakPoint.y);
            Log.i(TAG, &quot;endPoint : &quot; + endPoint.x + &quot;, &quot; + endPoint.y);
            path.lineTo((endPoint.x - breakPoint.x) * (temp - downLength) / upLength + breakPoint.x, (endPoint.y - breakPoint.y) * (temp - downLength) / upLength + breakPoint.y);
        } else {
            Log.i(TAG, &quot;down x : &quot; + (breakPoint.x - startPoint.x) * temp / downLength + &quot;,down y: &quot; + (breakPoint.y - startPoint.y) * temp / downLength);
            path.lineTo((breakPoint.x - startPoint.x) * temp / downLength + startPoint.x, (breakPoint.y - startPoint.y) * temp / downLength + startPoint.y);
        }
        canvas.drawPath(path, tickPaint);
    }

    // 画边框
    private void drawBorder(Canvas canvas) {
        float temp;
        if (animatedValue &gt; 1f) {
            temp = animatedValue * mRadius;
        } else {
            temp = mRadius;
        }
        canvas.drawCircle(center, center, temp, borderPaint);
    }

    // 画checkbox内部
    private void drawTrim(Canvas canvas) {
        canvas.drawCircle(center, center, (mRadius - mStrokeWidth) * animatedValue, trimPaint);
    }

    @Override
    public void onClick(View view) {
        toggle();
    }

    /**
     * 判断checkbox是否选中状态
     *
     * @return
     */
    public boolean isChecked() {
        return isChecked;
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked 是否选中
     */
    public void setChecked(boolean isChecked) {
        this.setChecked(isChecked, false);
    }

    /**
     * 设置checkbox的状态
     *
     * @param isChecked   是否选中
     * @param isAnimation 切换时是否有动画
     */
    public void setChecked(boolean isChecked, boolean isAnimation) {
        this.isChecked = isChecked;
        if (isAnimation) {
            if (isChecked) {
                checkedAnimation();
            } else {
                uncheckedAnimation();
            }
        } else {
            animatedValue = isChecked ? 1f : 0f;
            tickValue = 1f;
            invalidate();
        }
        if (listener != null) {
            listener.onCheckedChanged(this, isChecked);
        }
    }

    public interface OnCheckedChangeListener {
        void onCheckedChanged(SmoothCheckBox smoothCheckBox, boolean isChecked);
    }
}
</code></pre><p>下面是SmoothCheckBox的源码下载，如果有问题可以在下面留言来交流：</p>
<p><a href="/uploads/20151205/SmoothCheckBox.rar">SmoothCheckBox.rar</a></p>
<p>GitHub:</p>
<p><a href="https://github.com/yuqirong/SmoothCheckBox" target="_blank" rel="external">SmoothCheckBox</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天给大家带来的是一款全新的CheckBox，是不是对系统自带的CheckBox产生乏味感了呢，那就来看看下面的CheckBox吧！</p>
<p>之前在逛GitHub的时候看到一款比较新颖的CheckBox：<a href="https://github.com/andy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探Android ORM框架之greenDAO]]></title>
    <link href="http://yuqirong.me/2015/11/24/%E5%88%9D%E6%8E%A2Android%20ORM%E6%A1%86%E6%9E%B6%E4%B9%8BgreenDAO/"/>
    <id>http://yuqirong.me/2015/11/24/初探Android ORM框架之greenDAO/</id>
    <published>2015-11-24T13:14:30.000Z</published>
    <updated>2016-02-21T14:20:16.913Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许多ORM (对象关系映射 英语：Object Relational Mapping) 的第三方框架，比如greenDAO、ActiveAndroid、ormlite等。说到ORM，相信有过J2EE开发经验的童鞋对此并不陌生，在web开发中就有Hibernate、MyBatis等框架提供使用。那么今天就来介绍一下主角：greenDAO。</p>
<p>根据 <a href="http://greenrobot.org/" target="_blank" rel="external">greenrobot</a> 官方的介绍，greenDAO是一款轻量，快速，适用于Android数据库的ORM框架。具有很高的性能以及消耗很少的内存。其他的优点和特性就不在这里一一介绍了，想要了解的同学可以去访问它的项目地址：<a href="https://github.com/greenrobot/greenDAO" target="_blank" rel="external">https://github.com/greenrobot/greenDAO</a>。</p>
<p>说了这么多，下面就开始我们的正题吧。</p>
<p>在使用greenDAO之前，我们有一件事情不得不做，那就是用代码生成器生成数据模型以及xxxDao等</p>
<p>新建一个java module，取名greendaogeneration(名字随意取，不要在意细节↖(^ω^)↗)，然后在build.gradle(Module:greendaogeneration)中添加依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao-generator:2.0.0&#39;</code></p>
<p>在 src/main 目录下新建一个与 java 同层级的 java-gen 目录，然后配置 Android 工程的 build.gradle(Module:app)，分别添加如下sourceSets。</p>
<pre><code>android {
    compileSdkVersion 23
    buildToolsVersion &quot;23.0.2&quot;

    defaultConfig {
        applicationId &quot;com.yuqirong.greendaodemo&quot;
        minSdkVersion 14
        targetSdkVersion 23
        versionCode 1
        versionName &quot;1.0&quot;
    }
    buildTypes {
        release {
            minifyEnabled false
            proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
        }
    }
    sourceSets {
        main {
            java.srcDirs = [&apos;src/main/java&apos;, &apos;src/main/java-gen&apos;]
        }
    }
}
</code></pre><p>然后在greendaogeneration中创建一个GreenDaoGeneration类，用于生成代码：</p>
<pre><code>public class GreenDaoGeneration {

    public static void main(String[] arg0) {

        try {
            Schema schema = new Schema(1, &quot;com.yuqirong.greendao&quot;);
            addLocation(schema);
            new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    public static void addLocation(Schema schema){
        Entity location= schema.addEntity(&quot;Location&quot;);
        location.addIdProperty();
        location.addDoubleProperty(&quot;lon&quot;);
        location.addIntProperty(&quot;level&quot;);
        location.addStringProperty(&quot;address&quot;);
        location.addStringProperty(&quot;city_name&quot;);
        location.addIntProperty(&quot;alevel&quot;);
        location.addDoubleProperty(&quot;lat&quot;);
    }
}
</code></pre><p>其中在创建Schema对象的参数中，第一个表示数据库的版本号，我们传入了“1”，第二个参数是生成代码的包名，我们传入了”com.yuqirong.greendao”，那么生成的代码就自动在”com.yuqirong.greendao”包下了。</p>
<p>在addLocatiion方法中，我们打算把“Location”这个类(其实到现在为止，Location实体类还未生成)保存在数据库中，<code>schema.addEntity(&quot;Location&quot;)</code>传入的Location，那么该表的表名就叫Location，然后我们又定义了在Location表中会有lon、lat、city_name三个字段。所以如果你想创建多张表，那么就要像addLocation()这样的方法多写几个。好了，该做的差不多都做了，最后再<code>new DaoGenerator().generateAll(schema, &quot;C:/Users/yuqirong/Desktop/GreenDaoDemo/app/src/main/java-gen&quot;);</code>把之前的schema传入，第二个参数传的是之前创建的java-gen的路径(建议传入绝对路径，之前在这里被坑了好久↖(~^~)↗)。代码运行之后再到”com.yuqirong.greendao”路径下去看，发现会有许多类生成：</p>
<p><img src="/uploads/20151124/20151124235609.png" alt="这里写图片描述"></p>
<p>至于这些类的作用，我们到下面再说。</p>
<p>第二步在Android Studio的build.gradle(Module:app)中添加以下依赖：</p>
<p><code>compile &#39;de.greenrobot:greendao:2.0.0&#39;</code>  </p>
<p>这样我们就可以在项目中使用greenDAO了。</p>
<p>在正式使用greenDAO前我们需要了解几个greenDAO中的类(也就是上面代码生成的几个类)：</p>
<ul>
<li><p>DaoMaster ：一看这个类名我们就知道这个类肯定是大总管级别的，DaoMaster继承自AbstractDaoMaster。在AbstractDaoMaster中保存了sqlitedatebase对象以及以Map的形式保存了各种操作DAO。DaoMaster还提供了一些创建和删除table的静态方法。另外在DaoMaster类里面有一个静态内部类DevOpenHelper，DevOpenHelper间接继承了SQLiteOpenHelper，通常我们会用<code>new DaoMaster.DevOpenHelper(this, &quot;notes-db&quot;, null)</code>来得到一个DevOpenHelper对象，第一个参数是Context，第二个参数是数据库名，第三个参数是CursorFactory，通常我们传入null。就上面这样简单的一句话你就实际上创建了一个SQLiteOpenHelper对象，而不需要输入<code>&quot;CREATE TABLE...&quot;</code> SQL语句，greenDAO已经帮你做好了一切。</p>
</li>
<li><p>DaoSession：会话层。主要功能就是操作具体的DAO对象，比如各种getXXXDao()方法。</p>
</li>
<li><p>XXXDao：实际生成的DAO类(即生成的LocationDao)，主要对应于某张表的CRUD，比如说LocationDao，那相对应就是对Location表的操作。</p>
</li>
<li><p>XXXEntity：主要是各个实体类(也就是上面生成的Location)，里面的属性与表中的字段相对应。比如上面的LocationDao，那么实体类就是Location，Location实体类中有lon，lat，city_name,alevel,level,address六个属性，那么在Location表中就有lon，lat，city_name,alevel,level,address六个字段。</p>
</li>
</ul>
<p>通过上面几个类作用的介绍，相信大家对greenDAO有了一个初步的印象，下面我们就要真枪实弹了，一起来看一个简单的Demo吧：</p>
<pre><code>DaoMaster.DevOpenHelper devOpenHelper = new DaoMaster.DevOpenHelper(context, &quot;location&quot;, null);
SQLiteDatabase writableDB = devOpenHelper.getWritableDatabase();
DaoMaster daoMaster = new DaoMaster(writableDB);
DaoSession daoSession = daoMaster.newSession();
</code></pre><p>上面的代码很简单，我们创建了一个名叫“location”的数据库，然后通过daoMaster得到了daoSession，有了daoSession，我们就可以得到各种xxxDao，之后的CRUD都是通过xxxDao来操作。</p>
<pre><code>LocationDao locationDao = daoSession.getLocationDao();
Location local = new Location(null,120.15507,2,&quot;&quot;,&quot;杭州市&quot;,4,30.27408);
locationDao.insert(local);
</code></pre><p>我们创建了一个Location的对象，然后调用<code>locationDao.insert()</code>方法就把local的数据插入到location的表中，是不是简单到难以让人置信?!只需要三行代码，而不再需要原生的ContentValues了。不得不感叹greenDAO太方便了。</p>
<p>除了添加数据的，greenDAO还提供删除数据的方法：<code>locationDao.deleteByKey(id);</code>id为当前要删除的那行的主键。</p>
<p>更新数据的方法：<code>locationDao.update(local);</code>local为新的数据。</p>
<p>查询数据的方法： </p>
<ul>
<li><code>locationDao.queryRaw(String where, String...selectionArg)</code>,可以看到greenDAO支持sql语句查询。</li>
<li><p>greenDAO还支持一种更为简单的查询方式，不再需要你去写sql语句(查询Location的lon大于120度和lat大于30度)： </p>
<pre><code>List&lt;Location&gt; list = locationDao.queryBuilder()
                        .where(LocationDao.Properties.Lat.gt(30d), LocationDao.Properties.Lon.gt(120d))
                        .build()
                        .list();
</code></pre></li>
</ul>
<p>好了，关于greenDAO的简单使用就先到这里，至于深入使用我们有机会再讲吧！</p>
<p>依据惯例，下面提供本Demo的源码:</p>
<p><a href="/uploads/20151124/GreenDaoDemo.rar">GreenDaoDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，我们都不可避免地要使用SQLite数据库来存储数据。但是Android提供给我们的API在操作数据库中并不简洁，而且更重要的一点是，在读取数据时无法把读到的字段直接映射成对象，需要我们手动去写代码↖(&gt;﹏&lt;)↗。于是在这种情况下，产生了许]]>
    </summary>
    
      <category term="greenDAO" scheme="http://yuqirong.me/tags/greenDAO/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[简单实现满屏表情下落的动画效果，你也可以]]></title>
    <link href="http://yuqirong.me/2015/11/12/%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%E6%BB%A1%E5%B1%8F%E8%A1%A8%E6%83%85%E4%B8%8B%E8%90%BD%E7%9A%84%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C%EF%BC%8C%E4%BD%A0%E4%B9%9F%E5%8F%AF%E4%BB%A5/"/>
    <id>http://yuqirong.me/2015/11/12/简单实现满屏表情下落的动画效果，你也可以/</id>
    <published>2015-11-12T14:39:14.000Z</published>
    <updated>2016-02-21T14:20:31.424Z</updated>
    <content type="html"><![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img src="/uploads/20151112/20151112224542.gif" alt="这里写图片描述"></p>
<p>看完上面的效果图，大家一定都迫不及待地想要试一试了，那就让我们来动手吧。</p>
<p>首先我们定义一个实体类DropLook:</p>
<pre><code>/**
 * 下落的表情
 */
public class DropLook {

    // x轴坐标
    private float x;
    // y轴坐标
    private float y;
    // 初始旋转角度
    private float rotation;
    // 下落速度
    private float speed;
    // 旋转速度
    private float rotationSpeed;
    // 宽度
    private int width;
    // 高度
    private int height;
    // 图片
    private Bitmap bitmap;

    public float getX() {
        return x;
    }

    public void setX(float x) {
        this.x = x;
    }

    public float getY() {
        return y;
    }

    public void setY(float y) {
        this.y = y;
    }

    public float getRotationSpeed() {
        return rotationSpeed;
    }

    public void setRotationSpeed(float rotationSpeed) {
        this.rotationSpeed = rotationSpeed;
    }

    public float getRotation() {
        return rotation;
    }

    public void setRotation(float rotation) {
        this.rotation = rotation;
    }

    public float getSpeed() {
        return speed;
    }

    public void setSpeed(float speed) {
        this.speed = speed;
    }

    public int getWidth() {
        return width;
    }

    public void setWidth(int width) {
        this.width = width;
    }

    public Bitmap getBitmap() {
        return bitmap;
    }

    public void setBitmap(Bitmap bitmap) {
        this.bitmap = bitmap;
    }

    public int getHeight() {
        return height;
    }

    public void setHeight(int height) {
        this.height = height;
    }

}
</code></pre><p>我们定义的实体类很简单，只是设置了如宽高、x，y坐标、下落速度等。接下来我们再创建一个DropLookFactory类，用来创建DropLook对象。</p>
<pre><code>public class DropLookFactory {

    private DropLookFactory() {

    }

    public static DropLook createDropLook(int width, int height,Bitmap originalBitmap) {
        DropLook look = new DropLook();
        if (originalBitmap == null) {
            throw new NullPointerException(&quot;originalBitmap cannot be null&quot;);
        }
        // 设置与图片等宽
        look.setWidth(originalBitmap.getWidth());
        // 设置与图片等高
        look.setHeight(originalBitmap.getHeight());
        // 设置起始位置的X坐标
        look.setX((float) Math.random() * (width - look.getWidth()));
        // 设置起始位置的Y坐标
        look.setY((float) Math.random() * (height - look.getHeight()));
        // 设置速度
        look.setSpeed(20 + (float) Math.random() * 40);
        // 设置初始旋转角度
        look.setRotation((float) Math.random() * 180 - 90);
        // 设置旋转速度
        look.setRotationSpeed((float) Math.random() * 90 - 60);
        // 设置图片
        look.setBitmap(originalBitmap);
        return look;
    }

}
</code></pre><p>其中<code>createDropLook(Context context, float xRange, Bitmap originalBitmap)</code>的第一个参数代表着下落表情在x轴上的范围，第二个参数代表在y轴上的范围，第三个参数是表情的图片。在createDropLook方法中相信大家都看得懂，主要就是用随机数初始化DropLook的坐标及下落速度等。</p>
<p>好了，下面就是今天的重头戏DropLookView，先来看看onMeasure(): </p>
<pre><code> @Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);
    if (widthMode == MeasureSpec.EXACTLY) {
        mWidth = widthSize;
    } else {
        mWidth = Tools.dip2px(getContext(),200);
    }
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);
    if (heightMode == MeasureSpec.EXACTLY) {
        mHeight = heightSize;
    } else {
        mHeight = Tools.dip2px(getContext(),200);
    }
    setMeasuredDimension(mWidth, mHeight);
    if (looks.size() == 0) {
        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
            looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
        }
        Log.i(TAG, &quot;num = &quot; + looks.size());
    }
}
</code></pre><p>onMeasure里主要是对View的测量，如果是<code>wrap_content</code>的话设置一个默认的宽高度200dp。然后就是初始化DropLook，looks是DropLook类的集合，用于管理DropLook。而<code>DEFAULT_LOOK_NUMS</code>是默认的looks集合的数量。</p>
<p>接下来就是最关键的onDraw():</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    super.onDraw(canvas);
    canvas.save();
    long nowTime = System.currentTimeMillis();
    if (nowTime - startTime &lt; 100) {
        try {
            Thread.sleep(100 + startTime - nowTime);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }

    for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

        DropLook look = looks.get(i);
        mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
        mMatrix.postRotate(look.getRotation());
        mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
        canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

        look.setY(look.getY() + look.getSpeed());
        if (look.getY() &gt; getHeight()) {
            look.setY((float) (0 - Math.random() * look.getHeight()));
        }

        look.setRotation(look.getRotation() + look.getRotationSpeed());
    }

    canvas.restore();
    startTime = System.currentTimeMillis();
    invalidate();
}
</code></pre><p>一开始判断时间间隔如果没有超过100ms，就让线程睡眠一会。然后就是用drawBitmap的方法把looks里面逐个绘制出来。并且再把look的y轴坐标加上下落速度等，旋转的角度也是如此。最后就是调用invalidate()不断地重绘。总体上并没有什么难点。</p>
<p>以下是DropLookView的完整代码：</p>
<pre><code>/**
 * 表情下落view
 */
public class DropLookView extends View {

    // 表情
    private Bitmap mBitmap;
    // 所有表情集合
    List&lt;DropLook&gt; looks = new ArrayList();
    // view开始时间
    private long startTime;
    // view宽度
    private int mWidth;
    // view高度
    private int mHeight;
    // 画笔
    private Paint mPaint;
    // 默认表情下落数
    private static final int DEFAULT_DROP_LOOK_NUMS = 35;

    private static final String TAG = &quot;DropLookView&quot;;

    private Matrix mMatrix = new Matrix();

    public DropLookView(Context context) {
        this(context, null);
    }

    public DropLookView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public DropLookView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        // 图片
        mBitmap = BitmapFactory.decodeResource(getResources(), R.drawable.d_5_xiaoku);
    }

    @Override
    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
        int widthSize = MeasureSpec.getSize(widthMeasureSpec);
        int widthMode = MeasureSpec.getMode(widthMeasureSpec);
        if (widthMode == MeasureSpec.EXACTLY) {
            mWidth = widthSize;
        } else {
            mWidth = Tools.dip2px(getContext(),200);
        }
        int heightSize = MeasureSpec.getSize(heightMeasureSpec);
        int heightMode = MeasureSpec.getMode(heightMeasureSpec);
        if (heightMode == MeasureSpec.EXACTLY) {
            mHeight = heightSize;
        } else {
            mHeight = Tools.dip2px(getContext(),200);
        }
        setMeasuredDimension(mWidth, mHeight);
        if (looks.size() == 0) {
            for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; ++i) {
                looks.add(DropLookFactory.createDropLook(mWidth, mHeight, mBitmap));
            }
            Log.i(TAG, &quot;num = &quot; + looks.size());
        }
    }

    @Override
    protected void onDraw(Canvas canvas) {
        super.onDraw(canvas);
        canvas.save();
        long nowTime = System.currentTimeMillis();
        if (nowTime - startTime &lt; 100) {
            try {
                Thread.sleep(100 + startTime - nowTime);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
        }

        for (int i = 0; i &lt; DEFAULT_DROP_LOOK_NUMS; i++) {

            DropLook look = looks.get(i);
            mMatrix.setTranslate(-look.getWidth() / 2, -look.getHeight() / 2);
            mMatrix.postRotate(look.getRotation());
            mMatrix.postTranslate(look.getWidth() / 2 + look.getX(), look.getHeight() / 2 + look.getY());
            canvas.drawBitmap(look.getBitmap(), mMatrix, mPaint);

            look.setY(look.getY() + look.getSpeed());
            if (look.getY() &gt; getHeight()) {
                look.setY((float) (0 - Math.random() * look.getHeight()));
            }

            look.setRotation(look.getRotation() + look.getRotationSpeed());
        }

        canvas.restore();
        startTime = System.currentTimeMillis();
        invalidate();
    }

}
</code></pre><p>该讲的也差不多讲完了，其实并没有想象中的那么有难度，实现起来也比较容易。当然DropLookView也有需要改进的地方。比如说可以在布局文件中自定义表情下落的数量等。这些就需要自己根据需求来更改了，那今天就先这样吧。</p>
<p>下面是本Demo的完整代码：<br><a href="/uploads/20151112/DropDownView.rar">DropLookView.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>首先我相信大家一定玩过微信吧。之前在玩微信的时候，给好友发一句“圣诞快乐”就会有满屏的圣诞树往下掉，当时觉得这个动画好酷。正好在公司的项目中需要用到这样的动画效果。于是写了一个小Demo,就有了这篇文章。</p>
<p>下图是做出的相关效果： </p>
<p><img sr]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[史上最简单粗暴实现侧滑菜单]]></title>
    <link href="http://yuqirong.me/2015/11/04/%E5%8F%B2%E4%B8%8A%E6%9C%80%E7%AE%80%E5%8D%95%E7%B2%97%E6%9A%B4%E5%AE%9E%E7%8E%B0%E4%BE%A7%E6%BB%91%E8%8F%9C%E5%8D%95/"/>
    <id>http://yuqirong.me/2015/11/04/史上最简单粗暴实现侧滑菜单/</id>
    <published>2015-11-04T12:47:16.000Z</published>
    <updated>2016-02-21T14:20:45.816Z</updated>
    <content type="html"><![CDATA[<p>在Android开发中，相信侧滑菜单大家都不陌生吧，几乎是每个app都必备的。从早期的 <a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="external">SlidingMenu</a> 再到           <a href="https://github.com/SpecialCyCi/AndroidResideMenu" target="_blank" rel="external">AndroidResideMenu</a> 最后到Android自带的DrawerLayout，无处不体现着侧滑菜单的诱人魅力。侧滑菜单可以拓展app的内容，充分利用手机屏幕，增加程序的可玩性。既然有这么多可供选择的侧滑菜单使用，那为什么我们还要自己写呢？我觉得我们在使用侧滑菜单的时候应该要懂得其中的原理，更好的，可以自己写一个侧滑菜单来加深体会。</p>
<p>好了，话不多说。来看看我们所谓“史上最简单粗暴实现的侧滑菜单”的产物吧：</p>
<p><img src="/uploads/20151104/20151104205135.gif" alt="这里写图片描述"></p>
<p>看完了上面的gif，想不想自己也写一个呢，那还等什么，一起来看看喽。</p>
<p>首先来说一下侧滑菜单实现的思路：侧滑菜单的布局为MenuLayout，还有主页的布局为MainLayout。MenuLayout在MainLayout的左边，当手指向右滑动的时候，MainLayout就向右滑动，同时MenuLayout跟着向右滑动，于是就显示出了侧滑菜单。以下是示意图：</p>
<p><img src="/uploads/20151104/20151104000149.png" alt="这里写图片描述"></p>
<p>大概地了解思路以后，我们先来看看布局文件。</p>
<p>layout_slidemenu.xml(侧滑菜单的布局)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;@drawable/menu_bg&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;ListView
        android:id=&quot;@+id/lv_menu&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:cacheColorHint=&quot;@null&quot; /&gt;
&lt;/LinearLayout&gt;
</code></pre><p>layout_activity_main.xml(主界面的布局)：</p>
<pre><code>&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot;
android:background=&quot;#55666666&quot;
android:orientation=&quot;vertical&quot; &gt;

    &lt;LinearLayout
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:background=&quot;@drawable/top_bar_bg&quot;
        android:gravity=&quot;center_vertical&quot; &gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_menu&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_margin=&quot;10dp&quot;
            android:layout_gravity=&quot;center_vertical&quot;
            android:background=&quot;@drawable/img_menu&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_marginLeft=&quot;15dp&quot;
            android:text=&quot;SlidingMenu&quot;
            android:layout_gravity=&quot;center_vertical&quot;
            android:textColor=&quot;#ffffff&quot;
            android:textSize=&quot;22sp&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>layout_main.xml(activity的布局)，注意，主界面的布局一定要放在菜单布局的后面：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
xmlns:tools=&quot;http://schemas.android.com/tools&quot;
android:layout_width=&quot;match_parent&quot;
android:layout_height=&quot;match_parent&quot; &gt;

    &lt;com.yuqirong.slidingmenu.view.SlidingMenu
        android:id=&quot;@+id/slideMenu1&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot; &gt;

        &lt;!-- 菜单界面的布局 --&gt;

        &lt;include layout=&quot;@layout/layout_slidemenu&quot; /&gt;

        &lt;!-- 主界面的布局 --&gt;

        &lt;include layout=&quot;@layout/layout_activity_main&quot; /&gt;
    &lt;/com.yuqirong.slidingmenu.view.SlidingMenu&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>看完了布局文件，下面我们就来看看代码(以下为部分代码，并非全部)：</p>
<pre><code>public class SlidingMenu extends FrameLayout {

    private ViewDragHelper mdDragHelper;

    public SlidingMenu(Context context) {
        this(context, null);
    }

    public SlidingMenu(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public SlidingMenu(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        mdDragHelper = ViewDragHelper.create(this, callback);
    }
}
</code></pre><p>我们创建一个类名叫SlidingMenu，继承自FrameLayout，然后重写构造器。在构造器中新建了一个ViewDragHelper的对象。如果你还不知道ViewDragHelper为何物，建议你去看看<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/46858663" target="_blank" rel="external">《Android ViewDragHelper完全解析 自定义ViewGroup神器》</a>，这里就不展开叙述了。在<code>ViewDragHelper.create(Context context,ViewDragHelper.Callback callback)</code>里我们传入了一个回调callback，那接下来就来看看这个callback：</p>
<pre><code> Callback callback = new Callback() {

    @Override
    public boolean tryCaptureView(View view, int arg1) {
        return true;
    }

    public int getViewHorizontalDragRange(View child) {
        return menuWidth;
    }

    @Override
    public int clampViewPositionHorizontal(View child, int left, int dx) {
        if (child == mainView) {
            if (left &lt; 0)
                return 0;
            else if (left &gt; menuWidth)
                return menuWidth;
            else
                return left;
        } else if (child == menuView) {
            if (left &gt; 0)
                return 0;
            else if (left &gt; menuWidth)
                return menuWidth;
            else
                return left;
        }
        return 0;
    }

    public void onViewPositionChanged(View changedView, int left, int top,
                                      int dx, int dy) {
        if (changedView == mainView)
            menuView.offsetLeftAndRight(dx);
        else
            mainView.offsetLeftAndRight(dx);
        invalidate();
    }

    ;

    public void onViewReleased(View releasedChild, float xvel, float yvel) {
        if (releasedChild == mainView) {
            if (status == Status.Open) {
                // 关闭侧滑菜单
                close();
                return;
            }
            if (xvel == 0
                    &amp;&amp; Math.abs(mainView.getLeft()) &gt; menuWidth / 2.0f) {
                // 打开侧滑菜单
                open();
            } else if (xvel &gt; 0) {
                open();
            } else {
                close();
            }
        } else {
            if (xvel == 0
                    &amp;&amp; Math.abs(mainView.getLeft()) &gt; menuWidth / 2.0f) {
                // 打开侧滑菜单
                open();
            }else if (xvel &gt; 0) {
                open();
            } else {
                // 关闭侧滑菜单
                close();
            }
        }
    }

};
</code></pre><p>我们发现在callback中几乎完成了绝大部分的逻辑。首先在<code>tryCaptureView(View view, int arg1)</code>直接返回了true，因为无论在mainView(主View)还是在menuView(菜单View)都应该去捕获，而<code>getViewHorizontalDragRange(View child)</code>返回的应该是menuView的宽度，也就是说滑动的时候最多能滑menuWidth的距离。而menuWidth是在<code>onFinishInflate()</code>中得到的。至于<code>clampViewPositionHorizontal(View child, int left, int dx)</code>和<code>onViewPositionChanged(View changedView, int left, int top,int dx, int dy)</code>两个方法逻辑很简单，相信大家都看得懂。最后在<code>onViewReleased(View releasedChild, float xvel, float yvel)</code>方法中判断了菜单打开或关闭的逻辑，比如在菜单关闭的情况下，只要手指向右滑或是停止滑动时侧滑菜单在屏幕中的宽度大于menuWidth/2这两种情况下，侧滑菜单都是执行open()方法，其它的情况以此类推。下面就来看看open()和close()方法。</p>
<pre><code>/**
 * 打开菜单
 */
public void open() {
    if (mdDragHelper.smoothSlideViewTo(mainView, menuWidth, 0)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
    preStatus = status;
    status = Status.Open;
    if (listener != null &amp;&amp; preStatus == Status.Close) {
        listener.statusChanged(status);
    }
}

/**
 * 关闭菜单
 */
public void close() {
    if (mdDragHelper.smoothSlideViewTo(mainView, 0, 0)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
    preStatus = status;
    status = Status.Close;
    if (listener != null &amp;&amp; preStatus == Status.Open) {
        listener.statusChanged(status);
    }
}

/**
 * 切换菜单状态
 */
public void toggle() {
    if (status == Status.Close) {
        open();
    } else {
        close();
    }
} 

@Override
public void computeScroll() {
    super.computeScroll();
    // 开始执行动画
    if (mdDragHelper.continueSettling(true)) {
        ViewCompat.postInvalidateOnAnimation(this);
    }
}
</code></pre><p>我们发现在<code>open()</code>和<code>close()</code>两个方法中都调用了<code>ViewCompat.postInvalidateOnAnimation(this);</code>而<code>postInvalidateOnAnimation(View view)</code>需要重写<code>computeScroll()</code>来实现平滑滚动的效果，一般的写法都如上代码所示，不需要改动。再重新回到<code>open()</code>和<code>close()</code>两个方法，其中的listener就是菜单开关状态的监听器，当状态改变的时候都会回调listener的<code>statusChanged(Status status)</code>方法。</p>
<p>最后的最后，别忘了在<code>onLayout(boolean changed, int left, int top, int right, int bottom)</code>中把menuView设置在mainView的左边。而menuView和mainView都是在<code>onFinishInflate()</code>中得到的。</p>
<pre><code>@Override
protected void onFinishInflate() {
    super.onFinishInflate();
    if(getChildCount()!=2){
        throw new IllegalArgumentException(&quot;子view的数量必须为2个&quot;);
    }
    menuView = getChildAt(0);
    mainView = getChildAt(1);
    menuWidth = menuView.getLayoutParams().width;
}

@Override
protected void onLayout(boolean changed, int left, int top, int right,
                        int bottom) {
    menuView.layout(-menuWidth, 0, 0, menuView.getMeasuredHeight());
    mainView.layout(0, 0, right, bottom);
}
</code></pre><p>好了，讲解了这么多，差不多把SlidingMenu的代码逻辑讲解完成了。如果有什么疑问，可以在下面留言。</p>
<p>国际惯例，下面贴出源码下载链接：</p>
<p><a href="/uploads/20151104/SlidingMenu.rar">SlidingMenu.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Android开发中，相信侧滑菜单大家都不陌生吧，几乎是每个app都必备的。从早期的 <a href="https://github.com/jfeinstein10/SlidingMenu" target="_blank" rel="external">SlidingM]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android onTouch事件传递机制解析]]></title>
    <link href="http://yuqirong.me/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2015/10/29/Android onTouch事件传递机制解析/</id>
    <published>2015-10-29T14:56:09.000Z</published>
    <updated>2016-02-21T14:20:08.513Z</updated>
    <content type="html"><![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事件传递的机制了，顺便写一篇博客来记录一下。下面就让我们来看看吧。</p>
<p>大家都知道一般我们使用的UI控件都是继承自共同的父类——View。所以View这个类应该掌管着onTouch事件的相关处理。那就让我们去看看：在View中寻找Touch相关的方法，其中一个很容易地引起了我们的注意：dispatchTouchEvent(MotionEvent event)。根据方法名的意思应该是负责分发触摸事件的，下面给出了源码：</p>
<pre><code>/**
 * Pass the touch screen motion event down to the target view, or this
 * view if it is the target.
 *
 * @param event The motion event to be dispatched.
 * @return True if the event was handled by the view, false otherwise.
 */
 public boolean dispatchTouchEvent(MotionEvent event) {
    // If the event should be handled by accessibility focus first.
    if (event.isTargetAccessibilityFocus()) {
        // We don&apos;t have focus or no virtual descendant has it, do not handle the event.
        if (!isAccessibilityFocusedViewOrHost()) {
            return false;
        }
        // We have focus and got the event, then use normal event dispatch.
        event.setTargetAccessibilityFocus(false);
    }

    boolean result = false;

    if (mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onTouchEvent(event, 0);
    }

    final int actionMasked = event.getActionMasked();
    if (actionMasked == MotionEvent.ACTION_DOWN) {
        // Defensive cleanup for new gesture
        stopNestedScroll();
    }

    if (onFilterTouchEventForSecurity(event)) {
        //noinspection SimplifiableIfStatement
        ListenerInfo li = mListenerInfo;
        if (li != null &amp;&amp; li.mOnTouchListener != null
                &amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED
                &amp;&amp; li.mOnTouchListener.onTouch(this, event)) {
            result = true;
        }

        if (!result &amp;&amp; onTouchEvent(event)) {
            result = true;
        }
    }

    if (!result &amp;&amp; mInputEventConsistencyVerifier != null) {
        mInputEventConsistencyVerifier.onUnhandledEvent(event, 0);
    }

    // Clean up after nested scrolls if this is the end of a gesture;
    // also cancel it if we tried an ACTION_DOWN but we didn&apos;t want the rest
    // of the gesture.
    if (actionMasked == MotionEvent.ACTION_UP ||
            actionMasked == MotionEvent.ACTION_CANCEL ||
            (actionMasked == MotionEvent.ACTION_DOWN &amp;&amp; !result)) {
        stopNestedScroll();
    }

    return result;
}
</code></pre><p>源码有点长，但我们不必每一行都看。首先注意到dispatchTouchEvent的返回值是boolean类型的，注释上的解释：<code>@return True if the event was handled by the view, false otherwise.</code>也就是说如果该触摸事件被这个View消费了就返回true，否则返回false。在方法中首先判断了该event是否是否得到了焦点，如果没有得到焦点直接返回false。然后让我们把目光转向<code>if (li != null &amp;&amp; li.mOnTouchListener != null&amp;&amp; (mViewFlags &amp; ENABLED_MASK) == ENABLED&amp;&amp; li.mOnTouchListener.onTouch(this, event))</code>这个片段，看到这里有一个名为li的局部变量，属于 ListenerInfo 类，经 mListenerInfo 赋值得到。ListenerInfo只是一个包装类，里面封装了大量的监听器。再在 View 类中去寻找 mListenerInfo ，可以看到下面的代码：</p>
<pre><code>  ListenerInfo getListenerInfo() {
    if (mListenerInfo != null) {
        return mListenerInfo;
    }
    mListenerInfo = new ListenerInfo();
    return mListenerInfo;
}
</code></pre><p>因此我们可以知道mListenerInfo是不为空的，所以li也不是空，第一个判断为true，然后看到li.mOnTouchListener，前面说过ListenerInfo是一个监听器的封装类，所以我们同样去追踪mOnTouchListener：</p>
<pre><code>/**
 * Register a callback to be invoked when a touch event is sent to this view.
 * @param l the touch listener to attach to this view
 */
public void setOnTouchListener(OnTouchListener l) {
    getListenerInfo().mOnTouchListener = l;
}
</code></pre><p>正是通过上面的方法来设置 mOnTouchListener 的，我想上面的方法大家肯定都很熟悉吧，正是我们平时经常用的 xxx.setOnTouchListener ，好了我们从中得知如果设置了OnTouchListener则第二个判断也为true，第三个判断为如果该View是否为enable，默认都是enable的，所以同样为true。还剩最后一个：<code>li.mOnTouchListener.onTouch(this, event)</code>，显然是回调了第二个判断中监听器的onTouch()方法，如果onTouch()方法返回true,则上面四个判断全部为true,dispatchTouchEvent()方法会返回true，并且不会执行<code>if (!result &amp;&amp; onTouchEvent(event))</code>这个判断；而在这个判断中我们又看到了一个熟悉的方法：onTouchEvent()。所以想要执行onTouchEvent，则在上面的四个判断中必须至少有一个false。</p>
<p>那就假定我们在onTouch()方法中返回的是false，这样就顺利地执行了onTouchEvent，那就看看onTouchEvent的源码吧：</p>
<pre><code>/**
 * Implement this method to handle touch screen motion events.
 * &lt;p&gt;
 * If this method is used to detect click actions, it is recommended that
 * the actions be performed by implementing and calling
 * {@link #performClick()}. This will ensure consistent system behavior,
 * including:
 * &lt;ul&gt;
 * &lt;li&gt;obeying click sound preferences
 * &lt;li&gt;dispatching OnClickListener calls
 * &lt;li&gt;handling {@link AccessibilityNodeInfo#ACTION_CLICK ACTION_CLICK} when
 * accessibility features are enabled
 * &lt;/ul&gt;
 *
 * @param event The motion event.
 * @return True if the event was handled, false otherwise.
 */
public boolean onTouchEvent(MotionEvent event) {
    final float x = event.getX();
    final float y = event.getY();
    final int viewFlags = mViewFlags;
    final int action = event.getAction();

    if ((viewFlags &amp; ENABLED_MASK) == DISABLED) {
        if (action == MotionEvent.ACTION_UP &amp;&amp; (mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
            setPressed(false);
        }
        // A disabled view that is clickable still consumes the touch
        // events, it just doesn&apos;t respond to them.
        return (((viewFlags &amp; CLICKABLE) == CLICKABLE
                || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE)
                || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE);
    }

    if (mTouchDelegate != null) {
        if (mTouchDelegate.onTouchEvent(event)) {
            return true;
        }
    }

    if (((viewFlags &amp; CLICKABLE) == CLICKABLE ||
            (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) ||
            (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE) {
        switch (action) {
            case MotionEvent.ACTION_UP:
                boolean prepressed = (mPrivateFlags &amp; PFLAG_PREPRESSED) != 0;
                if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0 || prepressed) {
                    // take focus if we don&apos;t have it already and we should in
                    // touch mode.
                    boolean focusTaken = false;
                    if (isFocusable() &amp;&amp; isFocusableInTouchMode() &amp;&amp; !isFocused()) {
                        focusTaken = requestFocus();
                    }

                    if (prepressed) {
                        // The button is being released before we actually
                        // showed it as pressed.  Make it show the pressed
                        // state now (before scheduling the click) to ensure
                        // the user sees it.
                        setPressed(true, x, y);
                   }

                    if (!mHasPerformedLongPress &amp;&amp; !mIgnoreNextUpEvent) {
                        // This is a tap, so remove the longpress check
                        removeLongPressCallback();

                        // Only perform take click actions if we were in the pressed state
                        if (!focusTaken) {
                            // Use a Runnable and post this rather than calling
                            // performClick directly. This lets other visual state
                            // of the view update before click actions start.
                            if (mPerformClick == null) {
                                mPerformClick = new PerformClick();
                            }
                            if (!post(mPerformClick)) {
                                performClick();
                            }
                        }
                    }

                    if (mUnsetPressedState == null) {
                        mUnsetPressedState = new UnsetPressedState();
                    }

                    if (prepressed) {
                        postDelayed(mUnsetPressedState,
                                ViewConfiguration.getPressedStateDuration());
                    } else if (!post(mUnsetPressedState)) {
                        // If the post failed, unpress right now
                        mUnsetPressedState.run();
                    }

                    removeTapCallback();
                }
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_DOWN:
                mHasPerformedLongPress = false;

                if (performButtonActionOnTouchDown(event)) {
                    break;
                }

                // Walk up the hierarchy to determine if we&apos;re inside a scrolling container.
                boolean isInScrollingContainer = isInScrollingContainer();

                // For views inside a scrolling container, delay the pressed feedback for
                // a short period in case this is a scroll.
                if (isInScrollingContainer) {
                    mPrivateFlags |= PFLAG_PREPRESSED;
                    if (mPendingCheckForTap == null) {
                        mPendingCheckForTap = new CheckForTap();
                    }
                    mPendingCheckForTap.x = event.getX();
                    mPendingCheckForTap.y = event.getY();
                    postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
                } else {
                    // Not inside a scrolling container, so show the feedback right away
                    setPressed(true, x, y);
                    checkForLongClick(0);
                }
                break;

            case MotionEvent.ACTION_CANCEL:
                setPressed(false);
                removeTapCallback();
                removeLongPressCallback();
                mInContextButtonPress = false;
                mHasPerformedLongPress = false;
                mIgnoreNextUpEvent = false;
                break;

            case MotionEvent.ACTION_MOVE:
                drawableHotspotChanged(x, y);

                // Be lenient about moving outside of buttons
                if (!pointInView(x, y, mTouchSlop)) {
                    // Outside button
                    removeTapCallback();
                    if ((mPrivateFlags &amp; PFLAG_PRESSED) != 0) {
                        // Remove any future long press/tap checks
                        removeLongPressCallback();

                        setPressed(false);
                    }
                }
                break;
        }

        return true;
    }

    return false;
}
</code></pre><p>这段源码比 dispatchTouchEvent 的还要长，不过同样我们挑重点的看：<br><code>if (((viewFlags &amp; CLICKABLE) == CLICKABLE || (viewFlags &amp; LONG_CLICKABLE) == LONG_CLICKABLE) || (viewFlags &amp; CONTEXT_CLICKABLE) == CONTEXT_CLICKABLE)</code><br>看到这句话就大概知道了主要是判断该view是否是可点击的，如果可以点击则接着执行，否则直接返回false。可以看到if里面用switch来判断是哪种触摸事件，但在最后都是返回true的。还有一点要注意：在 ACTION_UP 中会执行 performClick() 方法：</p>
<pre><code>public boolean performClick() {
    final boolean result;
    final ListenerInfo li = mListenerInfo;
    if (li != null &amp;&amp; li.mOnClickListener != null) {
        playSoundEffect(SoundEffectConstants.CLICK);
        li.mOnClickListener.onClick(this);
        result = true;
    } else {
        result = false;
    }

    sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_CLICKED);
    return result;
}
</code></pre><p>可以看到上面的<code>li.mOnClickListener.onClick(this);</code>，没错，我们好像又有了新的发现。根据上面的经验，这句代码会去回调我们设置好的点击事件监听器。也就是我们平常用的xxx.setOnClickListener(listener);</p>
<pre><code>/**
 * Register a callback to be invoked when this view is clicked. If this view is not
 * clickable, it becomes clickable.
 *
 * @param l The callback that will run
 *
 * @see #setClickable(boolean)
 */
public void setOnClickListener(@Nullable OnClickListener l) {
    if (!isClickable()) {
        setClickable(true);
    }
    getListenerInfo().mOnClickListener = l;
}
</code></pre><p>我们可以看到上面方法设置正是mListenerInfo的点击监听器，验证了上面的猜想。到了这里onTouch事件的传递机制基本已经分析完成了,也算是告一段落了。</p>
<p>好了，这下我们可以解决开头的问题了，顺便我们再来小结一下：在dispatchTouchEvent中，如果设置了OnTouchListener并且View是enable的，那么首先被执行的是OnTouchListener中的<code>onTouch(View v, MotionEvent event)</code>。若onTouch返回true,则dispatchTouchEvent不再往下执行并且返回true；不然会执行onTouchEvent，在onTouchEvent中若View是可点击的，则返回true，不然为false。还有在onTouchEvent中若View是可点击以及当前触摸事件为ACTION_UP，会执行performClick()，回调OnClickListener的onClick方法。下面是我画的一张草图：<br><img src="/uploads/20151029/20151029230937.png" alt="这里写图片描述"></p>
<p>还有一点值得注意的地方是：假如当前事件是ACTION_DOWN，只有dispatchTouchEvent返回true了之后该View才会接收到接下来的ACTION_MOVE,ACTION_UP事件，也就是说只有事件被消费了才能接收接下来的事件。</p>
<p>好了，今天就到这里了，如果有什么问题可以在下面留言。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>记得刚开始学习Android的时候，对于onTouch相关的事件一头雾水。分不清onTouch()，onTouchEvent()和OnClick()之间的关系和先后顺序，觉得有必要搞清onTouch事件传递的原理。经过一段时间的琢磨以及网上相关博客的介绍，总算是了解了触摸事]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
</feed>
