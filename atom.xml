<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2017-12-01T14:50:36.801Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[Vue.js安装教程]]></title>
    <link href="http://yuqirong.me/2017/12/01/Vue.js%E5%AE%89%E8%A3%85%E6%95%99%E7%A8%8B/"/>
    <id>http://yuqirong.me/2017/12/01/Vue.js安装教程/</id>
    <published>2017-11-30T16:29:14.000Z</published>
    <updated>2017-12-01T14:50:36.801Z</updated>
    <content type="html"><![CDATA[<h1 id="u5B89_u88C5_u6B65_u9AA4"><a href="#u5B89_u88C5_u6B65_u9AA4" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>安装 node.js (网址：<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a>)。</p>
</li>
<li><p>基于 node.js ,利用淘宝 npm 镜像安装相关依赖。在 cmd 里直接输入：<code>npm install -g cnpm –registry=https://registry.npm.taobao.org</code>，回车，等待安装。</p>
</li>
<li><p>安装全局 vue-cli 脚手架,用于帮助搭建所需的模板框架，在 cmd 里 </p>
<ol>
<li><p>输入：<code>cnpm install -g vue-cli</code>，回车，等待安装；</p>
</li>
<li><p>输入： vue ，回车，若出现 vue 信息说明表示成功。</p>
</li>
</ol>
</li>
<li><p>创建项目，在 cmd 里输入：<code>vue init webpack vue_test(项目文件夹名)</code> ，回车，等待一小会儿，依次出现下列选项，输入后创建成功。</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20171201/20171201223625.jpg" alt="create vue project"></p>
</li>
<li><p>安装依赖，在 cmd 里 </p>
<ol>
<li><p>输入：<code>cd vue_test</code> ，回车，进入到具体项目文件夹</p>
</li>
<li><p>输入：<code>npm install</code>，回车，等待一小会儿，安装依赖。</p>
</li>
</ol>
</li>
<li><p>测试环境是否搭建成功</p>
<ol>
<li><p>在 cmd 里输入：<code>npm run dev</code></p>
</li>
<li><p>在浏览里输入：localhost:8080(默认端口为8080)</p>
<p>运行起来后的效果如下图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20171201/20171201223752.jpg" alt="Vue running"></p>
</li>
</ol>
</li>
</ol>
<h1 id="u5B89_u88C5_u4E2D_u9047_u5230_u7684_u95EE_u9898"><a href="#u5B89_u88C5_u4E2D_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="安装中遇到的问题"></a>安装中遇到的问题</h1><h2 id="vue_init_webpack_vue_test"><a href="#vue_init_webpack_vue_test" class="headerlink" title="vue init webpack vue_test"></a>vue init webpack vue_test</h2><pre><code>C:\Users\h\Desktop&gt;vue init webpack vue_test
C:\Users\h\AppData\Roaming\npm\node_modules\vue-cli\bin\vue-init:60
let template = program.args[0]
^^^

SyntaxError: Block-scoped declarations (let, const, function, class) not yet sup
ported outside strict mode
    at exports.runInThisContext (vm.js:54:16)
    at Module._compile (module.js:375:25)
    at Object.Module._extensions..js (module.js:406:10)
    at Module.load (module.js:345:32)
    at Function.Module._load (module.js:302:12)
    at Function.Module.runMain (module.js:431:10)
    at startup (node.js:141:18)
    at node.js:977:3
</code></pre><p>nodejs版本太低，去官网更新即可。</p>
<h2 id="npm_install"><a href="#npm_install" class="headerlink" title="npm install"></a>npm install</h2><pre><code>C:\Users\h\Desktop\vue_test&gt;npm install

&gt; chromedriver@2.33.2 install C:\Users\h\Desktop\vue_test\node_modules\chromedri
ver
&gt; node install.js

Downloading https://chromedriver.storage.googleapis.com/2.33/chromedriver_win32.
zip
Saving to C:\Users\h\AppData\Local\Temp\chromedriver\chromedriver_win32.zip
ChromeDriver installation failed Error with http(s) request: Error: connect ETIM
EDOUT 172.217.160.112:443
npm WARN optional SKIPPING OPTIONAL DEPENDENCY: fsevents@1.1.3 (node_modules\fse
vents):
npm WARN notsup SKIPPING OPTIONAL DEPENDENCY: Unsupported platform for fsevents@
1.1.3: wanted {&quot;os&quot;:&quot;darwin&quot;,&quot;arch&quot;:&quot;any&quot;} (current: {&quot;os&quot;:&quot;win32&quot;,&quot;arch&quot;:&quot;x64&quot;}
)

npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! chromedriver@2.33.2 install: `node install.js`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the chromedriver@2.33.2 install script.
npm ERR! This is probably not a problem with npm. There is likely additional log
ging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\h\AppData\Roaming\npm-cache\_logs\2017-11-25T07_25_19_228Z
-debug.log
</code></pre><p>因为 chromedriver 被墙了，所以需要输入命令 <code>cnpm install chromedriver</code> ，安装 chromedriver 。</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5B89_u88C5_u6B65_u9AA4"><a href="#u5B89_u88C5_u6B65_u9AA4" class="headerlink" title="安装步骤"></a>安装步骤</h1><ol>
<li><p>安装 node.js (网址：]]>
    </summary>
    
      <category term="Vue.js" scheme="http://yuqirong.me/tags/Vue-js/"/>
    
      <category term="Vue.js" scheme="http://yuqirong.me/categories/Vue-js/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[VirtualAPK源码解析]]></title>
    <link href="http://yuqirong.me/2017/11/12/VirtualAPK%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/11/12/VirtualAPK源码解析/</id>
    <published>2017-11-12T14:03:58.000Z</published>
    <updated>2017-11-12T15:34:52.817Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>VirtualAPK 是滴滴开源的一款 Android 插件化的框架。</p>
<p>现在市面上，成熟的插件化框架已经挺多了，那为什么还要重新开发一款轮子呢？</p>
<ol>
<li>大部分开源框架所支持的功能还不够全面</li>
<li>兼容性问题严重，大部分开源方案不够健壮</li>
<li>已有的开源方案不适合滴滴的业务场景</li>
</ol>
<p>在加载耦合插件方面，VirtualAPK是开源方案的首选。</p>
<p>以上是滴滴给出的官方解释。</p>
<p>对于我们开发者来说，这种当然是好事。第一，我们选择插件化框架的余地变多了；第二，我们也可以多学习学习框架内部实现的原理，一举两得。</p>
<p>那就不说废话了，一起来看。</p>
<h1 id="u4F7F_u7528_u65B9_u6CD5"><a href="#u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="使用方法"></a>使用方法</h1><p>使用方法直接抄 GitHub 上的，就将就着看吧。</p>
<ul>
<li><p>第一步： 初始化插件引擎</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">attachBaseContext</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.attachBaseContext(base);</span><br><span class="line">    PluginManager.getInstance(base).init();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>第二步：加载插件</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PluginManager</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">loadPlugin</span><span class="params">(File apk)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  当插件入口被调用后，插件的后续逻辑均不需要宿主干预，均走原生的Android流程。 比如，在插件内部，如下代码将正确执行：</p>
  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.activity_book_manager);</span><br><span class="line">    LinearLayout holder = (LinearLayout)findViewById(R.id.holder);</span><br><span class="line">    TextView imei = (TextView)findViewById(R.id.imei);</span><br><span class="line">    imei.setText(IDUtil.getUUID(<span class="keyword">this</span>));</span><br><span class="line">     </span><br><span class="line">    <span class="comment">// bind service in plugin</span></span><br><span class="line">    Intent service = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, BookManagerService.class);</span><br><span class="line">    bindService(service, mConnection, Context.BIND_AUTO_CREATE);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// start activity in plugin</span></span><br><span class="line">    Intent intent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>, TCPClientActivity.class);</span><br><span class="line">    startActivity(intent);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h1 id="u6E90_u7801_u89E3_u6790"><a href="#u6E90_u7801_u89E3_u6790" class="headerlink" title="源码解析"></a>源码解析</h1><p>使用方法很简单，下面就顺着上面的代码一步步去探究实现原理。</p>
<h2 id="u521D_u59CB_u5316_u63D2_u4EF6_u6846_u67B6"><a href="#u521D_u59CB_u5316_u63D2_u4EF6_u6846_u67B6" class="headerlink" title="初始化插件框架"></a>初始化插件框架</h2><p>第一步就是初始化框架：<code>PluginManager.getInstance(base).init();</code></p>
<h3 id="PluginManager-getInstance_28Context_base_29"><a href="#PluginManager-getInstance_28Context_base_29" class="headerlink" title="PluginManager.getInstance(Context base)"></a>PluginManager.getInstance(Context base)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> PluginManager <span class="title">getInstance</span><span class="params">(Context base)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (PluginManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>)</span><br><span class="line">                sInstance = <span class="keyword">new</span> PluginManager(base);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">PluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Context app = context.getApplicationContext();</span><br><span class="line">    <span class="keyword">if</span> (app == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = context;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">this</span>.mContext = ((Application)app).getBaseContext();</span><br><span class="line">    &#125;</span><br><span class="line">    prepare();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>PluginManager 设计为了单例模式，负责管理插件的一些操作。</p>
<p>在初始化的时候，得到全局 Context ，以防出现内存泄漏的情况。</p>
<p>之后调用了 <code>prepare()</code> 方法，做一些预备操作。</p>
<h3 id="prepare_28_29"><a href="#prepare_28_29" class="headerlink" title="prepare()"></a>prepare()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">prepare</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// host base context</span></span><br><span class="line">      Systems.sHostContext = getHostContext();</span><br><span class="line"><span class="comment">// hook instrumentation</span></span><br><span class="line">      <span class="keyword">this</span>.hookInstrumentationAndHandler();</span><br><span class="line">      <span class="keyword">this</span>.hookSystemServices();</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>prepare()</code> 中，将宿主 Context 赋值给了 Systems.sHostContext 。这样，在之后的代码中可以方便地访问到宿主 Context 。</p>
<p>然后分为了两步操作，hookInstrumentationAndHandler 和 hookSystemServices 。为运行插件做一些必要的 hook 操作。</p>
<h3 id="hookInstrumentationAndHandler_28_29"><a href="#hookInstrumentationAndHandler_28_29" class="headerlink" title="hookInstrumentationAndHandler()"></a>hookInstrumentationAndHandler()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">hookInstrumentationAndHandler</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Instrumentation baseInstrumentation = ReflectUtil.getInstrumentation(<span class="keyword">this</span>.mContext);</span><br><span class="line">        <span class="keyword">if</span> (baseInstrumentation.getClass().getName().contains(<span class="string">"lbe"</span>)) &#123;</span><br><span class="line">            <span class="comment">// reject executing in paralell space, for example, lbe.</span></span><br><span class="line">            System.exit(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建插件的 instrumentation</span></span><br><span class="line">        <span class="keyword">final</span> VAInstrumentation instrumentation = <span class="keyword">new</span> VAInstrumentation(<span class="keyword">this</span>, baseInstrumentation);</span><br><span class="line">        Object activityThread = ReflectUtil.getActivityThread(<span class="keyword">this</span>.mContext);</span><br><span class="line">        <span class="comment">// 将插件的 instrumentation 设置到当前的 activityThread 中</span></span><br><span class="line">        ReflectUtil.setInstrumentation(activityThread, instrumentation);</span><br><span class="line">        <span class="comment">// 给 mainThreadHandler 设置 callback</span></span><br><span class="line">        ReflectUtil.setHandlerCallback(<span class="keyword">this</span>.mContext, instrumentation);</span><br><span class="line">        <span class="keyword">this</span>.mInstrumentation = instrumentation;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="hookSystemServices_28_29"><a href="#hookSystemServices_28_29" class="headerlink" title="hookSystemServices()"></a>hookSystemServices()</h2><pre><code>private void hookSystemServices() {
    try {
        // 得到当前系统中的 ActivityManager 单例
        Singleton&lt;IActivityManager&gt; defaultSingleton = (Singleton&lt;IActivityManager&gt;) ReflectUtil.getField(ActivityManagerNative.class, null, &quot;gDefault&quot;);
        // 创建 ActivityManager 的动态代理 
        IActivityManager activityManagerProxy = ActivityManagerProxy.newInstance(this, defaultSingleton.get());

        // Hook IActivityManager from ActivityManagerNative  利用反射将系统的 ActivityManager 单例替换为 activityManagerProxy 
        ReflectUtil.setField(defaultSingleton.getClass().getSuperclass(), defaultSingleton, &quot;mInstance&quot;, activityManagerProxy);

        if (defaultSingleton.get() == activityManagerProxy) {
            this.mActivityManager = activityManagerProxy;
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h2 id="init_28_29"><a href="#init_28_29" class="headerlink" title="init()"></a>init()</h2><pre><code>public void init() {
    // ComponentsHandler 感觉像是插件中四大组件的管理者
    mComponentsHandler = new ComponentsHandler(this);
    // 用的是 asynctask 的线程池
    RunUtil.getThreadPool().execute(new Runnable() {
        @Override
        public void run() {
            // 空方法，给之后的东西，万一有什么需要初始化的
            doInWorkThread();
        }
    });
}

private void doInWorkThread() {
}
</code></pre><h1 id="u52A0_u8F7D_u63D2_u4EF6"><a href="#u52A0_u8F7D_u63D2_u4EF6" class="headerlink" title="加载插件"></a>加载插件</h1><p>load plugin apk ：</p>
<pre><code>PluginManager.getInstance(base).loadPlugin(apk);
</code></pre><h2 id="loadPlugin_28File_apk_29"><a href="#loadPlugin_28File_apk_29" class="headerlink" title="loadPlugin(File apk)"></a>loadPlugin(File apk)</h2><pre><code>public void loadPlugin(File apk) throws Exception {
    if (null == apk) {
        throw new IllegalArgumentException(&quot;error : apk is null.&quot;);
    }

    if (!apk.exists()) {
        throw new FileNotFoundException(apk.getAbsolutePath());
    }

    LoadedPlugin plugin = LoadedPlugin.create(this, this.mContext, apk);
    if (null != plugin) {
        this.mPlugins.put(plugin.getPackageName(), plugin);
        // 创建插件中的 application
        plugin.invokeApplication();
    } else {
        throw  new RuntimeException(&quot;Can&apos;t load plugin which is invalid: &quot; + apk.getAbsolutePath());
    }
}
</code></pre><h2 id="LoadedPlugin"><a href="#LoadedPlugin" class="headerlink" title="LoadedPlugin"></a>LoadedPlugin</h2><h3 id="PackageParserCompat-parsePackage"><a href="#PackageParserCompat-parsePackage" class="headerlink" title="PackageParserCompat.parsePackage"></a>PackageParserCompat.parsePackage</h3><pre><code>public static final PackageParser.Package parsePackage(final Context context, final File apk, final int flags) throws PackageParser.PackageParserException {
    if (Build.VERSION.SDK_INT &gt;= 24) {
        return PackageParserV24.parsePackage(context, apk, flags);
    } else if (Build.VERSION.SDK_INT &gt;= 21) {
        return PackageParserLollipop.parsePackage(context, apk, flags);
    } else {
        return PackageParserLegacy.parsePackage(context, apk, flags);
    }
}
</code></pre><h3 id="new_PackageInfo_28_29"><a href="#new_PackageInfo_28_29" class="headerlink" title="new PackageInfo()"></a>new PackageInfo()</h3><pre><code>this.mPackageInfo = new PackageInfo();
this.mPackageInfo.applicationInfo = this.mPackage.applicationInfo;
this.mPackageInfo.applicationInfo.sourceDir = apk.getAbsolutePath();
this.mPackageInfo.signatures = this.mPackage.mSignatures;
this.mPackageInfo.packageName = this.mPackage.packageName;
if (pluginManager.getLoadedPlugin(mPackageInfo.packageName) != null) {
    throw new RuntimeException(&quot;plugin has already been loaded : &quot; + mPackageInfo.packageName);
}
this.mPackageInfo.versionCode = this.mPackage.mVersionCode;
this.mPackageInfo.versionName = this.mPackage.mVersionName;
this.mPackageInfo.permissions = new PermissionInfo[0];
</code></pre><h3 id="createResources_28context_2C_apk_29"><a href="#createResources_28context_2C_apk_29" class="headerlink" title="createResources(context, apk)"></a>createResources(context, apk)</h3><pre><code>@WorkerThread
private static Resources createResources(Context context, File apk) {
    if (Constants.COMBINE_RESOURCES) {
        //如果插件资源合并到宿主里面去的情况，插件可以访问宿主的资源
        Resources resources = new ResourcesManager().createResources(context, apk.getAbsolutePath());
        // hook resource
        ResourcesManager.hookResources(context, resources);
        return resources;
    } else {
        //插件使用独立的Resources，不与宿主有关系，无法访问到宿主的资源
        Resources hostResources = context.getResources();
        // 利用 addAssetPath 来创建 assetManager
        AssetManager assetManager = createAssetManager(context, apk);
        // 创建 Resources
        return new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
    }
}
</code></pre><h2 id="createResources_28Context_hostContext_2C_String_apk_29"><a href="#createResources_28Context_hostContext_2C_String_apk_29" class="headerlink" title="createResources(Context hostContext, String apk)"></a>createResources(Context hostContext, String apk)</h2><pre><code>public static synchronized Resources createResources(Context hostContext, String apk) {
    Resources hostResources = hostContext.getResources();
    Resources newResources = null;
    AssetManager assetManager;
    try {
        if (Build.VERSION.SDK_INT &lt; Build.VERSION_CODES.LOLLIPOP) {
            // 在Android 5.0 之前，addAssetPath 只是把 apk 路径加入到资源路径列表里
            // 但是资源的解析其实是在很早的时候就已经执行完了
            // 所以重新构造一个新的 AssetManager，再 hook resource 替换系统的 mResource
            assetManager = AssetManager.class.newInstance();
            ReflectUtil.invoke(AssetManager.class, assetManager, &quot;addAssetPath&quot;, hostContext.getApplicationInfo().sourceDir);
        } else {
            // Android 5.0 资源做过分区，直接获取宿主的 assetManager
            assetManager = hostResources.getAssets();
        }
        // 将当前插件的资源路径加入到 assetManager 中
        ReflectUtil.invoke(AssetManager.class, assetManager, &quot;addAssetPath&quot;, apk);
        // 获取之前加载完毕的插件，得到它们的 apk 路径再重新添加到 assetManager 中
        // 是否在 Android 5.0 及以上不需要此步骤？
        List&lt;LoadedPlugin&gt; pluginList = PluginManager.getInstance(hostContext).getAllLoadedPlugins();
        for (LoadedPlugin plugin : pluginList) {
            ReflectUtil.invoke(AssetManager.class, assetManager, &quot;addAssetPath&quot;, plugin.getLocation());
        }
        // 对一些安卓厂商做兼容性处理，Resources 的类名各不同
        // 创建 resource
        if (isMiUi(hostResources)) {
            newResources = MiUiResourcesCompat.createResources(hostResources, assetManager);
        } else if (isVivo(hostResources)) {
            newResources = VivoResourcesCompat.createResources(hostContext, hostResources, assetManager);
        } else if (isNubia(hostResources)) {
            newResources = NubiaResourcesCompat.createResources(hostResources, assetManager);
        } else if (isNotRawResources(hostResources)) {
            newResources = AdaptationResourcesCompat.createResources(hostResources, assetManager);
        } else {
            // is raw android resources
            newResources = new Resources(assetManager, hostResources.getDisplayMetrics(), hostResources.getConfiguration());
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
    return newResources;
}
</code></pre><h2 id="hookResources_28Context_base_2C_Resources_resources_29"><a href="#hookResources_28Context_base_2C_Resources_resources_29" class="headerlink" title="hookResources(Context base, Resources resources)"></a>hookResources(Context base, Resources resources)</h2><pre><code>public static void hookResources(Context base, Resources resources) {
    if (Build.VERSION.SDK_INT &gt;= 24) {
        return;
    }

    try {
        // 替换 hostContext 中的 mResources
        ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, resources);
        // 替换 packageInfo 中的 mResources
        Object loadedApk = ReflectUtil.getPackageInfo(base);
        ReflectUtil.setField(loadedApk.getClass(), loadedApk, &quot;mResources&quot;, resources);
        // 将 resource 放入 mActiveResources 中
        Object activityThread = ReflectUtil.getActivityThread(base);
        Object resManager = ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mResourcesManager&quot;);
        Map&lt;Object, WeakReference&lt;Resources&gt;&gt; map = (Map&lt;Object, WeakReference&lt;Resources&gt;&gt;) ReflectUtil.getField(resManager.getClass(), resManager, &quot;mActiveResources&quot;);
        Object key = map.keySet().iterator().next();
        map.put(key, new WeakReference&lt;&gt;(resources));
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h3 id="createClassLoader_28Context_context_2C_File_apk_2C_File_libsDir_2C_ClassLoader_parent_29"><a href="#createClassLoader_28Context_context_2C_File_apk_2C_File_libsDir_2C_ClassLoader_parent_29" class="headerlink" title="createClassLoader(Context context, File apk, File libsDir, ClassLoader parent)"></a>createClassLoader(Context context, File apk, File libsDir, ClassLoader parent)</h3><pre><code>private static ClassLoader createClassLoader(Context context, File apk, File libsDir, ClassLoader parent) {
    // create classloader
    File dexOutputDir = context.getDir(Constants.OPTIMIZE_DIR, Context.MODE_PRIVATE);
    String dexOutputPath = dexOutputDir.getAbsolutePath();
    DexClassLoader loader = new DexClassLoader(apk.getAbsolutePath(), dexOutputPath, libsDir.getAbsolutePath(), parent);
    // 如果合并，就会把宿主的 classloader 中的 dex 加入到插件中的 classloader
    if (Constants.COMBINE_CLASSLOADER) {
        try {
            DexUtil.insertDex(loader);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
    return loader;
}
</code></pre><h3 id="tryToCopyNativeLib_28apk_29_3B"><a href="#tryToCopyNativeLib_28apk_29_3B" class="headerlink" title="tryToCopyNativeLib(apk);"></a>tryToCopyNativeLib(apk);</h3><p>复制 .so 文件</p>
<h3 id="Cache_instrumentations"><a href="#Cache_instrumentations" class="headerlink" title="Cache instrumentations"></a>Cache instrumentations</h3><pre><code>Map&lt;ComponentName, InstrumentationInfo&gt; instrumentations = new HashMap&lt;ComponentName, InstrumentationInfo&gt;();
for (PackageParser.Instrumentation instrumentation : this.mPackage.instrumentation) {
    instrumentations.put(instrumentation.getComponentName(), instrumentation.info);
}
this.mInstrumentationInfos = Collections.unmodifiableMap(instrumentations);
this.mPackageInfo.instrumentation = instrumentations.values().toArray(new InstrumentationInfo[instrumentations.size()]);
</code></pre><h3 id="Cache_activities"><a href="#Cache_activities" class="headerlink" title="Cache activities"></a>Cache activities</h3><pre><code>Map&lt;ComponentName, ActivityInfo&gt; activityInfos = new HashMap&lt;ComponentName, ActivityInfo&gt;();
for (PackageParser.Activity activity : this.mPackage.activities) {
    activityInfos.put(activity.getComponentName(), activity.info);
}
this.mActivityInfos = Collections.unmodifiableMap(activityInfos);
this.mPackageInfo.activities = activityInfos.values().toArray(new ActivityInfo[activityInfos.size()]);
</code></pre><h3 id="Cache_providers"><a href="#Cache_providers" class="headerlink" title="Cache providers"></a>Cache providers</h3><pre><code>Map&lt;String, ProviderInfo&gt; providers = new HashMap&lt;String, ProviderInfo&gt;();
Map&lt;ComponentName, ProviderInfo&gt; providerInfos = new HashMap&lt;ComponentName, ProviderInfo&gt;();
for (PackageParser.Provider provider : this.mPackage.providers) {
    providers.put(provider.info.authority, provider.info);
    providerInfos.put(provider.getComponentName(), provider.info);
}
this.mProviders = Collections.unmodifiableMap(providers);
this.mProviderInfos = Collections.unmodifiableMap(providerInfos);
this.mPackageInfo.providers = providerInfos.values().toArray(new ProviderInfo[providerInfos.size()]);
</code></pre><h3 id="Register_broadcast_receivers_dynamically"><a href="#Register_broadcast_receivers_dynamically" class="headerlink" title="Register broadcast receivers dynamically"></a>Register broadcast receivers dynamically</h3><pre><code>Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();
for (PackageParser.Activity receiver : this.mPackage.receivers) {
    receivers.put(receiver.getComponentName(), receiver.info);

    try {
        // 得到插件中的 BroadcastReceiver 的实例
        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());
        // 注册广播
        for (PackageParser.ActivityIntentInfo aii : receiver.intents) {
            this.mHostContext.registerReceiver(br, aii);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
this.mReceiverInfos = Collections.unmodifiableMap(receivers);
this.mPackageInfo.receivers = receivers.values().toArray(new ActivityInfo[receivers.size()]);
</code></pre><h1 id="u63D2_u4EF6Activity_u52A0_u8F7D_u8FC7_u7A0B"><a href="#u63D2_u4EF6Activity_u52A0_u8F7D_u8FC7_u7A0B" class="headerlink" title="插件Activity加载过程"></a>插件Activity加载过程</h1><h1 id="VAInstrumentation"><a href="#VAInstrumentation" class="headerlink" title="VAInstrumentation"></a>VAInstrumentation</h1><h2 id="execStartActivity"><a href="#execStartActivity" class="headerlink" title="execStartActivity"></a>execStartActivity</h2><pre><code>public ActivityResult execStartActivity(
        Context who, IBinder contextThread, IBinder token, Activity target,
        Intent intent, int requestCode, Bundle options) {
    // 这个主要是当component为null时，根据启动Activity时，配置的action，data,category等去已加载的plugin中匹配到确定的Activity的。
    mPluginManager.getComponentsHandler().transformIntentToExplicitAsNeeded(intent);
    // null component is an implicitly intent
    if (intent.getComponent() != null) {
        Log.i(TAG, String.format(&quot;execStartActivity[%s : %s]&quot;, intent.getComponent().getPackageName(),
                intent.getComponent().getClassName()));
        // 先将 intent 中的 packagename 和 classname 替换为 Stub Activity
        this.mPluginManager.getComponentsHandler().markIntentIfNeeded(intent);
    }
    // 利用反射去执行原来的 execStartActivity 方法
    ActivityResult result = realExecStartActivity(who, contextThread, token, target,
                intent, requestCode, options);

    return result;

}
</code></pre><h2 id="ComponentsHandler"><a href="#ComponentsHandler" class="headerlink" title="ComponentsHandler"></a>ComponentsHandler</h2><h2 id="transformIntentToExplicitAsNeeded"><a href="#transformIntentToExplicitAsNeeded" class="headerlink" title="transformIntentToExplicitAsNeeded"></a>transformIntentToExplicitAsNeeded</h2><pre><code>public Intent transformIntentToExplicitAsNeeded(Intent intent) {
    ComponentName component = intent.getComponent();
    if (component == null) {
        ResolveInfo info = mPluginManager.resolveActivity(intent);
        if (info != null &amp;&amp; info.activityInfo != null) {
            component = new ComponentName(info.activityInfo.packageName, info.activityInfo.name);
            intent.setComponent(component);
        }
    }

    return intent;
}
</code></pre><h2 id="markIntentIfNeeded"><a href="#markIntentIfNeeded" class="headerlink" title="markIntentIfNeeded"></a>markIntentIfNeeded</h2><pre><code>public void markIntentIfNeeded(Intent intent) {
    if (intent.getComponent() == null) {
        return;
    }
    String targetPackageName = intent.getComponent().getPackageName();
    String targetClassName = intent.getComponent().getClassName();
    // search map and return specific launchmode stub activity
    // 先将目标的 packagename 和 classname 保存好，之后以便恢复的
    if (!targetPackageName.equals(mContext.getPackageName()) &amp;&amp; mPluginManager.getLoadedPlugin(targetPackageName) != null) {
        intent.putExtra(Constants.KEY_IS_PLUGIN, true);
        intent.putExtra(Constants.KEY_TARGET_PACKAGE, targetPackageName);
        intent.putExtra(Constants.KEY_TARGET_ACTIVITY, targetClassName);
        // 根据 launchMode 、theme 查找对应类型的 stub activity
        // 并将 intent 中的目标 activity 替换为 stub activity
        dispatchStubActivity(intent);
    }
}
</code></pre><h1 id="VAInstrumentation-1"><a href="#VAInstrumentation-1" class="headerlink" title="VAInstrumentation"></a>VAInstrumentation</h1><h2 id="newActivity"><a href="#newActivity" class="headerlink" title="newActivity"></a>newActivity</h2><pre><code>@Override
public Activity newActivity(ClassLoader cl, String className, Intent intent) throws InstantiationException, IllegalAccessException, ClassNotFoundException {
    try {
        cl.loadClass(className);
    } catch (ClassNotFoundException e) {
        // 若出错则说明要启动的是插件里面的classname
        LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
        String targetClassName = PluginUtil.getTargetActivity(intent);

        Log.i(TAG, String.format(&quot;newActivity[%s : %s]&quot;, className, targetClassName));

        if (targetClassName != null) {
            Activity activity = mBase.newActivity(plugin.getClassLoader(), targetClassName, intent);
            activity.setIntent(intent);

            try {
                // for 4.1+  设置好 resource
                ReflectUtil.setField(ContextThemeWrapper.class, activity, &quot;mResources&quot;, plugin.getResources());
            } catch (Exception ignored) {
                // ignored.
            }

            return activity;
        }
    }
    // 启动的不是插件中的activity就使用原来的
    return mBase.newActivity(cl, className, intent);
}
</code></pre><h2 id="callActivityOnCreate"><a href="#callActivityOnCreate" class="headerlink" title="callActivityOnCreate"></a>callActivityOnCreate</h2><pre><code>@Override
public void callActivityOnCreate(Activity activity, Bundle icicle) {
    final Intent intent = activity.getIntent();
    // 根据 KEY_IS_PLUGIN 来判断是否是启动插件 activity
    if (PluginUtil.isIntentFromPlugin(intent)) {
        Context base = activity.getBaseContext();
        try {
            // 将创建出来的插件 activity 中 mResources mBase mApplication 进行替换
            LoadedPlugin plugin = this.mPluginManager.getLoadedPlugin(intent);
            ReflectUtil.setField(base.getClass(), base, &quot;mResources&quot;, plugin.getResources());
            ReflectUtil.setField(ContextWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());
            ReflectUtil.setField(Activity.class, activity, &quot;mApplication&quot;, plugin.getApplication());
            ReflectUtil.setFieldNoException(ContextThemeWrapper.class, activity, &quot;mBase&quot;, plugin.getPluginContext());

            // set screenOrientation 设置屏幕方向
            ActivityInfo activityInfo = plugin.getActivityInfo(PluginUtil.getComponent(intent));
            if (activityInfo.screenOrientation != ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED) {
                activity.setRequestedOrientation(activityInfo.screenOrientation);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    mBase.callActivityOnCreate(activity, icicle);
}
</code></pre><h1 id="u63D2_u4EF6Service_u52A0_u8F7D_u8FC7_u7A0B"><a href="#u63D2_u4EF6Service_u52A0_u8F7D_u8FC7_u7A0B" class="headerlink" title="插件Service加载过程"></a>插件Service加载过程</h1><h1 id="ActivityManagerProxy"><a href="#ActivityManagerProxy" class="headerlink" title="ActivityManagerProxy"></a>ActivityManagerProxy</h1><h2 id="invoke"><a href="#invoke" class="headerlink" title="invoke"></a>invoke</h2><pre><code>@Override
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
    if (&quot;startService&quot;.equals(method.getName())) {
        try {
            return startService(proxy, method, args);
        } catch (Throwable e) {
            Log.e(TAG, &quot;Start service error&quot;, e);
        }
    } 
    ...
}
</code></pre><h2 id="startService"><a href="#startService" class="headerlink" title="startService"></a>startService</h2><pre><code>private Object startService(Object proxy, Method method, Object[] args) throws Throwable {
    IApplicationThread appThread = (IApplicationThread) args[0];
    Intent target = (Intent) args[1];
    ResolveInfo resolveInfo = this.mPluginManager.resolveService(target, 0);
    if (null == resolveInfo || null == resolveInfo.serviceInfo) {
        // 如果为空的话，不是启动的插件service
        return method.invoke(this.mActivityManager, args);
    }
    // 
    return startDelegateServiceForTarget(target, resolveInfo.serviceInfo, null, RemoteService.EXTRA_COMMAND_START_SERVICE);
}
</code></pre><h2 id="startDelegateServiceForTarget"><a href="#startDelegateServiceForTarget" class="headerlink" title="startDelegateServiceForTarget"></a>startDelegateServiceForTarget</h2><pre><code>private ComponentName startDelegateServiceForTarget(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) {
    Intent wrapperIntent = wrapperTargetIntent(target, serviceInfo, extras, command);
    return mPluginManager.getHostContext().startService(wrapperIntent);
}
</code></pre><h2 id="wrapperTargetIntent"><a href="#wrapperTargetIntent" class="headerlink" title="wrapperTargetIntent"></a>wrapperTargetIntent</h2><pre><code>private Intent wrapperTargetIntent(Intent target, ServiceInfo serviceInfo, Bundle extras, int command) {
    // fill in service with ComponentName
    target.setComponent(new ComponentName(serviceInfo.packageName, serviceInfo.name));
    String pluginLocation = mPluginManager.getLoadedPlugin(target.getComponent()).getLocation();

    // start delegate service to run plugin service inside
    // 检查插件 service 是否是本地还是远程，再选择相对应的 delegate service
    boolean local = PluginUtil.isLocalService(serviceInfo);
    Class&lt;? extends Service&gt; delegate = local ? LocalService.class : RemoteService.class;
    // 创建新的 intent ，用来启动 delegate service。intent 中会保存插件 service 的相关信息
    Intent intent = new Intent();
    // 设置 class 为对应的 delegate service classname
    intent.setClass(mPluginManager.getHostContext(), delegate);
    intent.putExtra(RemoteService.EXTRA_TARGET, target);
    intent.putExtra(RemoteService.EXTRA_COMMAND, command);
    intent.putExtra(RemoteService.EXTRA_PLUGIN_LOCATION, pluginLocation);
    if (extras != null) {
        intent.putExtras(extras);
    }

    return intent;
}
</code></pre><h1 id="LocalService"><a href="#LocalService" class="headerlink" title="LocalService"></a>LocalService</h1><h2 id="onStartCommand"><a href="#onStartCommand" class="headerlink" title="onStartCommand"></a>onStartCommand</h2><pre><code>@Override
public int onStartCommand(Intent intent, int flags, int startId) {
    if (null == intent || !intent.hasExtra(EXTRA_TARGET) || !intent.hasExtra(EXTRA_COMMAND)) {
        return START_STICKY;
    }

    Intent target = intent.getParcelableExtra(EXTRA_TARGET);
    int command = intent.getIntExtra(EXTRA_COMMAND, 0);
    if (null == target || command &lt;= 0) {
        return START_STICKY;
    }

    ComponentName component = target.getComponent();
    LoadedPlugin plugin = mPluginManager.getLoadedPlugin(component);

    switch (command) {
        case EXTRA_COMMAND_START_SERVICE: {
            ActivityThread mainThread = (ActivityThread) ReflectUtil.getActivityThread(getBaseContext());
            IApplicationThread appThread = mainThread.getApplicationThread();
            Service service;
            // 判断该插件的 service 是否已经创建过
            if (this.mPluginManager.getComponentsHandler().isServiceAvailable(component)) {
                // 直接从已启动服务 map 中取出该插件的 service
                service = this.mPluginManager.getComponentsHandler().getService(component);
            } else {
                try {
                    // 创建插件 service 对象
                    service = (Service) plugin.getClassLoader().loadClass(component.getClassName()).newInstance();

                    // 需要调用 attach
                    Application app = plugin.getApplication();
                    IBinder token = appThread.asBinder();
                    Method attach = service.getClass().getMethod(&quot;attach&quot;, Context.class, ActivityThread.class, String.class, IBinder.class, Application.class, Object.class);
                    IActivityManager am = mPluginManager.getActivityManager();
                    attach.invoke(service, plugin.getPluginContext(), mainThread, component.getClassName(), token, app, am);
                    // oncreate
                    service.onCreate();
                    // 放入已启动服务 map 中
                    this.mPluginManager.getComponentsHandler().rememberService(component, service);
                } catch (Throwable t) {
                    return START_STICKY;
                }
            }
            // 调用 onStartCommand
            service.onStartCommand(target, 0, this.mPluginManager.getComponentsHandler().getServiceCounter(service).getAndIncrement());
            break;
        }
    ...
}
</code></pre><h1 id="u63D2_u4EF6BroadcastReceiver_u52A0_u8F7D_u8FC7_u7A0B"><a href="#u63D2_u4EF6BroadcastReceiver_u52A0_u8F7D_u8FC7_u7A0B" class="headerlink" title="插件BroadcastReceiver加载过程"></a>插件BroadcastReceiver加载过程</h1><h1 id="LoadedPlugin-1"><a href="#LoadedPlugin-1" class="headerlink" title="LoadedPlugin"></a>LoadedPlugin</h1><pre><code>Map&lt;ComponentName, ActivityInfo&gt; receivers = new HashMap&lt;ComponentName, ActivityInfo&gt;();
for (PackageParser.Activity receiver : this.mPackage.receivers) {
    receivers.put(receiver.getComponentName(), receiver.info);

    try {
        // 得到插件中的 BroadcastReceiver 的实例
        BroadcastReceiver br = BroadcastReceiver.class.cast(getClassLoader().loadClass(receiver.getComponentName().getClassName()).newInstance());
        // 注册广播
        for (PackageParser.ActivityIntentInfo aii : receiver.intents) {
            this.mHostContext.registerReceiver(br, aii);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre><h1 id="u63D2_u4EF6ContentProvider_u52A0_u8F7D_u8FC7_u7A0B"><a href="#u63D2_u4EF6ContentProvider_u52A0_u8F7D_u8FC7_u7A0B" class="headerlink" title="插件ContentProvider加载过程"></a>插件ContentProvider加载过程</h1><h1 id="PluginContext"><a href="#PluginContext" class="headerlink" title="PluginContext"></a>PluginContext</h1><pre><code>@Override
public ContentResolver getContentResolver() {
    return new PluginContentResolver(getHostContext());
}
</code></pre><h1 id="PluginContentResolver"><a href="#PluginContentResolver" class="headerlink" title="PluginContentResolver"></a>PluginContentResolver</h1><pre><code>public PluginContentResolver(Context context) {
    super(context);
    mBase = context.getContentResolver();
    mPluginManager = PluginManager.getInstance(context);
}
</code></pre><h2 id="acquireProvider"><a href="#acquireProvider" class="headerlink" title="acquireProvider"></a>acquireProvider</h2><pre><code>protected IContentProvider acquireProvider(Context context, String auth) {
    try {
        if (mPluginManager.resolveContentProvider(auth, 0) != null) {
            return mPluginManager.getIContentProvider();
        }

        return (IContentProvider) sAcquireProvider.invoke(mBase, context, auth);
    } catch (Exception e) {
        e.printStackTrace();
    }

    return null;
}
</code></pre><h1 id="PluginManager"><a href="#PluginManager" class="headerlink" title="PluginManager"></a>PluginManager</h1><h2 id="getIContentProvider"><a href="#getIContentProvider" class="headerlink" title="getIContentProvider"></a>getIContentProvider</h2><pre><code>public synchronized IContentProvider getIContentProvider() {
    if (mIContentProvider == null) {
        hookIContentProviderAsNeeded();
    }

    return mIContentProvider;
}
</code></pre><h2 id="hookIContentProviderAsNeeded"><a href="#hookIContentProviderAsNeeded" class="headerlink" title="hookIContentProviderAsNeeded"></a>hookIContentProviderAsNeeded</h2><pre><code>private void hookIContentProviderAsNeeded() {
    Uri uri = Uri.parse(PluginContentResolver.getUri(mContext));
    mContext.getContentResolver().call(uri, &quot;wakeup&quot;, null, null);
    try {
        Field authority = null;
        Field mProvider = null;
        ActivityThread activityThread = (ActivityThread) ReflectUtil.getActivityThread(mContext);
        Map mProviderMap = (Map) ReflectUtil.getField(activityThread.getClass(), activityThread, &quot;mProviderMap&quot;);
        Iterator iter = mProviderMap.entrySet().iterator();
        while (iter.hasNext()) {
            Map.Entry entry = (Map.Entry) iter.next();
            Object key = entry.getKey();
            Object val = entry.getValue();
            String auth;
            if (key instanceof String) {
                auth = (String) key;
            } else {
                if (authority == null) {
                    authority = key.getClass().getDeclaredField(&quot;authority&quot;);
                    authority.setAccessible(true);
                }
                auth = (String) authority.get(key);
            }
            if (auth.equals(PluginContentResolver.getAuthority(mContext))) {
                if (mProvider == null) {
                    mProvider = val.getClass().getDeclaredField(&quot;mProvider&quot;);
                    mProvider.setAccessible(true);
                }
                IContentProvider rawProvider = (IContentProvider) mProvider.get(val);
                IContentProvider proxy = IContentProviderProxy.newInstance(mContext, rawProvider);
                mIContentProvider = proxy;
                Log.d(TAG, &quot;hookIContentProvider succeed : &quot; + mIContentProvider);
                break;
            }
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>VirtualAPK 是滴滴开源的一款 Android 插件化的框架。</p>
<p>现在市面上，成熟的插件]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[View事件分发机制源码解析]]></title>
    <link href="http://yuqirong.me/2017/10/31/View%E4%BA%8B%E4%BB%B6%E5%88%86%E5%8F%91%E6%9C%BA%E5%88%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/10/31/View事件分发机制源码解析/</id>
    <published>2017-10-31T13:06:30.000Z</published>
    <updated>2017-11-04T06:02:00.872Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>Android View 事件分发的机制可以说是 Android 开发者必知点之一，一般在面试的过程中肯定也有涉及。之前重新梳理了一下 View 事件的分发，所以为了有所记录，下定决心要写一篇关于 View 事件分发的博客。</p>
<p>虽然很早之前也写了一篇关于事件分发的博客<a href="http://yuqirong.me/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">《Android onTouch事件传递机制解析》</a>，但是在这篇中分析不够全面，Activity 和 ViewGroup 没有涉及到。那么就来“再续前缘”吧。</p>
<p>事件分发可以说分为三个部分，</p>
<ul>
<li>一个是 Activity </li>
<li>然后是 ViewGroup</li>
<li>最后是 View</li>
</ul>
<p>我们在分析事件分发时，也会依次按照这三个部分来入手。</p>
<p>因为最后的 View 部分在之前已经分析过了（也就是<a href="http://yuqirong.me/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">《Android onTouch事件传递机制解析》</a>），所以今天的内容里关于 View 部分的就不再讲了，大家可以自己去这篇博客中接着看下去。</p>
<p>好咯，下面就是我们的 show time ！</p>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><p>先入手第一部分：Activity 。</p>
<h2 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h2><h3 id="dispatchTouchEvent_28MotionEvent_ev_29"><a href="#dispatchTouchEvent_28MotionEvent_ev_29" class="headerlink" title="dispatchTouchEvent(MotionEvent ev)"></a>dispatchTouchEvent(MotionEvent ev)</h3><p>在 Activity 的扎堆代码中，我们先从 <code>dispatchTouchEvent(MotionEvent ev)</code> 看起。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果是 down 事件，回调 onUserInteraction()</span></span><br><span class="line">    <span class="comment">// onUserInteraction 是空方法，可以用来判断用户是否正在和设备交互</span></span><br><span class="line">    <span class="comment">// 当用户触摸屏幕或是点击按键都会回调此方法</span></span><br><span class="line">    <span class="keyword">if</span> (ev.getAction() == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">        onUserInteraction();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getWindow().superDispatchTouchEvent(ev)) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 getWindow().superDispatchTouchEvent 返回 false 的话就交给 onTouchEvent 处理</span></span><br><span class="line">    <span class="keyword">return</span> onTouchEvent(ev);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Activity 的 <code>dispatchTouchEvent(MotionEvent ev)</code> 方法代码很短，我们先跟着 <code>getWindow().superDispatchTouchEvent(ev)</code> 去走。如果 <code>getWindow().superDispatchTouchEvent(ev)</code> 返回了 true ，那就代表着事件有 View 去响应处理了；否则返回 false 的话，就说明没有 View 处理，那么就转回来交给了 Activity 来处理，也就是 <code>onTouchEvent(ev)</code> 方法。</p>
<h3 id="onTouchEvent_28MotionEvent_event_29"><a href="#onTouchEvent_28MotionEvent_event_29" class="headerlink" title="onTouchEvent(MotionEvent event)"></a>onTouchEvent(MotionEvent event)</h3><p>在 Activity 的 <code>onTouchEvent(ev)</code> 方法中会去判断该触摸事件的坐标是否在 Window 范围之外，如果在范围之外就关闭该 Activity （注意：Window 设置了 mCloseOnTouchOutside 为 true 的情况下）并且返回 true；否则返回 false 。具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mWindow.shouldCloseOnTouch(<span class="keyword">this</span>, event)) &#123;</span><br><span class="line">        finish();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，现在回过头来讲讲有 View 去处理事件的情形。</p>
<p>我们都知道 getWindow() 实际上是得到了当前 Activity 的 Window 对象，而 Window 的具体实现是 PhoneWindow 。所以我们接着要去看 PhoneWindow 的 <code>superDispatchTouchEvent(ev)</code> 方法。</p>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><h3 id="superDispatchTouchEvent_28MotionEvent_event_29"><a href="#superDispatchTouchEvent_28MotionEvent_event_29" class="headerlink" title="superDispatchTouchEvent(MotionEvent event)"></a>superDispatchTouchEvent(MotionEvent event)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mDecor.superDispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 PhoneWindow 中直接把事件交给了 mDecor 来处理，而 mDecor 正是 Window 中持有的 DecorView 对象。在这里，也代表着事件从 Activity 传给了 ViewGroup 。</p>
<p>接着跟下去。</p>
<h2 id="DecorView"><a href="#DecorView" class="headerlink" title="DecorView"></a>DecorView</h2><h3 id="superDispatchTouchEvent_28MotionEvent_event_29-1"><a href="#superDispatchTouchEvent_28MotionEvent_event_29-1" class="headerlink" title="superDispatchTouchEvent(MotionEvent event)"></a>superDispatchTouchEvent(MotionEvent event)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">superDispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DecorView 的 <code>superDispatchTouchEvent(MotionEvent event)</code> 方法代码也很短了[/笑哭]，直接调用了父类的 <code>dispatchTouchEvent(event)</code> 方法。DecorView 是继承了 FrameLayout 的。而在 FrameLayout 中并没有去重写 <code>dispatchTouchEvent(event)</code> 。所以我们要去看 ViewGroup 的 <code>dispatchTouchEvent(event)</code> 方法了。</p>
<p>至此为止，我们第一部分关于 Activity 的事件分发已经讲完了。接下去的就是第二部分关于 ViewGroup 的了。</p>
<h1 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h1><p>第二部分，ViewGroup 。</p>
<h2 id="ViewGroup-1"><a href="#ViewGroup-1" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><p>上面讲到了我们要去 ViewGroup 中看 <code>dispatchTouchEvent(event)</code> 方法。</p>
<h3 id="dispatchTouchEvent_28event_29"><a href="#dispatchTouchEvent_28event_29" class="headerlink" title="dispatchTouchEvent(event)"></a>dispatchTouchEvent(event)</h3><p><code>dispatchTouchEvent(event)</code> 方法挺长的，在这里我们就把它分段进行分析，这样也更加容易理解。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent ev)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onTouchEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">                         </span><br><span class="line">    <span class="comment">// If the event targets the accessibility focused view and this is it, start</span></span><br><span class="line">    <span class="comment">// normal event dispatch. Maybe a descendant is what will handle the click.</span></span><br><span class="line">    <span class="keyword">if</span> (ev.isTargetAccessibilityFocus() &amp;&amp; isAccessibilityFocusedViewOrHost()) &#123;</span><br><span class="line">        ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 返回值，代表着该View是否处理事件</span></span><br><span class="line">    <span class="keyword">boolean</span> handled = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 判断当前 window 是否有被遮挡，若返回 false 则丢弃这个事件</span></span><br><span class="line">    <span class="keyword">if</span> (onFilterTouchEventForSecurity(ev)) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> action = ev.getAction();</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionMasked = action &amp; MotionEvent.ACTION_MASK;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是 ACTION_DOWN 事件，那么需要恢复初始状态以及 mFirstTouchTarget 置空等</span></span><br><span class="line">        <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            <span class="comment">// Throw away all previous state when starting a new touch gesture.</span></span><br><span class="line">            <span class="comment">// The framework may have dropped the up or cancel event for the previous gesture</span></span><br><span class="line">            <span class="comment">// due to an app switch, ANR, or some other state change.</span></span><br><span class="line">            cancelAndClearTouchTargets(ev);</span><br><span class="line">            <span class="comment">// 在 resetTouchState 会对 FLAG_DISALLOW_INTERCEPT 重置</span></span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">     ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>dispatchTouchEvent(event)</code> 方法的一开始，首先以 Window 是否被遮挡来过滤掉一些不必要的事件。之后若是手指按下的 ACTION_DOWN 事件的话，做一些状态清除等工作，比如 mFirstTouchTarget = null 。 当 ViewGroup 的子元素成功处理了事件后，mFirstTouchTarget 就会被赋值并指向了子元素。因此当触摸事件为 ACTION_DOWN 时，说明这是一轮新的事件，还不知道哪个 View 可以处理该事件，所以 mFirstTouchTarget 会被置为 null 了。</p>
<p>这一小段代码理解后，我们再接着往下看。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ----------第 1 小点----------</span></span><br><span class="line"><span class="comment">// 检查是否需要拦截事件</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> intercepted;</span><br><span class="line"><span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">        || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------第 2 小点----------</span></span><br><span class="line">    <span class="comment">// disallowIntercept 代表着子View是否禁止让父ViewGroup拦截事件</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> disallowIntercept = (mGroupFlags &amp; FLAG_DISALLOW_INTERCEPT) != <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 如果不禁止，就调用 onInterceptTouchEvent </span></span><br><span class="line">    <span class="keyword">if</span> (!disallowIntercept) &#123;</span><br><span class="line">        intercepted = onInterceptTouchEvent(ev);</span><br><span class="line">        ev.setAction(action); <span class="comment">// restore action in case it was changed</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        intercepted = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// There are no touch targets and this action is not an initial down</span></span><br><span class="line">    <span class="comment">// so this view group continues to intercept touches.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// ----------第 3 小点----------</span></span><br><span class="line">    <span class="comment">// 如果 mFirstTouchTarget 等于 null ，则说明子 view 中都不处理事件，并且不是 ACTION_DOWN 事件，当前 viewgroup 默认拦截该事件</span></span><br><span class="line">    intercepted = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (intercepted || mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里判断了 ViewGroup 是否要去拦截事件。根据判断 <code>actionMasked == MotionEvent.ACTION_DOWN || mFirstTouchTarget != null</code> ，我们可以知道一点，当 <code>mFirstTouchTarget</code> 为 null 时，就说明了子 View 中都不会处理这轮事件了，那么就应该把该事件直接交回给 ViewGroup （此时的事件肯定是 ACTION_MOVE 或者 ACTION_UP 了）。所以直接设置了 <code>intercepted = true</code> ，也就是上面代码中的第 3 小点。</p>
<p>反之，若为 ACTION_DOWN 事件，那么说明是一轮全新的事件。是需要去问问子 View 到底要不要处理事件的。同理，mFirstTouchTarget != null 的话肯定是找到子 View 来处理事件了，所以也不能马上判断是否拦截，需要继续深入。也就是上面的第 1 小点。</p>
<p>剩下最后一个第 2 小点。</p>
<p>之后先得到 disallowIntercept ，disallowIntercept 与 FLAG_DISALLOW_INTERCEPT 有关。而 FLAG_DISALLOW_INTERCEPT 又是通过 <code>requestDisallowInterceptTouchEvent</code> 方法来设置的。如果 disallowIntercept 是 true ，说明子 View 禁止让父 ViewGroup 拦截事件。那就直接设置 <code>intercepted = false</code> 。这里要注意下，当为 ACTION_DOWN 事件时，会重置 FLAG_DISALLOW_INTERCEPT 标记位，所以 ACTION_DOWN 事件在 ViewGroup 的 <code>onInterceptTouchEvent</code> 方法中一定会询问自己是否需要拦截，而 ACTION_MOVE 和 ACTION_UP 则不一定。</p>
<p>反之，若 disallowIntercept 为 false 的话，那么 ViewGroup 会调用 <code>onInterceptTouchEvent(ev)</code> 方法来判断自己是否要去拦截，开发者可以去重写这个方法来达到一些拦截的目的，该方法默认返回 false ，也就是不拦截。</p>
<p>趁热，接着撸。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 检查下是否是 ACTION_CANCEL 事件</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> canceled = resetCancelNextUpFlag(<span class="keyword">this</span>)</span><br><span class="line">        || actionMasked == MotionEvent.ACTION_CANCEL;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 是否分发给多个子 View ，默认是 false</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> split = (mGroupFlags &amp; FLAG_SPLIT_MOTION_EVENTS) != <span class="number">0</span>;</span><br><span class="line">TouchTarget newTouchTarget = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">boolean</span> alreadyDispatchedToNewTouchTarget = <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 不被 ViewGroup 拦截并且不是 ACTION_CANCEL 事件</span></span><br><span class="line"><span class="keyword">if</span> (!canceled &amp;&amp; !intercepted) &#123;</span><br><span class="line"></span><br><span class="line">    View childWithAccessibilityFocus = ev.isTargetAccessibilityFocus()</span><br><span class="line">            ? findChildWithAccessibilityFocus() : <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当为 ACTION_DOWN 等事件时，要去寻找可以处理的子View，然后下发</span></span><br><span class="line">    <span class="keyword">if</span> (actionMasked == MotionEvent.ACTION_DOWN</span><br><span class="line">            || (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_DOWN)</span><br><span class="line">            || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex(); <span class="comment">// always 0 for down</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> idBitsToAssign = split ? <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex)</span><br><span class="line">                : TouchTarget.ALL_POINTER_IDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Clean up earlier touch targets for this pointer id in case they</span></span><br><span class="line">        <span class="comment">// have become out of sync.</span></span><br><span class="line">        removePointersFromTouchTargets(idBitsToAssign);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; childrenCount != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> x = ev.getX(actionIndex);</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">float</span> y = ev.getY(actionIndex);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 获取 z 轴上从大到小排序的子 view 顺序</span></span><br><span class="line">            <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = buildTouchDispatchChildList();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">                    &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">            <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">            <span class="comment">// 开始遍历子 view</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = childrenCount - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="comment">// 确认子 View 的下标</span></span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(</span><br><span class="line">                        childrenCount, i, customOrder);</span><br><span class="line">                <span class="comment">// 根据下标，得到子View</span></span><br><span class="line">                <span class="keyword">final</span> View child = getAndVerifyPreorderedView(</span><br><span class="line">                        preorderedList, children, childIndex);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果当前 view 没有焦点，那么跳过</span></span><br><span class="line">                <span class="keyword">if</span> (childWithAccessibilityFocus != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (childWithAccessibilityFocus != child) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    childWithAccessibilityFocus = <span class="keyword">null</span>;</span><br><span class="line">                    i = childrenCount - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 点击是否落在子view范围内和子view是否正在动画</span></span><br><span class="line">                <span class="keyword">if</span> (!canViewReceivePointerEvents(child)</span><br><span class="line">                        || !isTransformedTouchPointInView(x, y, child, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                newTouchTarget = getTouchTarget(child);</span><br><span class="line">                <span class="keyword">if</span> (newTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// Child is already receiving touch within its bounds.</span></span><br><span class="line">                    <span class="comment">// Give it the new pointer in addition to the ones it is handling.</span></span><br><span class="line">                    newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                resetCancelNextUpFlag(child);</span><br><span class="line">                <span class="comment">// 分发给该子 View 的 dispatchTouchEvent 方法</span></span><br><span class="line">                <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, <span class="keyword">false</span>, child, idBitsToAssign)) &#123;</span><br><span class="line">                    <span class="comment">// Child wants to receive touch within its bounds.</span></span><br><span class="line">                    mLastTouchDownTime = ev.getDownTime();</span><br><span class="line">                    <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">// childIndex points into presorted list, find original index</span></span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; childrenCount; j++) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (children[childIndex] == mChildren[j]) &#123;</span><br><span class="line">                                mLastTouchDownIndex = j;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        mLastTouchDownIndex = childIndex;</span><br><span class="line">                    &#125;</span><br><span class="line">                    mLastTouchDownX = ev.getX();</span><br><span class="line">                    mLastTouchDownY = ev.getY();</span><br><span class="line">                    <span class="comment">//给 mFirstTouchTarget 赋值，该事件已经交给子 View 处理了</span></span><br><span class="line">                    newTouchTarget = addTouchTarget(child, idBitsToAssign);</span><br><span class="line">                    alreadyDispatchedToNewTouchTarget = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// The accessibility focus didn't handle the event, so clear</span></span><br><span class="line">                <span class="comment">// the flag and do a normal dispatch to all children.</span></span><br><span class="line">                ev.setTargetAccessibilityFocus(<span class="keyword">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (preorderedList != <span class="keyword">null</span>) preorderedList.clear();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (newTouchTarget == <span class="keyword">null</span> &amp;&amp; mFirstTouchTarget != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Did not find a child to receive the event.</span></span><br><span class="line">            <span class="comment">// Assign the pointer to the least recently added target.</span></span><br><span class="line">            newTouchTarget = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (newTouchTarget.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">                newTouchTarget = newTouchTarget.next;</span><br><span class="line">            &#125;</span><br><span class="line">            newTouchTarget.pointerIdBits |= idBitsToAssign;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码较长，基本上的逻辑就是为 ACTION_DOWN 等事件找一个可以处理的子 View 。</p>
<p>先遍历了所有的子 View ，会根据点击坐标是否落在子view范围内以及子view是否正在动画来判断是否接收事件。</p>
<p>如果找到了一个子 View 可以接收事件，那么就会调用它的 <code>dispatchTouchEvent</code> 方法。若 <code>dispatchTouchEvent</code> 方法返回 true 的话，说明该 View 确认处理该事件了，那么之后给 mFirstTouchTarget 赋值；否则就继续遍历重复之前的流程了。</p>
<p>三言两语就概括了这段代码的逻辑。</p>
<p>再来看最后一段代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">        <span class="comment">// Dispatch to touch targets.</span></span><br><span class="line">        <span class="comment">// 如果 mFirstTouchTarget 为空，那么有可能没有子 View 或者所有的子 View 都不处理该事件了</span></span><br><span class="line">        <span class="keyword">if</span> (mFirstTouchTarget == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// No touch targets so treat this as an ordinary view.</span></span><br><span class="line">            <span class="comment">// 交给自己处理，调用 ViewGroup 的 super.dispatchTouchEvent 方法</span></span><br><span class="line">            handled = dispatchTransformedTouchEvent(ev, canceled, <span class="keyword">null</span>,</span><br><span class="line">                    TouchTarget.ALL_POINTER_IDS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//处理有 mFirstTouchTarget 并且除了 ACTION_DOWN 以外的事件</span></span><br><span class="line">            <span class="comment">// Dispatch to touch targets, excluding the new touch target if we already</span></span><br><span class="line">            <span class="comment">// dispatched to it.  Cancel touch targets if necessary.</span></span><br><span class="line">            TouchTarget predecessor = <span class="keyword">null</span>;</span><br><span class="line">            TouchTarget target = mFirstTouchTarget;</span><br><span class="line">            <span class="keyword">while</span> (target != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">final</span> TouchTarget next = target.next;</span><br><span class="line">                <span class="comment">// alreadyDispatchedToNewTouchTarget 为 true 就说明了 mFirstTouchTarget 被赋值了</span></span><br><span class="line">                <span class="comment">// 所以事件已经交给子 View 处理了，这里就返回 true </span></span><br><span class="line">                <span class="keyword">if</span> (alreadyDispatchedToNewTouchTarget &amp;&amp; target == newTouchTarget) &#123;</span><br><span class="line">                    handled = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// cancelChild 为 true 的话就说明接下来的事件被 ViewGroup 拦截了，需要传递 ACTION_CANCEL 事件</span></span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">boolean</span> cancelChild = resetCancelNextUpFlag(target.child)</span><br><span class="line">                            || intercepted;</span><br><span class="line">                    <span class="comment">// 传递 ACTION_CANCEL 事件给子 View</span></span><br><span class="line">                    <span class="keyword">if</span> (dispatchTransformedTouchEvent(ev, cancelChild,</span><br><span class="line">                            target.child, target.pointerIdBits)) &#123;</span><br><span class="line">                        handled = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">// 释放 mFirstTouchTarget ，之后事件就交给了 ViewGroup 自己处理了</span></span><br><span class="line">                    <span class="keyword">if</span> (cancelChild) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (predecessor == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            mFirstTouchTarget = next;</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            predecessor.next = next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        target.recycle();</span><br><span class="line">                        target = next;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                predecessor = target;</span><br><span class="line">                target = next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Update list of touch targets for pointer up or cancel, if needed.</span></span><br><span class="line">        <span class="comment">// 当为 ACTION_CANCEL 和 ACTION_UP 等事件的一些重置状态</span></span><br><span class="line">        <span class="keyword">if</span> (canceled</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_UP</span><br><span class="line">                || actionMasked == MotionEvent.ACTION_HOVER_MOVE) &#123;</span><br><span class="line">            resetTouchState();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (split &amp;&amp; actionMasked == MotionEvent.ACTION_POINTER_UP) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> actionIndex = ev.getActionIndex();</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> idBitsToRemove = <span class="number">1</span> &lt;&lt; ev.getPointerId(actionIndex);</span><br><span class="line">            removePointersFromTouchTargets(idBitsToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handled &amp;&amp; mInputEventConsistencyVerifier != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventConsistencyVerifier.onUnhandledEvent(ev, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回是否处理的 boolean 值</span></span><br><span class="line">    <span class="keyword">return</span> handled;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一开头，判断了 <code>mFirstTouchTarget == null</code> 。如果是空的话，就代表着可能 ViewGroup 中没有子 View ，或者所有的子 View 都不打算处理这轮的事件。那么只能交给 ViewGroup 自己处理了。之后调用了 <code>dispatchTransformedTouchEvent(ev, canceled, null, TouchTarget.ALL_POINTER_IDS)</code> 方法。</p>
<p>细心的同学已经发现，这个事件分发给子 View 调用的是同一个方法。不同的是，分发给子 View 的是 <code>dispatchTransformedTouchEvent(ev, canceled, child, TouchTarget.ALL_POINTER_IDS)</code> 。也就是说，第三个参数一个是 null ，而另一个是 child 。其实，在 <code>dispatchTransformedTouchEvent</code> 内部的逻辑大概是这样的，省略了其他代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (child == <span class="keyword">null</span>) &#123;</span><br><span class="line">    handled = <span class="keyword">super</span>.dispatchTouchEvent(event);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    handled = child.dispatchTouchEvent(event);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，当传入是 null 的话，调用的直接是 <code>super.dispatchTouchEvent(event)</code> ，也就是 View 类的 <code>dispatchTouchEvent</code> 方法了。</p>
<p>再来看 <code>mFirstTouchTarget != null</code> 的情况。</p>
<p>mFirstTouchTarget 不为空的话，代码里处理的都是除了 ACTION_DOWN 的事件，也就是 ACTION_MOVE 和 ACTION_UP 事件。若 alreadyDispatchedToNewTouchTarget 为 true ，那么这正是上面给 mFirstTouchTarget 赋值时留下来的“锅”，直接返回 handled = true 即可。</p>
<p>否则就直接将事件分发给子 View 了。这里注意下，若 cancelChild 为 true 的话，就代表着事件被 ViewGroup 拦截了，所以分发给子 View 的将是 ACTION_CANCEL 事件，之后把 mFirstTouchTarget 置空了。那么之后事件再过来，调用的就是 ViewGroup 的 <code>super.dispatchTouchEvent(event)</code> ，就完成了把事件分发给 ViewGroup 了。</p>
<p>这样，以后的事件就完全移交给 ViewGroup 了，没子 View 什么事了。</p>
<p>最后就是对 ACTION_CANCEL 和 ACTION_UP 事件的一些状态重置。</p>
<p>在这，基本上把 ViewGroup 这部分讲完了。</p>
<h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><p>View 部分的事件分发就参考一下<a href="http://yuqirong.me/2015/10/29/Android%20onTouch%E4%BA%8B%E4%BB%B6%E4%BC%A0%E9%80%92%E6%9C%BA%E5%88%B6%E8%A7%A3%E6%9E%90/">《Android onTouch事件传递机制解析》</a>，这里面讲的还是挺清楚的，很早以前写的，不多讲了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>今天的内容都讲的差不多了，也把事件分发的机制又整理了一遍。当然也有一些不完善的地方，比如事件是怎样传递给 Activity 的在本文中没有涉及到，想了解的同学可以看下这篇<a href="http://blog.csdn.net/singwhatiwanna/article/details/50775201" target="_blank" rel="external">《Android中MotionEvent的来源和ViewRootImpl》</a>，任大神的作品。</p>
<p>好了，要说再见了。如果有问题的同学可以在下面留言。</p>
<p>Goodbye …</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/singwhatiwanna/article/details/50775201" target="_blank" rel="external">Android中MotionEvent的来源和ViewRootImpl</a></li>
<li><a href="http://blog.csdn.net/u013927241/article/details/77919424" target="_blank" rel="external">Android 事件分发机制源码攻略（二） —— ViewGroup篇</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>Andr]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="View" scheme="http://yuqirong.me/tags/View/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(四)：Window的删除机制]]></title>
    <link href="http://yuqirong.me/2017/10/23/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E5%9B%9B)%EF%BC%9AWindow%E7%9A%84%E5%88%A0%E9%99%A4%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2017/10/23/Window源码解析(四)：Window的删除机制/</id>
    <published>2017-10-23T13:46:03.000Z</published>
    <updated>2017-10-28T05:57:05.782Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a></p>
<p>第二篇：<a href="/2017/10/08/Window源码解析(二)：Window的添加机制/">《Window源码解析(二)：Window的添加机制》</a></p>
<p>第二篇：<a href="/2017/10/10/Window源码解析(三)：Window的更新机制/">《Window源码解析(三)：Window的更新机制》</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>这篇将是 Window 系列的最后一篇了，主要来讲讲 Window 删除的机制原理。</p>
<p>其实相对于 Window 的添加和更新来说，删除也是换汤不换药的。也是通过 WindowSession 和 WindowManagerService 来完成这个步骤的。</p>
<h1 id="Window_u7684_u5220_u9664_u673A_u5236"><a href="#Window_u7684_u5220_u9664_u673A_u5236" class="headerlink" title="Window的删除机制"></a>Window的删除机制</h1><p>我们删除 Window 的代码：</p>
<p><code>WindowManager.removeView</code></p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><h3 id="removeView_28View_view_29"><a href="#removeView_28View_view_29" class="headerlink" title="removeView(View view)"></a>removeView(View view)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span> </span>&#123;</span><br><span class="line">    mGlobal.removeView(view, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WindowManager 是一个接口，具体实现是 WindowManagerImpl 类。不用说，WindowManagerImpl 内部肯定是 WindowManagerGlobal 在“作祟”咯。</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="removeView_28View_view_2C_boolean_immediate_29"><a href="#removeView_28View_view_2C_boolean_immediate_29" class="headerlink" title="removeView(View view, boolean immediate)"></a>removeView(View view, boolean immediate)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 得到当前 view 的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        View curView = mRoots.get(index).getView();</span><br><span class="line">        <span class="comment">// 主要执行删除 view 的操作</span></span><br><span class="line">        removeViewLocked(index, immediate);</span><br><span class="line">        <span class="comment">// 如果要删除的 view 不是 viewrootimpl 中的 view ，那么会抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (curView == view) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Calling with view "</span> + view</span><br><span class="line">                + <span class="string">" but the ViewAncestor is attached to "</span> + curView);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>removeView(View view, boolean immediate)</code> 先找到了打算删除的 View 的索引。然后根据索引去执行删除操作。</p>
<p>若 <code>immediate</code> 参数传入的是 true ，那么就执行了同步删除操作；否则就是异步删除操作了。大多使用的都是异步删除操作，避免出错，即 <code>immediate</code> 为 false；</p>
<p>其实这个方法的重点都放在了 <code>removeViewLocked(index, immediate)</code> 中了。</p>
<h3 id="removeViewLocked_28int_index_2C_boolean_immediate_29"><a href="#removeViewLocked_28int_index_2C_boolean_immediate_29" class="headerlink" title="removeViewLocked(int index, boolean immediate)"></a>removeViewLocked(int index, boolean immediate)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">removeViewLocked</span><span class="params">(<span class="keyword">int</span> index, <span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    ViewRootImpl root = mRoots.get(index);</span><br><span class="line">    View view = root.getView();</span><br><span class="line">		</span><br><span class="line">    <span class="comment">// 关闭输入法</span></span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        InputMethodManager imm = InputMethodManager.getInstance();</span><br><span class="line">        <span class="keyword">if</span> (imm != <span class="keyword">null</span>) &#123;</span><br><span class="line">            imm.windowDismissed(mViews.get(index).getWindowToken());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用 die 方法，将 immediate 传入，即是否为同步删除</span></span><br><span class="line">    <span class="keyword">boolean</span> deferred = root.die(immediate);</span><br><span class="line">    <span class="keyword">if</span> (view != <span class="keyword">null</span>) &#123;</span><br><span class="line">        view.assignParent(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">if</span> (deferred) &#123;</span><br><span class="line"><span class="comment">// 添加到马上移除的集合中</span></span><br><span class="line">            mDyingViews.add(view);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>removeViewLocked(int index, boolean immediate)</code> 中，调用了 ViewRootImpl 的 die 方法。大多数的默认情况下，<code>immediate</code> 都为 false 。</p>
<p>之后又将 view 添加到 mDyingViews 中。mDyingViews 维持着都是即将要删除的 View 。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="die_28boolean_immediate_29"><a href="#die_28boolean_immediate_29" class="headerlink" title="die(boolean immediate)"></a>die(boolean immediate)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">die</span><span class="params">(<span class="keyword">boolean</span> immediate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Make sure we do execute immediately if we are in the middle of a traversal or the damage</span></span><br><span class="line">    <span class="comment">// done by dispatchDetachedFromWindow will cause havoc on return.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是同步移除，则马上执行 doDie</span></span><br><span class="line">    <span class="keyword">if</span> (immediate &amp;&amp; !mIsInTraversal) &#123;</span><br><span class="line">        doDie();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!mIsDrawing) &#123;</span><br><span class="line">        destroyHardwareRenderer();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">"Attempting to destroy the window while drawing!\n"</span> +</span><br><span class="line">                <span class="string">"  window="</span> + <span class="keyword">this</span> + <span class="string">", title="</span> + mWindowAttributes.getTitle());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 异步的话就利用 handler 发一个 messaage , 接收到 message 后也是执行 doDie 方法</span></span><br><span class="line">    mHandler.sendEmptyMessage(MSG_DIE);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>die(boolean immediate)</code> 方法中，不管同步还是异步，都是执行 <code>doDie()</code> 方法。不同的就是同步是马上执行，而异步是利用 Handler 去发消息，接收到消息后在执行。</p>
<h3 id="doDie_28_29"><a href="#doDie_28_29" class="headerlink" title="doDie()"></a>doDie()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doDie</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先检查线程，要在主线程中进行</span></span><br><span class="line">    checkThread();</span><br><span class="line">    <span class="keyword">if</span> (LOCAL_LOGV) Log.v(mTag, <span class="string">"DIE in "</span> + <span class="keyword">this</span> + <span class="string">" of "</span> + mSurface);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mRemoved) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mRemoved = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mAdded) &#123;</span><br><span class="line">            <span class="comment">// 如果是已经添加到 Window 上的，执行删除操作</span></span><br><span class="line">            dispatchDetachedFromWindow();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAdded &amp;&amp; !mFirst) &#123;</span><br><span class="line">            destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (mView != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> viewVisibility = mView.getVisibility();</span><br><span class="line">                <span class="keyword">boolean</span> viewVisibilityChanged = mViewVisibility != viewVisibility;</span><br><span class="line">                <span class="keyword">if</span> (mWindowAttributesChanged || viewVisibilityChanged) &#123;</span><br><span class="line">                    <span class="comment">// If layout params have been changed, first give them</span></span><br><span class="line">                    <span class="comment">// to the window manager to make sure it has the correct</span></span><br><span class="line">                    <span class="comment">// animation info.</span></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> ((relayoutWindow(mWindowAttributes, viewVisibility, <span class="keyword">false</span>)</span><br><span class="line">                                &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>) &#123;</span><br><span class="line">                            mWindowSession.finishDrawing(mWindow);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                mSurface.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将 mAdded 设置为 false</span></span><br><span class="line">        mAdded = <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 从对应的 mRoots mParams mDyingViews 中移除该 view 的引用</span></span><br><span class="line">    WindowManagerGlobal.getInstance().doRemoveView(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>doDie()</code> 方法中主要看两点：</p>
<ol>
<li>dispatchDetachedFromWindow() 是去执行删除 window 的方法；</li>
<li>WindowManagerGlobal.getInstance().doRemoveView(this) 把 mRoot 、mParams 和 mDyingViews 中关于当前 Window 的参数都移除了。</li>
</ol>
<p>所以我们接下来，还是要看下 dispatchDetachedFromWindow() 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dispatchDetachedFromWindow</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 在这里调用 view 的 dispatchDetachedFromWindow 方法</span></span><br><span class="line">    <span class="keyword">if</span> (mView != <span class="keyword">null</span> &amp;&amp; mView.mAttachInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mAttachInfo.mTreeObserver.dispatchOnWindowAttachedChange(<span class="keyword">false</span>);</span><br><span class="line">        mView.dispatchDetachedFromWindow();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 辅助功能相关的操作</span></span><br><span class="line">    mAccessibilityInteractionConnectionManager.ensureNoConnection();</span><br><span class="line">    mAccessibilityManager.removeAccessibilityStateChangeListener(</span><br><span class="line">            mAccessibilityInteractionConnectionManager);</span><br><span class="line">    mAccessibilityManager.removeHighTextContrastStateChangeListener(</span><br><span class="line">            mHighContrastTextManager);</span><br><span class="line">    removeSendWindowContentChangedCallback();</span><br><span class="line">    <span class="comment">// 垃圾回收的工作</span></span><br><span class="line">    destroyHardwareRenderer();</span><br><span class="line"></span><br><span class="line">    setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    mView.assignParent(<span class="keyword">null</span>);</span><br><span class="line">    mView = <span class="keyword">null</span>;</span><br><span class="line">    mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    mSurface.release();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mInputQueueCallback != <span class="keyword">null</span> &amp;&amp; mInputQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputQueueCallback.onInputQueueDestroyed(mInputQueue);</span><br><span class="line">        mInputQueue.dispose();</span><br><span class="line">        mInputQueueCallback = <span class="keyword">null</span>;</span><br><span class="line">        mInputQueue = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mInputEventReceiver != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputEventReceiver.dispose();</span><br><span class="line">        mInputEventReceiver = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 重点来了，调用 session 来做 window 移除操作</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        mWindowSession.remove(mWindow);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Dispose the input channel after removing the window so the Window Manager</span></span><br><span class="line">    <span class="comment">// doesn't interpret the input channel being closed as an abnormal termination.</span></span><br><span class="line">    <span class="keyword">if</span> (mInputChannel != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mInputChannel.dispose();</span><br><span class="line">        mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDisplayManager.unregisterDisplayListener(mDisplayListener);</span><br><span class="line">    <span class="comment">// 解除 view 绘制之类的操作</span></span><br><span class="line">    unscheduleTraversals();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法一开头，先回调了 View 的 dispatchDetachedFromWindow 方法，该方法表示 View 马上要从 Window 上删除了。在这个方法内，可以做一些资源回收的工作。</p>
<p>之后做的就是一些垃圾回收的工作，比如清楚数据和消息，移除回调等。</p>
<p>再然后要看的就是 <code>mWindowSession.remove(mWindow)</code> ，这步才是真正调用了 Session 来移除 Window 的操作，是 IPC 的过程。具体的我们深入去看了。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(IWindow window)</span> </span>&#123;</span><br><span class="line">    mService.removeWindow(<span class="keyword">this</span>, window);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Session 中直接调用了 WindowManagerService 的 <code>removeWindow(Session session, IWindow client)</code> 方法。</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeWindow</span><span class="params">(Session session, IWindow client)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">        <span class="comment">// 得到 windowstate 对象</span></span><br><span class="line">        WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 进行移除 window 操作</span></span><br><span class="line">        removeWindowLocked(win);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先得到 WindowState 对象，再调用 removeWindowLocked 去移除该 WindowState 。而具体的 removeWindowLocked 代码我们在这就不深入了，可以自行研究。</p>
<p>至此，整个 Window 移除机制就分析完毕了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>终于终于终于把 Window 的相关内容都重新梳理完毕了，也花了将近一个月的时间。</p>
<p>之前有一些似懂非懂的点也明朗了，但是还是有一些地方没有深入去涉及。比如 WindowManagerService 内部的操作。</p>
<p>以后的路还很长，期待自己再深入下去。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/innost/article/details/47660193" target="_blank" rel="external">《深入理解Android 卷III》第四章 深入理解WindowManagerService</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(三)：Window的更新机制]]></title>
    <link href="http://yuqirong.me/2017/10/10/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%89)%EF%BC%9AWindow%E7%9A%84%E6%9B%B4%E6%96%B0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2017/10/10/Window源码解析(三)：Window的更新机制/</id>
    <published>2017-10-10T12:53:03.000Z</published>
    <updated>2017-10-15T07:48:06.507Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a></p>
<p>第二篇：<a href="/2017/10/08/Window源码解析(二)：Window的添加机制/">《Window源码解析(二)：Window的添加机制》</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>在上一篇中，介绍了 Window 添加机制的实现。</p>
<p>那么今天就好好探究探究 Window 更新机制。其实 Window 的更新内部流程和添加 Window 并无什么差异，所以本篇可能会讲得比较简略。</p>
<p>但是还是值得我们去了解的，那么老死机开车了。</p>
<h1 id="Window_u7684_u66F4_u65B0_u673A_u5236"><a href="#Window_u7684_u66F4_u65B0_u673A_u5236" class="headerlink" title="Window的更新机制"></a>Window的更新机制</h1><p>我们更新 Window 的代码：</p>
<p><code>WindowManager.updateViewLayout</code></p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><h3 id="updateViewLayout_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29"><a href="#updateViewLayout_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29" class="headerlink" title="updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params)"></a>updateViewLayout(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</h3><p>所以我们的入口就是 WindowManagerImpl 实现类的，先看代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    mGlobal.updateViewLayout(view, params);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然，内部还是交给了 WindowManagerGlobal 来处理了，而且这代码和 <code>addView</code> 的极其类似。</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="updateViewLayout_28View_view_2C_ViewGroup-LayoutParams_params_29"><a href="#updateViewLayout_28View_view_2C_ViewGroup-LayoutParams_params_29" class="headerlink" title="updateViewLayout(View view, ViewGroup.LayoutParams params)"></a>updateViewLayout(View view, ViewGroup.LayoutParams params)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams)params;</span><br><span class="line"></span><br><span class="line">    view.setLayoutParams(wparams);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// 找到该 view 的索引</span></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">true</span>);</span><br><span class="line">        ViewRootImpl root = mRoots.get(index);</span><br><span class="line">        <span class="comment">// 替换 params</span></span><br><span class="line">        mParams.remove(index);</span><br><span class="line">        mParams.add(index, wparams);</span><br><span class="line">        root.setLayoutParams(wparams, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这代码也基本上一看就懂的。因为是更新 Window ，所以肯定是要替换 params 了。</p>
<p>之后就是调用 <code>ViewRootImpl.setLayoutParams</code> 来设置新的 params 。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setLayoutParams_28WindowManager-LayoutParams_attrs_2C_boolean_newView_29"><a href="#setLayoutParams_28WindowManager-LayoutParams_attrs_2C_boolean_newView_29" class="headerlink" title="setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)"></a>setLayoutParams(WindowManager.LayoutParams attrs, boolean newView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setLayoutParams</span><span class="params">(WindowManager.LayoutParams attrs, <span class="keyword">boolean</span> newView)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        applyKeepScreenOnFlag(mWindowAttributes);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 传入的 newView 是 false ，不执行这些代码</span></span><br><span class="line">        <span class="keyword">if</span> (newView) &#123;</span><br><span class="line">            mSoftInputMode = attrs.softInputMode;</span><br><span class="line">            requestLayout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Don't lose the mode we last auto-computed.</span></span><br><span class="line">        <span class="keyword">if</span> ((attrs.softInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)</span><br><span class="line">                == WindowManager.LayoutParams.SOFT_INPUT_ADJUST_UNSPECIFIED) &#123;</span><br><span class="line">            mWindowAttributes.softInputMode = (mWindowAttributes.softInputMode</span><br><span class="line">                    &amp; ~WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST)</span><br><span class="line">                    | (oldSoftInputMode &amp; WindowManager.LayoutParams.SOFT_INPUT_MASK_ADJUST);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mWindowAttributesChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">// 使 view 重走三大流程</span></span><br><span class="line">        scheduleTraversals();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setLayoutParams</code> 中，调用了 <code>scheduleTraversals()</code> 方法。</p>
<p>在之前讲 View 工作原理的时候，我们都看过 <code>scheduleTraversals()</code> 最后会调用 <code>performTraversals()</code> 来开始 View 的测量、布局和绘制。所以在这，也就触发了 View 重新去调整自己。</p>
<h3 id="performTraversals_28_29"><a href="#performTraversals_28_29" class="headerlink" title="performTraversals()"></a>performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	...</span><br><span class="line">	relayoutResult = relayoutWindow(params, viewVisibility, insetsPending);</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performTraversals()</code> 方法太长了，其他的都不看了，我们只注意这一句代码。</p>
<p>接着，在内部又调用了 <code>relayoutWindow(params, viewVisibility, insetsPending)</code> 方法。一看这方法名就知道这方法都干什么了。</p>
<h3 id="relayoutWindow_28_29"><a href="#relayoutWindow_28_29" class="headerlink" title="relayoutWindow()"></a>relayoutWindow()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(WindowManager.LayoutParams params, <span class="keyword">int</span> viewVisibility,</span><br><span class="line">        <span class="keyword">boolean</span> insetsPending)</span> <span class="keyword">throws</span> RemoteException </span>&#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 看得出来，这里又是调用 session 来走 IPC 流程，然后得到更新 window 的结果 relayoutResult</span></span><br><span class="line">    <span class="keyword">int</span> relayoutResult = mWindowSession.relayout(</span><br><span class="line">            mWindow, mSeq, params,</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredWidth() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            (<span class="keyword">int</span>) (mView.getMeasuredHeight() * appScale + <span class="number">0.5f</span>),</span><br><span class="line">            viewVisibility, insetsPending ? WindowManagerGlobal.RELAYOUT_INSETS_PENDING : <span class="number">0</span>,</span><br><span class="line">            mWinFrame, mPendingOverscanInsets, mPendingContentInsets, mPendingVisibleInsets,</span><br><span class="line">            mPendingStableInsets, mPendingOutsets, mPendingBackDropFrame, mPendingConfiguration,</span><br><span class="line">            mSurface);</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> relayoutResult;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>到了这一步，我们再次相遇熟悉的 <code>mWindowSession</code> 。</p>
<p>也知道了其实这是走了一个 IPC 的调用过程，在它内部肯定会利用 WindowManagerService 来完成 Window 的更新。</p>
<p>而 relayoutResult 就是这 IPC 最后返回的结果，也就是 Window 更新的结果。</p>
<p>虽然套路都懂了，但是有时候我们还是要吃。那么就去 Session 类中看看。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="relayout_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29"><a href="#relayout_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29" class="headerlink" title="relayout(IWindow window, int seq, WindowManager.LayoutParams attrs … )"></a>relayout(IWindow window, int seq, WindowManager.LayoutParams attrs … )</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayout</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        <span class="keyword">int</span> requestedWidth, <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewFlags,</span><br><span class="line">        <span class="keyword">int</span> flags, Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span><br><span class="line">        Rect outVisibleInsets, Rect outStableInsets, Rect outsets, Rect outBackdropFrame,</span><br><span class="line">        Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG_WM, <span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; ENTERED relayout from "</span></span><br><span class="line">            + Binder.getCallingPid());</span><br><span class="line">    <span class="keyword">int</span> res = mService.relayoutWindow(<span class="keyword">this</span>, window, seq, attrs,</span><br><span class="line">            requestedWidth, requestedHeight, viewFlags, flags,</span><br><span class="line">            outFrame, outOverscanInsets, outContentInsets, outVisibleInsets,</span><br><span class="line">            outStableInsets, outsets, outBackdropFrame, outConfig, outSurface);</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">false</span>) Slog.d(TAG_WM, <span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; EXITING relayout to "</span></span><br><span class="line">            + Binder.getCallingPid());</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和我们预想的一样，内部是调用了 mService ，也就是 WindowManagerService 。</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><h3 id="relayoutWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29"><a href="#relayoutWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs__u2026__29" class="headerlink" title="relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs … )"></a>relayoutWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs … )</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">relayoutWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">           WindowManager.LayoutParams attrs, <span class="keyword">int</span> requestedWidth,</span><br><span class="line">           <span class="keyword">int</span> requestedHeight, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> flags,</span><br><span class="line">           Rect outFrame, Rect outOverscanInsets, Rect outContentInsets,</span><br><span class="line">           Rect outVisibleInsets, Rect outStableInsets, Rect outOutsets, Rect outBackdropFrame,</span><br><span class="line">           Configuration outConfig, Surface outSurface)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">boolean</span> configChanged;</span><br><span class="line">       <span class="keyword">boolean</span> hasStatusBarPermission =</span><br><span class="line">               mContext.checkCallingOrSelfPermission(android.Manifest.permission.STATUS_BAR)</span><br><span class="line">                       == PackageManager.PERMISSION_GRANTED;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> origId = Binder.clearCallingIdentity();</span><br><span class="line">       <span class="keyword">synchronized</span>(mWindowMap) &#123;</span><br><span class="line">		<span class="comment">// 根据 session 和client 得到 windowState 对象</span></span><br><span class="line">           WindowState win = windowForClientLocked(session, client, <span class="keyword">false</span>);</span><br><span class="line">           <span class="keyword">if</span> (win == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 将属性进行相应的转换后保存到 WindowState</span></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">		<span class="comment">// 去更新  window</span></span><br><span class="line">		<span class="keyword">if</span> (viewVisibility == View.VISIBLE &amp;&amp;</span><br><span class="line">               (win.mAppToken == <span class="keyword">null</span> || !win.mAppToken.clientHidden)) &#123;</span><br><span class="line">            result = relayoutVisibleWindow(outConfig, result, win, winAnimator, attrChanges,</span><br><span class="line">                    oldVisibility);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                result = createSurfaceControl(outSurface, result, win, winAnimator);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                mInputMonitor.updateInputWindowsLw(<span class="keyword">true</span> <span class="comment">/*force*/</span>);</span><br><span class="line"></span><br><span class="line">                Slog.w(TAG_WM, <span class="string">"Exception thrown when creating surface for client "</span></span><br><span class="line">                         + client + <span class="string">" ("</span> + win.mAttrs.getTitle() + <span class="string">")"</span>,</span><br><span class="line">                         e);</span><br><span class="line">                Binder.restoreCallingIdentity(origId);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		...			</span><br><span class="line"></span><br><span class="line">           <span class="keyword">boolean</span> toBeDisplayed = (result &amp; WindowManagerGlobal.RELAYOUT_RES_FIRST_TIME) != <span class="number">0</span>;</span><br><span class="line">           <span class="keyword">if</span> (imMayMove &amp;&amp; (moveInputMethodWindowsIfNeededLocked(<span class="keyword">false</span>) || toBeDisplayed)) &#123;</span><br><span class="line">               <span class="comment">// Little hack here -- we -should- be able to rely on the</span></span><br><span class="line">               <span class="comment">// function to return true if the IME has moved and needs</span></span><br><span class="line">               <span class="comment">// its layer recomputed.  However, if the IME was hidden</span></span><br><span class="line">               <span class="comment">// and isn't actually moved in the list, its layer may be</span></span><br><span class="line">               <span class="comment">// out of data so we make sure to recompute it.</span></span><br><span class="line">               <span class="comment">// 如果窗口排序有改动，那么为 DisplayContent 的所有窗口分配最终的显示次序</span></span><br><span class="line">               mLayersController.assignLayersLocked(win.getWindowList());</span><br><span class="line">           &#125;</span><br><span class="line">		...</span><br><span class="line">		<span class="comment">// 更新 window 后设置一些变量</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>WMS 的 <code>relayoutWindow</code> 方法中，先得到了需要更新的 WindowState 对象，接着去执行更新。如果 Window 的显示次序变化了的话，需要重新分配次序。最后就是设置一些 Window 更新完成后的一些变量了。</p>
<p>而其他的代码太复杂了，学艺不精，不能全部分析出来。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>总之，Window 更新也和添加一样，都是通过 session 来调用 IPC 过程完成的。并且最终实现都是在 WindowManagerService 里。</p>
<p>至此，还有一篇 Window 删除还没分析。不用猜也知道，这流程肯定也是差不多的。但是我们还是要深入其中一探究竟。</p>
<p>今天就完结了，bye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/amwihihc/article/details/7992329" target="_blank" rel="external">Android源码分析之WindowManager.LayoutParams属性更新过程</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(二)：Window的添加机制]]></title>
    <link href="http://yuqirong.me/2017/10/08/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%BA%8C)%EF%BC%9AWindow%E7%9A%84%E6%B7%BB%E5%8A%A0%E6%9C%BA%E5%88%B6/"/>
    <id>http://yuqirong.me/2017/10/08/Window源码解析(二)：Window的添加机制/</id>
    <published>2017-10-08T07:34:03.000Z</published>
    <updated>2017-10-10T12:50:29.660Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a></p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>在上一篇中，我们讲了 Window 和 DecorView 的那些事，如果没有看过的同学请点击这里：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》</a>。</p>
<p>而今天就要来详细了解 Window 的添加机制了，到底在 WindowManager.addView 中做了什么事情？我们一起来看看吧！！</p>
<h1 id="Window_u7684_u6DFB_u52A0_u673A_u5236"><a href="#Window_u7684_u6DFB_u52A0_u673A_u5236" class="headerlink" title="Window的添加机制"></a>Window的添加机制</h1><p>上面我们看到了在 <code>makeVisible()</code> 中调用了 <code>wm.addView(mDecor, getWindow().getAttributes())</code> 将 DecorView 视图添加到 Window 上。</p>
<p>那么调用这句代码之后究竟发生了什么呢，这就需要我们一步一步慢慢去揭开了。</p>
<h2 id="WindowManager"><a href="#WindowManager" class="headerlink" title="WindowManager"></a>WindowManager</h2><p>WindowManager 是一个接口，继承了 ViewManager 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ViewManager</span></span><br><span class="line"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">updateViewLayout</span><span class="params">(View view, ViewGroup.LayoutParams params)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">removeView</span><span class="params">(View view)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，ViewManager 中定义的方法非常熟悉，也是平时我们经常使用的，就是对 View 的增删改。</p>
<p>对 WindowManager 具体的实现就是 WindowManagerImpl 这个类了。在后面我们会接触到它的。</p>
<p>那么，我们就开始吧。</p>
<h2 id="WindowManagerImpl"><a href="#WindowManagerImpl" class="headerlink" title="WindowManagerImpl"></a>WindowManagerImpl</h2><h3 id="addView_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29"><a href="#addView_28@NonNull_View_view_2C_@NonNull_ViewGroup-LayoutParams_params_29" class="headerlink" title="addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params)"></a>addView(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(@NonNull View view, @NonNull ViewGroup.LayoutParams params)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查是否需要使用默认的 token ，token 就是一个 binder 对象</span></span><br><span class="line">    <span class="comment">// 如果没有父 window ，那么我们需要使用默认的 token</span></span><br><span class="line">    applyDefaultToken(params);</span><br><span class="line">    <span class="comment">// 调用 WindowManagerGlobal 来实现添加 view</span></span><br><span class="line">    mGlobal.addView(view, params, mContext.getDisplay(), mParentWindow);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 WindowManagerImpl 也没有直接实现 View 的添加，而是转交给了 WindowManagerGlobal 类来做这件事。其实除了 <code>addView</code> 之外，<code>updateViewLayout</code> 和 <code>removeView</code> 也都是通过 WindowManagerGlobal 来实现的，这是桥接模式的体现。</p>
<p>那么我们继续跟下去。</p>
<h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29"><a href="#addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29" class="headerlink" title="addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)"></a>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addView</span><span class="params">(View view, ViewGroup.LayoutParams params,</span><br><span class="line">        Display display, Window parentWindow)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查参数有无错误，如果是子 window 的话要调整一些参数</span></span><br><span class="line">    <span class="keyword">if</span> (view == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"view must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (display == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"display must not be null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!(params <span class="keyword">instanceof</span> WindowManager.LayoutParams)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Params must be WindowManager.LayoutParams"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> WindowManager.LayoutParams wparams = (WindowManager.LayoutParams) params;</span><br><span class="line">    <span class="keyword">if</span> (parentWindow != <span class="keyword">null</span>) &#123;</span><br><span class="line">        parentWindow.adjustLayoutParamsForSubWindow(wparams);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If there's no parent, then hardware acceleration for this view is</span></span><br><span class="line">        <span class="comment">// set from the application's hardware acceleration setting.</span></span><br><span class="line">        <span class="keyword">final</span> Context context = view.getContext();</span><br><span class="line">        <span class="keyword">if</span> (context != <span class="keyword">null</span></span><br><span class="line">                &amp;&amp; (context.getApplicationInfo().flags</span><br><span class="line">                        &amp; ApplicationInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>) &#123;</span><br><span class="line">            wparams.flags |= WindowManager.LayoutParams.FLAG_HARDWARE_ACCELERATED;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ViewRootImpl root;</span><br><span class="line">    View panelParentView = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">        <span class="comment">// Start watching for system property changes.</span></span><br><span class="line">        <span class="keyword">if</span> (mSystemPropertyUpdater == <span class="keyword">null</span>) &#123;</span><br><span class="line">            mSystemPropertyUpdater = <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (<span class="keyword">int</span> i = mRoots.size() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">                            mRoots.get(i).loadSystemProperties();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;;</span><br><span class="line">            SystemProperties.addChangeCallback(mSystemPropertyUpdater);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (mDyingViews.contains(view)) &#123;</span><br><span class="line">                <span class="comment">// Don't wait for MSG_DIE to make it's way through root's queue.</span></span><br><span class="line">                mRoots.get(index).doDie();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"View "</span> + view</span><br><span class="line">                        + <span class="string">" has already been added to the window manager."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// The previous removeView() had not completed executing. Now it has.</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this is a panel window, then find the window it is being</span></span><br><span class="line">        <span class="comment">// attached to for future reference.</span></span><br><span class="line">        <span class="keyword">if</span> (wparams.type &gt;= WindowManager.LayoutParams.FIRST_SUB_WINDOW &amp;&amp;</span><br><span class="line">                wparams.type &lt;= WindowManager.LayoutParams.LAST_SUB_WINDOW) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> count = mViews.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (mRoots.get(i).mWindow.asBinder() == wparams.token) &#123;</span><br><span class="line">                    panelParentView = mViews.get(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建新的 viewrootimpl</span></span><br><span class="line">        root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line"></span><br><span class="line">        view.setLayoutParams(wparams);</span><br><span class="line">        <span class="comment">// 保存当前界面这些参数</span></span><br><span class="line">        <span class="comment">// mViews 存储所有 window 所对应的 view</span></span><br><span class="line">        mViews.add(view);</span><br><span class="line">        <span class="comment">// mRoots 存储所有 window 所对应的 ViewRootImpl</span></span><br><span class="line">        mRoots.add(root);</span><br><span class="line">        <span class="comment">// mParams 存储所有 window 所对应的布局参数</span></span><br><span class="line">        mParams.add(wparams);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// do this last because it fires off messages to start doing things</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 setview 来开始 view 的测量 布局 绘制流程，完成 window 的添加</span></span><br><span class="line">        root.setView(view, wparams, panelParentView);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// BadTokenException or InvalidDisplayException, clean up.</span></span><br><span class="line">        <span class="keyword">synchronized</span> (mLock) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> index = findViewLocked(view, <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                removeViewLocked(index, <span class="keyword">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code> 中，我们捋一捋它干了什么事：</p>
<ol>
<li>检查了参数，如果是子 Window 的话，还要调整参数；</li>
<li>创建 ViewRootImpl ，然后将当前界面的参数保存起来；</li>
<li>调用 ViewRootImpl 的 setView 来更新界面并完成 Window 的添加；</li>
</ol>
<p>可以看出，Window 的添加还需要我们到 <code>ViewRootImpl.setView</code> 中去看，同时也即将开启 View 三大工作流程。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29"><a href="#setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29" class="headerlink" title="setView(View view, WindowManager.LayoutParams attrs, View panelParentView)"></a>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">           <span class="comment">// 开始了 view 的三大工作流程</span></span><br><span class="line">           ...</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">               mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">               collectViewAttributes();</span><br><span class="line">               <span class="comment">// 利用 mWindowSession 来添加 window ，是一个 IPC 的过程</span></span><br><span class="line">               res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes,</span><br><span class="line">                       getHostVisibility(), mDisplay.getDisplayId(),</span><br><span class="line">                       mAttachInfo.mContentInsets, mAttachInfo.mStableInsets,</span><br><span class="line">                       mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">           &#125; <span class="keyword">catch</span> (RemoteException e) &#123;</span><br><span class="line">               mAdded = <span class="keyword">false</span>;</span><br><span class="line">               mView = <span class="keyword">null</span>;</span><br><span class="line">               mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">               mInputChannel = <span class="keyword">null</span>;</span><br><span class="line">               mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">               unscheduleTraversals();</span><br><span class="line">               setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Adding window failed"</span>, e);</span><br><span class="line">           &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (restore) &#123;</span><br><span class="line">                   attrs.restore();</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 检查 IPC 的结果，若不是 ADD_OKAY ，就说明添加 window 失败</span></span><br><span class="line">	<span class="keyword">if</span> (res &lt; WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">               mAttachInfo.mRootView = <span class="keyword">null</span>;</span><br><span class="line">               mAdded = <span class="keyword">false</span>;</span><br><span class="line">               mFallbackEventHandler.setView(<span class="keyword">null</span>);</span><br><span class="line">               unscheduleTraversals();</span><br><span class="line">               setAccessibilityFocus(<span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">               <span class="keyword">switch</span> (res) &#123;</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_APP_TOKEN:</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_BAD_SUBWINDOW_TOKEN:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is not valid; is your activity running?"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_NOT_APP_TOKEN:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is not for an application"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_APP_EXITING:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- app for token "</span> + attrs.token</span><br><span class="line">                               + <span class="string">" is exiting"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_DUPLICATE_ADD:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(</span><br><span class="line">                               <span class="string">"Unable to add window -- window "</span> + mWindow</span><br><span class="line">                               + <span class="string">" has already been added"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_STARTING_NOT_NEEDED:</span><br><span class="line">                       <span class="comment">// Silently ignore -- we would have just removed it</span></span><br><span class="line">                       <span class="comment">// right away, anyway.</span></span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_MULTIPLE_SINGLETON:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- another window of type "</span></span><br><span class="line">                               + mWindowAttributes.type + <span class="string">" already exists"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_PERMISSION_DENIED:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.BadTokenException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- permission denied for window type "</span></span><br><span class="line">                               + mWindowAttributes.type);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_INVALID_DISPLAY:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.InvalidDisplayException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- the specified display can not be found"</span>);</span><br><span class="line">                   <span class="keyword">case</span> WindowManagerGlobal.ADD_INVALID_TYPE:</span><br><span class="line">                       <span class="keyword">throw</span> <span class="keyword">new</span> WindowManager.InvalidDisplayException(<span class="string">"Unable to add window "</span></span><br><span class="line">                               + mWindow + <span class="string">" -- the specified window type "</span></span><br><span class="line">                               + mWindowAttributes.type + <span class="string">" is not valid"</span>);</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(</span><br><span class="line">                       <span class="string">"Unable to add window -- unknown error code "</span> + res);</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">		...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里，View 也开始了测量、布局、绘制的三大流程。</p>
<p>之后，利用 <code>mWindowSession</code> 来添加 window ，<code>mWindowSession</code> 的类型是 IWindowSession ，它是一个 Binder 对象，其真正的实现类是 Session 。所以这是一个 IPC 的过程。这步具体的实现我们下面再看。</p>
<p>在添加完成后，根据返回值 res 来判断添加 window 是否成功。若不是 WindowManagerGlobal.ADD_OKAY 则说明添加失败了，抛出对应的异常。</p>
<h2 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h2><h3 id="addToDisplay_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29"><a href="#addToDisplay_28IWindow_window_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29" class="headerlink" title="addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)"></a>addToDisplay(IWindow window, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addToDisplay</span><span class="params">(IWindow window, <span class="keyword">int</span> seq, WindowManager.LayoutParams attrs,</span><br><span class="line">        <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId, Rect outContentInsets, Rect outStableInsets,</span><br><span class="line">        Rect outOutsets, InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mService.addWindow(<span class="keyword">this</span>, window, seq, attrs, viewVisibility, displayId,</span><br><span class="line">            outContentInsets, outStableInsets, outOutsets, outInputChannel);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Session 中，发现添加 Window 的操作交给了 mService ，而 mService 其实就是 WindowManagerService 。终于来到了最终 boss 这里了，那我们直击要害吧！</p>
<h2 id="WindowManagerService"><a href="#WindowManagerService" class="headerlink" title="WindowManagerService"></a>WindowManagerService</h2><h3 id="addWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29"><a href="#addWindow_28Session_session_2C_IWindow_client_2C_int_seq_2C_WindowManager-LayoutParams_attrs_2C_int_viewVisibility_2C_int_displayId_2C_Rect_outContentInsets_2C_Rect_outStableInsets_2C_Rect_outOutsets_2C_InputChannel_outInputChannel_29" class="headerlink" title="addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)"></a>addWindow(Session session, IWindow client, int seq, WindowManager.LayoutParams attrs, int viewVisibility, int displayId, Rect outContentInsets, Rect outStableInsets, Rect outOutsets, InputChannel outInputChannel)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">addWindow</span><span class="params">(Session session, IWindow client, <span class="keyword">int</span> seq,</span><br><span class="line">        WindowManager.LayoutParams attrs, <span class="keyword">int</span> viewVisibility, <span class="keyword">int</span> displayId,</span><br><span class="line">        Rect outContentInsets, Rect outStableInsets, Rect outOutsets,</span><br><span class="line">        InputChannel outInputChannel)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] appOp = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">1</span>];</span><br><span class="line">    <span class="comment">// 校验 window 的权限，如果不是 ADD_OKAY 就不通过</span></span><br><span class="line">    <span class="keyword">int</span> res = mPolicy.checkAddPermission(attrs, appOp);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">			</span><br><span class="line">    <span class="comment">// 初步校验一些参数，不通过就会返回错误的 res 值 </span></span><br><span class="line">    <span class="comment">// 比如检查子窗口，就要求父窗口必须已经存在等</span></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> addToken = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 拿到 layoutparams.token ，进行校验</span></span><br><span class="line">    WindowToken token = mTokenMap.get(attrs.token);</span><br><span class="line">    AppWindowToken atoken = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">boolean</span> addToastWindowRequiresToken = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 校验 token 有效性， 如果 token 为空或不正确的话，那么直接返回 ADD_BAD_APP_TOKEN 等异常</span></span><br><span class="line">    <span class="keyword">if</span> (token == <span class="keyword">null</span>) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (...) &#123;</span><br><span class="line">        ...</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (token.appWindowToken != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Slog.w(TAG_WM, <span class="string">"Non-null appWindowToken for system window of type="</span> + type);</span><br><span class="line">        <span class="comment">// It is not valid to use an app token with other system types; we will</span></span><br><span class="line">        <span class="comment">// instead make a new token for it (as if null had been passed in for the token).</span></span><br><span class="line">        attrs.token = <span class="keyword">null</span>;</span><br><span class="line">        token = <span class="keyword">new</span> WindowToken(<span class="keyword">this</span>, <span class="keyword">null</span>, -<span class="number">1</span>, <span class="keyword">false</span>);</span><br><span class="line">        addToken = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 为新窗口创建了新的 WindowState 对象</span></span><br><span class="line">    WindowState win = <span class="keyword">new</span> WindowState(<span class="keyword">this</span>, session, client, token,</span><br><span class="line">                attachedWindow, appOp[<span class="number">0</span>], seq, attrs, viewVisibility, displayContent);</span><br><span class="line"></span><br><span class="line">    res = mPolicy.prepareAddWindowLw(win, attrs);</span><br><span class="line">    <span class="keyword">if</span> (res != WindowManagerGlobal.ADD_OKAY) &#123;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (type == TYPE_INPUT_METHOD) &#123;</span><br><span class="line">        win.mGivenInsetsPending = <span class="keyword">true</span>;</span><br><span class="line">        mInputMethodWindow = win;</span><br><span class="line">        addInputMethodWindowToListLocked(win);</span><br><span class="line">        imMayMove = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (type == TYPE_INPUT_METHOD_DIALOG) &#123;</span><br><span class="line">        mInputMethodDialogs.add(win);</span><br><span class="line">        <span class="comment">// 将新的 WindowState 按显示次序插入到当前 DisplayContent 的 mWindows 列表中</span></span><br><span class="line">        addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">        moveInputMethodDialogsLocked(findDesiredInputMethodWindowIndexLocked(<span class="keyword">true</span>));</span><br><span class="line">        imMayMove = <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 将新的 WindowState 按显示次序插入到当前 DisplayContent 的 mWindows 列表中</span></span><br><span class="line">        addWindowToListInOrderLocked(win, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (type == TYPE_WALLPAPER) &#123;</span><br><span class="line">            mWallpaperControllerLocked.clearLastWallpaperTimeoutTime();</span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((attrs.flags&amp;FLAG_SHOW_WALLPAPER) != <span class="number">0</span>) &#123;</span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (mWallpaperControllerLocked.isBelowWallpaperTarget(win)) &#123;</span><br><span class="line">            <span class="comment">// If there is currently a wallpaper being shown, and</span></span><br><span class="line">            <span class="comment">// the base layer of the new window is below the current</span></span><br><span class="line">            <span class="comment">// layer of the target window, then adjust the wallpaper.</span></span><br><span class="line">            <span class="comment">// This is to avoid a new window being placed between the</span></span><br><span class="line">            <span class="comment">// wallpaper and its target.</span></span><br><span class="line">            displayContent.pendingLayoutChanges |= FINISH_LAYOUT_REDO_WALLPAPER;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据窗口的排序结果，为 DisplayContent 的所有窗口分配最终的显示次序</span></span><br><span class="line">    mLayersController.assignLayersLocked(displayContent.getWindowList());</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 返回添加窗口的结果</span></span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 WindowManagerService 中做的事情有很多，一开始利用 <code>mPolicy.checkAddPermission</code> 检查了权限，这里面可大有文章，利用 <code>type = WindowManager.LayoutParams.TYPE_TOAST</code> 来跳过权限显示悬浮窗的故事就来自于这里。想详细了解的同学请看<a href="http://blog.csdn.net/self_study/article/details/52859790" target="_blank" rel="external">《Android 悬浮窗权限各机型各系统适配大全》</a>。</p>
<p>然后就是校验了一些参数，比如 token 。token 是用来表示窗口的一个令牌，其实是一个 Binder 对象。只有符合条件的 token 才能被 WindowManagerService 通过并添加到应用上。</p>
<p>再然后就是创建了一个 WindowState 对象，利用这个对象按照显示次序插入 mWindows 列表中，最后就是依据排序来确定窗口的最终显示次序。并返回了 Window 添加的结果 res 。</p>
<p>到这，整个添加 Window 的过程就结束了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>Window 添加其实就是一个 IPC 的过程，而更新和删除 Window 也是如此，基本上步骤都是相似的。</p>
<p>接下来就顺便把 Window 更新和删除的流程都梳理一遍吧。</p>
<p>静静等待此系列第三篇出炉！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://blog.csdn.net/innost/article/details/47660193" target="_blank" rel="external">《深入理解Android 卷III》第四章 深入理解WindowManagerService</a></li>
<li><a href="http://blog.csdn.net/self_study/article/details/52859790" target="_blank" rel="external">Android 悬浮窗权限各机型各系统适配大全</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<p>第一篇：<a href="/2017/09/28/Window源码解析(一)：与DecorView的那些事/">《Window源码解析(一)：与DecorView的那些事》<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Window源码解析(一)：与DecorView的那些事]]></title>
    <link href="http://yuqirong.me/2017/09/28/Window%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90(%E4%B8%80)%EF%BC%9A%E4%B8%8EDecorView%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://yuqirong.me/2017/09/28/Window源码解析(一)：与DecorView的那些事/</id>
    <published>2017-09-28T06:39:03.000Z</published>
    <updated>2017-11-04T06:02:33.675Z</updated>
    <content type="html"><![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>今天我们来讲讲 Window ，Window 代表着一个窗口。</p>
<p>比如在 Activity 中，我们可以设置自定义的视图 View ，其实 View 并不是直接附着在 Activity 上，而是 View 附着在 Window 上，Activity 又持有一个 Window 对象。可见，Window 是一个重要的角色，主要用来负责管理 View 的。而 Window 和 View 又是通过 ViewRootImpl 来建立联系的，这在之前的<a href="/2017/09/18/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/">《View的工作原理》</a>中介绍过。</p>
<p>所以一个 Window 就对应着一个 View 和一个 ViewRootImpl 。</p>
<p>同理，Dialog 和 Toast 等的视图也都是附着在 Window 上。</p>
<p>除此之外，相信看过《Android开发艺术探索》的同学都知道。Window 有三种类型，分别对应着：</p>
<ol>
<li>应用 Window ，即 Activity 的 Window 。对应的 type 为1~99；</li>
<li>子 Window ，比如 Dialog 的 Window ，子 Window 并不能单独存在，需要有父 Window 的支持。对应的 type 为1000~1999；</li>
<li>系统 Window ，需要权限声明才可以创建，比如常用的 Toast 和状态栏等都是系统级别的 Window。对应的 type 为2000~2999；</li>
</ol>
<p>这三种 Window 的区分方法就是依靠 WindowManager.LayoutParams 中的 type 来决定的。type 越大，Window 就越显示在层级顶部。</p>
<p>粗看有这么多知识点，所以我们确实有必要对 Window 好好深入了解一下。在这，我们先详细介绍一下 Window 和 Activity 的那些“纠葛”，然后再深入 Window 的内部机制。</p>
<h1 id="u521D_u89C1Window"><a href="#u521D_u89C1Window" class="headerlink" title="初见Window"></a>初见Window</h1><h2 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h2><h3 id="attach_28Context_context_2C_ActivityThread_aThread_2C__u2026_29"><a href="#attach_28Context_context_2C_ActivityThread_aThread_2C__u2026_29" class="headerlink" title="attach(Context context, ActivityThread aThread, …)"></a>attach(Context context, ActivityThread aThread, …)</h3><p>Window 第一次出现在 Activity 的视野中，是在 Activity 的 <code>attach</code> 方法中，具体代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Context context, ActivityThread aThread,</span><br><span class="line">        Instrumentation instr, IBinder token, <span class="keyword">int</span> ident,</span><br><span class="line">        Application application, Intent intent, ActivityInfo info,</span><br><span class="line">        CharSequence title, Activity parent, String id,</span><br><span class="line">        NonConfigurationInstances lastNonConfigurationInstances,</span><br><span class="line">        Configuration config, String referrer, IVoiceInteractor voiceInteractor,</span><br><span class="line">        Window window)</span> </span>&#123;</span><br><span class="line">    attachBaseContext(context);</span><br><span class="line"></span><br><span class="line">    mFragments.attachHost(<span class="keyword">null</span> <span class="comment">/*parent*/</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建 window 对象</span></span><br><span class="line">    mWindow = <span class="keyword">new</span> PhoneWindow(<span class="keyword">this</span>, window);</span><br><span class="line">    mWindow.setWindowControllerCallback(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 设置回调，用来回调接收触摸、按键等事件</span></span><br><span class="line">    mWindow.setCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.setOnWindowDismissedCallback(<span class="keyword">this</span>);</span><br><span class="line">    mWindow.getLayoutInflater().setPrivateFactory(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) &#123;</span><br><span class="line">        mWindow.setSoftInputMode(info.softInputMode);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (info.uiOptions != <span class="number">0</span>) &#123;</span><br><span class="line">        mWindow.setUiOptions(info.uiOptions);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置窗口管理器，其实是创建了 WindowManagerImpl 对象</span></span><br><span class="line">    <span class="comment">// WindowManager 是接口，而 WindowManagerImpl 是 WindowManger 的实现类</span></span><br><span class="line">    mWindow.setWindowManager(</span><br><span class="line">            (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),</span><br><span class="line">            mToken, mComponent.flattenToString(),</span><br><span class="line">            (info.flags &amp; ActivityInfo.FLAG_HARDWARE_ACCELERATED) != <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (mParent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mWindow.setContainer(mParent.getWindow());</span><br><span class="line">    &#125;</span><br><span class="line">    mWindowManager = mWindow.getWindowManager();</span><br><span class="line">    mCurrentConfig = config;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法中创建了一个 PhoneWindow 对象，而 PhoneWindow 其实就是 Window 的具体实现类，Window 只是一个接口而已。之后设置了回调，这样当 Window 接收到触摸或者按键等事件后，会回调给 Activity 。</p>
<p>另外还给 Window 对象设置了窗口管理器，也就是我们经常用到的 WindowManager 。</p>
<p>WindowManager 是外界接触 Window 的入口，也就是说，想要对 Window 进行一些操作需要用过 WindowManager 来完成。</p>
<h1 id="u4E0EDecorView_u7684_u90A3_u4E9B_u4E8B"><a href="#u4E0EDecorView_u7684_u90A3_u4E9B_u4E8B" class="headerlink" title="与DecorView的那些事"></a>与DecorView的那些事</h1><p>在开头中说到，Window 是用来负责管理 View 的。</p>
<p>现在 Window 已经创建完毕了，那么到底什么时候与 View 发生了交集了呢？</p>
<p>我们需要深入到 <code>onCreate()</code> 中一个熟悉的方法： <code>setContentView(R.layout.activity_main)</code> 。</p>
<h2 id="Activity-1"><a href="#Activity-1" class="headerlink" title="Activity"></a>Activity</h2><h3 id="setContentView_28@LayoutRes_int_layoutResID_29"><a href="#setContentView_28@LayoutRes_int_layoutResID_29" class="headerlink" title="setContentView(@LayoutRes int layoutResID)"></a>setContentView(@LayoutRes int layoutResID)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(@LayoutRes <span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里 getWindow 得到的正是上面创建的 PhoneWindow 对象</span></span><br><span class="line">    getWindow().setContentView(layoutResID);</span><br><span class="line">    initWindowDecorActionBar();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现它调用的是 Window 中的同名方法。</p>
<p>接着到 PhoneWindow 中跟进，查看具体实现的逻辑。</p>
<h2 id="PhoneWindow"><a href="#PhoneWindow" class="headerlink" title="PhoneWindow"></a>PhoneWindow</h2><h3 id="setContentView_28int_layoutResID_29"><a href="#setContentView_28int_layoutResID_29" class="headerlink" title="setContentView(int layoutResID)"></a>setContentView(int layoutResID)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">      <span class="comment">// Note: FEATURE_CONTENT_TRANSITIONS may be set in the process of installing the window</span></span><br><span class="line">      <span class="comment">// decor, when theme attributes and the like are crystalized. Do not check the feature</span></span><br><span class="line">      <span class="comment">// before this happens.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// mContentParent 是放置窗口内容的父 viewgroup ，可能是 decorView 本身，也有可能是它的子 viewgroup</span></span><br><span class="line"><span class="comment">// 如果 mContentParent 是空的，那么就说明 decorView 是空的</span></span><br><span class="line">      <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">	<span class="comment">// 创建 decorview</span></span><br><span class="line">          installDecor();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">          mContentParent.removeAllViews();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (hasFeature(FEATURE_CONTENT_TRANSITIONS)) &#123;</span><br><span class="line">          <span class="keyword">final</span> Scene newScene = Scene.getSceneForLayout(mContentParent, layoutResID,</span><br><span class="line">                  getContext());</span><br><span class="line">          transitionTo(newScene);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="comment">// 将 layout 布局加入到 mContentParent 中并去解析 layout xml 文件</span></span><br><span class="line">          mLayoutInflater.inflate(layoutResID, mContentParent);</span><br><span class="line">      &#125;</span><br><span class="line">      mContentParent.requestApplyInsets();</span><br><span class="line"><span class="comment">// 通知 activity 窗口内容已经发生变化了</span></span><br><span class="line">      <span class="keyword">final</span> Callback cb = getCallback();</span><br><span class="line">      <span class="keyword">if</span> (cb != <span class="keyword">null</span> &amp;&amp; !isDestroyed()) &#123;</span><br><span class="line">          cb.onContentChanged();</span><br><span class="line">      &#125;</span><br><span class="line">      mContentParentExplicitlySet = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setContentView(int layoutResID)</code> 中，一开始判断了 mContentParent 。mContentParent 其实就是我们设置的 contentView 的父视图。</p>
<p>关于 mContentParent ，在 PhoneWindow 中有注释：</p>
<pre><code>// This is the view in which the window contents are placed. It is either
// mDecor itself, or a child of mDecor where the contents go.
</code></pre><p>意思就是说，当我们不需要 titlebar 的时候，mContentParent 其实就和 DecorView 一样了；有 titlebar 的时候，DecorView 的内容就分为了 titlebar 和 mContentParent 。</p>
<p>所以如果 mContentParent 为空，那么可以说明还没有创建过 DecorView 。</p>
<p>我们总结一下，在 <code>setContentView(int layoutResID)</code> 中主要就是这三件事：</p>
<ol>
<li>创建 DecorView 视图对象；</li>
<li>将自定义的视图 layout_main.xml 进行解析并添加到 mContentParent 中；</li>
<li>去通知 activity 窗口视图已经改变了，进行相关操作；</li>
</ol>
<p>我们去 <code>installDecor()</code> 中看看究竟怎么创建 DecorView 的。</p>
<h3 id="installDecor_28_29"><a href="#installDecor_28_29" class="headerlink" title="installDecor()"></a>installDecor()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">installDecor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    mForceDecorInstall = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (mDecor == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果 decorview 为空，调用 generateDecor 来创建 decorview</span></span><br><span class="line">        mDecor = generateDecor(-<span class="number">1</span>);</span><br><span class="line">        mDecor.setDescendantFocusability(ViewGroup.FOCUS_AFTER_DESCENDANTS);</span><br><span class="line">        mDecor.setIsRootNamespace(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (!mInvalidatePanelMenuPosted &amp;&amp; mInvalidatePanelMenuFeatures != <span class="number">0</span>) &#123;</span><br><span class="line">            mDecor.postOnAnimation(mInvalidatePanelMenuRunnable);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mDecor.setWindow(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (mContentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 创建 mContentParent ，也就是 contentView 的父视图</span></span><br><span class="line">        mContentParent = generateLayout(mDecor);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Set up decor part of UI to ignore fitsSystemWindows if appropriate.</span></span><br><span class="line">        mDecor.makeOptionalFitsSystemWindows();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> DecorContentParent decorContentParent = (DecorContentParent) mDecor.findViewById(</span><br><span class="line">                R.id.decor_content_parent);</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>installDecor()</code> 中，调用了 <code>generateDecor()</code> 方法来创建 DecorView；</p>
<p>之后又调用 <code>generateLayout(mDecor)</code> 来创建 mContentParent 。</p>
<h3 id="generateDecor_28int_featureId_29"><a href="#generateDecor_28int_featureId_29" class="headerlink" title="generateDecor(int featureId)"></a>generateDecor(int featureId)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> DecorView <span class="title">generateDecor</span><span class="params">(<span class="keyword">int</span> featureId)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// System process doesn't have application context and in that case we need to directly use</span></span><br><span class="line">    <span class="comment">// the context we have. Otherwise we want the application context, so we don't cling to the</span></span><br><span class="line">    <span class="comment">// activity.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到 context 上下文</span></span><br><span class="line">    Context context;</span><br><span class="line">    <span class="keyword">if</span> (mUseDecorContext) &#123;</span><br><span class="line">        Context applicationContext = getContext().getApplicationContext();</span><br><span class="line">        <span class="keyword">if</span> (applicationContext == <span class="keyword">null</span>) &#123;</span><br><span class="line">            context = getContext();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            context = <span class="keyword">new</span> DecorContext(applicationContext, getContext().getResources());</span><br><span class="line">            <span class="keyword">if</span> (mTheme != -<span class="number">1</span>) &#123;</span><br><span class="line">                context.setTheme(mTheme);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        context = getContext();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 DecorView 对象</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> DecorView(context, featureId, <span class="keyword">this</span>, getAttributes());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>generateDecor(int featureId)</code> 方法比较简单，之前初始化了一下 context ，然后直接 new 了一个 DecorView 完事！</p>
<h3 id="generateLayout_28DecorView_decor_29"><a href="#generateLayout_28DecorView_decor_29" class="headerlink" title="generateLayout(DecorView decor)"></a>generateLayout(DecorView decor)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> ViewGroup <span class="title">generateLayout</span><span class="params">(DecorView decor)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 应用当前的主题，比如设置一些 window 属性等</span></span><br><span class="line">    ... </span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据主题设置去选择 layoutResource</span></span><br><span class="line">    <span class="comment">// 这个 layoutResource 也就是 DecorView 的子 View 的布局</span></span><br><span class="line">    <span class="keyword">int</span> layoutResource;</span><br><span class="line">    <span class="keyword">int</span> features = getLocalFeatures();</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_NO_TITLE)) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// If no other features and not embedded, only need a title.</span></span><br><span class="line">        <span class="comment">// If the window is floating, we need a dialog layout</span></span><br><span class="line">        <span class="keyword">if</span> (mIsFloating) &#123;</span><br><span class="line">            TypedValue res = <span class="keyword">new</span> TypedValue();</span><br><span class="line">            getContext().getTheme().resolveAttribute(</span><br><span class="line">                    R.attr.dialogTitleDecorLayout, res, <span class="keyword">true</span>);</span><br><span class="line">            layoutResource = res.resourceId;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_BAR)) != <span class="number">0</span>) &#123;</span><br><span class="line">            layoutResource = a.getResourceId(</span><br><span class="line">                    R.styleable.Window_windowActionBarFullscreenDecorLayout,</span><br><span class="line">                    R.layout.screen_action_bar);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 比较常见的就是这种布局</span></span><br><span class="line">            layoutResource = R.layout.screen_title;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// System.out.println("Title!");</span></span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_ACTION_MODE_OVERLAY)) != <span class="number">0</span>) &#123;</span><br><span class="line">        layoutResource = R.layout.screen_simple_overlay_action_mode;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Embedded, so no decoration is needed.</span></span><br><span class="line">        layoutResource = R.layout.screen_simple;</span><br><span class="line">        <span class="comment">// System.out.println("Simple!");</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.startChanging();</span><br><span class="line">    <span class="comment">// 这个方法里将上面 layoutResource 的布局转换并添加到 DecorVew 中</span></span><br><span class="line">    mDecor.onResourcesLoaded(mLayoutInflater, layoutResource);</span><br><span class="line">    <span class="comment">// 得到 contentParent（id = android.R.id.content）, 也就是我们 setContentView 的父视图</span></span><br><span class="line">    ViewGroup contentParent = (ViewGroup)findViewById(ID_ANDROID_CONTENT);</span><br><span class="line">    <span class="keyword">if</span> (contentParent == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Window couldn't find content container view"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_INDETERMINATE_PROGRESS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        ProgressBar progress = getCircularProgressBar(<span class="keyword">false</span>);</span><br><span class="line">        <span class="keyword">if</span> (progress != <span class="keyword">null</span>) &#123;</span><br><span class="line">            progress.setIndeterminate(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((features &amp; (<span class="number">1</span> &lt;&lt; FEATURE_SWIPE_TO_DISMISS)) != <span class="number">0</span>) &#123;</span><br><span class="line">        registerSwipeCallbacks();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Remaining setup -- of background and title -- that only applies</span></span><br><span class="line">    <span class="comment">// to top-level windows.</span></span><br><span class="line">    <span class="comment">// 背景设置和标题设置</span></span><br><span class="line">    <span class="keyword">if</span> (getContainer() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> Drawable background;</span><br><span class="line">        <span class="keyword">if</span> (mBackgroundResource != <span class="number">0</span>) &#123;</span><br><span class="line">            background = getContext().getDrawable(mBackgroundResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            background = mBackgroundDrawable;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowBackground(background);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> Drawable frame;</span><br><span class="line">        <span class="keyword">if</span> (mFrameResource != <span class="number">0</span>) &#123;</span><br><span class="line">            frame = getContext().getDrawable(mFrameResource);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            frame = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mDecor.setWindowFrame(frame);</span><br><span class="line"></span><br><span class="line">        mDecor.setElevation(mElevation);</span><br><span class="line">        mDecor.setClipToOutline(mClipToOutline);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitle != <span class="keyword">null</span>) &#123;</span><br><span class="line">            setTitle(mTitle);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mTitleColor == <span class="number">0</span>) &#123;</span><br><span class="line">            mTitleColor = mTextColor;</span><br><span class="line">        &#125;</span><br><span class="line">        setTitleColor(mTitleColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecor.finishChanging();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> contentParent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法中大致的逻辑就是，根据主题的设置情况来选择 DecorView 子 View 的 layoutResource 。在这，我们就看看最常用的一种布局 R.layout.screen_title (位于 /frameworks/base/core/res/res/layout/screen_title.xml ):</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">LinearLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:orientation</span>=<span class="value">"vertical"</span></span><br><span class="line">    <span class="attribute">android:fitsSystemWindows</span>=<span class="value">"true"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- Popout bar for action modes --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">ViewStub</span> <span class="attribute">android:id</span>=<span class="value">"@+id/action_mode_bar_stub"</span></span><br><span class="line">              <span class="attribute">android:inflatedId</span>=<span class="value">"@+id/action_mode_bar"</span></span><br><span class="line">              <span class="attribute">android:layout</span>=<span class="value">"@layout/action_mode_bar"</span></span><br><span class="line">              <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">              <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span></span><br><span class="line">              <span class="attribute">android:theme</span>=<span class="value">"?attr/actionBarTheme"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">FrameLayout</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span> </span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"?android:attr/windowTitleSize"</span></span><br><span class="line">        <span class="attribute">style</span>=<span class="value">"?android:attr/windowTitleBackgroundStyle"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">TextView</span> <span class="attribute">android:id</span>=<span class="value">"@android:id/title"</span> </span><br><span class="line">            <span class="attribute">style</span>=<span class="value">"?android:attr/windowTitleStyle"</span></span><br><span class="line">            <span class="attribute">android:background</span>=<span class="value">"@null"</span></span><br><span class="line">            <span class="attribute">android:fadingEdge</span>=<span class="value">"horizontal"</span></span><br><span class="line">            <span class="attribute">android:gravity</span>=<span class="value">"center_vertical"</span></span><br><span class="line">            <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">            <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">FrameLayout</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">FrameLayout</span> <span class="attribute">android:id</span>=<span class="value">"@android:id/content"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span> </span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"0dip"</span></span><br><span class="line">        <span class="attribute">android:layout_weight</span>=<span class="value">"1"</span></span><br><span class="line">        <span class="attribute">android:foregroundGravity</span>=<span class="value">"fill_horizontal|top"</span></span><br><span class="line">        <span class="attribute">android:foreground</span>=<span class="value">"?android:attr/windowContentOverlay"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">LinearLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>我们可以看到，DecorView 的子 View 其实是一个 LinearLayout ，而 LinearLayout 中有分为 titlebar 和 id 为 android:id/content 的 FrameLayout（其实就是 mContentParent）。</p>
<p>之后将这个视图创建出来并添加到 DecorView 中。</p>
<p>具体的代码可以深入 DecorView 的 <code>onResourcesLoaded(LayoutInflater inflater, int layoutResource)</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">onResourcesLoaded</span><span class="params">(LayoutInflater inflater, <span class="keyword">int</span> layoutResource)</span> </span>&#123;</span><br><span class="line">    mStackId = getStackId();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mBackdropFrameRenderer != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loadBackgroundDrawablesIfNeeded();</span><br><span class="line">        mBackdropFrameRenderer.onResourcesLoaded(</span><br><span class="line">                <span class="keyword">this</span>, mResizingBackgroundDrawable, mCaptionBackgroundDrawable,</span><br><span class="line">                mUserCaptionBackgroundDrawable, getCurrentColor(mStatusColorViewState),</span><br><span class="line">                getCurrentColor(mNavigationColorViewState));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mDecorCaptionView = createDecorCaptionView(inflater);</span><br><span class="line">    <span class="comment">// 解析之前选择出来的 layoutResource ，该 root 也就是 DecorView 的直接子 View</span></span><br><span class="line">    <span class="keyword">final</span> View root = inflater.inflate(layoutResource, <span class="keyword">null</span>);</span><br><span class="line">    <span class="keyword">if</span> (mDecorCaptionView != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDecorCaptionView.getParent() == <span class="keyword">null</span>) &#123;</span><br><span class="line">            addView(mDecorCaptionView,</span><br><span class="line">                    <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">        &#125;</span><br><span class="line">        mDecorCaptionView.addView(root,</span><br><span class="line">                <span class="keyword">new</span> ViewGroup.MarginLayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// Put it below the color views.</span></span><br><span class="line">        <span class="comment">// 将 root 视图添加到 DecorView 中</span></span><br><span class="line">        addView(root, <span class="number">0</span>, <span class="keyword">new</span> ViewGroup.LayoutParams(MATCH_PARENT, MATCH_PARENT));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 可以看出成员变量 mContentRoot 就是 DecorView 的直接子 View</span></span><br><span class="line">    <span class="comment">// 也就是 mContentParent 的父视图</span></span><br><span class="line">    mContentRoot = (ViewGroup) root;</span><br><span class="line">    initializeElevation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看到这，我们可以画一张图出来了，把 PhoneWindow 、DecorView 和 mContentParent 都理清楚：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170928/20170928102356.jpg" alt="View层级"> </p>
<p>然后进行标题设置之类的工作。最后得到并返回 mContentParent 。</p>
<p>到了这里，基本上把 Window 、DecorView 和 Activity 三者之间的关系整理清楚了，但是事情并没有结束。这时候的 DecorView 并没有真正添加到 Window 上去，只是创建出对象了并解析了视图而已。DecorView 还没有被 WindowManager 识别，Window 也还无法接受外界的输入信息。</p>
<p>那么，到底 DecorView 是什么时候附着到 Window 上去的？</p>
<p>这个答案需要我们到 ActivityThread 的 <code>handleResumeActivity()</code> 中找找了。回调  Activity 的 <code>onResume()</code> 生命周期后，又调用了 Activity 的 <code>makeVisible()</code> 方法。</p>
<h2 id="Activity-2"><a href="#Activity-2" class="headerlink" title="Activity"></a>Activity</h2><h3 id="makeVisible_28_29"><a href="#makeVisible_28_29" class="headerlink" title="makeVisible()"></a>makeVisible()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">makeVisible</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mWindowAdded) &#123;</span><br><span class="line">        <span class="comment">// WindowManager 是 ViewManager 的实现类</span></span><br><span class="line">        ViewManager wm = getWindowManager();</span><br><span class="line">        <span class="comment">// 将 decorview 添加到 window 中</span></span><br><span class="line">        wm.addView(mDecor, getWindow().getAttributes());</span><br><span class="line">        mWindowAdded = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 decorview 可见</span></span><br><span class="line">    mDecor.setVisibility(View.VISIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>走完这步，DecorView 才完成添加和显示出来，Activity 的视图才能被用户看到。</p>
<p>整个 Window 创建的流程也结束了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>Window 和 Decor 的“爱恨情仇”到这里就告一段落了，但是 Window 的内部机制我们还可以好好叙一叙。</p>
<p>注意到上面 WindowManager 的 <code>addView</code> 方法了吧？</p>
<p>Window 是怎么添加上去的，究竟在这里面发生了什么事呢？</p>
<p>只能留到下一篇再详细讲讲了。</p>
<p>bye bye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://mp.weixin.qq.com/s/NZ1GFkEn4UGNljYPVpdfhw" target="_blank" rel="external">结合源码，探索Android中的Window与DecorView</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文解析的源码基于 API 25，部分内容来自于《Android开发艺术探索》。</p>
<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>今天我们]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="View" scheme="http://yuqirong.me/tags/View/"/>
    
      <category term="Window" scheme="http://yuqirong.me/tags/Window/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[View的工作原理]]></title>
    <link href="http://yuqirong.me/2017/09/18/View%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2017/09/18/View的工作原理/</id>
    <published>2017-09-18T14:35:00.000Z</published>
    <updated>2017-11-04T06:02:06.048Z</updated>
    <content type="html"><![CDATA[<p>注：本文分析的源码基于 Android API 25</p>
<h1 id="View_u7ED8_u5236_u7684_u8D77_u70B9"><a href="#View_u7ED8_u5236_u7684_u8D77_u70B9" class="headerlink" title="View绘制的起点"></a>View绘制的起点</h1><h2 id="WindowManagerGlobal"><a href="#WindowManagerGlobal" class="headerlink" title="WindowManagerGlobal"></a>WindowManagerGlobal</h2><h3 id="addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29"><a href="#addView_28View_view_2C_ViewGroup-LayoutParams_params_2C_Display_display_2C_Window_parentWindow_29" class="headerlink" title="addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)"></a>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</h3><p>在 <code>WindowManagerGlobal</code> 的 <code>addView(View view, ViewGroup.LayoutParams params, Display display, Window parentWindow)</code> 方法中，创建了 <code>ViewRootImpl</code> 对象，将 <code>ViewRootImpl</code> 和 <code>DecorView</code> 相关联：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root = <span class="keyword">new</span> ViewRootImpl(view.getContext(), display);</span><br><span class="line">...</span><br><span class="line"><span class="comment">// view 是 PhoneWindow 的 DecorView</span></span><br><span class="line">root.setView(view, wparams, panelParentView);</span><br></pre></td></tr></table></figure>
<p><code>ViewRootImpl</code> 是用来连接 WindowManager 和 DecorView 的桥梁。通俗地来讲，Window 和 View 就是通过 <code>ViewRootImpl</code> 来建立联系的。</p>
<p>而 DecorView 是顶级的 View ，从它开始向下传递 measure 、 layout 和 draw 三个流程。</p>
<p>创建好了 <code>root</code> 之后，调用了 <code>ViewRootImpl</code> 的 <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</code> 方法。</p>
<p>将 DecorView 和 ViewRootImpl 相关联。</p>
<h2 id="ViewRootImpl"><a href="#ViewRootImpl" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29"><a href="#setView_28View_view_2C_WindowManager-LayoutParams_attrs_2C_View_panelParentView_29" class="headerlink" title="setView(View view, WindowManager.LayoutParams attrs, View panelParentView)"></a>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setView</span><span class="params">(View view, WindowManager.LayoutParams attrs, View panelParentView)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mView == <span class="keyword">null</span>) &#123;</span><br><span class="line">			<span class="comment">// 将 decorView 设置给全局的 mView</span></span><br><span class="line">               mView = view;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 标记已经添加了 decorView</span></span><br><span class="line">			mAdded = <span class="keyword">true</span>;</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 第一次发起布局，在添加到 WindowManager 之前</span></span><br><span class="line">			<span class="comment">// 确保在接收其他系统事件之前完成重新布局</span></span><br><span class="line">			requestLayout();</span><br><span class="line">			...</span><br><span class="line">			<span class="comment">// 利用 mWindowSession 以跨进程的方式向 WMS 发起一个调用，从而将DecorView 最终添加到 Window 上</span></span><br><span class="line">		  	<span class="keyword">try</span> &#123;</span><br><span class="line">		  	    mOrigWindowType = mWindowAttributes.type;</span><br><span class="line">		  	    mAttachInfo.mRecomputeGlobalAttributes = <span class="keyword">true</span>;</span><br><span class="line">		  	    collectViewAttributes();</span><br><span class="line">		  	    res = mWindowSession.addToDisplay(mWindow, mSeq, mWindowAttributes, getHostVisibility(), mDisplay.getDisplayId(), mAttachInfo.mContentInsets, mAttachInfo.mStableInsets, mAttachInfo.mOutsets, mInputChannel);</span><br><span class="line">               &#125; </span><br><span class="line">			...</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>setView(View view, WindowManager.LayoutParams attrs, View panelParentView)</code> 方法中，主要做的事情有：</p>
<ol>
<li>保存 DecorView</li>
<li>第一次调用 <code>requestLayout()</code> ，发起整个 View 的绘制流程</li>
<li>将 View 添加到 Window 上去</li>
</ol>
<p>而在这，我们重点关注 <code>requestLayout()</code> 方法，因为恰恰这句代码引发了整个 View 的绘制。</p>
<h3 id="requestLayout_28_29"><a href="#requestLayout_28_29" class="headerlink" title="requestLayout()"></a>requestLayout()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="annotation">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">requestLayout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">if</span> (!mHandlingLayoutInLayoutRequest) &#123;</span><br><span class="line"><span class="comment">// 检查当前线程</span></span><br><span class="line">         checkThread();</span><br><span class="line">         mLayoutRequested = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">// 调用绘制</span></span><br><span class="line">         scheduleTraversals();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>requestLayout()</code> 中先检查了线程，若 OK 后调用 <code>scheduleTraversals()</code> 。</p>
<h3 id="scheduleTraversals_28_29"><a href="#scheduleTraversals_28_29" class="headerlink" title="scheduleTraversals()"></a>scheduleTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">scheduleTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (!mTraversalScheduled) &#123;</span><br><span class="line">           mTraversalScheduled = <span class="keyword">true</span>;</span><br><span class="line">           mTraversalBarrier = mHandler.getLooper().getQueue().postSyncBarrier();</span><br><span class="line">		<span class="comment">// 发送消息，调用 mTraversalRunnable</span></span><br><span class="line">           mChoreographer.postCallback(</span><br><span class="line">                   Choreographer.CALLBACK_TRAVERSAL, mTraversalRunnable, <span class="keyword">null</span>);</span><br><span class="line">           <span class="keyword">if</span> (!mUnbufferedInputDispatch) &#123;</span><br><span class="line">               scheduleConsumeBatchedInput();</span><br><span class="line">           &#125;</span><br><span class="line">           notifyRendererOfFramePending();</span><br><span class="line">           pokeDrawLockIfNeeded();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> TraversalRunnable mTraversalRunnable = <span class="keyword">new</span> TraversalRunnable();</span><br><span class="line"></span><br><span class="line">   <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TraversalRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">       <span class="annotation">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		<span class="comment">// 内部调用了 performTraversals()</span></span><br><span class="line">           doTraversal();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>scheduleTraversals()</code> 中，其实是这样的：</p>
<p>scheduleTraversals() -&gt; 调用 mTraversalRunnable -&gt; doTraversal() -&gt; performTraversals()</p>
<p>所以最后还是要看 <code>performTraversals()</code> 。</p>
<h3 id="performTraversals_28_29"><a href="#performTraversals_28_29" class="headerlink" title="performTraversals()"></a>performTraversals()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performTraversals</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 计算 Activity 中 window 的宽高等等</span></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!mStopped || mReportNextDraw) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> focusChangedDueToTouchMode = ensureTouchModeLocally(</span><br><span class="line">                       (relayoutResult&amp;WindowManagerGlobal.RELAYOUT_RES_IN_TOUCH_MODE) != <span class="number">0</span>);</span><br><span class="line">               <span class="keyword">if</span> (focusChangedDueToTouchMode || mWidth != host.getMeasuredWidth()</span><br><span class="line">                       || mHeight != host.getMeasuredHeight() || contentInsetsChanged ||</span><br><span class="line">                       updatedConfiguration) &#123;</span><br><span class="line">                   <span class="comment">// 得到 view 宽高的规格</span></span><br><span class="line">                   <span class="comment">// mWidth 和 mHeight 即用来描述 Activity 窗口宽度和高度</span></span><br><span class="line">                   <span class="comment">// lp.width 和 lp.height 就是 DecorView 的宽高</span></span><br><span class="line">                   <span class="keyword">int</span> childWidthMeasureSpec = getRootMeasureSpec(mWidth, lp.width);</span><br><span class="line">                   <span class="keyword">int</span> childHeightMeasureSpec = getRootMeasureSpec(mHeight, lp.height);</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag, <span class="string">"Ooops, something changed!  mWidth="</span></span><br><span class="line">                           + mWidth + <span class="string">" measuredWidth="</span> + host.getMeasuredWidth()</span><br><span class="line">                           + <span class="string">" mHeight="</span> + mHeight</span><br><span class="line">                           + <span class="string">" measuredHeight="</span> + host.getMeasuredHeight()</span><br><span class="line">                           + <span class="string">" coveredInsetsChanged="</span> + contentInsetsChanged);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">                    <span class="comment">// 开始执行测量工作，测量是从这里发起的</span></span><br><span class="line">                   performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// Implementation of weights from WindowManager.LayoutParams</span></span><br><span class="line">                   <span class="comment">// We just grow the dimensions as needed and re-measure if</span></span><br><span class="line">                   <span class="comment">// needs be</span></span><br><span class="line">                   <span class="keyword">int</span> width = host.getMeasuredWidth();</span><br><span class="line">                   <span class="keyword">int</span> height = host.getMeasuredHeight();</span><br><span class="line">                   <span class="keyword">boolean</span> measureAgain = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 检查是否需要重新测量</span></span><br><span class="line">                   <span class="keyword">if</span> (lp.horizontalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                       width += (<span class="keyword">int</span>) ((mWidth - width) * lp.horizontalWeight);</span><br><span class="line">                       childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(width,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line">                   <span class="keyword">if</span> (lp.verticalWeight &gt; <span class="number">0.0f</span>) &#123;</span><br><span class="line">                       height += (<span class="keyword">int</span>) ((mHeight - height) * lp.verticalWeight);</span><br><span class="line">                       childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(height,</span><br><span class="line">                               MeasureSpec.EXACTLY);</span><br><span class="line">                       measureAgain = <span class="keyword">true</span>;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="comment">// 需要再次测量的话，就再执行一遍 performMeasure</span></span><br><span class="line">                   <span class="keyword">if</span> (measureAgain) &#123;</span><br><span class="line">                       <span class="keyword">if</span> (DEBUG_LAYOUT) Log.v(mTag,</span><br><span class="line">                               <span class="string">"And hey let's measure once more: width="</span> + width</span><br><span class="line">                               + <span class="string">" height="</span> + height);</span><br><span class="line">                       performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   layoutRequested = <span class="keyword">true</span>;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">boolean</span> didLayout = layoutRequested &amp;&amp; (!mStopped || mReportNextDraw);</span><br><span class="line">       <span class="keyword">boolean</span> triggerGlobalLayoutListener = didLayout</span><br><span class="line">               || mAttachInfo.mRecomputeGlobalAttributes;</span><br><span class="line">       <span class="keyword">if</span> (didLayout) &#123;</span><br><span class="line">           <span class="comment">// 执行布局工作，布局是从这里发起的</span></span><br><span class="line">           performLayout(lp, mWidth, mHeight);</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!cancelDraw &amp;&amp; !newSurface) &#123;</span><br><span class="line">           <span class="keyword">if</span> (mPendingTransitions != <span class="keyword">null</span> &amp;&amp; mPendingTransitions.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">               <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mPendingTransitions.size(); ++i) &#123;</span><br><span class="line">                   mPendingTransitions.get(i).startChangingAnimations();</span><br><span class="line">               &#125;</span><br><span class="line">               mPendingTransitions.clear();</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// 执行绘制工作，绘制是从这里发起的</span></span><br><span class="line">           performDraw();</span><br><span class="line">       &#125; </span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>performTraversals()</code> 方法的代码很长很长，但是我们关注点就可以放在三大流程上。其他的代码因为自己能力欠缺，并不能一一说出这些代码的作用。所以我们接下来就把重点放在：</p>
<ol>
<li>getRootMeasureSpec</li>
<li>performMeasure</li>
<li>performLayout</li>
<li>performDraw</li>
</ol>
<h1 id="u4E09_u5927_u6D41_u7A0B"><a href="#u4E09_u5927_u6D41_u7A0B" class="headerlink" title="三大流程"></a>三大流程</h1><h2 id="ViewRootImpl-1"><a href="#ViewRootImpl-1" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="measureHierarchy_28final_View_host_2C_final_WindowManager-LayoutParams_lp_2C_final_Resources_res_2C_final_int_desiredWindowWidth_2C_final_int_desiredWindowHeight_29"><a href="#measureHierarchy_28final_View_host_2C_final_WindowManager-LayoutParams_lp_2C_final_Resources_res_2C_final_int_desiredWindowWidth_2C_final_int_desiredWindowHeight_29" class="headerlink" title="measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)"></a>measureHierarchy(final View host, final WindowManager.LayoutParams lp, final Resources res, final int desiredWindowWidth, final int desiredWindowHeight)</h3><p>其实在 <code>performTraversals()</code> 中有一句代码</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Ask host how big it wants to be</span></span><br><span class="line">windowSizeMayChange |= measureHierarchy(host, lp, res,</span><br><span class="line">        desiredWindowWidth, desiredWindowHeight);</span><br></pre></td></tr></table></figure>
<p>在 <code>measureHierarchy</code> 方法中已经调用了 <code>performMeasure</code> 来进行测量。不过作用不同，只是为了确定 window 的大小而做的测量辅助。所以可以说，并不算上在三大流程中。</p>
<p>在 <code>measureHierarchy</code> 中，确定了 DecorView 的 <code>MeasureSpec</code> 。其中 <code>childWidthMeasureSpec</code> 和 <code>childHeightMeasureSpec</code> 即为 DecorView 对应的 <code>MeasureSpec</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// desiredWindowWidth 和 desiredWindowHeight 是屏幕的宽高</span></span><br><span class="line">childWidthMeasureSpec = getRootMeasureSpec(desiredWindowWidth, lp.width);</span><br><span class="line">childHeightMeasureSpec = getRootMeasureSpec(desiredWindowHeight, lp.height);</span><br><span class="line">performMeasure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br></pre></td></tr></table></figure>
<h3 id="getRootMeasureSpec_28int_windowSize_2C_int_rootDimension_29"><a href="#getRootMeasureSpec_28int_windowSize_2C_int_rootDimension_29" class="headerlink" title="getRootMeasureSpec(int windowSize, int rootDimension)"></a>getRootMeasureSpec(int windowSize, int rootDimension)</h3><p>那么就来看看 <code>getRootMeasureSpec</code> 咯。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getRootMeasureSpec</span><span class="params">(<span class="keyword">int</span> windowSize, <span class="keyword">int</span> rootDimension)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> measureSpec;</span><br><span class="line">    <span class="keyword">switch</span> (rootDimension) &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.MATCH_PARENT:</span><br><span class="line">        <span class="comment">// Window can't resize. Force root view to be windowSize.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">case</span> ViewGroup.LayoutParams.WRAP_CONTENT:</span><br><span class="line">        <span class="comment">// Window can resize. Set max size for root view.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(windowSize, MeasureSpec.AT_MOST);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">        <span class="comment">// Window wants to be an exact size. Force root view to be that size.</span></span><br><span class="line">        measureSpec = MeasureSpec.makeMeasureSpec(rootDimension, MeasureSpec.EXACTLY);</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> measureSpec;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码很简洁，也很易懂。</p>
<ol>
<li>如果是 MATCH_PARENT ，那么对应的就是窗口大小；</li>
<li>如果是 WRAP_CONTENT ，那么不能超过窗口大小；</li>
<li>固定大小，那么就是大小就是传入的 lp.width/lp.height 了。</li>
</ol>
<h2 id="ViewGroup"><a href="#ViewGroup" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="getChildMeasureSpec_28int_spec_2C_int_padding_2C_int_childDimension_29"><a href="#getChildMeasureSpec_28int_spec_2C_int_padding_2C_int_childDimension_29" class="headerlink" title="getChildMeasureSpec(int spec, int padding, int childDimension)"></a>getChildMeasureSpec(int spec, int padding, int childDimension)</h3><p>顺便，我们把平时自定义 ViewGroup 计算子 View 测量规格的 <code>getChildMeasureSpec</code> 方法也一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getChildMeasureSpec</span><span class="params">(<span class="keyword">int</span> spec, <span class="keyword">int</span> padding, <span class="keyword">int</span> childDimension)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 父容器的 mode</span></span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(spec);</span><br><span class="line">    <span class="comment">// 父容器的 size</span></span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(spec);</span><br><span class="line">    <span class="comment">// 子 view 可以使用空间，即父容器的 size - padding</span></span><br><span class="line">    <span class="keyword">int</span> size = Math.max(<span class="number">0</span>, specSize - padding);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> resultSize = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> resultMode = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="comment">// Parent has imposed an exact size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size. So be it.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent has imposed a maximum size on us</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... so be it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size, but our size is not fixed.</span></span><br><span class="line">            <span class="comment">// Constrain child to not be bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size. It can't be</span></span><br><span class="line">            <span class="comment">// bigger than us.</span></span><br><span class="line">            resultSize = size;</span><br><span class="line">            resultMode = MeasureSpec.AT_MOST;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Parent asked to see how big we want to be</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        <span class="keyword">if</span> (childDimension &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// Child wants a specific size... let him have it</span></span><br><span class="line">            resultSize = childDimension;</span><br><span class="line">            resultMode = MeasureSpec.EXACTLY;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to be our size... find out how big it should</span></span><br><span class="line">            <span class="comment">// be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (childDimension == LayoutParams.WRAP_CONTENT) &#123;</span><br><span class="line">            <span class="comment">// Child wants to determine its own size.... find out how</span></span><br><span class="line">            <span class="comment">// big it should be</span></span><br><span class="line">            resultSize = View.sUseZeroUnspecifiedMeasureSpec ? <span class="number">0</span> : size;</span><br><span class="line">            resultMode = MeasureSpec.UNSPECIFIED;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//noinspection ResourceType</span></span><br><span class="line">    <span class="keyword">return</span> MeasureSpec.makeMeasureSpec(resultSize, resultMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的 switch/case 代码比较简单，而且容易理解。我们可以整理为一张表格（该表格来自于《Android开发艺术探索》）：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170918/20170821150637571.png" alt="measurespec"></p>
<p>在这里，我们小结一下。对于 DecorView 来说，其 <code>MeasureSpec</code> 是由窗口的大小和自身的 <code>LayoutParams</code> 来共同决定的；而对于普通的 View 来说，其 <code>MeasureSpec</code> 是由父容器的 <code>MeasureSpec</code> 和自身的 <code>LayoutParams</code> 共同决定的。</p>
<h1 id="measure_u8FC7_u7A0B"><a href="#measure_u8FC7_u7A0B" class="headerlink" title="measure过程"></a>measure过程</h1><h2 id="ViewRootImpl-2"><a href="#ViewRootImpl-2" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performMeasure_28int_childWidthMeasureSpec_2C_int_childHeightMeasureSpec_29"><a href="#performMeasure_28int_childWidthMeasureSpec_2C_int_childHeightMeasureSpec_29" class="headerlink" title="performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)"></a>performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)</h3><p>分析 measure 过程，我们的起点就是在 <code>ViewRootImpl</code> 的 <code>performMeasure(int childWidthMeasureSpec, int childHeightMeasureSpec)</code> 方法中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performMeasure</span><span class="params">(<span class="keyword">int</span> childWidthMeasureSpec, <span class="keyword">int</span> childHeightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"measure"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 进行测量</span></span><br><span class="line">        mView.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>performMeasure</code> 中调用了 <code>measure</code> 方法。说到底，DecorView 只是一个所以我们又要进入 <code>View</code> 类中去看下。</p>
<h2 id="View"><a href="#View" class="headerlink" title="View"></a>View</h2><h3 id="measure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29"><a href="#measure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29" class="headerlink" title="measure(int widthMeasureSpec, int heightMeasureSpec)"></a>measure(int widthMeasureSpec, int heightMeasureSpec)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">measure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">       <span class="keyword">if</span> (forceLayout || needsLayout) &#123;</span><br><span class="line">           ...</span><br><span class="line">           <span class="keyword">if</span> (cacheIndex &lt; <span class="number">0</span> || sIgnoreMeasureCache) &#123;</span><br><span class="line">               <span class="comment">// measure ourselves, this should set the measured dimension flag back</span></span><br><span class="line">               <span class="comment">// 调用 onMeasure</span></span><br><span class="line">               onMeasure(widthMeasureSpec, heightMeasureSpec);</span><br><span class="line">               mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">long</span> value = mMeasureCache.valueAt(cacheIndex);</span><br><span class="line">               <span class="comment">// Casting a long to int drops the high 32 bits, no mask needed</span></span><br><span class="line">               setMeasuredDimensionRaw((<span class="keyword">int</span>) (value &gt;&gt; <span class="number">32</span>), (<span class="keyword">int</span>) value);</span><br><span class="line">               mPrivateFlags3 |= PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           ...</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p><code>View</code> 的 <code>measure</code> 方法内部是调用了 <code>onMeasure</code> 。所以我们还要接着跟进到 <code>onMeasure</code> 中才行。另外， <code>measure</code> 方法是用 final 修饰的，所以子类是无法进行重写的。</p>
<h2 id="FrameLayout"><a href="#FrameLayout" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><h3 id="onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29"><a href="#onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29" class="headerlink" title="onMeasure(int widthMeasureSpec, int heightMeasureSpec)"></a>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</h3><p>这里小提一下，我们都知道 DecorView 其实是一个 <code>FrameLayout</code> ，所以 <code>onMeasure</code> 应该在 <code>FrameLayout</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> count = getChildCount();</span><br><span class="line">    <span class="comment">// 判断当前 framelayout 布局的宽高是否至少一个是 match_parent 或者精确值 ，如果是则置 measureMatchParent 为 false .</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> measureMatchParentChildren =</span><br><span class="line">            MeasureSpec.getMode(widthMeasureSpec) != MeasureSpec.EXACTLY ||</span><br><span class="line">            MeasureSpec.getMode(heightMeasureSpec) != MeasureSpec.EXACTLY;</span><br><span class="line">    mMatchParentChildren.clear();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxHeight = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> maxWidth = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> childState = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 遍历不为 GONE 的子 view</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">        <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">        <span class="keyword">if</span> (mMeasureAllChildren || child.getVisibility() != GONE) &#123;</span><br><span class="line">            <span class="comment">// 对每一个子 View 进行测量</span></span><br><span class="line">            measureChildWithMargins(child, widthMeasureSpec, <span class="number">0</span>, heightMeasureSpec, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line">            <span class="comment">// 寻找子 View 中宽高的最大者，因为如果 FrameLayout 是 wrap_content 属性</span></span><br><span class="line">            <span class="comment">// 那么它的宽高取决于子 View 中的宽高最大者</span></span><br><span class="line">            maxWidth = Math.max(maxWidth,</span><br><span class="line">                    child.getMeasuredWidth() + lp.leftMargin + lp.rightMargin);</span><br><span class="line">            maxHeight = Math.max(maxHeight,</span><br><span class="line">                    child.getMeasuredHeight() + lp.topMargin + lp.bottomMargin);</span><br><span class="line">            childState = combineMeasuredStates(childState, child.getMeasuredState());</span><br><span class="line">            <span class="comment">// 如果 FrameLayout 为 wrap_content 且 子 view 的宽或高为 match_parent ，那么就添加到 mMatchParentChildren 中</span></span><br><span class="line">            <span class="keyword">if</span> (measureMatchParentChildren) &#123;</span><br><span class="line">                <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT ||</span><br><span class="line">                        lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                    mMatchParentChildren.add(child);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Account for padding too</span></span><br><span class="line">    maxWidth += getPaddingLeftWithForeground() + getPaddingRightWithForeground();</span><br><span class="line">    maxHeight += getPaddingTopWithForeground() + getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our minimum height and width</span></span><br><span class="line">    maxHeight = Math.max(maxHeight, getSuggestedMinimumHeight());</span><br><span class="line">    maxWidth = Math.max(maxWidth, getSuggestedMinimumWidth());</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Check against our foreground's minimum height and width</span></span><br><span class="line">    <span class="keyword">final</span> Drawable drawable = getForeground();</span><br><span class="line">    <span class="keyword">if</span> (drawable != <span class="keyword">null</span>) &#123;</span><br><span class="line">        maxHeight = Math.max(maxHeight, drawable.getMinimumHeight());</span><br><span class="line">        maxWidth = Math.max(maxWidth, drawable.getMinimumWidth());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//设置测量结果</span></span><br><span class="line">    setMeasuredDimension(resolveSizeAndState(maxWidth, widthMeasureSpec, childState),</span><br><span class="line">            resolveSizeAndState(maxHeight, heightMeasureSpec,</span><br><span class="line">                    childState &lt;&lt; MEASURED_HEIGHT_STATE_SHIFT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 子View中设置为match_parent的个数</span></span><br><span class="line">    count = mMatchParentChildren.size();</span><br><span class="line">    <span class="comment">// 若 FrameLayout 为 wrap_content 且 count &gt; 1</span></span><br><span class="line">    <span class="keyword">if</span> (count &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = mMatchParentChildren.get(i);</span><br><span class="line">            <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 如果子 View 的宽度是 match_parent 属性，那么对 childWidthMeasureSpec 修改：</span></span><br><span class="line">            <span class="comment">// 把 widthMeasureSpec 的宽度修改为:framelayout总宽度 - padding - margin，模式设置为 EXACTLY</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.width == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> width = Math.max(<span class="number">0</span>, getMeasuredWidth()</span><br><span class="line">                        - getPaddingLeftWithForeground() - getPaddingRightWithForeground()</span><br><span class="line">                        - lp.leftMargin - lp.rightMargin);</span><br><span class="line">                childWidthMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        width, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 否则就按照正常的来就行了</span></span><br><span class="line">                childWidthMeasureSpec = getChildMeasureSpec(widthMeasureSpec,</span><br><span class="line">                        getPaddingLeftWithForeground() + getPaddingRightWithForeground() +</span><br><span class="line">                        lp.leftMargin + lp.rightMargin,</span><br><span class="line">                        lp.width);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 高度同理</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec;</span><br><span class="line">            <span class="keyword">if</span> (lp.height == LayoutParams.MATCH_PARENT) &#123;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> height = Math.max(<span class="number">0</span>, getMeasuredHeight()</span><br><span class="line">                        - getPaddingTopWithForeground() - getPaddingBottomWithForeground()</span><br><span class="line">                        - lp.topMargin - lp.bottomMargin);</span><br><span class="line">                childHeightMeasureSpec = MeasureSpec.makeMeasureSpec(</span><br><span class="line">                        height, MeasureSpec.EXACTLY);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                childHeightMeasureSpec = getChildMeasureSpec(heightMeasureSpec,</span><br><span class="line">                        getPaddingTopWithForeground() + getPaddingBottomWithForeground() +</span><br><span class="line">                        lp.topMargin + lp.bottomMargin,</span><br><span class="line">                        lp.height);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//对于这部分的子 View 需要重新进行 measure 过程</span></span><br><span class="line">            child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果上面 <code>FrameLayout</code> 的 <code>onMeasure</code> 流程没看懂的话也没关系。其实总的来说重要的就只有遍历 <code>child.measure(childWidthMeasureSpec, childHeightMeasureSpec)</code> 这个方法，这是将父容器的 measure 过程传递到子 View 中。</p>
<h2 id="ViewGroup-1"><a href="#ViewGroup-1" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="measureChildWithMargins_28View_child_2C_int_parentWidthMeasureSpec_2C_int_widthUsed_2C_int_parentHeightMeasureSpec_2C_int_heightUsed_29"><a href="#measureChildWithMargins_28View_child_2C_int_parentWidthMeasureSpec_2C_int_widthUsed_2C_int_parentHeightMeasureSpec_2C_int_heightUsed_29" class="headerlink" title="measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)"></a>measureChildWithMargins(View child, int parentWidthMeasureSpec, int widthUsed, int parentHeightMeasureSpec, int heightUsed)</h3><p>可能有些人也有疑问，在上面 <code>measureChildWithMargins(child, widthMeasureSpec, 0, heightMeasureSpec, 0)</code> 后也没看到有 <code>child.measure</code> 的方法啊，这是因为在 <code>measureChildWithMargins</code> 中内部调用了 <code>child.measure</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">measureChildWithMargins</span><span class="params">(View child,</span><br><span class="line">        <span class="keyword">int</span> parentWidthMeasureSpec, <span class="keyword">int</span> widthUsed,</span><br><span class="line">        <span class="keyword">int</span> parentHeightMeasureSpec, <span class="keyword">int</span> heightUsed)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> MarginLayoutParams lp = (MarginLayoutParams) child.getLayoutParams();</span><br><span class="line">    <span class="comment">// getChildMeasureSpec 我们上面分析过了</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childWidthMeasureSpec = getChildMeasureSpec(parentWidthMeasureSpec,</span><br><span class="line">            mPaddingLeft + mPaddingRight + lp.leftMargin + lp.rightMargin</span><br><span class="line">                    + widthUsed, lp.width);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childHeightMeasureSpec = getChildMeasureSpec(parentHeightMeasureSpec,</span><br><span class="line">            mPaddingTop + mPaddingBottom + lp.topMargin + lp.bottomMargin</span><br><span class="line">                    + heightUsed, lp.height);</span><br><span class="line">    <span class="comment">// measure 传递给子 View</span></span><br><span class="line">    child.measure(childWidthMeasureSpec, childHeightMeasureSpec);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这下明白了吧？父容器就是遍历调用了 <code>child.measure</code> 这个方法将 measure 过程传递给每一个子 View 的。虽然不同的父容器 <code>onMeasure</code> 方法都不一样，但是相同的是，他们都会遍历调用 <code>child.measure</code> 。</p>
<h2 id="View-1"><a href="#View-1" class="headerlink" title="View"></a>View</h2><h3 id="onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29-1"><a href="#onMeasure_28int_widthMeasureSpec_2C_int_heightMeasureSpec_29-1" class="headerlink" title="onMeasure(int widthMeasureSpec, int heightMeasureSpec)"></a>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</h3><p>上面我们也讲过，<code>measure</code> 方法内部其实是调用了 <code>onMeasure</code> ，所以子 View 被父容器调用了 <code>measure</code> 后，也会调用属于自己的 <code>onMeasure</code> 方法。那么我们就直接看向 <code>View</code> 的 <code>onMeasure</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    setMeasuredDimension(getDefaultSize(getSuggestedMinimumWidth(), widthMeasureSpec),</span><br><span class="line">            getDefaultSize(getSuggestedMinimumHeight(), heightMeasureSpec));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>onMeasure</code> 方法只有一句代码，所以重点就是 <code>getDefaultSize(int size, int measureSpec)</code> 咯。</p>
<p><code>getSuggestedMinimumWidth()</code> 内部逻辑：</p>
<ol>
<li>若没有设置背景，就是 <code>android:minWidth</code> 的值；</li>
<li>若有设置背景，就是 max(android:minWidth, 背景 Drawable 的原始宽度)</li>
</ol>
<p><code>getSuggestedMinimumHeight()</code> 也是同理。</p>
<h3 id="getDefaultSize_28int_size_2C_int_measureSpec_29"><a href="#getDefaultSize_28int_size_2C_int_measureSpec_29" class="headerlink" title="getDefaultSize(int size, int measureSpec)"></a>getDefaultSize(int size, int measureSpec)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">getDefaultSize</span><span class="params">(<span class="keyword">int</span> size, <span class="keyword">int</span> measureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> result = size;</span><br><span class="line">    <span class="keyword">int</span> specMode = MeasureSpec.getMode(measureSpec);</span><br><span class="line">    <span class="keyword">int</span> specSize = MeasureSpec.getSize(measureSpec);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (specMode) &#123;</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.UNSPECIFIED:</span><br><span class="line">        result = size;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">// 直接返回 specSize</span></span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.AT_MOST:</span><br><span class="line">    <span class="keyword">case</span> MeasureSpec.EXACTLY:</span><br><span class="line">        result = specSize;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面我们可以看到：</p>
<ul>
<li>若是 UNSPECIFIED ，则直接返回的就是 <code>getSuggestedMinimumWidth/getSuggestedMinimumHeight</code> 的值；</li>
<li>若是 AT_MOST/EXACTLY ，直接用的就是 specSize 。</li>
</ul>
<p>而根据我们之前总结出来的表可知，只要 view 不指定固定大小，那么无论是 AT_MOST 还是 EXACTLY ，都是按照 parentSize 来的。</p>
<p>这也是为什么我们在自定义 View 时，如果不重写 <code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code> ，wrap_content 和 match_parent 效果一样的原因。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>我们把 measure 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performMeasure -&gt; DecorView.measure -&gt; DecorView.onMeasure -&gt; DecorView.measureChildWithMargins -&gt; ViewGroup.measure -&gt; ViewGroup.onMeasure -&gt; ViewGroup.measureChildWithMargins -&gt; … -&gt; View.measure -&gt; View.onMeasure</p>
<p>注：DecorView 其实就是 FrameLayout</p>
<h1 id="layout_u8FC7_u7A0B"><a href="#layout_u8FC7_u7A0B" class="headerlink" title="layout过程"></a>layout过程</h1><h2 id="ViewRootImpl-3"><a href="#ViewRootImpl-3" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performLayout_28WindowManager-LayoutParams_lp_2C_int_desiredWindowWidth_2C_int_desiredWindowHeight_29"><a href="#performLayout_28WindowManager-LayoutParams_lp_2C_int_desiredWindowWidth_2C_int_desiredWindowHeight_29" class="headerlink" title="performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)"></a>performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)</h3><p>在上面分析过，layout 过程是从 <code>ViewRootImpl</code> 中的 <code>performLayout(WindowManager.LayoutParams lp, int desiredWindowWidth, int desiredWindowHeight)</code> 开始的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performLayout</span><span class="params">(WindowManager.LayoutParams lp, <span class="keyword">int</span> desiredWindowWidth,</span><br><span class="line">        <span class="keyword">int</span> desiredWindowHeight)</span> </span>&#123;</span><br><span class="line">    mLayoutRequested = <span class="keyword">false</span>;</span><br><span class="line">    mScrollMayChange = <span class="keyword">true</span>;</span><br><span class="line">    mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> View host = mView;</span><br><span class="line">    <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_LAYOUT) &#123;</span><br><span class="line">        Log.v(mTag, <span class="string">"Laying out "</span> + host + <span class="string">" to ("</span> +</span><br><span class="line">                host.getMeasuredWidth() + <span class="string">", "</span> + host.getMeasuredHeight() + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"layout"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// host 就是 DecorView，调用了 layout 方法开始布局</span></span><br><span class="line">        host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">        mInLayout = <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">// mLayoutRequesters 为需要重新请求布局的 view 集合数</span></span><br><span class="line">        <span class="keyword">int</span> numViewsRequestingLayout = mLayoutRequesters.size();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 下面的代码主要用于若有请求重新布局的 view ，那么再进行重新布局</span></span><br><span class="line">        <span class="keyword">if</span> (numViewsRequestingLayout &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// requestLayout() was called during layout.</span></span><br><span class="line">            <span class="comment">// If no layout-request flags are set on the requesting views, there is no problem.</span></span><br><span class="line">            <span class="comment">// If some requests are still pending, then we need to clear those flags and do</span></span><br><span class="line">            <span class="comment">// a full request/measure/layout pass to handle this situation.</span></span><br><span class="line">            ArrayList&lt;View&gt; validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters,</span><br><span class="line">                    <span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// Set this flag to indicate that any further requests are happening during</span></span><br><span class="line">                <span class="comment">// the second pass, which may result in posting those requests to the next</span></span><br><span class="line">                <span class="comment">// frame instead</span></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// view 请求布局，进行重新测量和布局</span></span><br><span class="line">                <span class="keyword">int</span> numValidRequests = validLayoutRequesters.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                    <span class="keyword">final</span> View view = validLayoutRequesters.get(i);</span><br><span class="line">                    Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                            <span class="string">" during layout: running second layout pass"</span>);</span><br><span class="line">                    view.requestLayout();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 对整个View树进行重新测量</span></span><br><span class="line">                measureHierarchy(host, lp, mView.getContext().getResources(),</span><br><span class="line">                        desiredWindowWidth, desiredWindowHeight);</span><br><span class="line">                mInLayout = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 进行第二次布局</span></span><br><span class="line">                host.layout(<span class="number">0</span>, <span class="number">0</span>, host.getMeasuredWidth(), host.getMeasuredHeight());</span><br><span class="line"></span><br><span class="line">                mHandlingLayoutInLayoutRequest = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Check the valid requests again, this time without checking/clearing the</span></span><br><span class="line">                <span class="comment">// layout flags, since requests happening during the second pass get noop'd</span></span><br><span class="line">                validLayoutRequesters = getValidLayoutRequesters(mLayoutRequesters, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">if</span> (validLayoutRequesters != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">final</span> ArrayList&lt;View&gt; finalRequesters = validLayoutRequesters;</span><br><span class="line">                    <span class="comment">// Post second-pass requests to the next frame</span></span><br><span class="line">                    getRunQueue().post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">int</span> numValidRequests = finalRequesters.size();</span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numValidRequests; ++i) &#123;</span><br><span class="line">                                <span class="keyword">final</span> View view = finalRequesters.get(i);</span><br><span class="line">                                Log.w(<span class="string">"View"</span>, <span class="string">"requestLayout() improperly called by "</span> + view +</span><br><span class="line">                                        <span class="string">" during second layout pass: posting in next frame"</span>);</span><br><span class="line">                                view.requestLayout();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line">    mInLayout = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>基本可知，<code>performLayout</code> 是通过调用 DecorView 的 <code>layout</code> 方法来向下传递布局的。所以我们应该继续追踪 <code>FrameLayout</code> 的 <code>layout</code> 方法，其实就是 <code>ViewGroup</code> 的 <code>layout</code> 方法。</p>
<h2 id="ViewGroup-2"><a href="#ViewGroup-2" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29"><a href="#layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29" class="headerlink" title="layout(int l, int t, int r, int b)"></a>layout(int l, int t, int r, int b)</h3><p><code>FrameLayout</code> 的 <code>layout</code> 是父类 <code>ViewGroup</code> 实现的，添加了 final 修饰符，无法被重写：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mSuppressLayout &amp;&amp; (mTransition == <span class="keyword">null</span> || !mTransition.isChangingLayout())) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mTransition != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mTransition.layoutChange(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 调用 view 的 layout 方法</span></span><br><span class="line">        <span class="keyword">super</span>.layout(l, t, r, b);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;  </span><br><span class="line">        <span class="comment">// record the fact that we noop'd it; request layout when transition finishes</span></span><br><span class="line">        mLayoutCalledWhileSuppressed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>ViewGroup</code> 的 <code>layout</code> 方法中又调用了父类的方法 <code>super.layout(l, t, r, b)</code> 。所以我们又要到 <code>View</code> 类中去看。</p>
<h2 id="View-2"><a href="#View-2" class="headerlink" title="View"></a>View</h2><h3 id="layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29-1"><a href="#layout_28int_l_2C_int_t_2C_int_r_2C_int_b_29-1" class="headerlink" title="layout(int l, int t, int r, int b)"></a>layout(int l, int t, int r, int b)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@SuppressWarnings</span>(&#123;<span class="string">"unchecked"</span>&#125;)</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">layout</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> t, <span class="keyword">int</span> r, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> ((mPrivateFlags3 &amp; PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT) != <span class="number">0</span>) &#123;</span><br><span class="line">        onMeasure(mOldWidthMeasureSpec, mOldHeightMeasureSpec);</span><br><span class="line">        mPrivateFlags3 &amp;= ~PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 当前布局的四个顶点</span></span><br><span class="line">    <span class="keyword">int</span> oldL = mLeft;</span><br><span class="line">    <span class="keyword">int</span> oldT = mTop;</span><br><span class="line">    <span class="keyword">int</span> oldB = mBottom;</span><br><span class="line">    <span class="keyword">int</span> oldR = mRight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 计算四个顶点的值，判断布局位置是否改变</span></span><br><span class="line">    <span class="keyword">boolean</span> changed = isLayoutModeOptical(mParent) ?</span><br><span class="line">            setOpticalFrame(l, t, r, b) : setFrame(l, t, r, b);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果视图的大小和位置发生变化，会调用onLayout()</span></span><br><span class="line">    <span class="keyword">if</span> (changed || (mPrivateFlags &amp; PFLAG_LAYOUT_REQUIRED) == PFLAG_LAYOUT_REQUIRED) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 空方法</span></span><br><span class="line">        onLayout(changed, l, t, r, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (shouldDrawRoundScrollbar()) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mRoundScrollbarRenderer == <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRoundScrollbarRenderer = <span class="keyword">new</span> RoundScrollbarRenderer(<span class="keyword">this</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mRoundScrollbarRenderer = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        mPrivateFlags &amp;= ~PFLAG_LAYOUT_REQUIRED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 调用布局位置改变监听器</span></span><br><span class="line">        ListenerInfo li = mListenerInfo;</span><br><span class="line">        <span class="keyword">if</span> (li != <span class="keyword">null</span> &amp;&amp; li.mOnLayoutChangeListeners != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ArrayList&lt;OnLayoutChangeListener&gt; listenersCopy =</span><br><span class="line">                    (ArrayList&lt;OnLayoutChangeListener&gt;)li.mOnLayoutChangeListeners.clone();</span><br><span class="line">            <span class="keyword">int</span> numListeners = listenersCopy.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numListeners; ++i) &#123;</span><br><span class="line">                listenersCopy.get(i).onLayoutChange(<span class="keyword">this</span>, l, t, r, b, oldL, oldT, oldR, oldB);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_FORCE_LAYOUT;</span><br><span class="line">    mPrivateFlags3 |= PFLAG3_IS_LAID_OUT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的代码中做了这几件事：</p>
<ol>
<li>设置当前布局中的四个顶点；</li>
<li>调用 <code>setFrame</code> 来设置新的顶点位置；</li>
<li>调用 <code>onLayout</code> 方法；</li>
<li>回调布局位置改变监听器；</li>
</ol>
<h3 id="setOpticalFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#setOpticalFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="setOpticalFrame(int left, int top, int right, int bottom)"></a>setOpticalFrame(int left, int top, int right, int bottom)</h3><p>我们先来看 <code>setOpticalFrame</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">setOpticalFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    Insets parentInsets = mParent <span class="keyword">instanceof</span> View ?</span><br><span class="line">            ((View) mParent).getOpticalInsets() : Insets.NONE;</span><br><span class="line">    Insets childInsets = getOpticalInsets();</span><br><span class="line">    <span class="comment">// 调用 setFrame 方法</span></span><br><span class="line">    <span class="keyword">return</span> setFrame(</span><br><span class="line">            left   + parentInsets.left - childInsets.left,</span><br><span class="line">            top    + parentInsets.top  - childInsets.top,</span><br><span class="line">            right  + parentInsets.left + childInsets.right,</span><br><span class="line">            bottom + parentInsets.top  + childInsets.bottom);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 <code>setOpticalFrame</code> 的内部也是调用 <code>setFrame</code> 方法的。</p>
<h3 id="setFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#setFrame_28int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="setFrame(int left, int top, int right, int bottom)"></a>setFrame(int left, int top, int right, int bottom)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">setFrame</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> changed = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (DBG) &#123;</span><br><span class="line">        Log.d(<span class="string">"View"</span>, <span class="keyword">this</span> + <span class="string">" View.setFrame("</span> + left + <span class="string">","</span> + top + <span class="string">","</span></span><br><span class="line">                + right + <span class="string">","</span> + bottom + <span class="string">")"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果新值和旧值不相等，那就是布局位置改变了</span></span><br><span class="line">    <span class="keyword">if</span> (mLeft != left || mRight != right || mTop != top || mBottom != bottom) &#123;</span><br><span class="line">        changed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Remember our drawn bit</span></span><br><span class="line">        <span class="keyword">int</span> drawn = mPrivateFlags &amp; PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 计算新的宽高和旧的宽高</span></span><br><span class="line">        <span class="keyword">int</span> oldWidth = mRight - mLeft;</span><br><span class="line">        <span class="keyword">int</span> oldHeight = mBottom - mTop;</span><br><span class="line">        <span class="keyword">int</span> newWidth = right - left;</span><br><span class="line">        <span class="keyword">int</span> newHeight = bottom - top;</span><br><span class="line">        <span class="comment">// 判断大小是否改变</span></span><br><span class="line">        <span class="keyword">boolean</span> sizeChanged = (newWidth != oldWidth) || (newHeight != oldHeight);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Invalidate our old position</span></span><br><span class="line">        invalidate(sizeChanged);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 设置 view 的上下左右，赋予最新的值</span></span><br><span class="line">        mLeft = left;</span><br><span class="line">        mTop = top;</span><br><span class="line">        mRight = right;</span><br><span class="line">        mBottom = bottom;</span><br><span class="line">        mRenderNode.setLeftTopRightBottom(mLeft, mTop, mRight, mBottom);</span><br><span class="line"></span><br><span class="line">        mPrivateFlags |= PFLAG_HAS_BOUNDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 回调大小改变的方法</span></span><br><span class="line">        <span class="keyword">if</span> (sizeChanged) &#123;</span><br><span class="line">            sizeChange(newWidth, newHeight, oldWidth, oldHeight);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || mGhostView != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// If we are visible, force the DRAWN bit to on so that</span></span><br><span class="line">            <span class="comment">// this invalidate will go through (at least to our parent).</span></span><br><span class="line">            <span class="comment">// This is because someone may have invalidated this view</span></span><br><span class="line">            <span class="comment">// before this call to setFrame came in, thereby clearing</span></span><br><span class="line">            <span class="comment">// the DRAWN bit.</span></span><br><span class="line">            mPrivateFlags |= PFLAG_DRAWN;</span><br><span class="line">            invalidate(sizeChanged);</span><br><span class="line">            <span class="comment">// parent display list may need to be recreated based on a change in the bounds</span></span><br><span class="line">            <span class="comment">// of any child</span></span><br><span class="line">            invalidateParentCaches();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Reset drawn bit to original value (invalidate turns it off)</span></span><br><span class="line">        mPrivateFlags |= drawn;</span><br><span class="line"></span><br><span class="line">        mBackgroundSizeChanged = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (mForegroundInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mForegroundInfo.mBoundsChanged = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Android无障碍辅助功能通知</span></span><br><span class="line">        notifySubtreeAccessibilityStateChangedIfNeeded();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> changed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先回根据新旧的宽高进行比较，来确定是不是大小被改变了。如果是，会回调 <code>sizeChange(newWidth, newHeight, oldWidth, oldHeight)</code> 方法，这个方法是不是很眼熟呢？</p>
<p>之后还会把这消息通知给 <code>AccessibilityService</code> 无障碍服务。</p>
<p>最后返回布局是否改变的 boolean 值。</p>
<h2 id="FrameLayout-1"><a href="#FrameLayout-1" class="headerlink" title="FrameLayout"></a>FrameLayout</h2><h3 id="onLayout_28boolean_changed_2C_int_left_2C_int_top_2C_int_right_2C_int_bottom_29"><a href="#onLayout_28boolean_changed_2C_int_left_2C_int_top_2C_int_right_2C_int_bottom_29" class="headerlink" title="onLayout(boolean changed, int left, int top, int right, int bottom)"></a>onLayout(boolean changed, int left, int top, int right, int bottom)</h3><p>接着，根据布局改变值 <code>changed</code> 会调用 <code>onLayout</code> 方法。</p>
<p><code>onLayout</code> 方法在 View/ViewGroup 都是空的，是需要子类来实现的。所以我们还是要看 <code>FrameLayout</code> 中的 <code>onLayout</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onLayout</span><span class="params">(<span class="keyword">boolean</span> changed, <span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom)</span> </span>&#123;</span><br><span class="line">       layoutChildren(left, top, right, bottom, <span class="keyword">false</span> <span class="comment">/* no force left gravity */</span>);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onLayout</code> 中调用了 <code>layoutChildren</code> 方法。</p>
<h3 id="layoutChildren_28int_left_2C_int_top_2C_int_right_2C_int_bottom_2C_boolean_forceLeftGravity_29"><a href="#layoutChildren_28int_left_2C_int_top_2C_int_right_2C_int_bottom_2C_boolean_forceLeftGravity_29" class="headerlink" title="layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity)"></a>layoutChildren(int left, int top, int right, int bottom, boolean forceLeftGravity)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">layoutChildren</span><span class="params">(<span class="keyword">int</span> left, <span class="keyword">int</span> top, <span class="keyword">int</span> right, <span class="keyword">int</span> bottom, <span class="keyword">boolean</span> forceLeftGravity)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> count = getChildCount();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentLeft = getPaddingLeftWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentRight = right - left - getPaddingRightWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentTop = getPaddingTopWithForeground();</span><br><span class="line">       <span class="keyword">final</span> <span class="keyword">int</span> parentBottom = bottom - top - getPaddingBottomWithForeground();</span><br><span class="line"></span><br><span class="line">       <span class="comment">// 遍历子 view</span></span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; count; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> View child = getChildAt(i);</span><br><span class="line">           <span class="keyword">if</span> (child.getVisibility() != GONE) &#123;</span><br><span class="line">               <span class="keyword">final</span> LayoutParams lp = (LayoutParams) child.getLayoutParams();</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 子 view 的宽高</span></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> width = child.getMeasuredWidth();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> height = child.getMeasuredHeight();</span><br><span class="line"></span><br><span class="line">               <span class="keyword">int</span> childLeft;</span><br><span class="line">               <span class="keyword">int</span> childTop;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 得到子 view 的 gravity</span></span><br><span class="line">               <span class="keyword">int</span> gravity = lp.gravity;</span><br><span class="line">               <span class="keyword">if</span> (gravity == -<span class="number">1</span>) &#123;</span><br><span class="line">                   gravity = DEFAULT_CHILD_GRAVITY;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> layoutDirection = getLayoutDirection();</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> absoluteGravity = Gravity.getAbsoluteGravity(gravity, layoutDirection);</span><br><span class="line">               <span class="keyword">final</span> <span class="keyword">int</span> verticalGravity = gravity &amp; Gravity.VERTICAL_GRAVITY_MASK;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据不同的 gravity 来计算 childLeft</span></span><br><span class="line">               <span class="keyword">switch</span> (absoluteGravity &amp; Gravity.HORIZONTAL_GRAVITY_MASK) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_HORIZONTAL:</span><br><span class="line">                       childLeft = parentLeft + (parentRight - parentLeft - width) / <span class="number">2</span> +</span><br><span class="line">                       lp.leftMargin - lp.rightMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.RIGHT:</span><br><span class="line">                       <span class="keyword">if</span> (!forceLeftGravity) &#123;</span><br><span class="line">                           childLeft = parentRight - width - lp.rightMargin;</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.LEFT:</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childLeft = parentLeft + lp.leftMargin;</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">               <span class="comment">// 根据不同的 gravity 来计算 childTop</span></span><br><span class="line">               <span class="keyword">switch</span> (verticalGravity) &#123;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.TOP:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.CENTER_VERTICAL:</span><br><span class="line">                       childTop = parentTop + (parentBottom - parentTop - height) / <span class="number">2</span> +</span><br><span class="line">                       lp.topMargin - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">case</span> Gravity.BOTTOM:</span><br><span class="line">                       childTop = parentBottom - height - lp.bottomMargin;</span><br><span class="line">                       <span class="keyword">break</span>;</span><br><span class="line">                   <span class="keyword">default</span>:</span><br><span class="line">                       childTop = parentTop + lp.topMargin;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">// 调用子 view 的 layout 方法</span></span><br><span class="line">               child.layout(childLeft, childTop, childLeft + width, childTop + height);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>简单来说，在 <code>layoutChildren</code> 中，遍历所有可见的子 View ，然后得到它们的宽高。</p>
<p>再根据不同的 gravity 来计算 childLeft 和 childTop ，最后调用 child.layout 来向子 View 传递下去。</p>
<h2 id="u5C0F_u7ED3-1"><a href="#u5C0F_u7ED3-1" class="headerlink" title="小结"></a>小结</h2><p>我们把 layout 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performLayout -&gt; DecorView(ViewGroup).layout -&gt; View.layout -&gt; DecorView(FrameLayout).onLayout -&gt;  DecorView(FrameLayout).layoutChildren -&gt; ViewGroup.layout -&gt; View.layout -&gt; ViewGroup.onLayout -&gt; … -&gt; View.layout -&gt; View.onLayout</p>
<p>注： </p>
<ul>
<li>ViewGroup.onLayout 是抽象方法，根据不同的 ViewGroup 都有不同的实现方式。但是相同的是，都会遍历调用 child.layout 方法；</li>
<li>View.onLayout 是空方法；</li>
</ul>
<h1 id="draw_u8FC7_u7A0B"><a href="#draw_u8FC7_u7A0B" class="headerlink" title="draw过程"></a>draw过程</h1><p>最后一个，draw 过程。 draw 过程应该来说是比较简单的。</p>
<h2 id="ViewRootImpl-4"><a href="#ViewRootImpl-4" class="headerlink" title="ViewRootImpl"></a>ViewRootImpl</h2><h3 id="performDraw_28_29"><a href="#performDraw_28_29" class="headerlink" title="performDraw()"></a>performDraw()</h3><p>首先起点是 <code>performDraw()</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">performDraw</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mAttachInfo.mDisplayState == Display.STATE_OFF &amp;&amp; !mReportNextDraw) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> fullRedrawNeeded = mFullRedrawNeeded;</span><br><span class="line">    mFullRedrawNeeded = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    mIsDrawing = <span class="keyword">true</span>;</span><br><span class="line">    Trace.traceBegin(Trace.TRACE_TAG_VIEW, <span class="string">"draw"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 调用 draw 方法，fullRedrawNeeded 为是否重新绘制全部视图</span></span><br><span class="line">        draw(fullRedrawNeeded);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        mIsDrawing = <span class="keyword">false</span>;</span><br><span class="line">        Trace.traceEnd(Trace.TRACE_TAG_VIEW);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果是第一次绘制视图，那么显然应该绘制所有的视图，<code>fullRedrawNeeded</code> 参数就为 true ；反之如果由于某些原因，导致了视图重绘，那么就没有必要绘制所有视图，即为 false 。</p>
<h3 id="draw_28boolean_fullRedrawNeeded_29"><a href="#draw_28boolean_fullRedrawNeeded_29" class="headerlink" title="draw(boolean fullRedrawNeeded)"></a>draw(boolean fullRedrawNeeded)</h3><p><code>performDraw()</code> 内部又调用了私有方法 <code>draw(boolean fullRedrawNeeded)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(<span class="keyword">boolean</span> fullRedrawNeeded)</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// dirty 表示需要绘制的区域</span></span><br><span class="line">    <span class="keyword">final</span> Rect dirty = mDirty;</span><br><span class="line">    <span class="keyword">if</span> (mSurfaceHolder != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// The app owns the surface, we won't draw.</span></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        <span class="keyword">if</span> (animating &amp;&amp; mScroller != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mScroller.abortAnimation();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果需要全部绘制，那么 dirty 就是整个屏幕了</span></span><br><span class="line">    <span class="keyword">if</span> (fullRedrawNeeded) &#123;</span><br><span class="line">        mAttachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        dirty.set(<span class="number">0</span>, <span class="number">0</span>, (<span class="keyword">int</span>) (mWidth * appScale + <span class="number">0.5f</span>), (<span class="keyword">int</span>) (mHeight * appScale + <span class="number">0.5f</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用 drawSoftware ，把绘制区域 dirty 传入</span></span><br><span class="line">    <span class="keyword">if</span> (!drawSoftware(surface, mAttachInfo, xOffset, yOffset, scalingRequired, dirty)) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">        </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在确定了绘制的区域 <code>dirty</code> 之后，调用了 <code>drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)</code> 。</p>
<h3 id="drawSoftware_28Surface_surface_2C_AttachInfo_attachInfo_2C_int_xoff_2C_int_yoff_2C_boolean_scalingRequired_2C_Rect_dirty_29"><a href="#drawSoftware_28Surface_surface_2C_AttachInfo_attachInfo_2C_int_xoff_2C_int_yoff_2C_boolean_scalingRequired_2C_Rect_dirty_29" class="headerlink" title="drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)"></a>drawSoftware(Surface surface, AttachInfo attachInfo, int xoff, int yoff, boolean scalingRequired, Rect dirty)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">drawSoftware</span><span class="params">(Surface surface, AttachInfo attachInfo, <span class="keyword">int</span> xoff, <span class="keyword">int</span> yoff,</span><br><span class="line">        <span class="keyword">boolean</span> scalingRequired, Rect dirty)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Draw with software renderer.</span></span><br><span class="line">    <span class="keyword">final</span> Canvas canvas;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> left = dirty.left;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> top = dirty.top;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> right = dirty.right;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> bottom = dirty.bottom;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//锁定画布，由 dirty 区域决定</span></span><br><span class="line">        canvas = mSurface.lockCanvas(dirty);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// The dirty rectangle can be modified by Surface.lockCanvas()</span></span><br><span class="line">        <span class="comment">//noinspection ConstantConditions</span></span><br><span class="line">        <span class="keyword">if</span> (left != dirty.left || top != dirty.top || right != dirty.right</span><br><span class="line">                || bottom != dirty.bottom) &#123;</span><br><span class="line">            attachInfo.mIgnoreDirtyState = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// <span class="doctag">TODO:</span> Do this in native</span></span><br><span class="line">        canvas.setDensity(mDensity);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Surface.OutOfResourcesException e) &#123;</span><br><span class="line">        handleOutOfResourcesException(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">        Log.e(mTag, <span class="string">"Could not lock surface"</span>, e);</span><br><span class="line">        <span class="comment">// Don't assume this is due to out of memory, it could be</span></span><br><span class="line">        <span class="comment">// something else, and if it is something else then we could</span></span><br><span class="line">        <span class="comment">// kill stuff (or ourself) for no reason.</span></span><br><span class="line">        mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG_ORIENTATION || DEBUG_DRAW) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" drawing to bitmap w="</span></span><br><span class="line">                    + canvas.getWidth() + <span class="string">", h="</span> + canvas.getHeight());</span><br><span class="line">            <span class="comment">//canvas.drawARGB(255, 255, 0, 0);</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If this bitmap's format includes an alpha channel, we</span></span><br><span class="line">        <span class="comment">// need to clear it before drawing so that the child will</span></span><br><span class="line">        <span class="comment">// properly re-composite its drawing on a transparent</span></span><br><span class="line">        <span class="comment">// background. This automatically respects the clip/dirty region</span></span><br><span class="line">        <span class="comment">// or</span></span><br><span class="line">        <span class="comment">// If we are applying an offset, we need to clear the area</span></span><br><span class="line">        <span class="comment">// where the offset doesn't appear to avoid having garbage</span></span><br><span class="line">        <span class="comment">// left in the blank areas.</span></span><br><span class="line">        <span class="keyword">if</span> (!canvas.isOpaque() || yoff != <span class="number">0</span> || xoff != <span class="number">0</span>) &#123;</span><br><span class="line">            canvas.drawColor(<span class="number">0</span>, PorterDuff.Mode.CLEAR);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        dirty.setEmpty();</span><br><span class="line">        mIsAnimating = <span class="keyword">false</span>;</span><br><span class="line">        mView.mPrivateFlags |= View.PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (DEBUG_DRAW) &#123;</span><br><span class="line">            Context cxt = mView.getContext();</span><br><span class="line">            Log.i(mTag, <span class="string">"Drawing: package:"</span> + cxt.getPackageName() +</span><br><span class="line">                    <span class="string">", metrics="</span> + cxt.getResources().getDisplayMetrics() +</span><br><span class="line">                    <span class="string">", compatibilityInfo="</span> + cxt.getResources().getCompatibilityInfo());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            canvas.translate(-xoff, -yoff);</span><br><span class="line">            <span class="keyword">if</span> (mTranslator != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mTranslator.translateCanvas(canvas);</span><br><span class="line">            &#125;</span><br><span class="line">            canvas.setScreenDensity(scalingRequired ? mNoncompatDensity : <span class="number">0</span>);</span><br><span class="line">            attachInfo.mSetIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 调用 View 的 draw 方法</span></span><br><span class="line">            mView.draw(canvas);</span><br><span class="line"></span><br><span class="line">            drawAccessibilityFocusedDrawableIfNeeded(canvas);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (!attachInfo.mSetIgnoreDirtyState) &#123;</span><br><span class="line">                <span class="comment">// Only clear the flag if it was not set during the mView.draw() call</span></span><br><span class="line">                attachInfo.mIgnoreDirtyState = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            surface.unlockCanvasAndPost(canvas);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IllegalArgumentException e) &#123;</span><br><span class="line">            Log.e(mTag, <span class="string">"Could not unlock surface"</span>, e);</span><br><span class="line">            mLayoutRequested = <span class="keyword">true</span>;    <span class="comment">// ask wm for a new surface next time.</span></span><br><span class="line">            <span class="comment">//noinspection ReturnInsideFinallyBlock</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (LOCAL_LOGV) &#123;</span><br><span class="line">            Log.v(mTag, <span class="string">"Surface "</span> + surface + <span class="string">" unlockCanvasAndPost"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="View-3"><a href="#View-3" class="headerlink" title="View"></a>View</h2><h3 id="draw_28Canvas_canvas_29"><a href="#draw_28Canvas_canvas_29" class="headerlink" title="draw(Canvas canvas)"></a>draw(Canvas canvas)</h3><p>之后调用了 <code>View</code> 的 <code>draw(Canvas canvas)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">draw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> privateFlags = mPrivateFlags;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> dirtyOpaque = (privateFlags &amp; PFLAG_DIRTY_MASK) == PFLAG_DIRTY_OPAQUE &amp;&amp;</span><br><span class="line">            (mAttachInfo == <span class="keyword">null</span> || !mAttachInfo.mIgnoreDirtyState);</span><br><span class="line">    mPrivateFlags = (privateFlags &amp; ~PFLAG_DIRTY_MASK) | PFLAG_DRAWN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Draw traversal performs several drawing steps which must be executed</span><br><span class="line">     * in the appropriate order:</span><br><span class="line">     *</span><br><span class="line">     *      1. Draw the background</span><br><span class="line">     *      2. If necessary, save the canvas' layers to prepare for fading</span><br><span class="line">     *      3. Draw view's content</span><br><span class="line">     *      4. Draw children</span><br><span class="line">     *      5. If necessary, draw the fading edges and restore layers</span><br><span class="line">     *      6. Draw decorations (scrollbars for instance)</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第一步，画背景</span></span><br><span class="line">    <span class="keyword">int</span> saveCount;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) &#123;</span><br><span class="line">        drawBackground(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// skip step 2 &amp; 5 if possible (common case)</span></span><br><span class="line">    <span class="comment">// 可能的话，跳过第二步和第五步</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> viewFlags = mViewFlags;</span><br><span class="line">    <span class="keyword">boolean</span> horizontalEdges = (viewFlags &amp; FADING_EDGE_HORIZONTAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">boolean</span> verticalEdges = (viewFlags &amp; FADING_EDGE_VERTICAL) != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (!verticalEdges &amp;&amp; !horizontalEdges) &#123;</span><br><span class="line">        <span class="comment">// 第三步，画自己的内容</span></span><br><span class="line">        <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第四步，画自己子 view 的内容</span></span><br><span class="line">        dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">        <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">            mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 第六步，绘制View的装饰，比如 scrollbar 等 (foreground, scrollbars)</span></span><br><span class="line">        onDrawForeground(canvas);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 做完了，直接返回 we're done...</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span><br><span class="line">     * Here we do the full fledged routine...</span><br><span class="line">     * (this is an uncommon case where speed matters less,</span><br><span class="line">     * this is why we repeat some of the tests that have been</span><br><span class="line">     * done above)</span><br><span class="line">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> drawTop = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawBottom = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawLeft = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">boolean</span> drawRight = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> topFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> bottomFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> leftFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line">    <span class="keyword">float</span> rightFadeStrength = <span class="number">0.0f</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第二步，保存 canvas 图层</span></span><br><span class="line">    <span class="keyword">int</span> paddingLeft = mPaddingLeft;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> offsetRequired = isPaddingOffsetRequired();</span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        paddingLeft += getLeftPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> left = mScrollX + paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> right = left + mRight - mLeft - mPaddingRight - paddingLeft;</span><br><span class="line">    <span class="keyword">int</span> top = mScrollY + getFadeTop(offsetRequired);</span><br><span class="line">    <span class="keyword">int</span> bottom = top + getFadeHeight(offsetRequired);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (offsetRequired) &#123;</span><br><span class="line">        right += getRightPaddingOffset();</span><br><span class="line">        bottom += getBottomPaddingOffset();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> ScrollabilityCache scrollabilityCache = mScrollCache;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">float</span> fadeHeight = scrollabilityCache.fadingEdgeLength;</span><br><span class="line">    <span class="keyword">int</span> length = (<span class="keyword">int</span>) fadeHeight;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// clip the fade length if top and bottom fades overlap</span></span><br><span class="line">    <span class="comment">// overlapping fades produce odd-looking artifacts</span></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges &amp;&amp; (top + length &gt; bottom - length)) &#123;</span><br><span class="line">        length = (bottom - top) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// also clip horizontal fades if necessary</span></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges &amp;&amp; (left + length &gt; right - length)) &#123;</span><br><span class="line">        length = (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (verticalEdges) &#123;</span><br><span class="line">        topFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getTopFadingEdgeStrength()));</span><br><span class="line">        drawTop = topFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        bottomFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getBottomFadingEdgeStrength()));</span><br><span class="line">        drawBottom = bottomFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (horizontalEdges) &#123;</span><br><span class="line">        leftFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getLeftFadingEdgeStrength()));</span><br><span class="line">        drawLeft = leftFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">        rightFadeStrength = Math.max(<span class="number">0.0f</span>, Math.min(<span class="number">1.0f</span>, getRightFadingEdgeStrength()));</span><br><span class="line">        drawRight = rightFadeStrength * fadeHeight &gt; <span class="number">1.0f</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    saveCount = canvas.getSaveCount();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> solidColor = getSolidColor();</span><br><span class="line">    <span class="keyword">if</span> (solidColor == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> flags = Canvas.HAS_ALPHA_LAYER_SAVE_FLAG;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, right, top + length, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">            canvas.saveLayer(left, bottom - length, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">            canvas.saveLayer(left, top, left + length, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">            canvas.saveLayer(right - length, top, right, bottom, <span class="keyword">null</span>, flags);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        scrollabilityCache.setFadeColor(solidColor);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 3, draw the content</span></span><br><span class="line">    <span class="keyword">if</span> (!dirtyOpaque) onDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 4, draw the children</span></span><br><span class="line">    dispatchDraw(canvas);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 第五步，绘制边缘效果和恢复图层</span></span><br><span class="line">    <span class="keyword">final</span> Paint p = scrollabilityCache.paint;</span><br><span class="line">    <span class="keyword">final</span> Matrix matrix = scrollabilityCache.matrix;</span><br><span class="line">    <span class="keyword">final</span> Shader fade = scrollabilityCache.shader;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawTop) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * topFadeStrength);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, right, top + length, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawBottom) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * bottomFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">180</span>);</span><br><span class="line">        matrix.postTranslate(left, bottom);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, bottom - length, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawLeft) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * leftFadeStrength);</span><br><span class="line">        matrix.postRotate(-<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(left, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(left, top, left + length, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (drawRight) &#123;</span><br><span class="line">        matrix.setScale(<span class="number">1</span>, fadeHeight * rightFadeStrength);</span><br><span class="line">        matrix.postRotate(<span class="number">90</span>);</span><br><span class="line">        matrix.postTranslate(right, top);</span><br><span class="line">        fade.setLocalMatrix(matrix);</span><br><span class="line">        p.setShader(fade);</span><br><span class="line">        canvas.drawRect(right - length, top, right, bottom, p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    canvas.restoreToCount(saveCount);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Overlay is part of the content and draws beneath Foreground</span></span><br><span class="line">    <span class="keyword">if</span> (mOverlay != <span class="keyword">null</span> &amp;&amp; !mOverlay.isEmpty()) &#123;</span><br><span class="line">        mOverlay.getOverlayView().dispatchDraw(canvas);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Step 6, draw decorations (foreground, scrollbars)</span></span><br><span class="line">    onDrawForeground(canvas);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>draw 过程大概有下面几步：</p>
<ol>
<li>绘制背景：<code>background.draw(canvas)</code> ；</li>
<li>保存当前的图层信息（一般来说跳过）；</li>
<li>绘制自己：<code>onDraw(canvas)</code> ；</li>
<li>绘制children：<code>dispatchDraw(canvas)</code> ；</li>
<li>绘制边缘效果，恢复图层（一般来说跳过）；</li>
<li>绘制前景装饰：<code>onDrawForeground(canvas)</code> 。</li>
</ol>
<p>在这里，我们继续看一下 <code>dispatchDraw(Canvas canvas)</code> 方法，这个方法是向子 View 分发绘制流程的。</p>
<p>因为 View 没有子 View ，所以 <code>dispatchDraw(Canvas canvas)</code> 方法是空的，所以我们要到 ViewGroup 中去看看。</p>
<h2 id="ViewGroup-3"><a href="#ViewGroup-3" class="headerlink" title="ViewGroup"></a>ViewGroup</h2><h3 id="dispatchDraw_28Canvas_canvas_29"><a href="#dispatchDraw_28Canvas_canvas_29" class="headerlink" title="dispatchDraw(Canvas canvas)"></a>dispatchDraw(Canvas canvas)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">dispatchDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> usingRenderNodeProperties = canvas.isRecordingFor(mRenderNode);</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> childrenCount = mChildrenCount;</span><br><span class="line">    <span class="keyword">final</span> View[] children = mChildren;</span><br><span class="line">    <span class="keyword">int</span> flags = mGroupFlags;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; FLAG_RUN_ANIMATION) != <span class="number">0</span> &amp;&amp; canAnimate()) &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">boolean</span> buildCache = !isHardwareAccelerated();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 遍历子 view </span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> View child = children[i];</span><br><span class="line">            <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE) &#123;</span><br><span class="line">                <span class="keyword">final</span> LayoutParams params = child.getLayoutParams();</span><br><span class="line">                attachLayoutAnimationParameters(child, params, i, childrenCount);</span><br><span class="line">                bindLayoutAnimation(child);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> LayoutAnimationController controller = mLayoutAnimationController;</span><br><span class="line">        <span class="keyword">if</span> (controller.willOverlap()) &#123;</span><br><span class="line">            mGroupFlags |= FLAG_OPTIMIZE_INVALIDATE;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        controller.start();</span><br><span class="line"></span><br><span class="line">        mGroupFlags &amp;= ~FLAG_RUN_ANIMATION;</span><br><span class="line">        mGroupFlags &amp;= ~FLAG_ANIMATION_DONE;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (mAnimationListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mAnimationListener.onAnimationStart(controller.getAnimation());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> clipSaveCount = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> clipToPadding = (flags &amp; CLIP_TO_PADDING_MASK) == CLIP_TO_PADDING_MASK;</span><br><span class="line">    <span class="keyword">if</span> (clipToPadding) &#123;</span><br><span class="line">        clipSaveCount = canvas.save();</span><br><span class="line">        canvas.clipRect(mScrollX + mPaddingLeft, mScrollY + mPaddingTop,</span><br><span class="line">                mScrollX + mRight - mLeft - mPaddingRight,</span><br><span class="line">                mScrollY + mBottom - mTop - mPaddingBottom);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We will draw our child's animation, let's reset the flag</span></span><br><span class="line">    mPrivateFlags &amp;= ~PFLAG_DRAW_ANIMATION;</span><br><span class="line">    mGroupFlags &amp;= ~FLAG_INVALIDATE_REQUIRED;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">boolean</span> more = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">long</span> drawingTime = getDrawingTime();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (usingRenderNodeProperties) canvas.insertReorderBarrier();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> transientCount = mTransientIndices == <span class="keyword">null</span> ? <span class="number">0</span> : mTransientIndices.size();</span><br><span class="line">    <span class="keyword">int</span> transientIndex = transientCount != <span class="number">0</span> ? <span class="number">0</span> : -<span class="number">1</span>;</span><br><span class="line">    <span class="comment">// Only use the preordered list if not HW accelerated, since the HW pipeline will do the</span></span><br><span class="line">    <span class="comment">// draw reordering internally</span></span><br><span class="line">    <span class="keyword">final</span> ArrayList&lt;View&gt; preorderedList = usingRenderNodeProperties</span><br><span class="line">            ? <span class="keyword">null</span> : buildOrderedChildList();</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> customOrder = preorderedList == <span class="keyword">null</span></span><br><span class="line">            &amp;&amp; isChildrenDrawingOrderEnabled();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; childrenCount; i++) &#123;</span><br><span class="line">        <span class="keyword">while</span> (transientIndex &gt;= <span class="number">0</span> &amp;&amp; mTransientIndices.get(transientIndex) == i) &#123;</span><br><span class="line">            <span class="keyword">final</span> View transientChild = mTransientViews.get(transientIndex);</span><br><span class="line">            <span class="keyword">if</span> ((transientChild.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE ||</span><br><span class="line">                    transientChild.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                more |= drawChild(canvas, transientChild, drawingTime);</span><br><span class="line">            &#125;</span><br><span class="line">            transientIndex++;</span><br><span class="line">            <span class="keyword">if</span> (transientIndex &gt;= transientCount) &#123;</span><br><span class="line">                transientIndex = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> childIndex = getAndVerifyPreorderedIndex(childrenCount, i, customOrder);</span><br><span class="line">        <span class="keyword">final</span> View child = getAndVerifyPreorderedView(preorderedList, children, childIndex);</span><br><span class="line">        <span class="keyword">if</span> ((child.mViewFlags &amp; VISIBILITY_MASK) == VISIBLE || child.getAnimation() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 调用 drawChild 来绘制子 view</span></span><br><span class="line">            more |= drawChild(canvas, child, drawingTime);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>dispatchDraw(Canvas canvas)</code> 中，遍历子 View ，然后调用 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 方法来执行子 View 的绘制流程。</p>
<h3 id="drawChild_28Canvas_canvas_2C_View_child_2C_long_drawingTime_29"><a href="#drawChild_28Canvas_canvas_2C_View_child_2C_long_drawingTime_29" class="headerlink" title="drawChild(Canvas canvas, View child, long drawingTime)"></a>drawChild(Canvas canvas, View child, long drawingTime)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">drawChild</span><span class="params">(Canvas canvas, View child, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> child.draw(canvas, <span class="keyword">this</span>, drawingTime);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发现在 <code>drawChild(Canvas canvas, View child, long drawingTime)</code> 中还是调用了 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 方法。但是这个 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 和上面的 <code>draw(Canvas canvas)</code> 参数不同，所以不是同一个方法。</p>
<h2 id="View-4"><a href="#View-4" class="headerlink" title="View"></a>View</h2><h3 id="draw_28Canvas_canvas_2C_ViewGroup_parent_2C_long_drawingTime_29"><a href="#draw_28Canvas_canvas_2C_ViewGroup_parent_2C_long_drawingTime_29" class="headerlink" title="draw(Canvas canvas, ViewGroup parent, long drawingTime)"></a>draw(Canvas canvas, ViewGroup parent, long drawingTime)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">draw</span><span class="params">(Canvas canvas, ViewGroup parent, <span class="keyword">long</span> drawingTime)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 如果没有绘制缓存</span></span><br><span class="line">       <span class="keyword">if</span> (!drawingWithDrawingCache) &#123;</span><br><span class="line">           <span class="keyword">if</span> (drawingWithRenderNode) &#123;</span><br><span class="line">               mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">               ((DisplayListCanvas) canvas).drawRenderNode(renderNode);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// Fast path for layouts with no backgrounds</span></span><br><span class="line">               <span class="comment">// 如果设置了 willNotDraw 为 true ，那么不会绘制自己，直接跳过，优化绘制性能</span></span><br><span class="line">               <span class="comment">// View 默认是 false ，ViewGroup 默认是 true ，直接让自己的子 View 进入绘制</span></span><br><span class="line">               <span class="keyword">if</span> ((mPrivateFlags &amp; PFLAG_SKIP_DRAW) == PFLAG_SKIP_DRAW) &#123;</span><br><span class="line">                   mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">                   dispatchDraw(canvas);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="comment">// 调用 draw 方法</span></span><br><span class="line">                   draw(canvas);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="comment">// 有缓存就用缓存绘制</span></span><br><span class="line">           mPrivateFlags &amp;= ~PFLAG_DIRTY_MASK;</span><br><span class="line">           <span class="keyword">if</span> (layerType == LAYER_TYPE_NONE || mLayerPaint == <span class="keyword">null</span>) &#123;</span><br><span class="line">               <span class="comment">// no layer paint, use temporary paint to draw bitmap</span></span><br><span class="line">               Paint cachePaint = parent.mCachePaint;</span><br><span class="line">               <span class="keyword">if</span> (cachePaint == <span class="keyword">null</span>) &#123;</span><br><span class="line">                   cachePaint = <span class="keyword">new</span> Paint();</span><br><span class="line">                   cachePaint.setDither(<span class="keyword">false</span>);</span><br><span class="line">                   parent.mCachePaint = cachePaint;</span><br><span class="line">               &#125;</span><br><span class="line">               cachePaint.setAlpha((<span class="keyword">int</span>) (alpha * <span class="number">255</span>));</span><br><span class="line">               canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, cachePaint);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="comment">// use layer paint to draw the bitmap, merging the two alphas, but also restore</span></span><br><span class="line">               <span class="keyword">int</span> layerPaintAlpha = mLayerPaint.getAlpha();</span><br><span class="line">               <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                   mLayerPaint.setAlpha((<span class="keyword">int</span>) (alpha * layerPaintAlpha));</span><br><span class="line">               &#125;</span><br><span class="line">               canvas.drawBitmap(cache, <span class="number">0.0f</span>, <span class="number">0.0f</span>, mLayerPaint);</span><br><span class="line">               <span class="keyword">if</span> (alpha &lt; <span class="number">1</span>) &#123;</span><br><span class="line">                   mLayerPaint.setAlpha(layerPaintAlpha);</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>draw(Canvas canvas, ViewGroup parent, long drawingTime)</code> 中，若没有缓存的话：</p>
<ul>
<li>若 <code>willNotDraw</code> 设置为 false 的话，那么调用 <code>draw(canvas)</code> ；</li>
<li>否则直接调用 <code>dispatchDraw(canvas)</code> 分发给子 View ，一般适用于 ViewGroup ；</li>
</ul>
<p><code>willNotDraw</code> 代表一个 View 不需要绘制任何内容的话，那么系统会跳过，进行性能上的优化。</p>
<p>到这里，就调用了子 View 的 <code>draw(Canvas canvas)</code> 方法，从而实现了绘制过程的向下传递。</p>
<h2 id="u5C0F_u7ED3-2"><a href="#u5C0F_u7ED3-2" class="headerlink" title="小结"></a>小结</h2><p>我们把 draw 过程的代码流程理一下：</p>
<p>ViewRootImpl.performTraversals -&gt; ViewRootImpl.performDraw -&gt; ViewRootImpl.draw(boolean fullRedrawNeeded) -&gt; ViewRootImpl.drawSoftware -&gt; DecorView(View).draw(Canvas canvas) -&gt; DecorView(ViewGroup).dispatchDraw -&gt; DecorView(ViewGroup).drawChild -&gt; ViewGroup(View).draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; ViewGroup.dispatchDraw -&gt; ViewGroup.drawChild -&gt; ViewGroup.draw(Canvas canvas, ViewGroup parent, long drawingTime) -&gt; … -&gt; View.draw(Canvas canvas) -&gt; View.onDraw -&gt; View.dispatchDraw</p>
<p>注：</p>
<ul>
<li>其中 <code>View.dispatchDraw</code> 为空实现；</li>
<li>DecorView 在 <code>draw(Canvas canvas)</code> 的方法内不会调用 <code>onDraw</code> 方法；</li>
<li>ViewGroup 不会调用 <code>draw(Canvas canvas)</code> 方法；</li>
</ul>
<h1 id="u6700_u540E"><a href="#u6700_u540E" class="headerlink" title="最后"></a>最后</h1><p>总体来说，三个流程中主要还是 measure 过程较复杂。其他的两个流程整体上来说还是比较清晰简单的。</p>
<p>可以说 View 工作的三大流程是每一位 Android 开发者都必须掌握的。之前虽然也了解，但是没有写成博客好好捋一下，现在终于完成了，篇幅真的太长了。 ^_^</p>
<p>另外，除了需要了解这三大流程外，还需要知道 <code>requestLayout</code> 和 <code>invalidate</code> 等方法的原理。这些东西等有空了我理一理再写出来给大家吧。</p>
<p>今天就这样了，如果有不懂的地方可以在下面留言。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/a65861e946cb" target="_blank" rel="external">View绘制流程及源码解析(一)——performTraversals()源码分析</a></li>
<li><a href="http://blog.csdn.net/feiduclear_up/article/details/46772477" target="_blank" rel="external">从ViewRootImpl类分析View绘制的流程</a></li>
<li><a href="http://blog.csdn.net/a553181867/article/details/51494058" target="_blank" rel="external">Android View 测量流程(Measure)完全解析</a></li>
<li><a href="http://www.jianshu.com/p/6d66ea4998de" target="_blank" rel="external">Android学习笔记—深入理解View#04</a></li>
<li><a href="http://blog.csdn.net/a553181867/article/details/51570854" target="_blank" rel="external">Android View 绘制流程(Draw) 完全解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>注：本文分析的源码基于 Android API 25</p>
<h1 id="View_u7ED8_u5236_u7684_u8D77_u70B9"><a href="#View_u7ED8_u5236_u7684_u8D77_u70B9" class="headerlin]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="View" scheme="http://yuqirong.me/tags/View/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Retrofit源码解析]]></title>
    <link href="http://yuqirong.me/2017/08/03/Retrofit%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/08/03/Retrofit源码解析/</id>
    <published>2017-08-03T15:19:17.000Z</published>
    <updated>2017-08-05T11:47:36.360Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前对 OkHttp 进行过源码分析了，那么今天就来讲讲 Retrofit 。</p>
<p>Retrofit 其实是对 OkHttp 进行了一层封装，让开发者对网络操作更加方便快捷。</p>
<p>相信绝大多数的 Android 开发者都有使用过的经历。其 restful 风格的编程俘获了众多人的心。</p>
<p>废话就不多讲了，下面就要对 Retrofit 进行源码解析。</p>
<p>本文解析的 Retrofit 基于 v2.3.0 ，GitHub 地址：<a href="https://github.com/square/retrofit" target="_blank" rel="external">https://github.com/square/retrofit</a></p>
<h1 id="Retrofit__u4F7F_u7528_u65B9_u6CD5"><a href="#Retrofit__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Retrofit 使用方法"></a>Retrofit 使用方法</h1><p>直接抄官网的：</p>
<p>第一步，声明 API 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">GitHubService</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@GET</span>(<span class="string">"users/&#123;user&#125;/repos"</span>)</span><br><span class="line">  Call&lt;List&lt;Repo&gt;&gt; listRepos(<span class="annotation">@Path</span>(<span class="string">"user"</span>) String user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二步，构造出 <code>Retrofit</code> 对象：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder()</span><br><span class="line">    .baseUrl(<span class="string">"https://api.github.com/"</span>)</span><br><span class="line">    .addConverterFactory(GsonConverterFactory.create())</span><br><span class="line">    .build();</span><br></pre></td></tr></table></figure>
<p>第三步，得到 API 接口，直接调用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">GitHubService service = retrofit.create(GitHubService.class);</span><br><span class="line">Call&lt;List&lt;Repo&gt;&gt; repos = service.listRepos(<span class="string">"octocat"</span>);</span><br></pre></td></tr></table></figure>
<p>最后，就是调用 <code>repos</code> 执行 Call ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// sync</span></span><br><span class="line">repos.execute();</span><br><span class="line"><span class="comment">// async</span></span><br><span class="line">repos.enqueue(...);</span><br></pre></td></tr></table></figure>
<h1 id="u8BF7_u6C42_u6E90_u7801_u89E3_u6790"><a href="#u8BF7_u6C42_u6E90_u7801_u89E3_u6790" class="headerlink" title="请求源码解析"></a>请求源码解析</h1><p>我们先来看看发出网络请求部分的源码。</p>
<h2 id="Retrofit-Builder"><a href="#Retrofit-Builder" class="headerlink" title="Retrofit.Builder"></a>Retrofit.Builder</h2><p>首先切入点就是 <code>Retrofit.Builder</code> 。</p>
<p>在 <code>Retrofit.Builder</code> 中有以下的方法：</p>
<ul>
<li>client ： 设置 http client，默认是 OkHttpClient，会调用 <code>callFactory</code> 方法</li>
<li>callFactory ： 设置网络请求 call 的工厂，默认就是上面的 OkHttpClient</li>
<li>baseUrl ： api 的 base url</li>
<li>addConverterFactory ： 添加数据转换器工厂</li>
<li>addCallAdapterFactory　：　添加网络请求适配器工厂</li>
<li>callbackExecutor ： 回调方法执行器</li>
<li>validateEagerly ： 是否提前解析接口方法</li>
</ul>
<p>这些都是用来配置 <code>Builder</code> 的。</p>
<p>那么我们来看下 <code>Builder</code> 的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 确定平台，有 Android Java8 默认Platform 三种</span></span><br><span class="line">  <span class="keyword">this</span>(Platform.get());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Builder(Platform platform) &#123;</span><br><span class="line">  <span class="keyword">this</span>.platform = platform;</span><br><span class="line">  <span class="comment">// Add the built-in converter factory first. This prevents overriding its behavior but also</span></span><br><span class="line">  <span class="comment">// ensures correct behavior when using converters that consume all types.</span></span><br><span class="line">  <span class="comment">// 默认内置的数据转换器 BuiltInConverters</span></span><br><span class="line">  converterFactories.add(<span class="keyword">new</span> BuiltInConverters());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来个小插曲，我们来看下 Retrofit 是如何确定平台的：</p>
<h3 id="Platform"><a href="#Platform" class="headerlink" title="Platform"></a>Platform</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Platform PLATFORM = findPlatform();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> Platform <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> PLATFORM;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Platform <span class="title">findPlatform</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">"android.os.Build"</span>);</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT != <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> Android();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    Class.forName(<span class="string">"java.util.Optional"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Java8();</span><br><span class="line">  &#125; <span class="keyword">catch</span> (ClassNotFoundException ignored) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Platform();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码中可以看到，是通过反射判断有没有该类来实现的。若以后在开发的过程中有需要判断平台的需求，我们可以直接将该段代码 copy 过来。</p>
<p>接着，在创建 <code>Builder</code> 对象并进行自定义配置后，我们就要调用 <code>build()</code> 方法来构造出 <code>Retrofit</code> 对象了。那么，我们来看下 <code>build()</code> 方法里干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Retrofit <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (baseUrl == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Base URL required."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 默认为 OkHttpClient</span></span><br><span class="line">  okhttp3.Call.Factory callFactory = <span class="keyword">this</span>.callFactory;</span><br><span class="line">  <span class="keyword">if</span> (callFactory == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callFactory = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Android 平台下默认为 MainThreadExecutor</span></span><br><span class="line">  Executor callbackExecutor = <span class="keyword">this</span>.callbackExecutor;</span><br><span class="line">  <span class="keyword">if</span> (callbackExecutor == <span class="keyword">null</span>) &#123;</span><br><span class="line">    callbackExecutor = platform.defaultCallbackExecutor();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Make a defensive copy of the adapters and add the default Call adapter.</span></span><br><span class="line">  List&lt;CallAdapter.Factory&gt; adapterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.adapterFactories);</span><br><span class="line">  <span class="comment">// 添加 ExecutorCallAdapterFactory</span></span><br><span class="line">  adapterFactories.add(platform.defaultCallAdapterFactory(callbackExecutor));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Make a defensive copy of the converters. 默认有 BuiltInConverters</span></span><br><span class="line">  List&lt;Converter.Factory&gt; converterFactories = <span class="keyword">new</span> ArrayList&lt;&gt;(<span class="keyword">this</span>.converterFactories);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Retrofit(callFactory, baseUrl, converterFactories, adapterFactories,</span><br><span class="line">      callbackExecutor, validateEagerly);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中，做的事情有：检查配置、设置默认配置、创建 <code>Retrofit</code> 对象。</p>
<p>关于上面种种奇怪的类，我们先不关心，因为之后我们遇到了再分析。我们先把目光聚焦在 <code>Retrofit</code> 类上。</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><p><code>Retrofit</code> 类的构造方法没什么好看的，在这就不讲了。</p>
<p>得到 <code>Retrofit</code> 对象后就是调用 <code>create(final Class&lt;T&gt; service)</code> 方法来创建我们 API 接口的实例。</p>
<p>所以我们需要跟进 <code>create(final Class&lt;T&gt; service)</code> 中来看下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">T <span class="title">create</span><span class="params">(<span class="keyword">final</span> Class&lt;T&gt; service)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 校验是否为接口，且不能继承其他接口</span></span><br><span class="line">  Utils.validateServiceInterface(service);</span><br><span class="line">  <span class="comment">// 是否需要提前解析接口方法</span></span><br><span class="line">  <span class="keyword">if</span> (validateEagerly) &#123;</span><br><span class="line">    eagerlyValidateMethods(service);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 动态代理模式</span></span><br><span class="line">  <span class="keyword">return</span> (T) Proxy.newProxyInstance(service.getClassLoader(), <span class="keyword">new</span> Class&lt;?&gt;[] &#123; service &#125;,</span><br><span class="line">      <span class="keyword">new</span> InvocationHandler() &#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Platform platform = Platform.get();</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object... args)</span></span><br><span class="line">            <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">          <span class="comment">// If the method is a method from Object then defer to normal invocation.</span></span><br><span class="line">          <span class="keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;</span><br><span class="line">            <span class="keyword">return</span> method.invoke(<span class="keyword">this</span>, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">if</span> (platform.isDefaultMethod(method)) &#123;</span><br><span class="line">            <span class="keyword">return</span> platform.invokeDefaultMethod(method, service, proxy, args);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">          ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">          OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line">          <span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，最关键的就是动态代理。实际上，进行网络操作的都是通过代理类来完成的。如果对动态代理不太懂的同学请自行百度了，这里就不多讲了。</p>
<p>重点就是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将接口中的方法构造为 ServiceMethod</span></span><br><span class="line">ServiceMethod serviceMethod = loadServiceMethod(method);</span><br><span class="line">OkHttpCall okHttpCall = <span class="keyword">new</span> OkHttpCall&lt;&gt;(serviceMethod, args);</span><br><span class="line"><span class="keyword">return</span> serviceMethod.callAdapter.adapt(okHttpCall);</span><br></pre></td></tr></table></figure>
<p>这三句代码，下面我们着重来看。</p>
<p>在代理中，会根据参数中传入的具体接口方法来构造出对应的 <code>serviceMethod</code> 。<code>ServiceMethod</code> 类的作用就是把接口的方法适配为对应的 HTTP call 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ServiceMethod <span class="title">loadServiceMethod</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line">  ServiceMethod result;</span><br><span class="line">  <span class="keyword">synchronized</span> (serviceMethodCache) &#123;</span><br><span class="line"> <span class="comment">// 先从缓存中取，若没有就去创建对应的 ServiceMethod</span></span><br><span class="line">    result = serviceMethodCache.get(method);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 没有缓存就创建，之后再放入缓存中</span></span><br><span class="line">      result = <span class="keyword">new</span> ServiceMethod.Builder(<span class="keyword">this</span>, method).build();</span><br><span class="line">      serviceMethodCache.put(method, result);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在内部还维护了一个 <code>serviceMethodCache</code> 来缓存 <code>ServiceMethod</code> ，以便提高效率。我们就直接来看 <code>ServiceMethod</code> 是如何被创建的吧。</p>
<h2 id="ServiceMethod-Builder"><a href="#ServiceMethod-Builder" class="headerlink" title="ServiceMethod.Builder"></a>ServiceMethod.Builder</h2><p>发现 <code>ServiceMethod</code> 也是通过建造者模式来创建对象的。那就进入对应构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Builder</span><span class="params">(Retrofit retrofit, Method method)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.retrofit = retrofit;</span><br><span class="line">  <span class="keyword">this</span>.method = method;</span><br><span class="line">  <span class="comment">// 接口方法的注解</span></span><br><span class="line">  <span class="keyword">this</span>.methodAnnotations = method.getAnnotations();</span><br><span class="line">  <span class="comment">// 接口方法的参数类型</span></span><br><span class="line">  <span class="keyword">this</span>.parameterTypes = method.getGenericParameterTypes();</span><br><span class="line">  <span class="comment">// 接口方法参数的注解</span></span><br><span class="line">  <span class="keyword">this</span>.parameterAnnotationsArray = method.getParameterAnnotations();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中没有什么大的动作，那么就单刀直入 <code>build()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServiceMethod <span class="title">build</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 根据接口方法的注解和返回类型创建 callAdapter</span></span><br><span class="line">  <span class="comment">// 如果没有添加 CallAdapter 那么默认会用 ExecutorCallAdapterFactory</span></span><br><span class="line">  callAdapter = createCallAdapter();</span><br><span class="line">  <span class="comment">// calladapter 的响应类型中的泛型，比如 Call&lt;User&gt; 中的 User</span></span><br><span class="line">  responseType = callAdapter.responseType();</span><br><span class="line">  <span class="keyword">if</span> (responseType == Response.class || responseType == okhttp3.Response.class) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"'"</span></span><br><span class="line">        + Utils.getRawType(responseType).getName()</span><br><span class="line">        + <span class="string">"' is not a valid response body type. Did you mean ResponseBody?"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据之前泛型中的类型以及接口方法的注解创建 ResponseConverter</span></span><br><span class="line">  responseConverter = createResponseConverter();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据接口方法的注解构造请求方法，比如 @GET @POST @DELETE 等</span></span><br><span class="line">  <span class="comment">// 另外还有添加请求头，检查url中有无带?，转化 path 中的参数</span></span><br><span class="line">  <span class="keyword">for</span> (Annotation annotation : methodAnnotations) &#123;</span><br><span class="line">    parseMethodAnnotation(annotation);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (httpMethod == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"HTTP method annotation is required (e.g., @GET, @POST, etc.)."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 若无 body 则不能有 isMultipart 和 isFormEncoded</span></span><br><span class="line">  <span class="keyword">if</span> (!hasBody) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isMultipart) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(</span><br><span class="line">          <span class="string">"Multipart can only be specified on HTTP methods with request body (e.g., @POST)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (isFormEncoded) &#123;</span><br><span class="line">      <span class="keyword">throw</span> methodError(<span class="string">"FormUrlEncoded can only be specified on HTTP methods with "</span></span><br><span class="line">          + <span class="string">"request body (e.g., @POST)."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面的代码主要用来解析接口方法参数中的注解，比如 @Path @Query @QueryMap @Field 等等</span></span><br><span class="line">  <span class="comment">// 相应的，每个方法的参数都创建了一个 ParameterHandler&lt;?&gt; 对象</span></span><br><span class="line">  <span class="keyword">int</span> parameterCount = parameterAnnotationsArray.length;</span><br><span class="line">  parameterHandlers = <span class="keyword">new</span> ParameterHandler&lt;?&gt;[parameterCount];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> p = <span class="number">0</span>; p &lt; parameterCount; p++) &#123;</span><br><span class="line">    Type parameterType = parameterTypes[p];</span><br><span class="line">    <span class="keyword">if</span> (Utils.hasUnresolvableType(parameterType)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"Parameter type must not include a type variable or wildcard: %s"</span>,</span><br><span class="line">          parameterType);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Annotation[] parameterAnnotations = parameterAnnotationsArray[p];</span><br><span class="line">    <span class="keyword">if</span> (parameterAnnotations == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> parameterError(p, <span class="string">"No Retrofit annotation found."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    parameterHandlers[p] = parseParameter(p, parameterType, parameterAnnotations);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 检查构造出的请求有没有不对的地方？</span></span><br><span class="line">  <span class="keyword">if</span> (relativeUrl == <span class="keyword">null</span> &amp;&amp; !gotUrl) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Missing either @%s URL or @Url parameter."</span>, httpMethod);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!isFormEncoded &amp;&amp; !isMultipart &amp;&amp; !hasBody &amp;&amp; gotBody) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Non-body HTTP method cannot contain @Body."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isFormEncoded &amp;&amp; !gotField) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Form-encoded method must contain at least one @Field."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (isMultipart &amp;&amp; !gotPart) &#123;</span><br><span class="line">    <span class="keyword">throw</span> methodError(<span class="string">"Multipart method must contain at least one @Part."</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> ServiceMethod&lt;&gt;(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>build()</code> 中代码挺长的，总结起来就一句话：就是将 API 接口中的方法进行解析，构造成 <code>ServiceMethod</code> ，交给下面的 <code>OkHttpCall</code> 使用。</p>
<p>基本上做的事情就是：</p>
<ol>
<li>创建 CallAdapter ；</li>
<li>创建 ResponseConverter；</li>
<li>根据 API 接口方法的注解构造网络请求方法；</li>
<li>根据 API 接口方法参数中的注解构造网络请求的参数；</li>
<li>检查有无异常；</li>
</ol>
<p>代码中都是注释，在这里就不详细多讲了。</p>
<p><code>ServiceMethod serviceMethod = loadServiceMethod(method);</code> 这句代码我们看完了，那么看接下来的 <code>OkHttpCall okHttpCall = new OkHttpCall&lt;&gt;(serviceMethod, args);</code> 。</p>
<h2 id="OkHttpCall"><a href="#OkHttpCall" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><p>在 <code>OkHttpCall</code> 的构造器中没什么大动作，搞不了大事情的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">OkHttpCall(ServiceMethod&lt;T&gt; serviceMethod, Object[] args) &#123;</span><br><span class="line">  <span class="keyword">this</span>.serviceMethod = serviceMethod;</span><br><span class="line">  <span class="keyword">this</span>.args = args;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>而真正搞事情的是 <code>serviceMethod.callAdapter.adapt(okHttpCall);</code> 这句代码。</p>
<h2 id="ExecutorCallAdapterFactory"><a href="#ExecutorCallAdapterFactory" class="headerlink" title="ExecutorCallAdapterFactory"></a>ExecutorCallAdapterFactory</h2><p>在 Retrofit 中默认的 callAdapterFactory 是 <code>ExecutorCallAdapterFactory</code> 。我们就进入它的 <code>get(Type returnType, Annotation[] annotations, Retrofit retrofit)</code> 看看吧，返回了一个匿名类 <code>CallAdapter&lt;Object, Call&lt;?&gt;&gt;</code> ，在其中有 <code>adapt(Call&lt;Object&gt; call)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> CallAdapter&lt;?, ?&gt; get(Type returnType, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">  <span class="keyword">if</span> (getRawType(returnType) != Call.class) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">final</span> Type responseType = Utils.getCallResponseType(returnType);</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> CallAdapter&lt;Object, Call&lt;?&gt;&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Type <span class="title">responseType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> responseType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Call&lt;Object&gt; <span class="title">adapt</span><span class="params">(Call&lt;Object&gt; call)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到它 <code>return new ExecutorCallbackCall&lt;&gt;(callbackExecutor, call);</code> 。<code>ExecutorCallbackCall</code> 是实现了 <code>retrofit2.Call</code> ，这里注意下，是 Retrofit 中的 Call 而不是 OkHttp 中的 Call 。使用了装饰者模式把 <code>retrofit2.Call</code> 又包装了一层。</p>
<p>在得到了 <code>ExecutorCallbackCall</code> ，我们可以调用同步方法 <code>execute()</code> 或异步方法 <code>enqueue(Callback&lt;T&gt; callback)</code> 来执行该 call 。</p>
<h2 id="ExecutorCallAdapterFactory-ExecutorCallbackCall"><a href="#ExecutorCallAdapterFactory-ExecutorCallbackCall" class="headerlink" title="ExecutorCallAdapterFactory.ExecutorCallbackCall"></a>ExecutorCallAdapterFactory.ExecutorCallbackCall</h2><p>那我们就跟进同步方法 <code>execute()</code> 吧，异步的 <code>enqueue(Callback&lt;T&gt; callback)</code> 就不看了。了解过 OkHttp 的同学应该都知道这两个方法的区别，就是多了异步执行和回调的步骤而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> </span><br><span class="line"><span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">// delegate 就是构造器中传进来的 OkHttpCall</span></span><br><span class="line">  <span class="keyword">return</span> delegate.execute();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，其实就是调用了 <code>OkHttpCall</code> 的 <code>execute()</code> 方法。</p>
<p>所以我们又要回到 <code>OkHttpCall</code> 中了。</p>
<h2 id="OkHttpCall-1"><a href="#OkHttpCall-1" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Response&lt;T&gt; <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">   okhttp3.Call call;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already executed."</span>);</span><br><span class="line">     executed = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">     <span class="keyword">if</span> (creationFailure != <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">if</span> (creationFailure <span class="keyword">instanceof</span> IOException) &#123;</span><br><span class="line">         <span class="keyword">throw</span> (IOException) creationFailure;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">throw</span> (RuntimeException) creationFailure;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     call = rawCall;</span><br><span class="line">     <span class="keyword">if</span> (call == <span class="keyword">null</span>) &#123;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">	  <span class="comment">// 根据 serviceMethod 中的众多数据创建出 Okhttp 中的 Request 对象</span></span><br><span class="line">	  <span class="comment">// 注意的一点，会调用上面的 ParameterHandler.apply 方法来填充网络请求参数</span></span><br><span class="line">	  <span class="comment">// 然后再根据 OkhttpClient 创建出 Okhttp 中的 Call</span></span><br><span class="line">	  <span class="comment">// 这一步也说明了在 Retrofit 中的 OkHttpCall 内部请求最后会转换为 OkHttp 的 Call</span></span><br><span class="line">         call = rawCall = createRawCall();</span><br><span class="line">       &#125; <span class="keyword">catch</span> (IOException | RuntimeException e) &#123;</span><br><span class="line">         creationFailure = e;</span><br><span class="line">         <span class="keyword">throw</span> e;</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="comment">// 检查 call 是否取消</span></span><br><span class="line">   <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">     call.cancel();</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">// 执行 call 并转换响应的 response</span></span><br><span class="line">   <span class="keyword">return</span> parseResponse(call.execute());</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>execute()</code> 做的就是将 Retrofit 中的 call 转化为 OkHttp 中的 call 。</p>
<p>最后让 OkHttp 的 call 去执行。</p>
<p>至此，Retrofit 的网络请求部分源码已经全部解析一遍了。</p>
<p>剩下的就是响应部分了，趁热打铁。</p>
<h1 id="u54CD_u5E94_u6E90_u7801_u89E3_u6790"><a href="#u54CD_u5E94_u6E90_u7801_u89E3_u6790" class="headerlink" title="响应源码解析"></a>响应源码解析</h1><p>我们可以看到 <code>OkHttpCall.execute()</code> 中的最后一句：<code>parseResponse(call.execute())</code>。</p>
<p>所以对响应的处理就是 <code>parseResponse(okhttp3.Response rawResponse)</code> 这个方法了。</p>
<h2 id="OkHttpCall-2"><a href="#OkHttpCall-2" class="headerlink" title="OkHttpCall"></a>OkHttpCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response&lt;T&gt; <span class="title">parseResponse</span><span class="params">(okhttp3.Response rawResponse)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  ResponseBody rawBody = rawResponse.body();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Remove the body's source (the only stateful object) so we can pass the response along.</span></span><br><span class="line">  rawResponse = rawResponse.newBuilder()</span><br><span class="line">      .body(<span class="keyword">new</span> NoContentResponseBody(rawBody.contentType(), rawBody.contentLength()))</span><br><span class="line">      .build();</span><br><span class="line">  <span class="comment">// 如果返回的响应码不是成功的话，返回错误 Response</span></span><br><span class="line">  <span class="keyword">int</span> code = rawResponse.code();</span><br><span class="line">  <span class="keyword">if</span> (code &lt; <span class="number">200</span> || code &gt;= <span class="number">300</span>) &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">      ResponseBody bufferedBody = Utils.buffer(rawBody);</span><br><span class="line">      <span class="keyword">return</span> Response.error(bufferedBody, rawResponse);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      rawBody.close();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 如果返回的响应码是204或者205，返回没有 body 的成功 Response</span></span><br><span class="line">  <span class="keyword">if</span> (code == <span class="number">204</span> || code == <span class="number">205</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> Response.success(<span class="keyword">null</span>, rawResponse);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ExceptionCatchingRequestBody catchingBody = <span class="keyword">new</span> ExceptionCatchingRequestBody(rawBody);</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">// 将 body 转换为对应的泛型，然后返回成功 Response</span></span><br><span class="line">    T body = serviceMethod.toResponse(catchingBody);</span><br><span class="line">    <span class="keyword">return</span> Response.success(body, rawResponse);</span><br><span class="line">  &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">    <span class="comment">// If the underlying source threw an exception, propagate that rather than indicating it was</span></span><br><span class="line">    <span class="comment">// a runtime exception.</span></span><br><span class="line">    catchingBody.throwIfCaught();</span><br><span class="line">    <span class="keyword">throw</span> e;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parseResponse(okhttp3.Response rawResponse)</code> 中主要是这句代码：</p>
<p><code>T body = serviceMethod.toResponse(catchingBody);</code> </p>
<p>将 <code>ResponseBody</code> 直接转化为了泛型，可以猜到这也是 Converter 的功劳。</p>
<h2 id="ServiceMethod"><a href="#ServiceMethod" class="headerlink" title="ServiceMethod"></a>ServiceMethod</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">T <span class="title">toResponse</span><span class="params">(ResponseBody body)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> responseConverter.convert(body);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>果然没错，内部是调用了 <code>responseConverter</code> 的。</p>
<h2 id="BuiltInConverters"><a href="#BuiltInConverters" class="headerlink" title="BuiltInConverters"></a>BuiltInConverters</h2><p><code>BuiltInConverters</code> 中有好几种内置的 Converter 。并且只支持返回 <code>ResponseBody</code> 。我们来看下它们的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">StreamingResponseBodyConverter</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> StreamingResponseBodyConverter INSTANCE = <span class="keyword">new</span> StreamingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">BufferingResponseBodyConverter</span></span><br><span class="line">        <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">ResponseBody</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> BufferingResponseBodyConverter INSTANCE = <span class="keyword">new</span> BufferingResponseBodyConverter();</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ResponseBody <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// Buffer the entire body to avoid future I/O.</span></span><br><span class="line">            <span class="keyword">return</span> Utils.buffer(value);</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实说白了就是将 <code>ResponseBody</code> 转化为对应的数据类型了。比如在 <code>GsonConverterFactory</code> 中就是把 <code>ResponseBody</code> 用 gson 转化为对应的类型，有兴趣的同学可以自己看下。这里也没什么神秘的，相信大家都懂的。</p>
<p>到这里就把 Retrofit 响应部分的源码解析完毕了。</p>
<p>大家自行消化一下吧。</p>
<p>我自己也写得头晕了。。。笑 cry</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>最后，相信大家已经了解了 Retrofit 到底是怎么一回事了。</p>
<p>Retrofit 内部访问网络仍然是通过 OkHttp ，而只是把构造请求和响应封装了一下，更加简单易用了。</p>
<p>还有，看过框架源码的都知道在源码中有很多设计模式的体现，比如建造者模式、装饰者模式以及 OkHttp 中的责任链模式等。这些也正是值得我们学习的地方。</p>
<p>好啦，今天结束了。如果有问题的同学可以留言咯。</p>
<p>Goodbye</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/0c055ad46b6c" target="_blank" rel="external">Android：手把手带你深入剖析 Retrofit 2.0 源码</a></li>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/51304204" target="_blank" rel="external">Retrofit2 完全解析 探索与okhttp之间的关系</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>之前对 OkHttp 进行过源码分析了，那么今天就来讲讲 Retrofit 。</p>
<p>Retrofi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[OkHttp源码解析]]></title>
    <link href="http://yuqirong.me/2017/07/25/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/07/25/OkHttp源码解析/</id>
    <published>2017-07-25T12:54:57.000Z</published>
    <updated>2017-08-03T15:13:44.880Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
<p>现如今，在 Android 开发领域大多数都是选择以 OkHttp 作为网络框架。</p>
<p>然而，简单地会使用 OkHttp 并不能让我们得到满足。更深层次的，我们需要阅读框架的源码，才能用起来得心应手，融会贯通。</p>
<p>An HTTP &amp; HTTP/2 client for Android and Java applications.</p>
<p>这是官网上对于 OkHttp 的介绍，简单明了。同时，也印证了那句经典的话：</p>
<p>Talk is cheap, show me the code.</p>
<h1 id="OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5"><a href="#OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="OkHttp的简单使用方法"></a>OkHttp的简单使用方法</h1><p>OkHttp 使用方法，直接抄官网的 \(╯-╰)/ 。</p>
<p>GET 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</span><br><span class="line">    = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(body)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6DF1_u5165_u6E90_u7801"><a href="#u6DF1_u5165_u6E90_u7801" class="headerlink" title="深入源码"></a>深入源码</h1><p>在这里，先分析下同步请求的源码，之后再回过头来看异步请求的源码。</p>
<p>Let’s go !</p>
<h1 id="u540C_u6B65_u8BF7_u6C42"><a href="#u540C_u6B65_u8BF7_u6C42" class="headerlink" title="同步请求"></a>同步请求</h1><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>首先创建一个 <code>OkHttpClient</code> 对象，那我们看看在构造器中做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher; <span class="comment">// 分发器</span></span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy; <span class="comment">// 代理</span></span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols; <span class="comment">// 协议</span></span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors); <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors); <span class="comment">// 网络拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector; <span class="comment">// 代理选择</span></span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar; <span class="comment">// cookie</span></span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache; <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">    isTLS = isTLS || spec.isTls();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    X509TrustManager trustManager = systemDefaultTrustManager();</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool; <span class="comment">// 连接复用池</span></span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout; <span class="comment">// 连接超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout; <span class="comment">// 读取超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout; <span class="comment">// 写入超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中利用建造者模式来构建 <code>OkHttpClient</code> 的对象。当然，如果你想自定义 <code>OkHttpClient</code> 配置的话，就要 new 一个 <code>OkHttpClient.Builder</code> 来配置自己的参数了。相信大家都干过这种事情了(∩_∩)。</p>
<p><code>OkHttpClient</code> 的构造器中主要是扎堆扎堆的配置，没别的。</p>
<p>之后再调用 <code>newCall(Request request)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法里面其实是创建了一个 <code>RealCall</code> 的对象，那么我们就进入 <code>RealCall</code> 中去看看吧。</p>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>在 <code>RealCall</code> 的构造器中只是给一些变量赋值或初始化而已，没什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再把目光转向 <code>RealCall</code> 中的 <code>execute()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 call 已经被执行过了，就设置 executed 为 true</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加入 runningSyncCalls 队列中</span></span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 得到响应 result</span></span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 从 runningSyncCalls 队列中移除</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execute()</code> 方法为执行该 <code>RealCall</code>，在方法里面一开始检查了该 call 时候被执行。</p>
<p>然后又加入了 <code>Dispatcher</code> 的 <code>runningSyncCalls</code> 中。<code>runningSyncCalls</code> 队列只是用来记录正在同步请求中的 call ，在 call 完成请求后又会从 <code>runningSyncCalls</code> 中移除。</p>
<p>可见，在同步请求中 <code>Dispatcher</code> 参与的部分很少。但是在异步请求中， <code>Dispatcher</code> 可谓是大展身手。</p>
<p>最重要的方法，那就是 <code>getResponseWithInterceptorChain()</code> 。我们可以看到这方法是直接返回 <code>Response</code> 对象的，所以，在这个方法中一定做了很多很多的事情。</p>
<p>那就继续深入吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); <span class="comment">// 加入用户自定义的拦截器</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor); <span class="comment">// 重试和重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar())); <span class="comment">// 加入转化请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache())); <span class="comment">// 加入缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client)); <span class="comment">// 加入连接拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors()); <span class="comment">// 加入用户自定义的网络拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket)); <span class="comment">// 加入发出请求和读取响应的拦截器</span></span><br><span class="line">    </span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.readTimeoutMillis());</span><br><span class="line">    <span class="comment">// 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>getResponseWithInterceptorChain()</code> 方法中有一堆的拦截器！！！</p>
<p>关于拦截器，之前在 <a href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OKHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/">一起来写OKHttp的拦截器</a> 这篇博客中有讲过，若不了解的同学可以先看下。</p>
<p>我们都知道，拦截器是 OkHttp 的精髓。</p>
<ol>
<li><code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；</li>
<li><code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；</li>
<li><code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；</li>
<li><code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；</li>
<li><code>ConnectInterceptor</code> 用来建立连接的拦截器；</li>
<li><code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ;</li>
<li><code>CallServerInterceptor</code> 是真正向服务器发出请求且得到响应的拦截器；</li>
</ol>
<p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是责任链模式。</p>
<h2 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h2><p><code>RealInterceptorChain</code> 可以说是真正把这些拦截器串起来的一个角色。一个个拦截器就像一颗颗珠子，而 <code>RealInterceptorChain</code> 就是把这些珠子串连起来的那根绳子。</p>
<p>进入 <code>RealInterceptorChain</code> ，主要是 <code>proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">                        RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到下一次对应的 RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">            connection, index + <span class="number">1</span>, request, call, eventListener, readTimeout);</span><br><span class="line">    <span class="comment">// 当前次数的 interceptor</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认下一次的 interceptor 调用过 chain.proceed()</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中是一次次链式调用拦截器，可能有些同学还是看不懂。那么，我就捉急地画了一张示意图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170725/20170722185657.png" alt="interceptors"></p>
<p>有了这张图就好懂多了，如果还没懂的话就只能自己慢慢体会了。</p>
<p>下面就要进入分析拦截器的步骤了，至于用户自定义的拦截器在这就略过了。还有，拦截器只分析主要的 <code>intercept(Chain chain)</code> 代码。</p>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()),</span><br><span class="line">            call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果取消，就释放资源</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">            response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">            <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">            <span class="comment">// 路由连接失败，请求将不会被发送</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">            <span class="comment">// 服务器连接失败，请求可能已被发送</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">            <span class="comment">// 抛出未检查的异常，释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">                streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                            .body(<span class="keyword">null</span>)</span><br><span class="line">                            .build())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不需要重定向，那么 followUp 为空，会根据响应码判断</span></span><br><span class="line">        Request followUp = followUpRequest(response);</span><br><span class="line">        <span class="comment">// 释放资源，返回 response</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 response 的 body</span></span><br><span class="line">        closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// response 和 followUp 比较是否为同一个连接</span></span><br><span class="line">        <span class="comment">// 若为重定向就销毁旧连接，创建新连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">                    createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">                    + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将重定向操作得到的新请求设置给 request</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p>
<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">    <span class="comment">// 将用户友好的 request 构造为发送给服务器的 request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">// 若有请求体，则构造</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">        MediaType contentType = body.contentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="comment">// 使用 gzip 压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">        requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UA</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    <span class="comment">// 保存 networkResponse 的 cookie</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    <span class="comment">// 将 networkResponse 构造为对用户友好的 response</span></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">            .request(userRequest);</span><br><span class="line">    <span class="comment">// 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">            &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">            &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">        GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        responseBuilder.headers(strippedHeaders);</span><br><span class="line">        responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p>
<p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p>
<p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p>
<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 request 对应缓存中的 response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前时间，会和之前缓存的时间进行比较</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 得到缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">    <span class="comment">// 追踪缓存，其实就是计数</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存不适用，关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 禁止网络并且没有缓存的话，返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(<span class="number">504</span>)</span><br><span class="line">                .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 不用网络请求，返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给下一个拦截器，返回 networkResponse</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们同时有缓存和 networkResponse ，根据情况使用</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line">            <span class="comment">// 更新原来的缓存至最新</span></span><br><span class="line">            <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">            <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 保存之前未缓存的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 创建 httpCodec （抽象类），分别对应着 http1.1 和 http 2</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>streamAllocation.newStream</code> 创建了一个 <code>HttpCodec</code> 的对象。</p>
<p>而 <code>HttpCodec</code> 是一个抽象类，其实现类分别是 <code>Http1Codec</code> 和 <code>Http2Codec</code> 。相对应的就是 HTTP/1.1 和 HTTP/2.0 。</p>
<p>我们来看下 <code>streamAllocation.newStream</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(OkHttpClient client, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在连接池中找到一个可用的连接，然后创建出 HttpCodec 对象</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>newStream(OkHttpClient client, boolean doExtensiveHealthChecks)</code> 中先在连接池中找到可用的连接 <code>resultConnection</code> ，再结合 <code>sink</code> 和 <code>source</code> 创建出 <code>HttpCodec</code> 的对象。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 整理请求头并写入</span></span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 检查是否为有 body 的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">        <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return what</span></span><br><span class="line">        <span class="comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">        <span class="comment">// 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            httpCodec.flushRequest();</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">            <span class="comment">// 写入请求体</span></span><br><span class="line">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">            request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            bufferedRequestBody.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">            <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span></span><br><span class="line">            <span class="comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span></span><br><span class="line">            <span class="comment">// connection in a consistent state.</span></span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">    <span class="comment">// 得到响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造 response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">// 如果为 web socket 且状态码是 101 ，那么 body 为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取 body</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(httpCodec.openResponseBody(response))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求头中有 close 那么断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">            || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们也完全明白了 OkHttp 中的分层思想，每一个 interceptor 只处理自己的事，而剩余的就交给其他的 interceptor 。这种思想可以简化一些繁琐复杂的流程，从而达到逻辑清晰、互不干扰的效果。</p>
<h1 id="u5F02_u6B65_u8BF7_u6C42"><a href="#u5F02_u6B65_u8BF7_u6C42" class="headerlink" title="异步请求"></a>异步请求</h1><p>与同步请求直接调用 <code>execute()</code> 不同的是，异步请求是调用了 <code>enqueue(Callback responseCallback)</code> 这个方法。那么我们对异步请求探究的入口就是 <code>enqueue(Callback responseCallback)</code> 了。</p>
<h2 id="RealCall-1"><a href="#RealCall-1" class="headerlink" title="RealCall"></a>RealCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">// 加入到 dispatcher 中，这里包装成了 AsyncCall</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的方法就是调用了 <code>Dispatcher</code> 的 <code>enqueue(AsyncCall call)</code> 方法。这里需要注意的是，传入的是 <code>AsyncCall</code> 对象，而不是同步中的 <code>RealCall</code> 。</p>
<p>那么我们就跟进到 <code>Dispatcher</code> 的源码中吧，至于 <code>AsyncCall</code> 我们会在下面详细讲到。</p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前正在运行的异步 call 数 &lt; 64 &amp;&amp; 队列中请求同一个 host 的异步 call 数 &lt; 5</span></span><br><span class="line">    <span class="comment">// maxRequests = 64，maxRequestsPerHost = 5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">// 加入正在运行异步队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">// 加入到线程池中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加入预备异步队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>enqueue(AsyncCall call)</code> 中可以知道，OkHttp 在运行中的异步请求数最多为 63 ，而同一个 host 的异步请求数最多为 4 。否则会加入到 <code>readyAsyncCalls</code> 中。</p>
<p>在加入到 <code>runningAsyncCalls</code> 后，就会进入线程池中被执行。到了这里，我们就要到 <code>AsyncCall</code> 中一探究竟了。</p>
<h2 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">        <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用一连串的拦截器，得到响应</span></span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调结果</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 runningAsyncCalls 中移除，并作推进其他 call 的工作</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p>
<p>在得到 <code>Response</code> 后，进行结果的回调。</p>
<p>最后，调用了 <code>Dispatcher</code> 的 <code>finished</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除该 call</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="comment">// 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中</span></span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls)</code> 中对该 call 移除。</p>
<p>若在 <code>readyAsyncCalls</code> 中其他的 call ，就移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p>
<p>这样，完整的流程就循环起来了。</p>
<h1 id="Footer"><a href="#Footer" class="headerlink" title="Footer"></a>Footer</h1><p>基本上 OkHttp 的请求响应的流程就讲完了，篇幅有点长长长啊。</p>
<p>不过还有很多点没有涉及到的，比如连接池、缓存策略等等，都是值得我们去深究的。也是需要花很大的功夫才能了解透彻。</p>
<p>好了，那就到这里吧，有问题的同学可以留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="external">OKHttp源码解析</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
<li><a href="http://blog.csdn.net/qq_15274383/article/details/73729801" target="_blank" rel="external">OkHttp框架的RetryAndFollowUpInterceptor请求重定向源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可以伸缩的搜索栏，模仿华为应用市场]]></title>
    <link href="http://yuqirong.me/2017/07/03/%E5%8F%AF%E4%BB%A5%E4%BC%B8%E7%BC%A9%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%8F%EF%BC%8C%E6%A8%A1%E4%BB%BF%E5%8D%8E%E4%B8%BA%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA/"/>
    <id>http://yuqirong.me/2017/07/03/可以伸缩的搜索栏，模仿华为应用市场/</id>
    <published>2017-07-03T13:42:56.000Z</published>
    <updated>2017-07-04T14:55:44.587Z</updated>
    <content type="html"><![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
<p>关于搜索栏，可以说各种 app 都有不同的样式。影响比较深刻的就有华为应用市场的搜索栏（同样，简书的搜索栏也是类似的）。</p>
<p>而今天，就是带你来实现华为应用市场那样的搜索栏。</p>
<p>我们先放上我们实现的效果图吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170703150542.gif" alt="demo效果图"></p>
<p>怎么样，想不想学？</p>
<p>我们先来简述一下实现的思路吧，其实并不复杂。</p>
<p>首先，在搜索栏还未打开时，先确定半径 R ，然后假设一个变量 offset 用来动态改变搜索栏的宽度。如图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170704204905.png" alt="示意图"></p>
<p>所以可以得到一个公式：offset = total width - 2 * R ;</p>
<p>那么显而易见，offset 的取值就在 [0, total width - 2 * R] 之间了。</p>
<p>所以，我们可以借助属性动画来完成这数值的变化。在调用 <code>invalidate()</code> 进行重绘，达到动态增加搜索栏宽度的效果。反之，关闭搜索栏也是同理的。</p>
<p>那么下面就用代码来实现它咯！</p>
<h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>关于自定义的属性，我们可以想到的有搜索栏的背景颜色、搜索栏的位置（左或右）、搜索栏的状态（打开或关闭）等。具体的可以查看下面的 attrs.xml 。根据英文应该能知道对应属性的作用了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SearchBarView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_position"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_left"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_right"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_status"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_close"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_open"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_duration"</span> <span class="attribute">format</span>=<span class="value">"integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text"</span> <span class="attribute">format</span>=<span class="value">"string|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_icon"</span> <span class="attribute">format</span>=<span class="value">"reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>而在构造器中，肯定就是初始化一些 attrs 中的全局变量了，这也不是重点，都是机械式的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SearchBarView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.SearchBarView);</span><br><span class="line">    searchBarColor = array.getColor(R.styleable.SearchBarView_search_bar_color, DEFAULT_SEARCH_BAR_COLOR);</span><br><span class="line">    mPosition = array.getInteger(R.styleable.SearchBarView_search_bar_position, DEFAULT_RIGHT_POSITION);</span><br><span class="line">    mStatus = array.getInteger(R.styleable.SearchBarView_search_bar_status, STATUS_CLOSE);</span><br><span class="line">    <span class="keyword">int</span> mDuration = array.getInteger(R.styleable.SearchBarView_search_bar_duration, DEFAULT_ANIMATION_DURATION);</span><br><span class="line">    <span class="keyword">int</span> searchBarIcon = array.getResourceId(R.styleable.SearchBarView_search_bar_icon, android.R.drawable.ic_search_category_default);</span><br><span class="line">    mSearchText = array.getText(R.styleable.SearchBarView_search_bar_hint_text);</span><br><span class="line">    searchTextColor = array.getColor(R.styleable.SearchBarView_search_bar_hint_text_color, DEFAULT_SEARCH_TEXT_COLOR);</span><br><span class="line">    <span class="keyword">float</span> defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, DEFAULT_HINT_TEXT_SIZE, getResources().getDisplayMetrics());</span><br><span class="line">    <span class="keyword">float</span> searchTextSize = array.getDimension(R.styleable.SearchBarView_search_bar_hint_text_size, defaultTextSize);</span><br><span class="line">    defaultHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_HEIGHT, getResources().getDisplayMetrics());</span><br><span class="line">    array.recycle();</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    mPaint.setTextSize(searchTextSize);</span><br><span class="line">    mRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    mDstRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    bitmap = BitmapFactory.decodeResource(getResources(), searchBarIcon);</span><br><span class="line">    initAnimator(mDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initAnimator"><a href="#initAnimator" class="headerlink" title="initAnimator"></a>initAnimator</h2><p><code>initAnimator</code> 方法中是两个属性动画，打开和关闭动画。非常 easy 的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAnimator</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">    AccelerateInterpolator accelerateInterpolator = <span class="keyword">new</span> AccelerateInterpolator();</span><br><span class="line">    ValueAnimator.AnimatorUpdateListener animatorUpdateListener = <span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            mOffsetX = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// init open animator</span></span><br><span class="line">    openAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    openAnimator.setDuration(duration);</span><br><span class="line">    openAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    openAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_OPEN;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// init close animator</span></span><br><span class="line">    closeAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    closeAnimator.setDuration(duration);</span><br><span class="line">    closeAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    closeAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>同样，<code>onMeasure</code> 中的代码也是很机械的，基本上都是同一个套路了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mHeight = heightSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHeight = (<span class="keyword">int</span>) defaultHeight;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            mHeight = Math.min(heightSize, mHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索栏小圆圈的半径</span></span><br><span class="line">    mRadius = Math.min(mWidth, mHeight) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN) &#123;</span><br><span class="line">        mOffsetX = mWidth - mRadius * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>在 <code>onDraw</code> 中先画了搜索栏的背景，然后是搜索栏的图标，最后是搜索栏的提示文字。</p>
<p>画背景的时候，是需要根据搜索栏在左边还是右边的位置来确定值的。</p>
<p>而画图标的时候，是根据搜索栏关闭时那个圆的内切正方形作为 Rect 的。</p>
<p>最后画提示文字没什么好讲的了，都是定死的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// draw search bar</span></span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    <span class="keyword">int</span> left = mPosition == DEFAULT_RIGHT_POSITION ? mWidth - <span class="number">2</span> * mRadius - mOffsetX : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = mPosition == DEFAULT_RIGHT_POSITION ? mWidth : <span class="number">2</span> * mRadius + mOffsetX;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        canvas.drawRoundRect(left, <span class="number">0</span>, right, mHeight, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRectF.set(left, <span class="number">0</span>, right, mHeight);</span><br><span class="line">        canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// draw search bar icon</span></span><br><span class="line">    mDstRectF.set(left + (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius),</span><br><span class="line">            left + (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius));</span><br><span class="line">    canvas.drawBitmap(bitmap, <span class="keyword">null</span>, mDstRectF, mPaint);</span><br><span class="line">    <span class="comment">// draw search bar text</span></span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN &amp;&amp; !TextUtils.isEmpty(mSearchText)) &#123;</span><br><span class="line">        mPaint.setColor(searchTextColor);</span><br><span class="line">        Paint.FontMetrics fm = mPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">double</span> textHeight = Math.ceil(fm.descent - fm.ascent);</span><br><span class="line">        canvas.drawText(mSearchText.toString(), <span class="number">2</span> * mRadius, (<span class="keyword">float</span>) (mRadius + textHeight / <span class="number">2</span> - fm.descent), mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="startOpen_u3001startClose"><a href="#startOpen_u3001startClose" class="headerlink" title="startOpen、startClose"></a>startOpen、startClose</h2><p>最后，需要将 <code>startOpen</code> 和 <code>startClose</code> 方法暴露给外部，方便调用。在其内部就是调用两个属性动画而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为打开状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为关闭状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_CLOSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打开搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        closeAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    openAnimator.setIntValues(mOffsetX, mWidth - mRadius * <span class="number">2</span>);</span><br><span class="line">    openAnimator.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClose()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        openAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    closeAnimator.setIntValues(mOffsetX, <span class="number">0</span>);</span><br><span class="line">    closeAnimator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>到这也差不多了，该讲的都讲了，这篇写得真 TMD 简洁。至于和 <code>AppBarLayout</code> 的混合使用，见 GitHub 中的代码即可。</p>
<p>有问题的可以在下面留言。没问题的老铁可以来一波 star 。</p>
<p>FlexibleSearchBar：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/Flexibl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起来写OkHttp的拦截器]]></title>
    <link href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OkHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://yuqirong.me/2017/06/25/一起来写OkHttp的拦截器/</id>
    <published>2017-06-25T04:37:02.000Z</published>
    <updated>2017-07-22T08:23:55.849Z</updated>
    <content type="html"><![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。</p>
<p>现如今，做 Android 开发在选择网络框架时，大多数都会首推 Retrofit 。Retrofit 以其简洁优雅的代码俘获了大多数开发者的心。</p>
<p>然而 Retrofit 内部请求也是基于 OkHttp 的，所以在做一些自定义修改 HTTP 请求时，需要对 OkHttp 拦截器具有一定了解。相信熟悉 OkHttp 的同学都知道，OkHttp 内部是使用拦截器来完成请求和响应的，利用的是责任链设计模式。所以可以说，拦截器是 OkHttp 的精髓所在。</p>
<p>那么接下来，我们就通过一些例子来学习怎样编写 OkHttp 的拦截器吧，其实这些例子也正是之前我遇到的情景。</p>
<h1 id="00_3A01"><a href="#00_3A01" class="headerlink" title="00:01"></a>00:01</h1><h2 id="u6DFB_u52A0_u8BF7_u6C42_Header"><a href="#u6DFB_u52A0_u8BF7_u6C42_Header" class="headerlink" title="添加请求 Header"></a>添加请求 Header</h2><p>假设现在后台要求我们在请求 API 接口时，都在每一个接口的请求头上添加对应的 token 。使用 Retrofit 比较多的同学肯定会条件反射出以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FormUrlEncoded</span></span><br><span class="line"><span class="annotation">@POST</span>(<span class="string">"/mobile/login.htm"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">login</span><span class="params">(@Header(<span class="string">"token"</span>)</span> String token, @<span class="title">Field</span><span class="params">(<span class="string">"mobile"</span>)</span> String phoneNumber, @<span class="title">Field</span><span class="params">(<span class="string">"smsCode"</span>)</span> String smsCode)</span>;</span><br></pre></td></tr></table></figure>
<p>这样的写法自然可以，无非就是每次调用 login API 接口时都把 token 传进去而已。但是需要注意的是，假如现在有十多个 API 接口，每一个都需要传入 token ，难道我们去重复一遍又一遍吗？</p>
<p>相信有良知的程序员都会拒绝，因为这会导致代码的冗余。</p>
<p>那么有没有好的办法可以一劳永逸呢？答案是肯定的，那就要用到拦截器了。</p>
<p>代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenHeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// get token</span></span><br><span class="line">        String token = AppService.getToken();</span><br><span class="line">        Request originalRequest = chain.request();</span><br><span class="line">        <span class="comment">// get new request, add request header</span></span><br><span class="line">        Request updateRequest = originalRequest.newBuilder()</span><br><span class="line">                .header(<span class="string">"token"</span>, token)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(updateRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先拦截得到 originalRequest ，然后利用 originalRequest 生成新的 updateRequest ，再交给 chain 处理进行下一环。</p>
<p>最后，在 OkHttpClient 中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(GsonConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<h2 id="u6539_u53D8_u8BF7_u6C42_u4F53"><a href="#u6539_u53D8_u8BF7_u6C42_u4F53" class="headerlink" title="改变请求体"></a>改变请求体</h2><p>除了增加请求头之外，拦截器还可以改变请求体。</p>
<p>假设现在我们有如下需求：在上面的 login 接口基础上，后台要求我们传过去的请求参数是要按照一定规则经过加密的。</p>
<p>规则如下：</p>
<ul>
<li>请求参数名统一为content；</li>
<li>content值：JSON 格式的字符串经过 AES 加密后的内容；</li>
</ul>
<p>举个例子，根据上面的 login 接口，现有</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">mobile</span>":<span class="value"><span class="string">"157xxxxxxxx"</span></span>, "<span class="attribute">smsCode</span>":<span class="value"><span class="string">"xxxxxx"</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>JSON 字符串，然后再将其加密。最后以 content=[加密后的 JSON 字符串] 方式发送给后台。</p>
<p>看完了上面的 <code>TokenHeaderInterceptor</code> 之后，这需求对于我们来说可以算是信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestEncryptInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORM_NAME = <span class="string">"content"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RequestBody body = request.body();</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">            FormBody formBody = (FormBody) body;</span><br><span class="line">            Map&lt;String, String&gt; formMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从 formBody 中拿到请求参数，放入 formMap 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class="line">                formMap.put(formBody.name(i), formBody.value(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 formMap 转化为 json 然后 AES 加密</span></span><br><span class="line">            Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">            String jsonParams = gson.toJson(formMap);</span><br><span class="line">            String encryptParams = AESCryptUtils.encrypt(jsonParams.getBytes(CHARSET), AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 重新修改 body 的内容</span></span><br><span class="line">            body = <span class="keyword">new</span> FormBody.Builder().add(FORM_NAME, encryptParams).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    .post(body)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中已经添加了关键的注释，相信我已经不需要多解释什么了。</p>
<p>经过了这两种拦截器，相信同学们已经充分体会到了 OkHttp 的优点和与众不同。</p>
<p>最后，自定义拦截器的使用情景通常是对所有网络请求作统一处理。如果下次你也碰到这种类似的需求，别忘记使用自定义拦截器哦！</p>
<h1 id="00_3A02"><a href="#00_3A02" class="headerlink" title="00:02"></a>00:02</h1><p>呃呃呃，按道理来讲应该要结束了。</p>
<p>但是，我在这里开启一个番外篇吧，不过目标不是针对拦截器而是 ConverterFactory 。</p>
<p>还是后台需求，login 接口返回的数据也是经过 AES 加密的。所以需要我们针对所有响应体都做解密处理。</p>
<p>另外，还有很重要的一点，就是数据正常和异常时返回的 JSON 格式不一致。</p>
<p>在业务数据正常的时候（即 code 等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"请求成功"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">nickName</span>":<span class="value"><span class="string">"Hello"</span></span>,</span><br><span class="line">        "<span class="attribute">userId</span>": <span class="value"><span class="string">"1234567890"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>业务数据异常时（即 code 不等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">7008</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>而这会在使用 Retrofit 自动从 JSON 转化为 bean 类时报错。因为 data 中的正常数据中是 JSON ，而另一个异常数据中是字符串。</p>
<p>那么，如何解决上述的两个问题呢？</p>
<p>利用 <strong>自定义 ConverterFactory</strong> ！！</p>
<p>我们先创建包名 <code>retrofit2.converter.gson</code> ，为什么要创建这个包名呢？</p>
<p>因为自定义的 ConverterFactory 需要继承 Converter.Factory ，而 Converter.Factory 类默认是包修饰符。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>) <span class="comment">// Guarding public API nullability.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomConverterFactory(gson);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="comment">// attention here!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomResponseConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>CustomConverterFactory</code> 内部是根据 <code>CustomResponseConverter</code> 来转化 JSON 的，这才是我们的重点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomResponseConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CODE = <span class="string">"code"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA = <span class="string">"data"</span>;</span><br><span class="line"></span><br><span class="line">    CustomResponseConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String originalBody = value.string();</span><br><span class="line">            <span class="comment">// 先 AES 解密</span></span><br><span class="line">            String body = AESCryptUtils.decrypt(originalBody, AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 再获取 code </span></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject(body);</span><br><span class="line">            <span class="keyword">int</span> code = json.optInt(CODE);</span><br><span class="line">            <span class="comment">// 当 code 不为 200 时，设置 data 为 null，这样转化就不会出错了</span></span><br><span class="line">            <span class="keyword">if</span> (code != <span class="number">200</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = gson.fromJson(body, <span class="keyword">new</span> TypeToken&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">                &#125;.getType());</span><br><span class="line">                map.put(DATA, <span class="keyword">null</span>);</span><br><span class="line">                body = gson.toJson(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> adapter.fromJson(body);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也是很简单的，相信也不需要解释了。o(∩_∩)o</p>
<p>最后就是使用了 <code>CustomConverterFactory</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> RequestEncryptInterceptor())</span><br><span class="line">                .build();</span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(CustomConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<p>好了，这下真的把该讲的都讲完了，大家可以散了。</p>
<p>完结了。</p>
<p>再见！</p>
<p>再见！</p>
<p>再见！</p>
<p>重要的说三遍！！！</p>
<p>再说最后一遍，再见！！！</p>
<h1 id="00_3A03"><a href="#00_3A03" class="headerlink" title="00:03"></a>00:03</h1><p><strong>References</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/2263242fa02d" target="_blank" rel="external">如何使用Retrofit请求非Restful API</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(二)]]></title>
    <link href="http://yuqirong.me/2017/06/13/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2017/06/13/Kotlin入入入门(二)/</id>
    <published>2017-06-13T12:16:20.000Z</published>
    <updated>2017-06-14T14:14:52.085Z</updated>
    <content type="html"><![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a> 中已经介绍了如何配置 Kotlin 。另外，还把 Java 代码转换为了 Kotlin 代码。所以今天我们就来比较一下这两者代码之间的区别，从而实现快速入门 Kotlin 。</p>
<p>Now ，我们把之前相同含义的 Java 和 Kotlin 代码粘贴出来（上面是 Java 代码，下面是 Kotlin 代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>我们先慢慢地从上往下看，第一句 <code>package</code> 语句就有所不同。我们发现 Kotlin 中的所有代码没有以 <code>;</code> 结尾。另外，在 Kotlin 中并不要求包与目录匹配。即源文件可以在文件系统中的任意位置。</p>
<p>比如 <code>package me.yuqirong.kotlintest</code> 可能位于 /me/yuqirong/kotlintest2/ 文件夹下，并不会报错；而在 Java 中，包与目录必须匹配。</p>
<p>但是需要注意的一点是，在 AndroidManifest.xml 中配置的 Activity 的全类名必须和其路径一致，否则会找不到！</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>在 Kotlin 中，<code>class</code> 默认是 <code>public</code> 的，所以平常都省略不写。</p>
<p>继承父类和实现接口都用 <code>:</code> 来表示。不同的是继承父类是带 <code>()</code> 的，即表示构造器，比如上面的 <code>AppCompatActivity()</code> ；而接口则不需要 <code>()</code> 。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AppCompatActivity()</code> 就是继承，而 <code>View.OnClickListener</code> 就是实现。</p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>从比较的代码中可以知道：</p>
<ol>
<li>在 Kotlin 中默认方法的修饰符就是 <code>public</code> ，可以省略不写。</li>
<li>在 Kotlin 中重写的方法是要加 <code>override</code> 关键字的，而 Java 是以注解 <code>@Override</code> 来修饰的；</li>
<li>在 Kotlin 中方法都是用 <code>fun</code> 关键字来声明的；</li>
<li>在 Kotlin 中方法的参数是参数名在前，参数类型在后，中间以 <code>:</code> 隔开；若参数可能为空，则在参数类型后加 <code>?</code> 来表示。即上面代码中的 <code>(savedInstanceState: Bundle?)</code> ；</li>
<li><p>和参数表示类似，返回值也是以 <code>: 返回类型</code> 的方式表示的。比如上面的 Kotlin 代码可写为</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span>: Unit &#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Kotlin 中的 <code>Unit</code> 类型即 Java 中的 void 类型，可以省略不写。</p>
</li>
</ol>
<p>举个例子：</p>
<p>方法名 <code>multiplication</code> ，参数 <code>int a</code> 和 <code>int b</code> ，返回 <code>a</code> 和 <code>b</code> 相乘的值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人也许会有疑问，这和 Java 代码行数也差不多嘛。</p>
<p>当然还有更加简单的写法，函数体可以是表达式，并可从中推断出返回值类型。返回类型就可以省略不写了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a * b</span></span><br></pre></td></tr></table></figure>
<h1 id="u9644_u52A0_u9898"><a href="#u9644_u52A0_u9898" class="headerlink" title="附加题"></a>附加题</h1><h2 id="u5B9A_u4E49_u53D8_u91CF"><a href="#u5B9A_u4E49_u53D8_u91CF" class="headerlink" title="定义变量"></a>定义变量</h2><p>只读变量 val</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 推测为 Int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> j</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Kotlin 中的 <code>val</code> 关键字就类似于 Java 中的 <code>final</code> 。</p>
<p>可变变量 var</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="u5B57_u7B26_u4E32_u6A21_u677F"><a href="#u5B57_u7B26_u4E32_u6A21_u677F" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式，即可求值的代码片段，并将其结果连接到字符串中。一个模板表达式由一个 $ 开始并包含另一个简单的名称。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> text</span> = <span class="string">"World!"</span></span><br><span class="line">    println(<span class="string">"Hello, $&#123;text&#125;"</span>) <span class="comment">// 也可以去掉&#123;&#125;，即 println("Hello, $text")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：Hello, World!</p>
<h2 id="u57FA_u672C_u7C7B_u578B"><a href="#u57FA_u672C_u7C7B_u578B" class="headerlink" title="基本类型"></a>基本类型</h2><p>Kotlin 基本类型包括了数值、字符、布尔、字符串和数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment">// double 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Double</span> = <span class="number">125.2</span></span><br><span class="line"><span class="comment">// float 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Float</span> = <span class="number">123.2</span>f</span><br><span class="line"><span class="comment">// long 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> d</span>: <span class="typename">Long</span> = <span class="number">1234</span>L</span><br><span class="line"><span class="comment">// boolean 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> e</span>: <span class="typename">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// char 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> f</span>: <span class="typename">Char</span> = 'e'</span><br><span class="line"><span class="comment">// string 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> g</span>: String = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">// byte 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> h</span>: <span class="typename">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// short 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Short</span> = <span class="number">3</span></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> x</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="u6D41_u7A0B_u63A7_u5236"><a href="#u6D41_u7A0B_u63A7_u5236" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><p>if 表达式<br>  除了 Java 中 if 使用方法外，在 Kotlin 中还支持如下的写法：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> a</span> = <span class="number">101</span></span><br><span class="line">	<span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">100</span>)&#123;</span><br><span class="line">		print(<span class="string">"a &gt; 100 "</span>)</span><br><span class="line">		<span class="literal">true</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		print(<span class="string">"a &lt;= 100 "</span>)</span><br><span class="line">		<span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">    println(b)</span><br><span class="line">	<span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果：a &gt; 100 true</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    println(testIf(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testIf</span><span class="params">(a: <span class="typename">Int</span>)</span> = <span class="title">if</span><span class="params">(a &gt; 100)</span> true <span class="keyword">else</span> false</span></span><br></pre></td></tr></table></figure>
<p>  运行结果：false</p>
</li>
<li><p>when 表达式<br>  Kotlin 中的 when 表达式就是 Java 中的 switch 表达式，具体例子如下：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> collection</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;</span><br><span class="line">	print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 循环<br>  while 循环与 Java 中的无异。</p>
</li>
</ul>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>今天就讲到这里了，更多 Kotlin 的使用方法就期待下一篇吧！</p>
<p>Goodbye ! ~ ~</p>
<p>更多关于 Kotlin 的博客：</p>
<ul>
<li><a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(一)]]></title>
    <link href="http://yuqirong.me/2017/06/07/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://yuqirong.me/2017/06/07/Kotlin入入入门(一)/</id>
    <published>2017-06-07T12:10:22.000Z</published>
    <updated>2017-06-14T14:15:16.962Z</updated>
    <content type="html"><![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio 配置</h1><p>Android Studio 3.0 版本已经默认添加了对 Kotlin 的支持，所以以下 Android Studio 配置是针对于 3.0 版本以下的。</p>
<ol>
<li><p>安装 Kotlin 插件</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607210549.png" alt="Kotlin Plugin"></p>
</li>
<li><p>将 Java 代码转化为 Kotlin 代码</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607221409.png" alt="Converting Java code to Kotlin"></p>
<p> 之后代码就变成了如下：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件编辑之后，会跳出一个配置 Kotlin 的提示：</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222519.png" alt="Kotlin Configure"></p>
<p> 点击配置后，出现如下弹窗，点击 OK 即可</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222730.png" alt="Kotlin Configure Dialog"></p>
</li>
<li><p>配置完成后，可以看到项目的 build.gradle 多了一些：</p>
<pre><code>buildscript {
    ext.kotlin_version = &apos;1.1.2-4&apos;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre><p> app/build.gradle 的配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;

...

dependencies {
    ...
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
}
</code></pre></li>
</ol>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1><p>学习一门编程语言的首要任务就是写出 “Hello World” ，那就让我们迈下第一步吧。</p>
<p>activity_main.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/activity_main"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"me.yuqirong.kotlindemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/textView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 <code>onCreate(savedInstanceState: Bundle?)</code> 去得到 <code>textView</code> 。这里就体现出 Kotlin 的好处了，不再需要 <code>findViewById</code> 。而是先需要在 app/build.gradle 中添加如下配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;
// 添加以下这行
apply plugin: &apos;kotlin-android-extensions&apos;

...
</code></pre><p>配置好后，在代码中就可以直接使用了，是不是很方便呢！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，demo的效果图就是这样滴，不加特效！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607231545.png" alt="Demo效果图"></p>
<p>Goodbye ~ ~</p>
<p>Demo下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170607/KotlinDemo.rar" target="_blank" rel="external">KotlinDemo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[玩转仿探探卡片式滑动效果]]></title>
    <link href="http://yuqirong.me/2017/03/05/%E7%8E%A9%E8%BD%AC%E4%BB%BF%E6%8E%A2%E6%8E%A2%E5%8D%A1%E7%89%87%E5%BC%8F%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2017/03/05/玩转仿探探卡片式滑动效果/</id>
    <published>2017-03-05T14:45:22.000Z</published>
    <updated>2017-03-08T15:26:51.790Z</updated>
    <content type="html"><![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的原理肯定和 ListView / RecyclerView 类似，涉及到 Item View 的回收和重用，否则早就因为大量的 Item View 而 OOM 了。</p>
<p>再到后来，看到许多大神也推出了同样仿探探效果的博客，从头到尾阅读下来，写得通俗易懂，基本上没什么问题。于是，实现仿探探效果的想法再次出现在脑海中。那么，还犹豫什么，趁热来一发吧！就这么愉快地决定了。</p>
<p>首先面临的问题就是关于实现 View 上的考虑。毫无疑问，</p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p>重要的话讲三遍！！！</p>
<p>究其原因，第一，RecyclerView 是自带 Item View 回收和重用功能的，就不需要我们考虑这个问题了；第二，RecyclerView 的布局方式是通过设置 LayoutManager 来实现的，这样就充分地把布局和 RecyclerView “解耦”开来了。而 LayoutManager 是可以通过自定义的方式来实现的。这恰恰是我们想要的！！！再说一点，这也正是不选用 ListView 的原因之一。</p>
<p>下面，我们就开始动手了。带你见证奇迹的时刻。</p>
<h2 id="CardLayoutManager"><a href="#CardLayoutManager" class="headerlink" title="CardLayoutManager"></a>CardLayoutManager</h2><p>创建 <code>CardLayoutManager</code> 并继承自 <code>RecyclerView.LayoutManager</code> 。需要我们自己实现 <code>generateDefaultLayoutParams()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，像上面这样写即可。</p>
<p>下面这个方法就是我们的重点了。 <code>onLayoutChildren(final RecyclerView.Recycler recycler, RecyclerView.State state)</code> 方法就是用来实现 Item View 布局的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(<span class="keyword">final</span> RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayoutChildren(recycler, state);</span><br><span class="line">    <span class="comment">// 先移除所有view</span></span><br><span class="line">    removeAllViews();</span><br><span class="line">    <span class="comment">// 在布局之前，将所有的子 View 先 Detach 掉，放入到 Scrap 缓存中</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    <span class="keyword">int</span> itemCount = getItemCount();</span><br><span class="line">    <span class="comment">// 在这里，我们默认配置 CardConfig.DEFAULT_SHOW_ITEM = 3。即在屏幕上显示的卡片数为3</span></span><br><span class="line">    <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">    <span class="keyword">if</span> (itemCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">        <span class="comment">// 把数据源倒着循环，这样，第0个数据就在屏幕最上面了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = CardConfig.DEFAULT_SHOW_ITEM; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            <span class="comment">// 将 Item View 加入到 RecyclerView 中</span></span><br><span class="line">            addView(view);</span><br><span class="line">            <span class="comment">// 测量 Item View</span></span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// getDecoratedMeasuredWidth(view) 可以得到 Item View 的宽度</span></span><br><span class="line">            <span class="comment">// 所以 widthSpace 就是除了 Item View 剩余的值</span></span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="comment">// 同理</span></span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line">            <span class="comment">// 将 Item View 放入 RecyclerView 中布局</span></span><br><span class="line">            <span class="comment">// 在这里默认布局是放在 RecyclerView 中心</span></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line">            <span class="comment">// 其实屏幕上有四张卡片，但是我们把第三张和第四张卡片重叠在一起，这样看上去就只有三张</span></span><br><span class="line">            <span class="comment">// 第四张卡片主要是为了保持动画的连贯性</span></span><br><span class="line">            <span class="keyword">if</span> (position == CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">                <span class="comment">// 按照一定的规则缩放，并且偏移Y轴。</span></span><br><span class="line">                <span class="comment">// CardConfig.DEFAULT_SCALE 默认为0.1f，CardConfig.DEFAULT_TRANSLATE_Y 默认为14</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((position - <span class="number">1</span>) * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 mTouchListener 的意义就在于我们想让处于顶层的卡片是可以随意滑动的</span></span><br><span class="line">                <span class="comment">// 而第二层、第三层等等的卡片是禁止滑动的</span></span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据源个数小于或等于最大显示数时，和上面的代码差不多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = itemCount - <span class="number">1</span>; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            addView(view);</span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line"></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> View.OnTouchListener mOnTouchListener = <span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(v);</span><br><span class="line">        <span class="comment">// 把触摸事件交给 mItemTouchHelper，让其处理卡片滑动事件</span></span><br><span class="line">        <span class="keyword">if</span> (MotionEventCompat.getActionMasked(event) == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            mItemTouchHelper.startSwipe(childViewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>CardLayoutManager</code> 主要就是为 Item View 布局，然后根据 <code>position</code> 做相对应的偏差。我们一起来看下完成的效果图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306221018.jpg" alt="layout效果图"></p>
<p>可以看出，大致的效果已经有了。缺少的就是处理触摸滑动事件了。</p>
<h2 id="OnSwipeListener"><a href="#OnSwipeListener" class="headerlink" title="OnSwipeListener"></a>OnSwipeListener</h2><p>在看滑动事件的代码之前，我们先定义一个监听器。主要用于监听卡片滑动事件，代码就如下所示，注释也给出来了。应该都看得懂吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSwipeListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片还在滑动时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑动卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> ratio      滑动进度的比例</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑动的方向，CardConfig.SWIPING_LEFT 为向左滑，CardConfig.SWIPING_RIGHT 为向右滑，</span><br><span class="line">     *                   CardConfig.SWIPING_NONE 为不偏左也不偏右</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiping</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">float</span> ratio, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片完全滑出时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑出卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> t          该滑出卡片的数据</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑出的方向，CardConfig.SWIPED_LEFT 为左边滑出；CardConfig.SWIPED_RIGHT 为右边滑出</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, T t, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 所有的卡片全部滑出时回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipedClear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CardItemTouchHelperCallback"><a href="#CardItemTouchHelperCallback" class="headerlink" title="CardItemTouchHelperCallback"></a>CardItemTouchHelperCallback</h2><p>现在，我们可以回过头来看看卡片滑动了。对于 ItemTouchHelper 来处理 Item View 的触摸滑动事件相必都不陌生吧，如果对这方面不太了解的同学可以看一下我之前的博客：<a href="/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/">《RecyclerView实现拖拽排序和侧滑删除》</a>。</p>
<p>我们暂且命名为 CardItemTouchHelperCallback 。对于 ItemTouchHelper.Callback 而言，需要在 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中配置 <code>swipeFlags</code> 和 <code>dragFlags</code> 。</p>
<p>具体的方法如下，对于 <code>swipeFlags</code> 只关心左右两个方向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> swipeFlags = <span class="number">0</span>;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> CardLayoutManager) &#123;</span><br><span class="line">        swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意，前面说过，为了防止第二层和第三层卡片也能滑动，因此我们需要设置 <code>isItemViewSwipeEnabled()</code> 返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemViewSwipeEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是去重写 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 和 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法。但是因为在上面我们对于 <code>dragFlags</code> 配置的是 0 ，所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 中直接返回 false 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把目光投向 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移除之前设置的 onTouchListener, 否则触摸滑动会乱了</span></span><br><span class="line">    viewHolder.itemView.setOnTouchListener(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 删除相对应的数据	</span></span><br><span class="line">    <span class="keyword">int</span> layoutPosition = viewHolder.getLayoutPosition();</span><br><span class="line">    T remove = dataList.remove(layoutPosition);</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">    <span class="comment">// 卡片滑出后回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onSwiped(viewHolder, remove, direction == ItemTouchHelper.LEFT ? CardConfig.SWIPED_LEFT : CardConfig.SWIPED_RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当没有数据时回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (adapter.getItemCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mListener.onSwipedClear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好后，我们先来看看滑动效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307214251.gif" alt="swipe效果图"></p>
<p>发现还是差了点什么，没错！是缺少了动画。在滑动的过程中我们可以重写 <code>onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,
                            float dX, float dY, int actionState, boolean isCurrentlyActive)</code> 方法来添加动画：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildDraw</span><span class="params">(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,</span><br><span class="line">                        <span class="keyword">float</span> dX, <span class="keyword">float</span> dY, <span class="keyword">int</span> actionState, <span class="keyword">boolean</span> isCurrentlyActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);</span><br><span class="line">    View itemView = viewHolder.itemView;</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123;</span><br><span class="line">        <span class="comment">// 得到滑动的阀值</span></span><br><span class="line">        <span class="keyword">float</span> ratio = dX / getThreshold(recyclerView, viewHolder);</span><br><span class="line">        <span class="comment">// ratio 最大为 1 或 -1</span></span><br><span class="line">        <span class="keyword">if</span> (ratio &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ratio = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">            ratio = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认最大的旋转角度为 15 度</span></span><br><span class="line">        itemView.setRotation(ratio * CardConfig.DEFAULT_ROTATE_DEGREE);</span><br><span class="line">        <span class="keyword">int</span> childCount = recyclerView.getChildCount();</span><br><span class="line">        <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">1</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                <span class="comment">// 和之前 onLayoutChildren 是一个意思，不过是做相反的动画</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当数据源个数小于或等于最大显示数时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调监听器</span></span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratio != <span class="number">0</span>) &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, ratio &lt; <span class="number">0</span> ? CardConfig.SWIPING_LEFT : CardConfig.SWIPING_RIGHT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, CardConfig.SWIPING_NONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getThreshold</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recyclerView.getWidth() * getSwipeThreshold(viewHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们加上动画后，来看看效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307222247.gif" alt="swipe效果图"></p>
<p>发现还是有问题，第一层的卡片滑出去之后第二层的就莫名其妙地偏了。这正是因为 Item View 重用机制“捣鬼”。所以我们应该在 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中重置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setRotation(<span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成，我们试一下效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306234152.gif" alt="swipe效果图"></p>
<p>Perfect !</p>
<p>这正是我们梦寐以求的效果。我们终于实现了！！！</p>
<p>总结一下，在这整个代码流程中我们主要是运用了自定义 LayoutManager 以及 ItemTouchHelper.Callback 。总体来说还是比较简单的，相信你已经会啦。</p>
<p>Goodbye ~~</p>
<p>最后，放上 GitHub 地址：<a href="https://github.com/yuqirong/CardSwipeLayout" target="_blank" rel="external">yuqirong/CardSwipeLayout</a></p>
<p>喜欢的可以来一波 star 哦。@^_^@</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android-architecture之todo-mvp源码分析]]></title>
    <link href="http://yuqirong.me/2017/02/22/android-architecture%E4%B9%8Btodo-mvp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/02/22/android-architecture之todo-mvp源码分析/</id>
    <published>2017-02-22T13:08:02.000Z</published>
    <updated>2017-02-28T15:09:06.683Z</updated>
    <content type="html"><![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 下半年来，MVP 渐渐崛起成为了现在普遍流行的架构模式。但是各种不同实现方式的 MVP 架构层出不穷，也让新手不知所措。而 Google 作为“老大哥”，针对此现象为 Android 架构做出了“规范示例”：<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a> 。 </p>
<p>目前已有的架构示例如下图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170222230352.png" alt="stable sample"></p>
<p>而今天给大家带来的就是分析 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目的架构。那就快进入正题吧！</p>
<h1 id="todo-mvp"><a href="#todo-mvp" class="headerlink" title="todo-mvp"></a>todo-mvp</h1><p>先来看看项目包的目录结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227212108.png" alt="目录结构"></p>
<p>基本上目录结构可以分为四种：</p>
<ol>
<li>addedittask、statistics、taskdetail、tasks ：可以看出在 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目中是按功能来分包的，这些包中的结构都是一致的，待会我们只需要分析其中一个包即可；</li>
<li>data ：该分包下主要是数据层的代码，即 MVP 中的 Model 层；</li>
<li>util ：工具类包，在这里就不展开细讲了；</li>
<li>BaseView、BasePresenter ：MVP 中 View 和 Presenter 的基类。</li>
</ol>
<p>然后是官方给出的 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170228224356.png" alt="MVP"></p>
<h2 id="BaseView__u548C_BasePresenter"><a href="#BaseView__u548C_BasePresenter" class="headerlink" title="BaseView 和 BasePresenter"></a>BaseView 和 BasePresenter</h2><p>这里就先看一下 BaseView 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseView 是一个泛型接口，里面只有一个抽象方法 <code>setPresenter(T presenter)</code> ，用来设置 Presenter 。</p>
<p>然后是 BasePresenter 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasePresenter 接口也只有一个抽象方法 <code>start()</code> ，用于在 Activity/Fragment 的 <code>onResume()</code> 方法中调用。</p>
<h2 id="addedittask_u3001statistics_u3001taskdetail_u3001tasks"><a href="#addedittask_u3001statistics_u3001taskdetail_u3001tasks" class="headerlink" title="addedittask、statistics、taskdetail、tasks"></a>addedittask、statistics、taskdetail、tasks</h2><p>这四个分包从结构上来讲都是一样的，那么在这里我们就分析 tasks 这个分包吧。下面是该分包下的源码文件：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227215628.png" alt="task分包的结构"></p>
<p>我们以 <code>TasksContract</code> 为切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setLoadingIndicator</span><span class="params">(<span class="keyword">boolean</span> active)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasks</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskDetailsUi</span><span class="params">(String taskId)</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadTasks</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNewTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 <code>TasksContract</code> 接口其实就是用来定义 <code>View</code> 和 <code>Presenter</code> 的。 <code>View</code> 和 <code>Presenter</code> 继承了 <code>BaseView</code> 和 <code>BasePresenter</code> 。再回头看看上面的 <code>TaskPresenter</code> ，想必大家都猜到了，肯定是继承了 <code>Presenter</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksPresenter</span> <span class="keyword">implements</span> <span class="title">TasksContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksContract.View mTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TasksPresenter</span><span class="params">(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView)</span> </span>&#123;</span><br><span class="line">        mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null"</span>);</span><br><span class="line">        mTasksView = checkNotNull(tasksView, <span class="string">"tasksView cannot be null!"</span>);</span><br><span class="line"></span><br><span class="line">        mTasksView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadTasks(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TasksPresenter</code> 的构造方法中把 <code>tasksRepository</code> 和 <code>tasksView</code> 传入，并且把 <code>TasksPresenter</code> 对象设置给了 <code>mTasksView</code> 。这样，Presenter 就实现了 Model 和 View 的解耦。</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>data 代表了 MVP 中的 Model 。我们根据上面出现过的 <code>TasksRepository</code> 来分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TasksRepository INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksRemoteDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksLocalDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TasksRepository</span><span class="params">(@NonNull TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                            @NonNull TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</span><br><span class="line">        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">getInstance</span><span class="params">(TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                                              TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TasksRepository</code> 实现了 <code>TasksDataSource</code> 接口，<code>TasksDataSource</code> 接口定义了一些对 <code>Task</code> 的增删改查操作。在 <code>TasksRepository</code> 的构造方法中传入两个 <code>TasksDataSource</code> 对象，其实是模拟了本地数据存储和网络数据存储两种方式。至于其他的就不详细展开了，无非就是对数据读写之类的操作。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里，基本上把 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构的代码大致地讲了一遍。本篇博客就不对其他的代码展开分析了，因为我们注重的是该项目中的 MVP 架构实现方式。另外，todo 系列还有其他几种 MVP 实现的方式，只能下次有空再讲了。</p>
<p>就到这吧，Goodbye !</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android架构" scheme="http://yuqirong.me/tags/Android%E6%9E%B6%E6%9E%84/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NotificationListenerService的那些事儿]]></title>
    <link href="http://yuqirong.me/2017/02/09/NotificationListenerService%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://yuqirong.me/2017/02/09/NotificationListenerService的那些事儿/</id>
    <published>2017-02-09T13:00:04.000Z</published>
    <updated>2017-02-11T03:19:31.471Z</updated>
    <content type="html"><![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</code> 支持的事件监听类型中有 <code>TYPE_NOTIFICATION_STATE_CHANGED</code> ，该事件类型就是用来监听通知栏消息状态改变的，众多的抢红包插件利用的就是这个原理。</p>
<p>之后在 Github 上看到了 <a href="https://github.com/lendylongli/qianghongbao" target="_blank" rel="external">qianghongbao</a> 这个抢红包的项目，发现代码里面有一个 <a href="https://github.com/lendylongli/qianghongbao/blob/master/app/src/main/java/com/codeboy/qianghongbao/QHBNotificationService.java" target="_blank" rel="external">QHBNotificationService</a> 继承了 <code>NotificationListenerService</code> ，这个 <code>NotificationListenerService</code> 极大地引起了我的兴趣。查了一下资料，发现 <code>NotificationListenerService</code> 是在 Android 4.3 （API 18）时被加入的，作用就是用来监听通知栏消息。并且官方建议在 Android 4.3 及以上使用 <code>NotificationListenerService</code> 来监听通知栏消息，以此取代 <code>AccessibilityService</code> 。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170209/20170209220914.png" alt="Notification Listener"></p>
<p><code>NotificationListenerService</code> 的使用范围也挺广的，比如我们熟知的抢红包，智能手表同步通知，通知栏去广告工具等，都是利用它来完成的。所以，我也想赶时髦地好好利用这把“利器”。最后方案也就出来了：在 Android 4.3 以下（API &lt; 18）使用 <code>AccessibilityService</code> 来读取新通知，在 Android 4.3 及以上（API &gt;= 18）使用 <code>NotificationListenerService</code> 来满足需求。</p>
<p>这也正是本篇博客诞生的“起源”。</p>
<h1 id="NotificationListenerService"><a href="#NotificationListenerService" class="headerlink" title="NotificationListenerService"></a>NotificationListenerService</h1><p>在这里，我们就做一个小需求：实时检测微信的新通知，如果该通知是微信红包的话，就进入微信聊天页面。</p>
<p>准备好了吗，我们开始吧！</p>
<p>首先创建一个 <code>WeChatNotificationListenerService</code> 继承 <code>NotificationListenerService</code> 。然后在 <code>AndroidManifest.xml</code> 中进行声明相关权限和 <code>&lt;intent-filter&gt;</code> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">"com.yuqirong.listenwechatnotification.WeChatNotificationListenerService"</span></span><br><span class="line">          <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">          <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.service.notification.NotificationListenerService"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后一般会重写下面这三个方法：</p>
<ul>
<li><code>onNotificationPosted(StatusBarNotification sbn)</code> ：当有新通知到来时会回调；</li>
<li><code>onNotificationRemoved(StatusBarNotification sbn)</code> ：当有通知移除时会回调；</li>
<li><code>onListenerConnected()</code> ：当 <code>NotificationListenerService</code> 是可用的并且和通知管理器连接成功时回调。</li>
</ul>
<h2 id="onNotificationPosted_28StatusBarNotification_sbn_29"><a href="#onNotificationPosted_28StatusBarNotification_sbn_29" class="headerlink" title="onNotificationPosted(StatusBarNotification sbn)"></a>onNotificationPosted(StatusBarNotification sbn)</h2><p>下面我们来看看 <code>NotificationListenerService</code> 中的重点： <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationPosted</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该通知的包名不是微信，那么 pass 掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"com.tencent.mm"</span>.equals(sbn.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Notification notification = sbn.getNotification();</span><br><span class="line">    <span class="keyword">if</span> (notification == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PendingIntent pendingIntent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当 API &gt; 18 时，使用 extras 获取通知的详细信息</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Bundle extras = notification.extras;</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取通知标题</span></span><br><span class="line">            String title = extras.getString(Notification.EXTRA_TITLE, <span class="string">""</span>);</span><br><span class="line">            <span class="comment">// 获取通知内容</span></span><br><span class="line">            String content = extras.getString(Notification.EXTRA_TEXT, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(content) &amp;&amp; content.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                pendingIntent = notification.contentIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 API = 18 时，利用反射获取内容字段</span></span><br><span class="line">        List&lt;String&gt; textList = getText(notification);</span><br><span class="line">        <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp; text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                    pendingIntent = notification.contentIntent;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 pendingIntent 以此打开微信</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingIntent.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，对于分析 <code>Notification</code> 的内容分为了两种：</p>
<ul>
<li>当 API &gt; 18 时，利用 <code>Notification.extras</code> 来获取通知内容。<code>extras</code> 是在 API 19 时被加入的；</li>
<li>当 API = 18 时，利用反射获取 <code>Notification</code> 中的内容。具体的代码在下方。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getText</span><span class="params">(Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == notification) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteViews views = notification.bigContentView;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        views = notification.contentView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use reflection to examine the m_actions member of the given RemoteViews object.</span></span><br><span class="line">    <span class="comment">// It's not pretty, but it works.</span></span><br><span class="line">    List&lt;String&gt; text = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = views.getClass().getDeclaredField(<span class="string">"mActions"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        ArrayList&lt;Parcelable&gt; actions = (ArrayList&lt;Parcelable&gt;) field.get(views);</span><br><span class="line">        <span class="comment">// Find the setText() and setTime() reflection actions</span></span><br><span class="line">        <span class="keyword">for</span> (Parcelable p : actions) &#123;</span><br><span class="line">            Parcel parcel = Parcel.obtain();</span><br><span class="line">            p.writeToParcel(parcel, <span class="number">0</span>);</span><br><span class="line">            parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// The tag tells which type of action it is (2 is ReflectionAction, from the source)</span></span><br><span class="line">            <span class="keyword">int</span> tag = parcel.readInt();</span><br><span class="line">            <span class="keyword">if</span> (tag != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// View ID</span></span><br><span class="line">            parcel.readInt();</span><br><span class="line">            String methodName = parcel.readString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == methodName) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"setText"</span>)) &#123;</span><br><span class="line">                <span class="comment">// Parameter type (10 = Character Sequence)</span></span><br><span class="line">                parcel.readInt();</span><br><span class="line">                <span class="comment">// Store the actual string</span></span><br><span class="line">                String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();</span><br><span class="line">                text.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            parcel.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>凭着 <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法就已经可以完成监听微信通知并打开的动作了。下面我们来看一下其他关于 <code>NotificationListenerService</code> 的二三事。</p>
<h2 id="u53D6_u6D88_u901A_u77E5"><a href="#u53D6_u6D88_u901A_u77E5" class="headerlink" title="取消通知"></a>取消通知</h2><p>有了监听，<code>NotificationListenerService</code> 自然提供了可以取消通知的方法。取消通知的方法有：</p>
<ul>
<li><code>cancelNotification(String key)</code> ：是 API &gt;= 21 才可以使用的。利用 <code>StatusBarNotification</code> 的 <code>getKey()</code> 方法来获取 <code>key</code> 并取消通知。</li>
<li><code>cancelNotification(String pkg, String tag, int id)</code> ：在 API &lt; 21 时可以使用，在 API &gt;= 21 时使用此方法来取消通知将无效，被废弃。</li>
</ul>
<p>最后，取消通知的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelNotification</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        cancelNotification(sbn.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cancelNotification(sbn.getPackageName(), sbn.getTag(), sbn.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743"><a href="#u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743" class="headerlink" title="检测通知监听服务是否被授权"></a>检测通知监听服务是否被授权</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNotificationListenerEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; packageNames = NotificationManagerCompat.getEnabledListenerPackages(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (packageNames.contains(context.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762"><a href="#u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762" class="headerlink" title="打开通知监听设置页面"></a>打开通知监听设置页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openNotificationListenSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(<span class="string">"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898"><a href="#u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898" class="headerlink" title="被杀后再次启动时，监听不生效的问题"></a>被杀后再次启动时，监听不生效的问题</h2><p>这个问题来源于知乎问题： <a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></p>
<p>从问题的回答中可以了解到，是因为 <code>NotificationListenerService</code> 被杀后再次启动时，并没有去 <code>bindService</code> ，所以导致监听效果无效。</p>
<p>最后，在回答中还给出了解决方案：利用 <code>NotificationListenerService</code> 先 disable 再 enable ，重新触发系统的 rebind 操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toggleNotificationListenerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PackageManager pm = getPackageManager();</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用前提是 <code>NotificationListenerService</code> 已经被用户授予了权限，否则无效。另外，在自己的小米手机上实测，重新完成 rebind 操作需要等待 10 多秒（我的手机测试过大概在 13 秒左右）。幸运的是，官方也已经发现了这个问题，在 API 24 中提供了 <code>requestRebind(ComponentName componentName)</code> 方法来支持重新绑定。</p>
<h1 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h1><p>讲完了 <code>NotificationListenerService</code> 之后，按照前面说的那样，在 API &lt; 18 的时候使用 <code>AccessibilityService</code> 。</p>
<p>同样，创建一个 <code>WeChatAccessibilityService</code> ，并且在 <code>AndroidManifest.xml</code> 中进行声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name="com.yuqirong.listenwechatnotification.WeChatAccessibilityService"</span><br><span class="line">    android:label="@string/app_name"</span><br><span class="line">    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name="android.accessibilityservice"</span><br><span class="line">        android:resource="@xml/accessible_service_config" /&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>声明之后，还要对 <code>WeChatAccessibilityService</code> 进行配置。需要在 res 目录下新建一个 xml 文件夹，在里面新建一个 accessible_service_config.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">accessibility-service</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:accessibilityEventTypes</span>=<span class="value">"typeNotificationStateChanged"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFeedbackType</span>=<span class="value">"feedbackAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFlags</span>=<span class="value">"flagIncludeNotImportantViews"</span></span><br><span class="line">    <span class="attribute">android:canRetrieveWindowContent</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:description</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:notificationTimeout</span>=<span class="value">"100"</span></span><br><span class="line">    <span class="attribute">android:packageNames</span>=<span class="value">"com.tencent.mm"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后就是代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatAccessibilityService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            Notification notification = (Notification) event.getParcelableData();</span><br><span class="line">            List&lt;String&gt; textList = getText(notification);</span><br><span class="line">            <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp;</span><br><span class="line">                            text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">final</span> PendingIntent pendingIntent = notification.contentIntent;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pendingIntent.send();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了一圈 <code>WeChatAccessibilityService</code> 的代码，发现和 <code>WeChatNotificationListenerService</code> 在 API &lt; 18 时处理的逻辑是一样的，<code>getText(notification)</code> 方法就是上面那个，在这里就不复制粘贴了，基本没什么好讲的了。</p>
<p>有了 <code>WeChatAccessibilityService</code> 之后，在 API &lt; 18 的情况下也能监听通知啦。\(^ο^)/</p>
<p>我们终于实现了当初许下的那个需求了。 cry …</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>除了监听通知之外，<code>AccessibilityService</code> 还可以进行模拟点击、检测界面变化等功能。具体的可以在 GitHub 上搜索抢红包有关的 Repo 进行深入学习。</p>
<p>而 <code>NotificationListenerService</code> 的监听通知功能更加强大，也更加专业。在一些设备上，如果 <code>NotificationListenerService</code> 被授予了权限，那么可以做到该监听进程不死的效果，也算是另类的进程保活。</p>
<p>今天就到这儿了，拜拜！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170209/ListenWeChatNotification.rar" target="_blank" rel="external">ListenWeChatNotification.rar</a></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/about/versions/android-4.3.html#NotificationListener" target="_blank" rel="external">Android 4.3 APIs</a></li>
<li><a href="https://developer.android.google.cn/reference/android/service/notification/NotificationListenerService.html" target="_blank" rel="external">NotificationListenerService</a></li>
<li><a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView实现拖拽排序和侧滑删除]]></title>
    <link href="http://yuqirong.me/2017/02/03/RecyclerView%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4/"/>
    <id>http://yuqirong.me/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/</id>
    <published>2017-02-03T07:23:59.000Z</published>
    <updated>2017-02-06T15:00:50.673Z</updated>
    <content type="html"><![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提供了相应的功能。</p>
<p>接下来，我们就来看一下怎么用系统 API 来实现排序和删除的效果。</p>
<h2 id="u521B_u5EFA_ItemTouchHelper"><a href="#u521B_u5EFA_ItemTouchHelper" class="headerlink" title="创建 ItemTouchHelper"></a>创建 ItemTouchHelper</h2><p>创建一个 <code>ItemTouchHelper</code> 对象，然后其调用 <code>attachToRecyclerView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);</span><br><span class="line">recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="keyword">false</span>));</span><br><span class="line">RecyclerViewAdapter adapter = <span class="keyword">new</span> RecyclerViewAdapter();</span><br><span class="line">ItemTouchHelper helper = <span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> MyItemTouchCallback(adapter));</span><br><span class="line">helper.attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure>
<p>在创建 <code>ItemTouchHelper</code> 对象时候，需要我们传入一个实现了 <code>ItemTouchHelper.Callback</code> 接口的对象。而排序和删除的逻辑都封装在了这个 <code>ItemTouchHelper.Callback</code> 的对象里面了。</p>
<h2 id="u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3"><a href="#u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3" class="headerlink" title="实现 ItemTouchHelper.Callback 接口"></a>实现 ItemTouchHelper.Callback 接口</h2><p>创建 <code>MyItemTouchCallback</code> 类，实现 <code>ItemTouchHelper.Callback</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemTouchCallback</span> <span class="keyword">extends</span> <span class="title">ItemTouchHelper</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemTouchCallback</span><span class="params">(RecyclerViewAdapter adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>ItemTouchHelper.Callback</code> 接口后有三个方法需要重写：</p>
<ol>
<li><code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> ：设置滑动类型的标记。需要设置两种类型的 flag ，即 <code>dragFlags</code> 和 <code>swipeFlags</code> ，分别代表着拖拽标记和滑动标记。最后需要调用 <code>makeMovementFlags(dragFlags, swipeFlags)</code> 方法来合成返回。</li>
<li><code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> ：当用户拖拽列表某个 item 时会回调。很明显，拖拽排序的代码应该在这个方法中实现。</li>
<li><code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> ：当用户滑动列表某个 item 时会回调。所以侧滑删除的代码应该在这个方法中实现。</li>
</ol>
<h2 id="u91CD_u5199_u65B9_u6CD5"><a href="#u91CD_u5199_u65B9_u6CD5" class="headerlink" title="重写方法"></a>重写方法</h2><p>我们先来看看 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlag;</span><br><span class="line">    <span class="keyword">int</span> swipeFlag;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP</span><br><span class="line">                | ItemTouchHelper.RIGHT | ItemTouchHelper.LEFT;</span><br><span class="line">        swipeFlag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP;</span><br><span class="line">        swipeFlag = ItemTouchHelper.END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlag, swipeFlag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中根据 <code>layoutManager</code> 分为了两种情况：</p>
<ol>
<li>如果是 <code>GridLayoutManager</code> ，那么拖拽排序就可以细分为上下左右四个方向了，而且 <code>GridLayoutManager</code> 没有侧滑删除的功能；</li>
<li>若是其他的 <code>LayoutManager</code> ，比如说 <code>LinearLayoutManager</code> ，那么拖拽排序就只有上下两个方向了，并且设置 <code>swipeFlag</code> 为 <code>ItemTouchHelper.END</code> 类型；</li>
<li>对于其他自定义类型的 <code>LayoutManager</code> 可以自己根据自身情况补充。</li>
</ol>
<p>下面就是 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fromPosition = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">int</span> toPosition = target.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (fromPosition &lt; toPosition) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &lt; toPosition; i++) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &gt; toPosition; i--) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说过了，<code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法是用户在拖拽 item 的时候会回调。所以关于列表排序的代码应该写在这里。方法参数中的 <code>viewHolder</code> 代表的是用户当前拖拽的 item ，而 <code>target</code> 代表的是被用户拖拽所覆盖的那个 item 。所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法中的逻辑就是把 <code>fromPosition</code> 至 <code>toPosition</code> 为止改变它们的位置。</p>
<p>最后就是 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法了：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> void onSwiped(RecyclerView.ViewHolder viewHolder, <span class="built_in">int</span> direction) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">position</span> = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (direction == ItemTouchHelper.<span class="keyword">END</span>) &#123;</span><br><span class="line">        adapter.getDataList().remove(<span class="keyword">position</span>);</span><br><span class="line">        adapter.notifyItemRemoved(<span class="keyword">position</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在用户进行侧滑删除操作的时候会回调，其中的逻辑就是得到当前用户进行侧滑删除操作的 item ，然后将其删除。</p>
<p>到了这里，大功告成了。那么来看看效果吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170206222813.gif" alt="效果图"></p>
<h2 id="u6539_u5584_u7528_u6237_u4F53_u9A8C"><a href="#u6539_u5584_u7528_u6237_u4F53_u9A8C" class="headerlink" title="改善用户体验"></a>改善用户体验</h2><p>我们发现还有一些不完美的地方：比如当用户在拖拽排序的时候，可以改变当前拖拽 item 的透明度，这样就可以和其他 item 区分开来了。那么，我们需要去重写 <code>onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectedChanged</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> actionState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState);</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        viewHolder.itemView.setBackgroundColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应地，当用户手指从拖拽 item 中抬起的时候，我们需要把 item 的透明度复原。需要我们重写 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setBackgroundColor(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，来看看改进之后的效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170203223341.gif" alt="改进效果图"></p>
<p>今天就这样吧，拜拜啦！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170206/TestRV.rar" target="_blank" rel="external">TestRV.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于使用AlarmManager的注意事项]]></title>
    <link href="http://yuqirong.me/2017/01/21/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8AlarmManager%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yuqirong.me/2017/01/21/关于使用AlarmManager的注意事项/</id>
    <published>2017-01-21T15:25:16.000Z</published>
    <updated>2017-01-23T15:34:02.880Z</updated>
    <content type="html"><![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任务，比如设置闹铃、发送心跳包等。也许有人会有疑问：为什么不能使用相同具有定时效果的 <code>Timer</code> 和 <code>Handler</code> 呢？</p>
<p>其实答案非常简单，相对于 <code>Handler</code> 来说，使用 <code>sendEmptyMessageDelayed</code> 方法是依赖于 <code>Handler</code> 所在的线程的，如果线程结束，就起不到定时任务的效果；而 <code>AlarmManager</code> 依赖的是 Android 系统的服务，具备唤醒机制。比起 <code>Handler</code> 也就更合适了。</p>
<p>而至于 <code>Timer</code> 可以精确地做到定时操作，但是相比于 <code>AlarmManager</code> 而言还是差了一截。同理，如果手机关屏后长时间不使用， CPU 就会进入休眠模式。这个使用如果使用 <code>Timer</code> 来执行定时任务就会失败，因为 <code>Timer</code> 无法唤醒 CPU 。</p>
<p>所以，综上所述，<code>AlarmManager</code> 就成为了最佳选择。</p>
<h1 id="SDK_API__26lt_3B_19"><a href="#SDK_API__26lt_3B_19" class="headerlink" title="SDK API &lt; 19"></a>SDK API &lt; 19</h1><p>一般情况下，使用 <code>AlarmManager</code> 来执行重复定时任务的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p><code>setRepeating</code> 该方法用于设置重复定时任务。</p>
<ul>
<li>第一个参数表示闹钟类型：一般为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> 或者 <code>AlarmManager.RTC_WAKEUP</code> 。它们之间的区别就是前者是从手机开机后的时间，包含了手机睡眠时间；而后者使用的就是手机系统设置中的时间。所以如果设置为 <code>AlarmManager.RTC_WAKEUP</code> ，那么可以通过修改手机系统的时间来提前触发定时事件。另外，对于相似的 <code>AlarmManager.ELAPSED_REALTIME</code> 和 <code>AlarmManager.RTC</code> 来说，它们不会唤醒 CPU 。所以使用的频率较少；</li>
<li>第二个参数表示任务首次执行时间：与第一个参数密切相关。第一个参数若为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> ，那么当前时间就为 <code>SystemClock.elapsedRealtime()</code> ；若为 <code>AlarmManager.RTC_WAKEUP</code> ，那么当前时间就为 <code>System.currentTimeMillis()</code> ；</li>
<li>第三个参数表示两次执行的间隔时间：这个参数没什么好讲的，一般为常量；</li>
<li>第四个参数表示对应的响应动作：一般都是去发送广播，然后在广播接收 <code>onReceive(Context context, Intent intent)</code> 中做相关操作。</li>
</ul>
<p>至此，一切顺利，畅通无阻。</p>
<h1 id="SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23"><a href="#SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23" class="headerlink" title="SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23"></a>SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23</h1><p>当你写好代码、满心欢喜地将程序跑在手机上的时候，傻眼了！你会发现在 Android 4.4 及以上版本的定时任务不是按照规定时间间隔来执行的。比如你设置了每隔 3 分钟发出一个 HTTP 请求，结果你一看莫名其妙地变成了隔 5 分钟发一次。</p>
<p>What the fuck?</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122224816.png" alt="what the fuck"></p>
<p>然后你查阅 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a> 会看到如下几句话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122225322.png" alt="Android 4.4 API"></p>
<p>恍然大悟！原来是 Google 为了追求系统省电，所以“偷偷加工”了一下唤醒的时间间隔。但也正如上面官网中所说的那样，如果在 Android 4.4 及以上的设备还要追求精准的闹钟定时任务，要使用 <code>setExact()</code> 方法。</p>
<p>所以，相应的代码就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你写好了“加强版”的 <code>AlarmManager</code> 之后，内心肯定无比小激动。这下总应该行了吧？运行一下，果然没错！在 Android 4.4 上的确按照规定的时间间隔在执行任务。哈哈，这下大功告成了！！！</p>
<h1 id="SDK_API__26gt_3B_3D_23"><a href="#SDK_API__26gt_3B_3D_23" class="headerlink" title="SDK API &gt;= 23"></a>SDK API &gt;= 23</h1><p>在 Android 4.4 上品尝到胜利的甜头后，你顺便在 Android 6.0 的设备上测试了一下。结果。。。。。。你又 TMD 傻眼了！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122232341.png" alt="What the fuck"></p>
<p>发现在设备关屏静止一段时间后， <code>AlarmManager</code> 又又又不能正常工作了。相必此时你连日狗的心都有了吧！强忍着泪水，再次打开 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a> ，发现在 Android 6.0 中引入了低电耗模式和应用待机模式。然后接着往下看 <a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a> ，发现会有下面一段话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122234141.png" alt="Android 6.0 API"></p>
<p>啊啊啊啊啊啊！之前在 Android 4.4 上能用的 <code>setExact()</code> 方法在 Android 6.0 上因为低电耗模式又不能正常使用了。但是，Google 又又又提供了新的方法 <code>setExactAndAllowWhileIdle()</code> 来解决在低电耗模式下的闹钟触发。</p>
<p>所以，Attention！相关的代码又被改写为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到了这里，总算是把因 Android 版本差异导致 <code>AlarmManager</code> 的“坑”填完了。这份代码已经可以满足日常的重复定时任务了。</p>
<p>好了，该讲的都讲完了，上床睡觉。仓促地结尾，预祝大家新年快乐！</p>
<p>Goodbye ！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html" target="_blank" rel="external">AlarmManager</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Say Hello To 2017]]></title>
    <link href="http://yuqirong.me/2017/01/14/Say%20Hello%20To%202017/"/>
    <id>http://yuqirong.me/2017/01/14/Say Hello To 2017/</id>
    <published>2017-01-14T07:53:56.000Z</published>
    <updated>2017-01-14T08:47:28.646Z</updated>
    <content type="html"><![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h1><p>现在回望 2016 年，发现过得也是浑浑噩噩，时间总是在不知不觉中流逝。自从 2016 年的 6 月份毕业开始，算是真正地踏上社会了。尽管万般不情愿，但还是离开了温暖的校园生活，这也意味着自己需要承担更多的责任和义务，加油！</p>
<p>在工作上也并不是一帆风顺，经历过之前八月份的贸然离职后，也懂得了做任何事都需要理性思考，而不是凭着自己的“任性”，不然迟早会付出惨痛的代价。这也教导我要学会珍惜现在，才能放眼于未来。</p>
<p>在过去的 2016 一年里，自己对于 Android 的学习也从“表面”进入到“里面”。不再满足于常规、机械地使用 API ，而是乐于探究其中内在的原理，这也是 Android 进阶开发的必经之路。对于每一位做技术的人员而言，更多地要求自己寻求积累和沉淀，而不应该是盲目地处于一种“会用就好”的状态。</p>
<h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>新的 2017 年，做一个更好的自己。</p>
<p>学习计划：</p>
<ol>
<li>继续深入学习 Android ，理解其中的原理以及解析热门的第三方框架源码，书籍《深入理解 Android 》系列、《 Android 系统源代码情景分析》等；</li>
<li>学习 React JS ，学会利用 React Native 框架开发 APP 。并适当地深入理解其中的原理；</li>
<li>重温 Java ，书籍：《Java编程思想》 、《Effective Java》等；</li>
<li>学习设计模式以及数据结构和算法等，书籍《 Head First 设计模式》等。</li>
<li>更多。。。</li>
</ol>
<p>不念过去，不畏将来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>201]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
</feed>
