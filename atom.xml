<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2017-07-25T13:18:07.992Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[OkHttp源码解析]]></title>
    <link href="http://yuqirong.me/2017/07/25/OkHttp%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/07/25/OkHttp源码解析/</id>
    <published>2017-07-25T12:54:57.000Z</published>
    <updated>2017-07-25T13:18:07.992Z</updated>
    <content type="html"><![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a href="https://github.com/square/okhttp" target="_blank" rel="external">https://github.com/square/okhttp</a></p>
<p>现如今，在 Android 开发领域大多数都是选择以 OkHttp 作为网络框架。</p>
<p>然而，简单地会使用 OkHttp 并不能让我们得到满足。更深层次的，我们需要阅读框架的源码，才能用起来得心应手，融会贯通。</p>
<p>An HTTP &amp; HTTP/2 client for Android and Java applications.</p>
<p>这是官网上对于 OkHttp 的介绍，简单明了。同时，也印证了那句经典的话：</p>
<p>Talk is cheap, show me the code.</p>
<h1 id="OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5"><a href="#OkHttp_u7684_u7B80_u5355_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="OkHttp的简单使用方法"></a>OkHttp的简单使用方法</h1><p>OkHttp 使用方法，直接抄官网的 \(╯-╰)/ 。</p>
<p>GET 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">run</span><span class="params">(String url)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .build();</span><br><span class="line"></span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>POST 请求：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> MediaType JSON</span><br><span class="line">    = MediaType.parse(<span class="string">"application/json; charset=utf-8"</span>);</span><br><span class="line"></span><br><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient();</span><br><span class="line"></span><br><span class="line"><span class="function">String <span class="title">post</span><span class="params">(String url, String json)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  RequestBody body = RequestBody.create(JSON, json);</span><br><span class="line">  Request request = <span class="keyword">new</span> Request.Builder()</span><br><span class="line">      .url(url)</span><br><span class="line">      .post(body)</span><br><span class="line">      .build();</span><br><span class="line">  Response response = client.newCall(request).execute();</span><br><span class="line">  <span class="keyword">return</span> response.body().string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="u6DF1_u5165_u6E90_u7801"><a href="#u6DF1_u5165_u6E90_u7801" class="headerlink" title="深入源码"></a>深入源码</h1><p>在这里，先分析下同步请求的源码，之后再回过头来看异步请求的源码。</p>
<p>Let’s go !</p>
<h1 id="u540C_u6B65_u8BF7_u6C42"><a href="#u540C_u6B65_u8BF7_u6C42" class="headerlink" title="同步请求"></a>同步请求</h1><h2 id="OkHttpClient"><a href="#OkHttpClient" class="headerlink" title="OkHttpClient"></a>OkHttpClient</h2><p>首先创建一个 <code>OkHttpClient</code> 对象，那我们看看在构造器中做了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">OkHttpClient</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>(<span class="keyword">new</span> Builder());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">OkHttpClient(Builder builder) &#123;</span><br><span class="line">  <span class="keyword">this</span>.dispatcher = builder.dispatcher; <span class="comment">// 分发器</span></span><br><span class="line">  <span class="keyword">this</span>.proxy = builder.proxy; <span class="comment">// 代理</span></span><br><span class="line">  <span class="keyword">this</span>.protocols = builder.protocols; <span class="comment">// 协议</span></span><br><span class="line">  <span class="keyword">this</span>.connectionSpecs = builder.connectionSpecs;</span><br><span class="line">  <span class="keyword">this</span>.interceptors = Util.immutableList(builder.interceptors); <span class="comment">// 拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.networkInterceptors = Util.immutableList(builder.networkInterceptors); <span class="comment">// 网络拦截器</span></span><br><span class="line">  <span class="keyword">this</span>.eventListenerFactory = builder.eventListenerFactory;</span><br><span class="line">  <span class="keyword">this</span>.proxySelector = builder.proxySelector; <span class="comment">// 代理选择</span></span><br><span class="line">  <span class="keyword">this</span>.cookieJar = builder.cookieJar; <span class="comment">// cookie</span></span><br><span class="line">  <span class="keyword">this</span>.cache = builder.cache; <span class="comment">// 缓存</span></span><br><span class="line">  <span class="keyword">this</span>.internalCache = builder.internalCache;</span><br><span class="line">  <span class="keyword">this</span>.socketFactory = builder.socketFactory;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">boolean</span> isTLS = <span class="keyword">false</span>;</span><br><span class="line">  <span class="keyword">for</span> (ConnectionSpec spec : connectionSpecs) &#123;</span><br><span class="line">    isTLS = isTLS || spec.isTls();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (builder.sslSocketFactory != <span class="keyword">null</span> || !isTLS) &#123;</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = builder.sslSocketFactory;</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = builder.certificateChainCleaner;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    X509TrustManager trustManager = systemDefaultTrustManager();</span><br><span class="line">    <span class="keyword">this</span>.sslSocketFactory = systemDefaultSslSocketFactory(trustManager);</span><br><span class="line">    <span class="keyword">this</span>.certificateChainCleaner = CertificateChainCleaner.get(trustManager);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">this</span>.hostnameVerifier = builder.hostnameVerifier;</span><br><span class="line">  <span class="keyword">this</span>.certificatePinner = builder.certificatePinner.withCertificateChainCleaner(</span><br><span class="line">      certificateChainCleaner);</span><br><span class="line">  <span class="keyword">this</span>.proxyAuthenticator = builder.proxyAuthenticator;</span><br><span class="line">  <span class="keyword">this</span>.authenticator = builder.authenticator;</span><br><span class="line">  <span class="keyword">this</span>.connectionPool = builder.connectionPool; <span class="comment">// 连接复用池</span></span><br><span class="line">  <span class="keyword">this</span>.dns = builder.dns;</span><br><span class="line">  <span class="keyword">this</span>.followSslRedirects = builder.followSslRedirects;</span><br><span class="line">  <span class="keyword">this</span>.followRedirects = builder.followRedirects;</span><br><span class="line">  <span class="keyword">this</span>.retryOnConnectionFailure = builder.retryOnConnectionFailure;</span><br><span class="line">  <span class="keyword">this</span>.connectTimeout = builder.connectTimeout; <span class="comment">// 连接超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.readTimeout = builder.readTimeout; <span class="comment">// 读取超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.writeTimeout = builder.writeTimeout; <span class="comment">// 写入超时时间</span></span><br><span class="line">  <span class="keyword">this</span>.pingInterval = builder.pingInterval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造器中利用建造者模式来构建 <code>OkHttpClient</code> 的对象。当然，如果你想自定义 <code>OkHttpClient</code> 配置的话，就要 new 一个 <code>OkHttpClient.Builder</code> 来配置自己的参数了。相信大家都干过这种事情了(∩_∩)。</p>
<p><code>OkHttpClient</code> 的构造器中主要是扎堆扎堆的配置，没别的。</p>
<p>之后再调用 <code>newCall(Request request)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Call <span class="title">newCall</span><span class="params">(Request request)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> RealCall.newRealCall(<span class="keyword">this</span>, request, <span class="keyword">false</span> <span class="comment">/* for web socket */</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在方法里面其实是创建了一个 <code>RealCall</code> 的对象，那么我们就进入 <code>RealCall</code> 中去看看吧。</p>
<h2 id="RealCall"><a href="#RealCall" class="headerlink" title="RealCall"></a>RealCall</h2><p>在 <code>RealCall</code> 的构造器中只是给一些变量赋值或初始化而已，没什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> RealCall <span class="title">newRealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Safely publish the Call instance to the EventListener.</span></span><br><span class="line">    RealCall call = <span class="keyword">new</span> RealCall(client, originalRequest, forWebSocket);</span><br><span class="line">    call.eventListener = client.eventListenerFactory().create(call);</span><br><span class="line">    <span class="keyword">return</span> call;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">RealCall</span><span class="params">(OkHttpClient client, Request originalRequest, <span class="keyword">boolean</span> forWebSocket)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.client = client;</span><br><span class="line">    <span class="keyword">this</span>.originalRequest = originalRequest;</span><br><span class="line">    <span class="keyword">this</span>.forWebSocket = forWebSocket;</span><br><span class="line">    <span class="keyword">this</span>.retryAndFollowUpInterceptor = <span class="keyword">new</span> RetryAndFollowUpInterceptor(client, forWebSocket);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后再把目光转向 <code>RealCall</code> 中的 <code>execute()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果该 call 已经被执行过了，就设置 executed 为 true</span></span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 加入 runningSyncCalls 队列中</span></span><br><span class="line">        client.dispatcher().executed(<span class="keyword">this</span>);</span><br><span class="line">        <span class="comment">// 得到响应 result</span></span><br><span class="line">        Response result = getResponseWithInterceptorChain();</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// 从 runningSyncCalls 队列中移除</span></span><br><span class="line">        client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>execute()</code> 方法为执行该 <code>RealCall</code>，在方法里面一开始检查了该 call 时候被执行。</p>
<p>然后又加入了 <code>Dispatcher</code> 的 <code>runningSyncCalls</code> 中。<code>runningSyncCalls</code> 队列只是用来记录正在同步请求中的 call ，在 call 完成请求后又会从 <code>runningSyncCalls</code> 中移除。</p>
<p>可见，在同步请求中 <code>Dispatcher</code> 参与的部分很少。但是在异步请求中， <code>Dispatcher</code> 可谓是大展身手。</p>
<p>最重要的方法，那就是 <code>getResponseWithInterceptorChain()</code> 。我们可以看到这方法是直接返回 <code>Response</code> 对象的，所以，在这个方法中一定做了很多很多的事情。</p>
<p>那就继续深入吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Response <span class="title">getResponseWithInterceptorChain</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// Build a full stack of interceptors.</span></span><br><span class="line">    List&lt;Interceptor&gt; interceptors = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    interceptors.addAll(client.interceptors()); <span class="comment">// 加入用户自定义的拦截器</span></span><br><span class="line">    interceptors.add(retryAndFollowUpInterceptor); <span class="comment">// 重试和重定向拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> BridgeInterceptor(client.cookieJar())); <span class="comment">// 加入转化请求响应的拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CacheInterceptor(client.internalCache())); <span class="comment">// 加入缓存拦截器</span></span><br><span class="line">    interceptors.add(<span class="keyword">new</span> ConnectInterceptor(client)); <span class="comment">// 加入连接拦截器</span></span><br><span class="line">    <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">        interceptors.addAll(client.networkInterceptors()); <span class="comment">// 加入用户自定义的网络拦截器</span></span><br><span class="line">    &#125;</span><br><span class="line">    interceptors.add(<span class="keyword">new</span> CallServerInterceptor(forWebSocket)); <span class="comment">// 加入发出请求和读取响应的拦截器</span></span><br><span class="line">    </span><br><span class="line">    Interceptor.Chain chain = <span class="keyword">new</span> RealInterceptorChain(interceptors, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="number">0</span>,</span><br><span class="line">            originalRequest, <span class="keyword">this</span>, eventListener, client.readTimeoutMillis());</span><br><span class="line">    <span class="comment">// 利用 chain 来链式调用拦截器，最后的返回结果就是 Response 对象</span></span><br><span class="line">    <span class="keyword">return</span> chain.proceed(originalRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>getResponseWithInterceptorChain()</code> 方法中有一堆的拦截器！！！</p>
<p>关于拦截器，之前在 <a href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OKHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/">一起来写OKHttp的拦截器</a> 这篇博客中有讲过，若不了解的同学可以先看下。</p>
<p>我们都知道，拦截器是 OkHttp 的精髓。</p>
<ol>
<li><code>client.interceptors()</code> ，首先加入 <code>interceptors</code> 的是用户自定义的拦截器，比如修改请求头的拦截器等；</li>
<li><code>RetryAndFollowUpInterceptor</code> 是用来重试和重定向的拦截器，在下面我们会讲到；</li>
<li><code>BridgeInterceptor</code> 是用来将用户友好的请求转化为向服务器的请求，之后又把服务器的响应转化为对用户友好的响应；</li>
<li><code>CacheInterceptor</code> 是缓存拦截器，若存在缓存并且可用就直接返回该缓存，否则会向服务器请求；</li>
<li><code>ConnectInterceptor</code> 用来建立连接的拦截器；</li>
<li><code>client.networkInterceptors()</code> 加入用户自定义的 <code>networkInterceptors</code> ;</li>
<li><code>CallServerInterceptor</code> 是真正向服务器发出请求且得到响应的拦截器；</li>
</ol>
<p>最后在聚合了这些拦截器后，利用 <code>RealInterceptorChain</code> 来链式调用这些拦截器，利用的就是责任链模式。</p>
<h2 id="RealInterceptorChain"><a href="#RealInterceptorChain" class="headerlink" title="RealInterceptorChain"></a>RealInterceptorChain</h2><p><code>RealInterceptorChain</code> 可以说是真正把这些拦截器串起来的一个角色。一个个拦截器就像一颗颗珠子，而 <code>RealInterceptorChain</code> 就是把这些珠子串连起来的那根绳子。</p>
<p>进入 <code>RealInterceptorChain</code> ，主要是 <code>proceed(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec, RealConnection connection)</code> 这个方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">proceed</span><span class="params">(Request request, StreamAllocation streamAllocation, HttpCodec httpCodec,</span><br><span class="line">                        RealConnection connection)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (index &gt;= interceptors.size()) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError();</span><br><span class="line"></span><br><span class="line">    calls++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that the incoming request will use it.</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; !<span class="keyword">this</span>.connection.supportsUrl(request.url())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must retain the same host and port"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we already have a stream, confirm that this is the only call to chain.proceed().</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.httpCodec != <span class="keyword">null</span> &amp;&amp; calls &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptors.get(index - <span class="number">1</span>)</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 得到下一次对应的 RealInterceptorChain</span></span><br><span class="line">    RealInterceptorChain next = <span class="keyword">new</span> RealInterceptorChain(interceptors, streamAllocation, httpCodec,</span><br><span class="line">            connection, index + <span class="number">1</span>, request, call, eventListener, readTimeout);</span><br><span class="line">    <span class="comment">// 当前次数的 interceptor</span></span><br><span class="line">    Interceptor interceptor = interceptors.get(index);</span><br><span class="line">    <span class="comment">// 进行拦截处理，并且在 interceptor 链式调用 next 的 proceed 方法</span></span><br><span class="line">    Response response = interceptor.intercept(next);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 确认下一次的 interceptor 调用过 chain.proceed()</span></span><br><span class="line">    <span class="keyword">if</span> (httpCodec != <span class="keyword">null</span> &amp;&amp; index + <span class="number">1</span> &lt; interceptors.size() &amp;&amp; next.calls != <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"network interceptor "</span> + interceptor</span><br><span class="line">                + <span class="string">" must call proceed() exactly once"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Confirm that the intercepted response isn't null.</span></span><br><span class="line">    <span class="keyword">if</span> (response == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"interceptor "</span> + interceptor + <span class="string">" returned null"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (response.body() == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(</span><br><span class="line">                <span class="string">"interceptor "</span> + interceptor + <span class="string">" returned a response with no body"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在代码中是一次次链式调用拦截器，可能有些同学还是看不懂。那么，我就捉急地画了一张示意图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170725/20170722185657.png" alt="interceptors"></p>
<p>有了这张图就好懂多了，如果还没懂的话就只能自己慢慢体会了。</p>
<p>下面就要进入分析拦截器的步骤了，至于用户自定义的拦截器在这就略过了。还有，拦截器只分析主要的 <code>intercept(Chain chain)</code> 代码。</p>
<h2 id="RetryAndFollowUpInterceptor"><a href="#RetryAndFollowUpInterceptor" class="headerlink" title="RetryAndFollowUpInterceptor"></a>RetryAndFollowUpInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request request = chain.request();</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Call call = realChain.call();</span><br><span class="line">    EventListener eventListener = realChain.eventListener();</span><br><span class="line"></span><br><span class="line">    streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(), createAddress(request.url()),</span><br><span class="line">            call, eventListener, callStackTrace);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> followUpCount = <span class="number">0</span>;</span><br><span class="line">    Response priorResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 如果取消，就释放资源</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (canceled) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Response response = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">boolean</span> releaseConnection = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用下一个拦截器</span></span><br><span class="line">            response = realChain.proceed(request, streamAllocation, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RouteException e) &#123;</span><br><span class="line">            <span class="comment">// The attempt to connect via a route failed. The request will not have been sent.</span></span><br><span class="line">            <span class="comment">// 路由连接失败，请求将不会被发送</span></span><br><span class="line">            <span class="keyword">if</span> (!recover(e.getLastConnectException(), <span class="keyword">false</span>, request)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> e.getLastConnectException();</span><br><span class="line">            &#125;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="comment">// An attempt to communicate with a server failed. The request may have been sent.</span></span><br><span class="line">            <span class="comment">// 服务器连接失败，请求可能已被发送</span></span><br><span class="line">            <span class="keyword">boolean</span> requestSendStarted = !(e <span class="keyword">instanceof</span> ConnectionShutdownException);</span><br><span class="line">            <span class="keyword">if</span> (!recover(e, requestSendStarted, request)) <span class="keyword">throw</span> e;</span><br><span class="line">            releaseConnection = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// We're throwing an unchecked exception. Release any resources.</span></span><br><span class="line">            <span class="comment">// 抛出未检查的异常，释放资源</span></span><br><span class="line">            <span class="keyword">if</span> (releaseConnection) &#123;</span><br><span class="line">                streamAllocation.streamFailed(<span class="keyword">null</span>);</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Attach the prior response if it exists. Such responses never have a body.</span></span><br><span class="line">        <span class="keyword">if</span> (priorResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">            response = response.newBuilder()</span><br><span class="line">                    .priorResponse(priorResponse.newBuilder()</span><br><span class="line">                            .body(<span class="keyword">null</span>)</span><br><span class="line">                            .build())</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果不需要重定向，那么 followUp 为空，会根据响应码判断</span></span><br><span class="line">        Request followUp = followUpRequest(response);</span><br><span class="line">        <span class="comment">// 释放资源，返回 response</span></span><br><span class="line">        <span class="keyword">if</span> (followUp == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!forWebSocket) &#123;</span><br><span class="line">                streamAllocation.release();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 关闭 response 的 body</span></span><br><span class="line">        closeQuietly(response.body());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (++followUpCount &gt; MAX_FOLLOW_UPS) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(<span class="string">"Too many follow-up requests: "</span> + followUpCount);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (followUp.body() <span class="keyword">instanceof</span> UnrepeatableRequestBody) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> HttpRetryException(<span class="string">"Cannot retry streamed HTTP body"</span>, response.code());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// response 和 followUp 比较是否为同一个连接</span></span><br><span class="line">        <span class="comment">// 若为重定向就销毁旧连接，创建新连接</span></span><br><span class="line">        <span class="keyword">if</span> (!sameConnection(response, followUp.url())) &#123;</span><br><span class="line">            streamAllocation.release();</span><br><span class="line">            streamAllocation = <span class="keyword">new</span> StreamAllocation(client.connectionPool(),</span><br><span class="line">                    createAddress(followUp.url()), call, eventListener, callStackTrace);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (streamAllocation.codec() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Closing the body of "</span> + response</span><br><span class="line">                    + <span class="string">" didn't close its backing stream. Bad interceptor?"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 将重定向操作得到的新请求设置给 request</span></span><br><span class="line">        request = followUp;</span><br><span class="line">        priorResponse = response;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>RetryAndFollowUpInterceptor</code> 是用来失败重试以及重定向的拦截器。</p>
<h2 id="BridgeInterceptor"><a href="#BridgeInterceptor" class="headerlink" title="BridgeInterceptor"></a>BridgeInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    Request userRequest = chain.request();</span><br><span class="line">    Request.Builder requestBuilder = userRequest.newBuilder();</span><br><span class="line">    <span class="comment">// 将用户友好的 request 构造为发送给服务器的 request</span></span><br><span class="line">    RequestBody body = userRequest.body();</span><br><span class="line">    <span class="comment">// 若有请求体，则构造</span></span><br><span class="line">    <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">        MediaType contentType = body.contentType();</span><br><span class="line">        <span class="keyword">if</span> (contentType != <span class="keyword">null</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Type"</span>, contentType.toString());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> contentLength = body.contentLength();</span><br><span class="line">        <span class="keyword">if</span> (contentLength != -<span class="number">1</span>) &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Content-Length"</span>, Long.toString(contentLength));</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Transfer-Encoding"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            requestBuilder.header(<span class="string">"Transfer-Encoding"</span>, <span class="string">"chunked"</span>);</span><br><span class="line">            requestBuilder.removeHeader(<span class="string">"Content-Length"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Host"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Host"</span>, hostHeader(userRequest.url(), <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Keep Alive</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Connection"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Connection"</span>, <span class="string">"Keep-Alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we add an "Accept-Encoding: gzip" header field we're responsible for also decompressing</span></span><br><span class="line">    <span class="comment">// the transfer stream.</span></span><br><span class="line">    <span class="comment">// 使用 gzip 压缩</span></span><br><span class="line">    <span class="keyword">boolean</span> transparentGzip = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"Accept-Encoding"</span>) == <span class="keyword">null</span> &amp;&amp; userRequest.header(<span class="string">"Range"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        transparentGzip = <span class="keyword">true</span>;</span><br><span class="line">        requestBuilder.header(<span class="string">"Accept-Encoding"</span>, <span class="string">"gzip"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置 cookie</span></span><br><span class="line">    List&lt;Cookie&gt; cookies = cookieJar.loadForRequest(userRequest.url());</span><br><span class="line">    <span class="keyword">if</span> (!cookies.isEmpty()) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"Cookie"</span>, cookieHeader(cookies));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// UA</span></span><br><span class="line">    <span class="keyword">if</span> (userRequest.header(<span class="string">"User-Agent"</span>) == <span class="keyword">null</span>) &#123;</span><br><span class="line">        requestBuilder.header(<span class="string">"User-Agent"</span>, Version.userAgent());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造完后，将 request 交给下一个拦截器去处理。最后又得到服务端响应 networkResponse</span></span><br><span class="line">    Response networkResponse = chain.proceed(requestBuilder.build());</span><br><span class="line">    <span class="comment">// 保存 networkResponse 的 cookie</span></span><br><span class="line">    HttpHeaders.receiveHeaders(cookieJar, userRequest.url(), networkResponse.headers());</span><br><span class="line">    <span class="comment">// 将 networkResponse 构造为对用户友好的 response</span></span><br><span class="line">    Response.Builder responseBuilder = networkResponse.newBuilder()</span><br><span class="line">            .request(userRequest);</span><br><span class="line">    <span class="comment">// 如果 networkResponse 使用 gzip 并且有响应体的话，给用户友好的 response 设置响应体</span></span><br><span class="line">    <span class="keyword">if</span> (transparentGzip</span><br><span class="line">            &amp;&amp; <span class="string">"gzip"</span>.equalsIgnoreCase(networkResponse.header(<span class="string">"Content-Encoding"</span>))</span><br><span class="line">            &amp;&amp; HttpHeaders.hasBody(networkResponse)) &#123;</span><br><span class="line">        GzipSource responseBody = <span class="keyword">new</span> GzipSource(networkResponse.body().source());</span><br><span class="line">        Headers strippedHeaders = networkResponse.headers().newBuilder()</span><br><span class="line">                .removeAll(<span class="string">"Content-Encoding"</span>)</span><br><span class="line">                .removeAll(<span class="string">"Content-Length"</span>)</span><br><span class="line">                .build();</span><br><span class="line">        responseBuilder.headers(strippedHeaders);</span><br><span class="line">        responseBuilder.body(<span class="keyword">new</span> RealResponseBody(strippedHeaders, Okio.buffer(responseBody)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> responseBuilder.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>BridgeInterceptor</code> 这一步，先把用户友好的请求进行重新构造，变成了向服务器发送的请求。</p>
<p>之后调用 <code>chain.proceed(requestBuilder.build())</code> 进行下一个拦截器的处理。</p>
<p>等到后面的拦截器都处理完毕，得到响应。再把 <code>networkResponse</code> 转化成对用户友好的 <code>response</code> 。</p>
<h2 id="CacheInterceptor"><a href="#CacheInterceptor" class="headerlink" title="CacheInterceptor"></a>CacheInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 request 对应缓存中的 response</span></span><br><span class="line">    Response cacheCandidate = cache != <span class="keyword">null</span></span><br><span class="line">            ? cache.get(chain.request())</span><br><span class="line">            : <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 获取当前时间，会和之前缓存的时间进行比较</span></span><br><span class="line">    <span class="keyword">long</span> now = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 得到缓存策略</span></span><br><span class="line">    CacheStrategy strategy = <span class="keyword">new</span> CacheStrategy.Factory(now, chain.request(), cacheCandidate).get();</span><br><span class="line">    Request networkRequest = strategy.networkRequest;</span><br><span class="line">    Response cacheResponse = strategy.cacheResponse;</span><br><span class="line">    <span class="comment">// 追踪缓存，其实就是计数</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        cache.trackResponse(strategy);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 缓存不适用，关闭</span></span><br><span class="line">    <span class="keyword">if</span> (cacheCandidate != <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        closeQuietly(cacheCandidate.body()); <span class="comment">// The cache candidate wasn't applicable. Close it.</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we're forbidden from using the network and the cache is insufficient, fail.</span></span><br><span class="line">    <span class="comment">// 禁止网络并且没有缓存的话，返回失败</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span> &amp;&amp; cacheResponse == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response.Builder()</span><br><span class="line">                .request(chain.request())</span><br><span class="line">                .protocol(Protocol.HTTP_1_1)</span><br><span class="line">                .code(<span class="number">504</span>)</span><br><span class="line">                .message(<span class="string">"Unsatisfiable Request (only-if-cached)"</span>)</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .sentRequestAtMillis(-<span class="number">1L</span>)</span><br><span class="line">                .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If we don't need the network, we're done.</span></span><br><span class="line">    <span class="comment">// 不用网络请求，返回缓存</span></span><br><span class="line">    <span class="keyword">if</span> (networkRequest == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> cacheResponse.newBuilder()</span><br><span class="line">                .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response networkResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 交给下一个拦截器，返回 networkResponse</span></span><br><span class="line">        networkResponse = chain.proceed(networkRequest);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">// If we're crashing on I/O or otherwise, don't leak the cache body.</span></span><br><span class="line">        <span class="keyword">if</span> (networkResponse == <span class="keyword">null</span> &amp;&amp; cacheCandidate != <span class="keyword">null</span>) &#123;</span><br><span class="line">            closeQuietly(cacheCandidate.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果我们同时有缓存和 networkResponse ，根据情况使用</span></span><br><span class="line">    <span class="keyword">if</span> (cacheResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (networkResponse.code() == HTTP_NOT_MODIFIED) &#123;</span><br><span class="line">            Response response = cacheResponse.newBuilder()</span><br><span class="line">                    .headers(combine(cacheResponse.headers(), networkResponse.headers()))</span><br><span class="line">                    .sentRequestAtMillis(networkResponse.sentRequestAtMillis())</span><br><span class="line">                    .receivedResponseAtMillis(networkResponse.receivedResponseAtMillis())</span><br><span class="line">                    .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">                    .networkResponse(stripBody(networkResponse))</span><br><span class="line">                    .build();</span><br><span class="line">            networkResponse.body().close();</span><br><span class="line">            <span class="comment">// 更新原来的缓存至最新</span></span><br><span class="line">            <span class="comment">// Update the cache after combining headers but before stripping the</span></span><br><span class="line">            <span class="comment">// Content-Encoding header (as performed by initContentStream()).</span></span><br><span class="line">            cache.trackConditionalCacheHit();</span><br><span class="line">            cache.update(cacheResponse, response);</span><br><span class="line">            <span class="keyword">return</span> response;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            closeQuietly(cacheResponse.body());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Response response = networkResponse.newBuilder()</span><br><span class="line">            .cacheResponse(stripBody(cacheResponse))</span><br><span class="line">            .networkResponse(stripBody(networkResponse))</span><br><span class="line">            .build();</span><br><span class="line">    <span class="comment">// 保存之前未缓存的缓存</span></span><br><span class="line">    <span class="keyword">if</span> (cache != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (HttpHeaders.hasBody(response) &amp;&amp; CacheStrategy.isCacheable(response, networkRequest)) &#123;</span><br><span class="line">            <span class="comment">// Offer this request to the cache.</span></span><br><span class="line">            CacheRequest cacheRequest = cache.put(response);</span><br><span class="line">            <span class="keyword">return</span> cacheWritingResponse(cacheRequest, response);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (HttpMethod.invalidatesCache(networkRequest.method())) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cache.remove(networkRequest);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123;</span><br><span class="line">                <span class="comment">// The cache cannot be written.</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>CacheInterceptor</code> 做的事情就是根据请求拿到缓存，若没有缓存或者缓存失效，就进入网络请求阶段，否则会返回缓存。</p>
<h2 id="ConnectInterceptor"><a href="#ConnectInterceptor" class="headerlink" title="ConnectInterceptor"></a>ConnectInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    Request request = realChain.request();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// We need the network to satisfy this request. Possibly for validating a conditional GET.</span></span><br><span class="line">    <span class="keyword">boolean</span> doExtensiveHealthChecks = !request.method().equals(<span class="string">"GET"</span>);</span><br><span class="line">    <span class="comment">// 创建 httpCodec （抽象类），分别对应着 http1.1 和 http 2</span></span><br><span class="line">    HttpCodec httpCodec = streamAllocation.newStream(client, doExtensiveHealthChecks);</span><br><span class="line">    RealConnection connection = streamAllocation.connection();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> realChain.proceed(request, streamAllocation, httpCodec, connection);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里调用了 <code>streamAllocation.newStream</code> 创建了一个 <code>HttpCodec</code> 的对象。</p>
<p>而 <code>HttpCodec</code> 是一个抽象类，其实现类分别是 <code>Http1Codec</code> 和 <code>Http2Codec</code> 。相对应的就是 HTTP/1.1 和 HTTP/2.0 。</p>
<p>我们来看下 <code>streamAllocation.newStream</code> 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> HttpCodec <span class="title">newStream</span><span class="params">(OkHttpClient client, <span class="keyword">boolean</span> doExtensiveHealthChecks)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> connectTimeout = client.connectTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> readTimeout = client.readTimeoutMillis();</span><br><span class="line">    <span class="keyword">int</span> writeTimeout = client.writeTimeoutMillis();</span><br><span class="line">    <span class="keyword">boolean</span> connectionRetryEnabled = client.retryOnConnectionFailure();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 在连接池中找到一个可用的连接，然后创建出 HttpCodec 对象</span></span><br><span class="line">        RealConnection resultConnection = findHealthyConnection(connectTimeout, readTimeout,</span><br><span class="line">                writeTimeout, connectionRetryEnabled, doExtensiveHealthChecks);</span><br><span class="line">        HttpCodec resultCodec = resultConnection.newCodec(client, <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (connectionPool) &#123;</span><br><span class="line">            codec = resultCodec;</span><br><span class="line">            <span class="keyword">return</span> resultCodec;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RouteException(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>newStream(OkHttpClient client, boolean doExtensiveHealthChecks)</code> 中先在连接池中找到可用的连接 <code>resultConnection</code> ，再结合 <code>sink</code> 和 <code>source</code> 创建出 <code>HttpCodec</code> 的对象。</p>
<h2 id="CallServerInterceptor"><a href="#CallServerInterceptor" class="headerlink" title="CallServerInterceptor"></a>CallServerInterceptor</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    RealInterceptorChain realChain = (RealInterceptorChain) chain;</span><br><span class="line">    HttpCodec httpCodec = realChain.httpStream();</span><br><span class="line">    StreamAllocation streamAllocation = realChain.streamAllocation();</span><br><span class="line">    RealConnection connection = (RealConnection) realChain.connection();</span><br><span class="line">    Request request = realChain.request();    </span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> sentRequestMillis = System.currentTimeMillis();</span><br><span class="line">    <span class="comment">// 整理请求头并写入</span></span><br><span class="line">    httpCodec.writeRequestHeaders(request);</span><br><span class="line"></span><br><span class="line">    Response.Builder responseBuilder = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 检查是否为有 body 的请求方法</span></span><br><span class="line">    <span class="keyword">if</span> (HttpMethod.permitsRequestBody(request.method()) &amp;&amp; request.body() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If there's a "Expect: 100-continue" header on the request, wait for a "HTTP/1.1 100</span></span><br><span class="line">        <span class="comment">// Continue" response before transmitting the request body. If we don't get that, return what</span></span><br><span class="line">        <span class="comment">// we did get (such as a 4xx response) without ever transmitting the request body.</span></span><br><span class="line">        <span class="comment">// 如果有 Expect: 100-continue 在请求头中，那么要等服务器的响应</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"100-continue"</span>.equalsIgnoreCase(request.header(<span class="string">"Expect"</span>))) &#123;</span><br><span class="line">            httpCodec.flushRequest();</span><br><span class="line">            responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">true</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// Write the request body if the "Expect: 100-continue" expectation was met.</span></span><br><span class="line">            <span class="comment">// 写入请求体</span></span><br><span class="line">            Sink requestBodyOut = httpCodec.createRequestBody(request, request.body().contentLength());</span><br><span class="line">            BufferedSink bufferedRequestBody = Okio.buffer(requestBodyOut);</span><br><span class="line">            request.body().writeTo(bufferedRequestBody);</span><br><span class="line">            bufferedRequestBody.close();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!connection.isMultiplexed()) &#123;</span><br><span class="line">            <span class="comment">// If the "Expect: 100-continue" expectation wasn't met, prevent the HTTP/1 connection from</span></span><br><span class="line">            <span class="comment">// being reused. Otherwise we're still obligated to transmit the request body to leave the</span></span><br><span class="line">            <span class="comment">// connection in a consistent state.</span></span><br><span class="line">            streamAllocation.noNewStreams();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    httpCodec.finishRequest();</span><br><span class="line">    <span class="comment">// 得到响应头</span></span><br><span class="line">    <span class="keyword">if</span> (responseBuilder == <span class="keyword">null</span>) &#123;</span><br><span class="line">        responseBuilder = httpCodec.readResponseHeaders(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 构造 response</span></span><br><span class="line">    Response response = responseBuilder</span><br><span class="line">            .request(request)</span><br><span class="line">            .handshake(streamAllocation.connection().handshake())</span><br><span class="line">            .sentRequestAtMillis(sentRequestMillis)</span><br><span class="line">            .receivedResponseAtMillis(System.currentTimeMillis())</span><br><span class="line">            .build();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> code = response.code();</span><br><span class="line">    <span class="comment">// 如果为 web socket 且状态码是 101 ，那么 body 为空</span></span><br><span class="line">    <span class="keyword">if</span> (forWebSocket &amp;&amp; code == <span class="number">101</span>) &#123;</span><br><span class="line">        <span class="comment">// Connection is upgrading, but we need to ensure interceptors see a non-null response body.</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(Util.EMPTY_RESPONSE)</span><br><span class="line">                .build();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 读取 body</span></span><br><span class="line">        response = response.newBuilder()</span><br><span class="line">                .body(httpCodec.openResponseBody(response))</span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果请求头中有 close 那么断开连接</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="string">"close"</span>.equalsIgnoreCase(response.request().header(<span class="string">"Connection"</span>))</span><br><span class="line">            || <span class="string">"close"</span>.equalsIgnoreCase(response.header(<span class="string">"Connection"</span>))) &#123;</span><br><span class="line">        streamAllocation.noNewStreams();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 抛出协议异常</span></span><br><span class="line">    <span class="keyword">if</span> ((code == <span class="number">204</span> || code == <span class="number">205</span>) &amp;&amp; response.body().contentLength() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> ProtocolException(</span><br><span class="line">                <span class="string">"HTTP "</span> + code + <span class="string">" had non-zero Content-Length: "</span> + response.body().contentLength());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>CallServerInterceptor</code> 中可见，关于请求和响应部分都是通过 <code>HttpCodec</code> 来实现的。而在 <code>HttpCodec</code> 内部又是通过 <code>sink</code> 和 <code>source</code> 来实现的。所以说到底还是 IO 流在起作用。</p>
<h2 id="u5C0F_u7ED3"><a href="#u5C0F_u7ED3" class="headerlink" title="小结"></a>小结</h2><p>到这里，我们也完全明白了 OkHttp 中的分层思想，每一个 interceptor 只处理自己的事，而剩余的就交给其他的 interceptor 。这种思想可以简化一些繁琐复杂的流程，从而达到逻辑清晰、互不干扰的效果。</p>
<h1 id="u5F02_u6B65_u8BF7_u6C42"><a href="#u5F02_u6B65_u8BF7_u6C42" class="headerlink" title="异步请求"></a>异步请求</h1><p>与同步请求直接调用 <code>execute()</code> 不同的是，异步请求是调用了 <code>enqueue(Callback responseCallback)</code> 这个方法。那么我们对异步请求探究的入口就是 <code>enqueue(Callback responseCallback)</code> 了。</p>
<h2 id="RealCall-1"><a href="#RealCall-1" class="headerlink" title="RealCall"></a>RealCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Callback responseCallback)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (executed) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already Executed"</span>);</span><br><span class="line">        executed = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    captureCallStackTrace();</span><br><span class="line">    <span class="comment">// 加入到 dispatcher 中，这里包装成了 AsyncCall</span></span><br><span class="line">    client.dispatcher().enqueue(<span class="keyword">new</span> AsyncCall(responseCallback));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要的方法就是调用了 <code>Dispatcher</code> 的 <code>enqueue(AsyncCall call)</code> 方法。这里需要注意的是，传入的是 <code>AsyncCall</code> 对象，而不是同步中的 <code>RealCall</code> 。</p>
<p>那么我们就跟进到 <code>Dispatcher</code> 的源码中吧，至于 <code>AsyncCall</code> 我们会在下面详细讲到。</p>
<h2 id="Dispatcher"><a href="#Dispatcher" class="headerlink" title="Dispatcher"></a>Dispatcher</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果当前正在运行的异步 call 数 &lt; 64 &amp;&amp; 队列中请求同一个 host 的异步 call 数 &lt; 5</span></span><br><span class="line">    <span class="comment">// maxRequests = 64，maxRequestsPerHost = 5</span></span><br><span class="line">    <span class="keyword">if</span> (runningAsyncCalls.size() &lt; maxRequests &amp;&amp; runningCallsForHost(call) &lt; maxRequestsPerHost) &#123;</span><br><span class="line">        <span class="comment">// 加入正在运行异步队列</span></span><br><span class="line">        runningAsyncCalls.add(call);</span><br><span class="line">        <span class="comment">// 加入到线程池中</span></span><br><span class="line">        executorService().execute(call);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 加入预备异步队列</span></span><br><span class="line">        readyAsyncCalls.add(call);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建线程池</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> ExecutorService <span class="title">executorService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (executorService == <span class="keyword">null</span>) &#123;</span><br><span class="line">        executorService = <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE, <span class="number">60</span>, TimeUnit.SECONDS,</span><br><span class="line">                <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(), Util.threadFactory(<span class="string">"OkHttp Dispatcher"</span>, <span class="keyword">false</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从 <code>enqueue(AsyncCall call)</code> 中可以知道，OkHttp 在运行中的异步请求数最多为 63 ，而同一个 host 的异步请求数最多为 4 。否则会加入到 <code>readyAsyncCalls</code> 中。</p>
<p>在加入到 <code>runningAsyncCalls</code> 后，就会进入线程池中被执行。到了这里，我们就要到 <code>AsyncCall</code> 中一探究竟了。</p>
<h2 id="AsyncCall"><a href="#AsyncCall" class="headerlink" title="AsyncCall"></a>AsyncCall</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncCall</span> <span class="keyword">extends</span> <span class="title">NamedRunnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Callback responseCallback;</span><br><span class="line"></span><br><span class="line">    AsyncCall(Callback responseCallback) &#123;</span><br><span class="line">        <span class="keyword">super</span>(<span class="string">"OkHttp %s"</span>, redactedUrl());</span><br><span class="line">        <span class="keyword">this</span>.responseCallback = responseCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">host</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest.url().host();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Request <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> originalRequest;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">RealCall <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> RealCall.<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> signalledCallback = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 调用一连串的拦截器，得到响应</span></span><br><span class="line">            Response response = getResponseWithInterceptorChain();</span><br><span class="line">            <span class="keyword">if</span> (retryAndFollowUpInterceptor.isCanceled()) &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, <span class="keyword">new</span> IOException(<span class="string">"Canceled"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调结果</span></span><br><span class="line">                signalledCallback = <span class="keyword">true</span>;</span><br><span class="line">                responseCallback.onResponse(RealCall.<span class="keyword">this</span>, response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (signalledCallback) &#123;</span><br><span class="line">                <span class="comment">// Do not signal the callback twice!</span></span><br><span class="line">                Platform.get().log(INFO, <span class="string">"Callback failure for "</span> + toLoggableString(), e);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 回调失败</span></span><br><span class="line">                responseCallback.onFailure(RealCall.<span class="keyword">this</span>, e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">// 在 runningAsyncCalls 中移除，并作推进其他 call 的工作</span></span><br><span class="line">            client.dispatcher().finished(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>AsyncCall</code> 的 <code>execute()</code> 方法中，也是调用了 <code>getResponseWithInterceptorChain()</code> 方法来得到 <code>Response</code> 对象。从这里开始，就和同步请求的流程是一样的，就没必要讲了。</p>
<p>在得到 <code>Response</code> 后，进行结果的回调。</p>
<p>最后，调用了 <code>Dispatcher</code> 的 <code>finished</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(AsyncCall call)</span> </span>&#123;</span><br><span class="line">    finished(runningAsyncCalls, call, <span class="keyword">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">finished</span><span class="params">(Deque&lt;T&gt; calls, T call, <span class="keyword">boolean</span> promoteCalls)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> runningCallsCount;</span><br><span class="line">    Runnable idleCallback;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 移除该 call</span></span><br><span class="line">        <span class="keyword">if</span> (!calls.remove(call)) <span class="keyword">throw</span> <span class="keyword">new</span> AssertionError(<span class="string">"Call wasn't in-flight!"</span>);</span><br><span class="line">        <span class="comment">// 将 readyAsyncCalls 中的 call 移动到 runningAsyncCalls 中，并加入到线程池中</span></span><br><span class="line">        <span class="keyword">if</span> (promoteCalls) promoteCalls();</span><br><span class="line">        runningCallsCount = runningCallsCount();</span><br><span class="line">        idleCallback = <span class="keyword">this</span>.idleCallback;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (runningCallsCount == <span class="number">0</span> &amp;&amp; idleCallback != <span class="keyword">null</span>) &#123;</span><br><span class="line">        idleCallback.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>finished(Deque&lt;T&gt; calls, T call, boolean promoteCalls)</code> 中对该 call 移除。</p>
<p>若在 <code>readyAsyncCalls</code> 中其他的 call ，就移动到 <code>runningAsyncCalls</code> 中并加入线程池中。</p>
<p>这样，完整的流程就循环起来了。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>基本上 OkHttp 的请求响应的流程就讲完了，篇幅有点长长长啊。</p>
<p>不过还有很多点没有涉及到的，比如连接池、缓存策略等等，都是值得我们去深究的。也是需要花很大的功夫才能了解透彻。</p>
<p>好了，那就到这里吧，有问题的同学可以留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.jianshu.com/p/27c1554b7fee" target="_blank" rel="external">OKHttp源码解析</a></li>
<li><a href="https://blog.piasy.com/2016/07/11/Understand-OkHttp/" target="_blank" rel="external">拆轮子系列：拆 OkHttp</a></li>
<li><a href="http://blog.csdn.net/qq_15274383/article/details/73729801" target="_blank" rel="external">OkHttp框架的RetryAndFollowUpInterceptor请求重定向源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Header"><a href="#Header" class="headerlink" title="Header"></a>Header</h1><p>注：本文 OkHttp 源码解析基于 v3.8.1 。</p>
<p>OkHttp in GitHub：<a]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[可以伸缩的搜索栏，模仿华为应用市场]]></title>
    <link href="http://yuqirong.me/2017/07/03/%E5%8F%AF%E4%BB%A5%E4%BC%B8%E7%BC%A9%E7%9A%84%E6%90%9C%E7%B4%A2%E6%A0%8F%EF%BC%8C%E6%A8%A1%E4%BB%BF%E5%8D%8E%E4%B8%BA%E5%BA%94%E7%94%A8%E5%B8%82%E5%9C%BA/"/>
    <id>http://yuqirong.me/2017/07/03/可以伸缩的搜索栏，模仿华为应用市场/</id>
    <published>2017-07-03T13:42:56.000Z</published>
    <updated>2017-07-04T14:55:44.586Z</updated>
    <content type="html"><![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
<p>关于搜索栏，可以说各种 app 都有不同的样式。影响比较深刻的就有华为应用市场的搜索栏（同样，简书的搜索栏也是类似的）。</p>
<p>而今天，就是带你来实现华为应用市场那样的搜索栏。</p>
<p>我们先放上我们实现的效果图吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170703150542.gif" alt="demo效果图"></p>
<p>怎么样，想不想学？</p>
<p>我们先来简述一下实现的思路吧，其实并不复杂。</p>
<p>首先，在搜索栏还未打开时，先确定半径 R ，然后假设一个变量 offset 用来动态改变搜索栏的宽度。如图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170703/20170704204905.png" alt="示意图"></p>
<p>所以可以得到一个公式：offset = total width - 2 * R ;</p>
<p>那么显而易见，offset 的取值就在 [0, total width - 2 * R] 之间了。</p>
<p>所以，我们可以借助属性动画来完成这数值的变化。在调用 <code>invalidate()</code> 进行重绘，达到动态增加搜索栏宽度的效果。反之，关闭搜索栏也是同理的。</p>
<p>那么下面就用代码来实现它咯！</p>
<h2 id="attrs"><a href="#attrs" class="headerlink" title="attrs"></a>attrs</h2><p>关于自定义的属性，我们可以想到的有搜索栏的背景颜色、搜索栏的位置（左或右）、搜索栏的状态（打开或关闭）等。具体的可以查看下面的 attrs.xml 。根据英文应该能知道对应属性的作用了。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">resources</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="title">declare-styleable</span> <span class="attribute">name</span>=<span class="value">"SearchBarView"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_position"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_left"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"position_right"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_status"</span> <span class="attribute">format</span>=<span class="value">"enum"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_close"</span> <span class="attribute">value</span>=<span class="value">"4"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="title">enum</span> <span class="attribute">name</span>=<span class="value">"status_open"</span> <span class="attribute">value</span>=<span class="value">"1"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="title">attr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_duration"</span> <span class="attribute">format</span>=<span class="value">"integer"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text"</span> <span class="attribute">format</span>=<span class="value">"string|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_icon"</span> <span class="attribute">format</span>=<span class="value">"reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_color"</span> <span class="attribute">format</span>=<span class="value">"color|reference"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="title">attr</span> <span class="attribute">name</span>=<span class="value">"search_bar_hint_text_size"</span> <span class="attribute">format</span>=<span class="value">"dimension|reference"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="title">declare-styleable</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">resources</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h2 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h2><p>而在构造器中，肯定就是初始化一些 attrs 中的全局变量了，这也不是重点，都是机械式的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">SearchBarView</span><span class="params">(Context context, @Nullable AttributeSet attrs, <span class="keyword">int</span> defStyleAttr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(context, attrs, defStyleAttr);</span><br><span class="line">    TypedArray array = context.obtainStyledAttributes(attrs, R.styleable.SearchBarView);</span><br><span class="line">    searchBarColor = array.getColor(R.styleable.SearchBarView_search_bar_color, DEFAULT_SEARCH_BAR_COLOR);</span><br><span class="line">    mPosition = array.getInteger(R.styleable.SearchBarView_search_bar_position, DEFAULT_RIGHT_POSITION);</span><br><span class="line">    mStatus = array.getInteger(R.styleable.SearchBarView_search_bar_status, STATUS_CLOSE);</span><br><span class="line">    <span class="keyword">int</span> mDuration = array.getInteger(R.styleable.SearchBarView_search_bar_duration, DEFAULT_ANIMATION_DURATION);</span><br><span class="line">    <span class="keyword">int</span> searchBarIcon = array.getResourceId(R.styleable.SearchBarView_search_bar_icon, android.R.drawable.ic_search_category_default);</span><br><span class="line">    mSearchText = array.getText(R.styleable.SearchBarView_search_bar_hint_text);</span><br><span class="line">    searchTextColor = array.getColor(R.styleable.SearchBarView_search_bar_hint_text_color, DEFAULT_SEARCH_TEXT_COLOR);</span><br><span class="line">    <span class="keyword">float</span> defaultTextSize = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, DEFAULT_HINT_TEXT_SIZE, getResources().getDisplayMetrics());</span><br><span class="line">    <span class="keyword">float</span> searchTextSize = array.getDimension(R.styleable.SearchBarView_search_bar_hint_text_size, defaultTextSize);</span><br><span class="line">    defaultHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, DEFAULT_HEIGHT, getResources().getDisplayMetrics());</span><br><span class="line">    array.recycle();</span><br><span class="line">    mPaint = <span class="keyword">new</span> Paint(Paint.ANTI_ALIAS_FLAG);</span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    mPaint.setTextSize(searchTextSize);</span><br><span class="line">    mRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    mDstRectF = <span class="keyword">new</span> RectF();</span><br><span class="line">    bitmap = BitmapFactory.decodeResource(getResources(), searchBarIcon);</span><br><span class="line">    initAnimator(mDuration);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initAnimator"><a href="#initAnimator" class="headerlink" title="initAnimator"></a>initAnimator</h2><p><code>initAnimator</code> 方法中是两个属性动画，打开和关闭动画。非常 easy 的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">initAnimator</span><span class="params">(<span class="keyword">long</span> duration)</span> </span>&#123;</span><br><span class="line">    AccelerateInterpolator accelerateInterpolator = <span class="keyword">new</span> AccelerateInterpolator();</span><br><span class="line">    ValueAnimator.AnimatorUpdateListener animatorUpdateListener = <span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">            mOffsetX = (<span class="keyword">int</span>) animation.getAnimatedValue();</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// init open animator</span></span><br><span class="line">    openAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    openAnimator.setDuration(duration);</span><br><span class="line">    openAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    openAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_OPEN;</span><br><span class="line">            invalidate();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="comment">// init close animator</span></span><br><span class="line">    closeAnimator = <span class="keyword">new</span> ValueAnimator();</span><br><span class="line">    openAnimator.setInterpolator(accelerateInterpolator);</span><br><span class="line">    closeAnimator.setDuration(duration);</span><br><span class="line">    closeAnimator.addUpdateListener(animatorUpdateListener);</span><br><span class="line">    closeAnimator.addListener(<span class="keyword">new</span> AnimatorListenerAdapter() &#123;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationStart</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_PROCESS;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationEnd</span><span class="params">(Animator animation)</span> </span>&#123;</span><br><span class="line">            mStatus = STATUS_CLOSE;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onMeasure"><a href="#onMeasure" class="headerlink" title="onMeasure"></a>onMeasure</h2><p>同样，<code>onMeasure</code> 中的代码也是很机械的，基本上都是同一个套路了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onMeasure</span><span class="params">(<span class="keyword">int</span> widthMeasureSpec, <span class="keyword">int</span> heightMeasureSpec)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> widthMode = MeasureSpec.getMode(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> widthSize = MeasureSpec.getSize(widthMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightMode = MeasureSpec.getMode(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">int</span> heightSize = MeasureSpec.getSize(heightMeasureSpec);</span><br><span class="line">    <span class="keyword">if</span> (widthMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mWidth = widthSize;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (heightMode == MeasureSpec.EXACTLY) &#123;</span><br><span class="line">        mHeight = heightSize;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mHeight = (<span class="keyword">int</span>) defaultHeight;</span><br><span class="line">        <span class="keyword">if</span> (heightMode == MeasureSpec.AT_MOST) &#123;</span><br><span class="line">            mHeight = Math.min(heightSize, mHeight);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 搜索栏小圆圈的半径</span></span><br><span class="line">    mRadius = Math.min(mWidth, mHeight) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN) &#123;</span><br><span class="line">        mOffsetX = mWidth - mRadius * <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    setMeasuredDimension(mWidth, mHeight);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="onDraw"><a href="#onDraw" class="headerlink" title="onDraw"></a>onDraw</h2><p>在 <code>onDraw</code> 中先画了搜索栏的背景，然后是搜索栏的图标，最后是搜索栏的提示文字。</p>
<p>画背景的时候，是需要根据搜索栏在左边还是右边的位置来确定值的。</p>
<p>而画图标的时候，是根据搜索栏关闭时那个圆的内切正方形作为 Rect 的。</p>
<p>最后画提示文字没什么好讲的了，都是定死的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDraw</span><span class="params">(Canvas canvas)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// draw search bar</span></span><br><span class="line">    mPaint.setColor(searchBarColor);</span><br><span class="line">    <span class="keyword">int</span> left = mPosition == DEFAULT_RIGHT_POSITION ? mWidth - <span class="number">2</span> * mRadius - mOffsetX : <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> right = mPosition == DEFAULT_RIGHT_POSITION ? mWidth : <span class="number">2</span> * mRadius + mOffsetX;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        canvas.drawRoundRect(left, <span class="number">0</span>, right, mHeight, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mRectF.set(left, <span class="number">0</span>, right, mHeight);</span><br><span class="line">        canvas.drawRoundRect(mRectF, mRadius, mRadius, mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// draw search bar icon</span></span><br><span class="line">    mDstRectF.set(left + (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> - Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius),</span><br><span class="line">            left + (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius), (<span class="keyword">int</span>) ((<span class="number">1</span> + Math.sqrt(<span class="number">2</span>) / <span class="number">2</span>) * mRadius));</span><br><span class="line">    canvas.drawBitmap(bitmap, <span class="keyword">null</span>, mDstRectF, mPaint);</span><br><span class="line">    <span class="comment">// draw search bar text</span></span><br><span class="line">    <span class="keyword">if</span> (mStatus == STATUS_OPEN &amp;&amp; !TextUtils.isEmpty(mSearchText)) &#123;</span><br><span class="line">        mPaint.setColor(searchTextColor);</span><br><span class="line">        Paint.FontMetrics fm = mPaint.getFontMetrics();</span><br><span class="line">        <span class="keyword">double</span> textHeight = Math.ceil(fm.descent - fm.ascent);</span><br><span class="line">        canvas.drawText(mSearchText.toString(), <span class="number">2</span> * mRadius, (<span class="keyword">float</span>) (mRadius + textHeight / <span class="number">2</span> - fm.descent), mPaint);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="startOpen_u3001startClose"><a href="#startOpen_u3001startClose" class="headerlink" title="startOpen、startClose"></a>startOpen、startClose</h2><p>最后，需要将 <code>startOpen</code> 和 <code>startClose</code> 方法暴露给外部，方便调用。在其内部就是调用两个属性动画而已。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为打开状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_OPEN;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 判断搜索栏是否为关闭状态</span><br><span class="line"> *</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mStatus == STATUS_CLOSE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 打开搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startOpen</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isOpen()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        closeAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    openAnimator.setIntValues(mOffsetX, mWidth - mRadius * <span class="number">2</span>);</span><br><span class="line">    openAnimator.start();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * 关闭搜索栏</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">startClose</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (isClose()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (closeAnimator.isStarted()) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (openAnimator.isStarted()) &#123;</span><br><span class="line">        openAnimator.cancel();</span><br><span class="line">    &#125;</span><br><span class="line">    closeAnimator.setIntValues(mOffsetX, <span class="number">0</span>);</span><br><span class="line">    closeAnimator.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="End"><a href="#End" class="headerlink" title="End"></a>End</h2><p>到这也差不多了，该讲的都讲了，这篇写得真 TMD 简洁。至于和 <code>AppBarLayout</code> 的混合使用，见 GitHub 中的代码即可。</p>
<p>有问题的可以在下面留言。没问题的老铁可以来一波 star 。</p>
<p>FlexibleSearchBar：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/FlexibleSearchBar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>本项目的 GitHub 地址：<a href="https://github.com/yuqirong/FlexibleSearchBar" target="_blank" rel="external">https://github.com/yuqirong/Flexibl]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[一起来写OkHttp的拦截器]]></title>
    <link href="http://yuqirong.me/2017/06/25/%E4%B8%80%E8%B5%B7%E6%9D%A5%E5%86%99OkHttp%E7%9A%84%E6%8B%A6%E6%88%AA%E5%99%A8/"/>
    <id>http://yuqirong.me/2017/06/25/一起来写OkHttp的拦截器/</id>
    <published>2017-06-25T04:37:02.000Z</published>
    <updated>2017-07-22T08:23:55.849Z</updated>
    <content type="html"><![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。</p>
<p>现如今，做 Android 开发在选择网络框架时，大多数都会首推 Retrofit 。Retrofit 以其简洁优雅的代码俘获了大多数开发者的心。</p>
<p>然而 Retrofit 内部请求也是基于 OkHttp 的，所以在做一些自定义修改 HTTP 请求时，需要对 OkHttp 拦截器具有一定了解。相信熟悉 OkHttp 的同学都知道，OkHttp 内部是使用拦截器来完成请求和响应的，利用的是责任链设计模式。所以可以说，拦截器是 OkHttp 的精髓所在。</p>
<p>那么接下来，我们就通过一些例子来学习怎样编写 OkHttp 的拦截器吧，其实这些例子也正是之前我遇到的情景。</p>
<h1 id="00_3A01"><a href="#00_3A01" class="headerlink" title="00:01"></a>00:01</h1><h2 id="u6DFB_u52A0_u8BF7_u6C42_Header"><a href="#u6DFB_u52A0_u8BF7_u6C42_Header" class="headerlink" title="添加请求 Header"></a>添加请求 Header</h2><p>假设现在后台要求我们在请求 API 接口时，都在每一个接口的请求头上添加对应的 token 。使用 Retrofit 比较多的同学肯定会条件反射出以下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@FormUrlEncoded</span></span><br><span class="line"><span class="annotation">@POST</span>(<span class="string">"/mobile/login.htm"</span>)</span><br><span class="line"><span class="function">Call&lt;ResponseBody&gt; <span class="title">login</span><span class="params">(@Header(<span class="string">"token"</span>)</span> String token, @<span class="title">Field</span><span class="params">(<span class="string">"mobile"</span>)</span> String phoneNumber, @<span class="title">Field</span><span class="params">(<span class="string">"smsCode"</span>)</span> String smsCode)</span>;</span><br></pre></td></tr></table></figure>
<p>这样的写法自然可以，无非就是每次调用 login API 接口时都把 token 传进去而已。但是需要注意的是，假如现在有十多个 API 接口，每一个都需要传入 token ，难道我们去重复一遍又一遍吗？</p>
<p>相信有良知的程序员都会拒绝，因为这会导致代码的冗余。</p>
<p>那么有没有好的办法可以一劳永逸呢？答案是肯定的，那就要用到拦截器了。</p>
<p>代码很简单：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TokenHeaderInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="comment">// get token</span></span><br><span class="line">        String token = AppService.getToken();</span><br><span class="line">        Request originalRequest = chain.request();</span><br><span class="line">        <span class="comment">// get new request, add request header</span></span><br><span class="line">        Request updateRequest = originalRequest.newBuilder()</span><br><span class="line">                .header(<span class="string">"token"</span>, token)</span><br><span class="line">                .build();</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(updateRequest);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先拦截得到 originalRequest ，然后利用 originalRequest 生成新的 updateRequest ，再交给 chain 处理进行下一环。</p>
<p>最后，在 OkHttpClient 中使用：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .build();</span><br><span class="line"></span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(GsonConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<h2 id="u6539_u53D8_u8BF7_u6C42_u4F53"><a href="#u6539_u53D8_u8BF7_u6C42_u4F53" class="headerlink" title="改变请求体"></a>改变请求体</h2><p>除了增加请求头之外，拦截器还可以改变请求体。</p>
<p>假设现在我们有如下需求：在上面的 login 接口基础上，后台要求我们传过去的请求参数是要按照一定规则经过加密的。</p>
<p>规则如下：</p>
<ul>
<li>请求参数名统一为content；</li>
<li>content值：JSON 格式的字符串经过 AES 加密后的内容；</li>
</ul>
<p>举个例子，根据上面的 login 接口，现有</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;"<span class="attribute">mobile</span>":<span class="value"><span class="string">"157xxxxxxxx"</span></span>, "<span class="attribute">smsCode</span>":<span class="value"><span class="string">"xxxxxx"</span></span>&#125;</span><br></pre></td></tr></table></figure>
<p>JSON 字符串，然后再将其加密。最后以 content=[加密后的 JSON 字符串] 方式发送给后台。</p>
<p>看完了上面的 <code>TokenHeaderInterceptor</code> 之后，这需求对于我们来说可以算是信手拈来：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RequestEncryptInterceptor</span> <span class="keyword">implements</span> <span class="title">Interceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String FORM_NAME = <span class="string">"content"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CHARSET = <span class="string">"UTF-8"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Response <span class="title">intercept</span><span class="params">(Chain chain)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        Request request = chain.request();</span><br><span class="line">        RequestBody body = request.body();</span><br><span class="line">        <span class="keyword">if</span> (body <span class="keyword">instanceof</span> FormBody) &#123;</span><br><span class="line">            FormBody formBody = (FormBody) body;</span><br><span class="line">            Map&lt;String, String&gt; formMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">            <span class="comment">// 从 formBody 中拿到请求参数，放入 formMap 中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; formBody.size(); i++) &#123;</span><br><span class="line">                formMap.put(formBody.name(i), formBody.value(i));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 将 formMap 转化为 json 然后 AES 加密</span></span><br><span class="line">            Gson gson = <span class="keyword">new</span> Gson();</span><br><span class="line">            String jsonParams = gson.toJson(formMap);</span><br><span class="line">            String encryptParams = AESCryptUtils.encrypt(jsonParams.getBytes(CHARSET), AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 重新修改 body 的内容</span></span><br><span class="line">            body = <span class="keyword">new</span> FormBody.Builder().add(FORM_NAME, encryptParams).build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (body != <span class="keyword">null</span>) &#123;</span><br><span class="line">            request = request.newBuilder()</span><br><span class="line">                    .post(body)</span><br><span class="line">                    .build();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> chain.proceed(request);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中已经添加了关键的注释，相信我已经不需要多解释什么了。</p>
<p>经过了这两种拦截器，相信同学们已经充分体会到了 OkHttp 的优点和与众不同。</p>
<p>最后，自定义拦截器的使用情景通常是对所有网络请求作统一处理。如果下次你也碰到这种类似的需求，别忘记使用自定义拦截器哦！</p>
<h1 id="00_3A02"><a href="#00_3A02" class="headerlink" title="00:02"></a>00:02</h1><p>呃呃呃，按道理来讲应该要结束了。</p>
<p>但是，我在这里开启一个番外篇吧，不过目标不是针对拦截器而是 ConverterFactory 。</p>
<p>还是后台需求，login 接口返回的数据也是经过 AES 加密的。所以需要我们针对所有响应体都做解密处理。</p>
<p>另外，还有很重要的一点，就是数据正常和异常时返回的 JSON 格式不一致。</p>
<p>在业务数据正常的时候（即 code 等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">200</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"请求成功"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value">&#123;</span><br><span class="line">        "<span class="attribute">nickName</span>":<span class="value"><span class="string">"Hello"</span></span>,</span><br><span class="line">        "<span class="attribute">userId</span>": <span class="value"><span class="string">"1234567890"</span></span><br><span class="line">    </span>&#125;</span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>业务数据异常时（即 code 不等于 200 时）：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    "<span class="attribute">code</span>":<span class="value"><span class="number">7008</span></span>,</span><br><span class="line">    "<span class="attribute">msg</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span>,</span><br><span class="line">    "<span class="attribute">data</span>":<span class="value"><span class="string">"用户名或密码错误"</span></span><br><span class="line"></span>&#125;</span><br></pre></td></tr></table></figure>
<p>而这会在使用 Retrofit 自动从 JSON 转化为 bean 类时报错。因为 data 中的正常数据中是 JSON ，而另一个异常数据中是字符串。</p>
<p>那么，如何解决上述的两个问题呢？</p>
<p>利用 <strong>自定义 ConverterFactory</strong> ！！</p>
<p>我们先创建包名 <code>retrofit2.converter.gson</code> ，为什么要创建这个包名呢？</p>
<p>因为自定义的 ConverterFactory 需要继承 Converter.Factory ，而 Converter.Factory 类默认是包修饰符。</p>
<p>代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomConverterFactory</span> <span class="keyword">extends</span> <span class="title">Converter</span>.<span class="title">Factory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(<span class="keyword">new</span> Gson());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"ConstantConditions"</span>) <span class="comment">// Guarding public API nullability.</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> CustomConverterFactory <span class="title">create</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (gson == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"gson == null"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomConverterFactory(gson);</span><br><span class="line">    &#125;</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">CustomConverterFactory</span><span class="params">(Gson gson)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;ResponseBody, ?&gt; responseBodyConverter(Type type, Annotation[] annotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="comment">// attention here!</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> CustomResponseConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Converter&lt;?, RequestBody&gt; requestBodyConverter(Type type, Annotation[] parameterAnnotations, Annotation[] methodAnnotations, Retrofit retrofit) &#123;</span><br><span class="line">        TypeAdapter&lt;?&gt; adapter = gson.getAdapter(TypeToken.get(type));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GsonRequestBodyConverter&lt;&gt;(gson, adapter);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>CustomConverterFactory</code> 内部是根据 <code>CustomResponseConverter</code> 来转化 JSON 的，这才是我们的重点。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomResponseConverter</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Converter</span>&lt;<span class="title">ResponseBody</span>, <span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Gson gson;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TypeAdapter&lt;T&gt; adapter;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String CODE = <span class="string">"code"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DATA = <span class="string">"data"</span>;</span><br><span class="line"></span><br><span class="line">    CustomResponseConverter(Gson gson, TypeAdapter&lt;T&gt; adapter) &#123;</span><br><span class="line">        <span class="keyword">this</span>.gson = gson;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">convert</span><span class="params">(ResponseBody value)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String originalBody = value.string();</span><br><span class="line">            <span class="comment">// 先 AES 解密</span></span><br><span class="line">            String body = AESCryptUtils.decrypt(originalBody, AppConstant.getAESKey());</span><br><span class="line">            <span class="comment">// 再获取 code </span></span><br><span class="line">            JSONObject json = <span class="keyword">new</span> JSONObject(body);</span><br><span class="line">            <span class="keyword">int</span> code = json.optInt(CODE);</span><br><span class="line">            <span class="comment">// 当 code 不为 200 时，设置 data 为 null，这样转化就不会出错了</span></span><br><span class="line">            <span class="keyword">if</span> (code != <span class="number">200</span>) &#123;</span><br><span class="line">                Map&lt;String, String&gt; map = gson.fromJson(body, <span class="keyword">new</span> TypeToken&lt;Map&lt;String, String&gt;&gt;() &#123;</span><br><span class="line">                &#125;.getType());</span><br><span class="line">                map.put(DATA, <span class="keyword">null</span>);</span><br><span class="line">                body = gson.toJson(map);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> adapter.fromJson(body);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(e.getMessage());</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            value.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码也是很简单的，相信也不需要解释了。o(∩_∩)o</p>
<p>最后就是使用了 <code>CustomConverterFactory</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">OkHttpClient client = <span class="keyword">new</span> OkHttpClient.Builder()</span><br><span class="line">                .addNetworkInterceptor(<span class="keyword">new</span> TokenHeaderInterceptor())</span><br><span class="line">                .addInterceptor(<span class="keyword">new</span> RequestEncryptInterceptor())</span><br><span class="line">                .build();</span><br><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BuildConfig.BASE_URL)</span><br><span class="line">                .client(client).addConverterFactory(CustomConverterFactory.create()).build();</span><br></pre></td></tr></table></figure>
<p>好了，这下真的把该讲的都讲完了，大家可以散了。</p>
<p>完结了。</p>
<p>再见！</p>
<p>再见！</p>
<p>再见！</p>
<p>重要的说三遍！！！</p>
<p>再说最后一遍，再见！！！</p>
<h1 id="00_3A03"><a href="#00_3A03" class="headerlink" title="00:03"></a>00:03</h1><p><strong>References</strong></p>
<ul>
<li><a href="http://www.jianshu.com/p/2263242fa02d" target="_blank" rel="external">如何使用Retrofit请求非Restful API</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="00_3A00"><a href="#00_3A00" class="headerlink" title="00:00"></a>00:00</h1><p>一开始就不多说废话了，主要因为工作时遇到了一些使用 OkHttp 拦截器的问题，所以在此特写这篇以作记录。<]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(二)]]></title>
    <link href="http://yuqirong.me/2017/06/13/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%BA%8C)/"/>
    <id>http://yuqirong.me/2017/06/13/Kotlin入入入门(二)/</id>
    <published>2017-06-13T12:16:20.000Z</published>
    <updated>2017-06-14T14:14:52.084Z</updated>
    <content type="html"><![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a> 中已经介绍了如何配置 Kotlin 。另外，还把 Java 代码转换为了 Kotlin 代码。所以今天我们就来比较一下这两者代码之间的区别，从而实现快速入门 Kotlin 。</p>
<p>Now ，我们把之前相同含义的 Java 和 Kotlin 代码粘贴出来（上面是 Java 代码，下面是 Kotlin 代码）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle;</span><br><span class="line"><span class="keyword">import</span> android.support.annotation.Nullable;</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity;</span><br><span class="line"><span class="keyword">import</span> android.widget.TextView;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(@Nullable Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line">        TextView textView = (TextView) findViewById(R.id.textView);</span><br><span class="line">        textView.setText(<span class="string">"Hello World"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="package"><a href="#package" class="headerlink" title="package"></a>package</h2><p>我们先慢慢地从上往下看，第一句 <code>package</code> 语句就有所不同。我们发现 Kotlin 中的所有代码没有以 <code>;</code> 结尾。另外，在 Kotlin 中并不要求包与目录匹配。即源文件可以在文件系统中的任意位置。</p>
<p>比如 <code>package me.yuqirong.kotlintest</code> 可能位于 /me/yuqirong/kotlintest2/ 文件夹下，并不会报错；而在 Java 中，包与目录必须匹配。</p>
<p>但是需要注意的一点是，在 AndroidManifest.xml 中配置的 Activity 的全类名必须和其路径一致，否则会找不到！</p>
<h2 id="class"><a href="#class" class="headerlink" title="class"></a>class</h2><p>在 Kotlin 中，<code>class</code> 默认是 <code>public</code> 的，所以平常都省略不写。</p>
<p>继承父类和实现接口都用 <code>:</code> 来表示。不同的是继承父类是带 <code>()</code> 的，即表示构造器，比如上面的 <code>AppCompatActivity()</code> ；而接口则不需要 <code>()</code> 。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>(), View.OnClickListener &#123;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>AppCompatActivity()</code> 就是继承，而 <code>View.OnClickListener</code> 就是实现。</p>
<h2 id="method"><a href="#method" class="headerlink" title="method"></a>method</h2><p>从比较的代码中可以知道：</p>
<ol>
<li>在 Kotlin 中默认方法的修饰符就是 <code>public</code> ，可以省略不写。</li>
<li>在 Kotlin 中重写的方法是要加 <code>override</code> 关键字的，而 Java 是以注解 <code>@Override</code> 来修饰的；</li>
<li>在 Kotlin 中方法都是用 <code>fun</code> 关键字来声明的；</li>
<li>在 Kotlin 中方法的参数是参数名在前，参数类型在后，中间以 <code>:</code> 隔开；若参数可能为空，则在参数类型后加 <code>?</code> 来表示。即上面代码中的 <code>(savedInstanceState: Bundle?)</code> ；</li>
<li><p>和参数表示类似，返回值也是以 <code>: 返回类型</code> 的方式表示的。比如上面的 Kotlin 代码可写为</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span>: Unit &#123;</span></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> Kotlin 中的 <code>Unit</code> 类型即 Java 中的 void 类型，可以省略不写。</p>
</li>
</ol>
<p>举个例子：</p>
<p>方法名 <code>multiplication</code> ，参数 <code>int a</code> 和 <code>int b</code> ，返回 <code>a</code> 和 <code>b</code> 相乘的值：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span>: Int &#123;</span></span><br><span class="line">    <span class="keyword">return</span> a * b</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>有人也许会有疑问，这和 Java 代码行数也差不多嘛。</p>
<p>当然还有更加简单的写法，函数体可以是表达式，并可从中推断出返回值类型。返回类型就可以省略不写了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">multiplication</span><span class="params">(a: <span class="typename">Int, b: Int</span>)</span> = a * b</span></span><br></pre></td></tr></table></figure>
<h1 id="u9644_u52A0_u9898"><a href="#u9644_u52A0_u9898" class="headerlink" title="附加题"></a>附加题</h1><h2 id="u5B9A_u4E49_u53D8_u91CF"><a href="#u5B9A_u4E49_u53D8_u91CF" class="headerlink" title="定义变量"></a>定义变量</h2><p>只读变量 val</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// 推测为 Int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> j</span> = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>Kotlin 中的 <code>val</code> 关键字就类似于 Java 中的 <code>final</code> 。</p>
<p>可变变量 var</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">var</span> i</span>: <span class="typename">Int</span> = <span class="number">1</span></span><br><span class="line">i += <span class="number">1</span></span><br></pre></td></tr></table></figure>
<h2 id="u5B57_u7B26_u4E32_u6A21_u677F"><a href="#u5B57_u7B26_u4E32_u6A21_u677F" class="headerlink" title="字符串模板"></a>字符串模板</h2><p>字符串可以包含模板表达式，即可求值的代码片段，并将其结果连接到字符串中。一个模板表达式由一个 $ 开始并包含另一个简单的名称。</p>
<p>举个例子：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> text</span> = <span class="string">"World!"</span></span><br><span class="line">    println(<span class="string">"Hello, $&#123;text&#125;"</span>) <span class="comment">// 也可以去掉&#123;&#125;，即 println("Hello, $text")</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：Hello, World!</p>
<h2 id="u57FA_u672C_u7C7B_u578B"><a href="#u57FA_u672C_u7C7B_u578B" class="headerlink" title="基本类型"></a>基本类型</h2><p>Kotlin 基本类型包括了数值、字符、布尔、字符串和数组。</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// int 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> a</span>: <span class="typename">Int</span> = <span class="number">10000</span></span><br><span class="line"><span class="comment">// double 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Double</span> = <span class="number">125.2</span></span><br><span class="line"><span class="comment">// float 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Float</span> = <span class="number">123.2</span>f</span><br><span class="line"><span class="comment">// long 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> d</span>: <span class="typename">Long</span> = <span class="number">1234</span>L</span><br><span class="line"><span class="comment">// boolean 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> e</span>: <span class="typename">Boolean</span> = <span class="literal">false</span></span><br><span class="line"><span class="comment">// char 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> f</span>: <span class="typename">Char</span> = 'e'</span><br><span class="line"><span class="comment">// string 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> g</span>: String = <span class="string">"hello"</span></span><br><span class="line"><span class="comment">// byte 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> h</span>: <span class="typename">Byte</span> = <span class="number">1</span></span><br><span class="line"><span class="comment">// short 类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> i</span>: <span class="typename">Short</span> = <span class="number">3</span></span><br><span class="line"><span class="comment">// 数组类型</span></span><br><span class="line"><span class="variable"><span class="keyword">val</span> x</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<h2 id="u6D41_u7A0B_u63A7_u5236"><a href="#u6D41_u7A0B_u63A7_u5236" class="headerlink" title="流程控制"></a>流程控制</h2><ul>
<li><p>if 表达式<br>  除了 Java 中 if 使用方法外，在 Kotlin 中还支持如下的写法：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    <span class="variable"><span class="keyword">val</span> a</span> = <span class="number">101</span></span><br><span class="line">	<span class="variable"><span class="keyword">val</span> b</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">100</span>)&#123;</span><br><span class="line">		print(<span class="string">"a &gt; 100 "</span>)</span><br><span class="line">		<span class="literal">true</span></span><br><span class="line">		&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">		print(<span class="string">"a &lt;= 100 "</span>)</span><br><span class="line">		<span class="literal">false</span></span><br><span class="line">		&#125;</span><br><span class="line">    println(b)</span><br><span class="line">	<span class="variable"><span class="keyword">val</span> c</span>: <span class="typename">Boolean</span> = <span class="keyword">if</span>(a &gt; <span class="number">0</span>) <span class="literal">true</span> <span class="keyword">else</span> <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>  运行结果：a &gt; 100 true</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="typename">Array&lt;String&gt;</span>)</span> &#123;</span></span><br><span class="line">    println(testIf(<span class="number">100</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">testIf</span><span class="params">(a: <span class="typename">Int</span>)</span> = <span class="title">if</span><span class="params">(a &gt; 100)</span> true <span class="keyword">else</span> false</span></span><br></pre></td></tr></table></figure>
<p>  运行结果：false</p>
</li>
<li><p>when 表达式<br>  Kotlin 中的 when 表达式就是 Java 中的 switch 表达式，具体例子如下：</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">when</span> (x) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; print(<span class="string">"x == 1"</span>)</span><br><span class="line">    <span class="number">2</span> -&gt; print(<span class="string">"x == 2"</span>)</span><br><span class="line">    <span class="keyword">else</span> -&gt; print(<span class="string">"x is neither 1 nor 2"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>for 循环</p>
  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable"><span class="keyword">val</span> collection</span>: IntArray = intArrayOf(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;</span><br><span class="line">	print(item)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>while 循环<br>  while 循环与 Java 中的无异。</p>
</li>
</ul>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>今天就讲到这里了，更多 Kotlin 的使用方法就期待下一篇吧！</p>
<p>Goodbye ! ~ ~</p>
<p>更多关于 Kotlin 的博客：</p>
<ul>
<li><a href="/2017/06/07/Kotlin入入入门(一)/">Kotlin入入入门(一)</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u627E_u4E0D_u540C"><a href="#u627E_u4E0D_u540C" class="headerlink" title="找不同"></a>找不同</h1><p>之前在 <a href="/2017/06/07/Kotlin入入入门(一)]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Kotlin入入入门(一)]]></title>
    <link href="http://yuqirong.me/2017/06/07/Kotlin%E5%85%A5%E5%85%A5%E5%85%A5%E9%97%A8(%E4%B8%80)/"/>
    <id>http://yuqirong.me/2017/06/07/Kotlin入入入门(一)/</id>
    <published>2017-06-07T12:10:22.000Z</published>
    <updated>2017-06-14T14:15:16.961Z</updated>
    <content type="html"><![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio 配置</h1><p>Android Studio 3.0 版本已经默认添加了对 Kotlin 的支持，所以以下 Android Studio 配置是针对于 3.0 版本以下的。</p>
<ol>
<li><p>安装 Kotlin 插件</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607210549.png" alt="Kotlin Plugin"></p>
</li>
<li><p>将 Java 代码转化为 Kotlin 代码</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607221409.png" alt="Converting Java code to Kotlin"></p>
<p> 之后代码就变成了如下：</p>
 <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将文件编辑之后，会跳出一个配置 Kotlin 的提示：</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222519.png" alt="Kotlin Configure"></p>
<p> 点击配置后，出现如下弹窗，点击 OK 即可</p>
<p> <img src="http://ofyt9w4c2.bkt.clouddn.com//20170607/20170607222730.png" alt="Kotlin Configure Dialog"></p>
</li>
<li><p>配置完成后，可以看到项目的 build.gradle 多了一些：</p>
<pre><code>buildscript {
    ext.kotlin_version = &apos;1.1.2-4&apos;
    repositories {
        jcenter()
    }
    dependencies {
        classpath &apos;com.android.tools.build:gradle:2.2.2&apos;
        classpath &quot;org.jetbrains.kotlin:kotlin-gradle-plugin:$kotlin_version&quot;
    }
}
</code></pre><p> app/build.gradle 的配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;

...

dependencies {
    ...
    compile &quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&quot;
}
</code></pre></li>
</ol>
<h1 id="Hello_World"><a href="#Hello_World" class="headerlink" title="Hello World"></a>Hello World</h1><p>学习一门编程语言的首要任务就是写出 “Hello World” ，那就让我们迈下第一步吧。</p>
<p>activity_main.xml :</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">RelativeLayout</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">xmlns:tools</span>=<span class="value">"http://schemas.android.com/tools"</span></span><br><span class="line">    <span class="attribute">android:id</span>=<span class="value">"@+id/activity_main"</span></span><br><span class="line">    <span class="attribute">android:layout_width</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:layout_height</span>=<span class="value">"match_parent"</span></span><br><span class="line">    <span class="attribute">android:paddingBottom</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingLeft</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingRight</span>=<span class="value">"@dimen/activity_horizontal_margin"</span></span><br><span class="line">    <span class="attribute">android:paddingTop</span>=<span class="value">"@dimen/activity_vertical_margin"</span></span><br><span class="line">    <span class="attribute">tools:context</span>=<span class="value">"me.yuqirong.kotlindemo.MainActivity"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="title">TextView</span></span><br><span class="line">        <span class="attribute">android:id</span>=<span class="value">"@+id/textView"</span></span><br><span class="line">        <span class="attribute">android:layout_width</span>=<span class="value">"wrap_content"</span></span><br><span class="line">        <span class="attribute">android:layout_height</span>=<span class="value">"wrap_content"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">RelativeLayout</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后在 <code>onCreate(savedInstanceState: Bundle?)</code> 去得到 <code>textView</code> 。这里就体现出 Kotlin 的好处了，不再需要 <code>findViewById</code> 。而是先需要在 app/build.gradle 中添加如下配置：</p>
<pre><code>apply plugin: &apos;com.android.application&apos;
apply plugin: &apos;kotlin-android&apos;
// 添加以下这行
apply plugin: &apos;kotlin-android-extensions&apos;

...
</code></pre><p>配置好后，在代码中就可以直接使用了，是不是很方便呢！</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.yuqirong.kotlindemo</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> android.os.Bundle</span><br><span class="line"><span class="keyword">import</span> android.support.v7.app.AppCompatActivity</span><br><span class="line"><span class="keyword">import</span> kotlinx.android.synthetic.main.activity_main.*</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> : <span class="typename">AppCompatActivity</span></span>() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">fun</span> <span class="title">onCreate</span><span class="params">(savedInstanceState: <span class="typename">Bundle?</span>)</span> &#123;</span></span><br><span class="line">        super.onCreate(savedInstanceState)</span><br><span class="line">        setContentView(R.layout.activity_main)</span><br><span class="line">        textView.text = <span class="string">"Hello World"</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下，demo的效果图就是这样滴，不加特效！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170607/20170607231545.png" alt="Demo效果图"></p>
<p>Goodbye ~ ~</p>
<p>Demo下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170607/KotlinDemo.rar" target="_blank" rel="external">KotlinDemo</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="Android_Studio__u914D_u7F6E"><a href="#Android_Studio__u914D_u7F6E" class="headerlink" title="Android Studio 配置"></a>Android Studio ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Kotlin" scheme="http://yuqirong.me/tags/Kotlin/"/>
    
      <category term="Kotlin Blog" scheme="http://yuqirong.me/categories/Kotlin-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[玩转仿探探卡片式滑动效果]]></title>
    <link href="http://yuqirong.me/2017/03/05/%E7%8E%A9%E8%BD%AC%E4%BB%BF%E6%8E%A2%E6%8E%A2%E5%8D%A1%E7%89%87%E5%BC%8F%E6%BB%91%E5%8A%A8%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2017/03/05/玩转仿探探卡片式滑动效果/</id>
    <published>2017-03-05T14:45:22.000Z</published>
    <updated>2017-03-08T15:26:51.789Z</updated>
    <content type="html"><![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的原理肯定和 ListView / RecyclerView 类似，涉及到 Item View 的回收和重用，否则早就因为大量的 Item View 而 OOM 了。</p>
<p>再到后来，看到许多大神也推出了同样仿探探效果的博客，从头到尾阅读下来，写得通俗易懂，基本上没什么问题。于是，实现仿探探效果的想法再次出现在脑海中。那么，还犹豫什么，趁热来一发吧！就这么愉快地决定了。</p>
<p>首先面临的问题就是关于实现 View 上的考虑。毫无疑问，</p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p><strong>RecyclerView 是最佳选择！</strong></p>
<p>重要的话讲三遍！！！</p>
<p>究其原因，第一，RecyclerView 是自带 Item View 回收和重用功能的，就不需要我们考虑这个问题了；第二，RecyclerView 的布局方式是通过设置 LayoutManager 来实现的，这样就充分地把布局和 RecyclerView “解耦”开来了。而 LayoutManager 是可以通过自定义的方式来实现的。这恰恰是我们想要的！！！再说一点，这也正是不选用 ListView 的原因之一。</p>
<p>下面，我们就开始动手了。带你见证奇迹的时刻。</p>
<h2 id="CardLayoutManager"><a href="#CardLayoutManager" class="headerlink" title="CardLayoutManager"></a>CardLayoutManager</h2><p>创建 <code>CardLayoutManager</code> 并继承自 <code>RecyclerView.LayoutManager</code> 。需要我们自己实现 <code>generateDefaultLayoutParams()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="keyword">public</span> RecyclerView.<span class="function">LayoutParams <span class="title">generateDefaultLayoutParams</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RecyclerView.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT, ViewGroup.LayoutParams.WRAP_CONTENT);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一般情况下，像上面这样写即可。</p>
<p>下面这个方法就是我们的重点了。 <code>onLayoutChildren(final RecyclerView.Recycler recycler, RecyclerView.State state)</code> 方法就是用来实现 Item View 布局的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onLayoutChildren</span><span class="params">(<span class="keyword">final</span> RecyclerView.Recycler recycler, RecyclerView.State state)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onLayoutChildren(recycler, state);</span><br><span class="line">    <span class="comment">// 先移除所有view</span></span><br><span class="line">    removeAllViews();</span><br><span class="line">    <span class="comment">// 在布局之前，将所有的子 View 先 Detach 掉，放入到 Scrap 缓存中</span></span><br><span class="line">    detachAndScrapAttachedViews(recycler);</span><br><span class="line">    <span class="keyword">int</span> itemCount = getItemCount();</span><br><span class="line">    <span class="comment">// 在这里，我们默认配置 CardConfig.DEFAULT_SHOW_ITEM = 3。即在屏幕上显示的卡片数为3</span></span><br><span class="line">    <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">    <span class="keyword">if</span> (itemCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">        <span class="comment">// 把数据源倒着循环，这样，第0个数据就在屏幕最上面了</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = CardConfig.DEFAULT_SHOW_ITEM; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            <span class="comment">// 将 Item View 加入到 RecyclerView 中</span></span><br><span class="line">            addView(view);</span><br><span class="line">            <span class="comment">// 测量 Item View</span></span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="comment">// getDecoratedMeasuredWidth(view) 可以得到 Item View 的宽度</span></span><br><span class="line">            <span class="comment">// 所以 widthSpace 就是除了 Item View 剩余的值</span></span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="comment">// 同理</span></span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line">            <span class="comment">// 将 Item View 放入 RecyclerView 中布局</span></span><br><span class="line">            <span class="comment">// 在这里默认布局是放在 RecyclerView 中心</span></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line">            <span class="comment">// 其实屏幕上有四张卡片，但是我们把第三张和第四张卡片重叠在一起，这样看上去就只有三张</span></span><br><span class="line">            <span class="comment">// 第四张卡片主要是为了保持动画的连贯性</span></span><br><span class="line">            <span class="keyword">if</span> (position == CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">                <span class="comment">// 按照一定的规则缩放，并且偏移Y轴。</span></span><br><span class="line">                <span class="comment">// CardConfig.DEFAULT_SCALE 默认为0.1f，CardConfig.DEFAULT_TRANSLATE_Y 默认为14</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - (position - <span class="number">1</span>) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((position - <span class="number">1</span>) * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 设置 mTouchListener 的意义就在于我们想让处于顶层的卡片是可以随意滑动的</span></span><br><span class="line">                <span class="comment">// 而第二层、第三层等等的卡片是禁止滑动的</span></span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当数据源个数小于或等于最大显示数时，和上面的代码差不多</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> position = itemCount - <span class="number">1</span>; position &gt;= <span class="number">0</span>; position--) &#123;</span><br><span class="line">            <span class="keyword">final</span> View view = recycler.getViewForPosition(position);</span><br><span class="line">            addView(view);</span><br><span class="line">            measureChildWithMargins(view, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> widthSpace = getWidth() - getDecoratedMeasuredWidth(view);</span><br><span class="line">            <span class="keyword">int</span> heightSpace = getHeight() - getDecoratedMeasuredHeight(view);</span><br><span class="line"></span><br><span class="line">            layoutDecoratedWithMargins(view, widthSpace / <span class="number">2</span>, heightSpace / <span class="number">2</span>,</span><br><span class="line">                    widthSpace / <span class="number">2</span> + getDecoratedMeasuredWidth(view),</span><br><span class="line">                    heightSpace / <span class="number">2</span> + getDecoratedMeasuredHeight(view));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (position &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - position * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY(position * view.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                view.setOnTouchListener(mOnTouchListener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> View.OnTouchListener mOnTouchListener = <span class="keyword">new</span> View.OnTouchListener() &#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onTouch</span><span class="params">(View v, MotionEvent event)</span> </span>&#123;</span><br><span class="line">        RecyclerView.ViewHolder childViewHolder = mRecyclerView.getChildViewHolder(v);</span><br><span class="line">        <span class="comment">// 把触摸事件交给 mItemTouchHelper，让其处理卡片滑动事件</span></span><br><span class="line">        <span class="keyword">if</span> (MotionEventCompat.getActionMasked(event) == MotionEvent.ACTION_DOWN) &#123;</span><br><span class="line">            mItemTouchHelper.startSwipe(childViewHolder);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>总体来说，<code>CardLayoutManager</code> 主要就是为 Item View 布局，然后根据 <code>position</code> 做相对应的偏差。我们一起来看下完成的效果图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306221018.jpg" alt="layout效果图"></p>
<p>可以看出，大致的效果已经有了。缺少的就是处理触摸滑动事件了。</p>
<h2 id="OnSwipeListener"><a href="#OnSwipeListener" class="headerlink" title="OnSwipeListener"></a>OnSwipeListener</h2><p>在看滑动事件的代码之前，我们先定义一个监听器。主要用于监听卡片滑动事件，代码就如下所示，注释也给出来了。应该都看得懂吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSwipeListener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片还在滑动时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑动卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> ratio      滑动进度的比例</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑动的方向，CardConfig.SWIPING_LEFT 为向左滑，CardConfig.SWIPING_RIGHT 为向右滑，</span><br><span class="line">     *                   CardConfig.SWIPING_NONE 为不偏左也不偏右</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiping</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">float</span> ratio, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 卡片完全滑出时回调</span><br><span class="line">     *</span><br><span class="line">     * <span class="doctag">@param</span> viewHolder 该滑出卡片的viewHolder</span><br><span class="line">     * <span class="doctag">@param</span> t          该滑出卡片的数据</span><br><span class="line">     * <span class="doctag">@param</span> direction  卡片滑出的方向，CardConfig.SWIPED_LEFT 为左边滑出；CardConfig.SWIPED_RIGHT 为右边滑出</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, T t, <span class="keyword">int</span> direction)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 所有的卡片全部滑出时回调</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onSwipedClear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="CardItemTouchHelperCallback"><a href="#CardItemTouchHelperCallback" class="headerlink" title="CardItemTouchHelperCallback"></a>CardItemTouchHelperCallback</h2><p>现在，我们可以回过头来看看卡片滑动了。对于 ItemTouchHelper 来处理 Item View 的触摸滑动事件相必都不陌生吧，如果对这方面不太了解的同学可以看一下我之前的博客：<a href="/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/">《RecyclerView实现拖拽排序和侧滑删除》</a>。</p>
<p>我们暂且命名为 CardItemTouchHelperCallback 。对于 ItemTouchHelper.Callback 而言，需要在 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中配置 <code>swipeFlags</code> 和 <code>dragFlags</code> 。</p>
<p>具体的方法如下，对于 <code>swipeFlags</code> 只关心左右两个方向：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlags = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> swipeFlags = <span class="number">0</span>;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> CardLayoutManager) &#123;</span><br><span class="line">        swipeFlags = ItemTouchHelper.LEFT | ItemTouchHelper.RIGHT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlags, swipeFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点需要注意，前面说过，为了防止第二层和第三层卡片也能滑动，因此我们需要设置 <code>isItemViewSwipeEnabled()</code> 返回 false 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isItemViewSwipeEnabled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接下来，就是去重写 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 和 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法。但是因为在上面我们对于 <code>dragFlags</code> 配置的是 0 ，所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 中直接返回 false 即可。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这样，我们就把目光投向 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 移除之前设置的 onTouchListener, 否则触摸滑动会乱了</span></span><br><span class="line">    viewHolder.itemView.setOnTouchListener(<span class="keyword">null</span>);</span><br><span class="line">    <span class="comment">// 删除相对应的数据	</span></span><br><span class="line">    <span class="keyword">int</span> layoutPosition = viewHolder.getLayoutPosition();</span><br><span class="line">    T remove = dataList.remove(layoutPosition);</span><br><span class="line">    adapter.notifyDataSetChanged();</span><br><span class="line">    <span class="comment">// 卡片滑出后回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mListener.onSwiped(viewHolder, remove, direction == ItemTouchHelper.LEFT ? CardConfig.SWIPED_LEFT : CardConfig.SWIPED_RIGHT);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当没有数据时回调 OnSwipeListener 监听器</span></span><br><span class="line">    <span class="keyword">if</span> (adapter.getItemCount() == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mListener.onSwipedClear();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好后，我们先来看看滑动效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307214251.gif" alt="swipe效果图"></p>
<p>发现还是差了点什么，没错！是缺少了动画。在滑动的过程中我们可以重写 <code>onChildDraw(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,
                            float dX, float dY, int actionState, boolean isCurrentlyActive)</code> 方法来添加动画：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onChildDraw</span><span class="params">(Canvas c, RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder,</span><br><span class="line">                        <span class="keyword">float</span> dX, <span class="keyword">float</span> dY, <span class="keyword">int</span> actionState, <span class="keyword">boolean</span> isCurrentlyActive)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onChildDraw(c, recyclerView, viewHolder, dX, dY, actionState, isCurrentlyActive);</span><br><span class="line">    View itemView = viewHolder.itemView;</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_SWIPE) &#123;</span><br><span class="line">        <span class="comment">// 得到滑动的阀值</span></span><br><span class="line">        <span class="keyword">float</span> ratio = dX / getThreshold(recyclerView, viewHolder);</span><br><span class="line">        <span class="comment">// ratio 最大为 1 或 -1</span></span><br><span class="line">        <span class="keyword">if</span> (ratio &gt; <span class="number">1</span>) &#123;</span><br><span class="line">            ratio = <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ratio &lt; -<span class="number">1</span>) &#123;</span><br><span class="line">            ratio = -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 默认最大的旋转角度为 15 度</span></span><br><span class="line">        itemView.setRotation(ratio * CardConfig.DEFAULT_ROTATE_DEGREE);</span><br><span class="line">        <span class="keyword">int</span> childCount = recyclerView.getChildCount();</span><br><span class="line">        <span class="comment">// 当数据源个数大于最大显示数时</span></span><br><span class="line">        <span class="keyword">if</span> (childCount &gt; CardConfig.DEFAULT_SHOW_ITEM) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">1</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                <span class="comment">// 和之前 onLayoutChildren 是一个意思，不过是做相反的动画</span></span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 当数据源个数小于或等于最大显示数时</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> position = <span class="number">0</span>; position &lt; childCount - <span class="number">1</span>; position++) &#123;</span><br><span class="line">                <span class="keyword">int</span> index = childCount - position - <span class="number">1</span>;</span><br><span class="line">                View view = recyclerView.getChildAt(position);</span><br><span class="line">                view.setScaleX(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setScaleY(<span class="number">1</span> - index * CardConfig.DEFAULT_SCALE + Math.abs(ratio) * CardConfig.DEFAULT_SCALE);</span><br><span class="line">                view.setTranslationY((index - Math.abs(ratio)) * itemView.getMeasuredHeight() / CardConfig.DEFAULT_TRANSLATE_Y);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 回调监听器</span></span><br><span class="line">        <span class="keyword">if</span> (mListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ratio != <span class="number">0</span>) &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, ratio &lt; <span class="number">0</span> ? CardConfig.SWIPING_LEFT : CardConfig.SWIPING_RIGHT);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mListener.onSwiping(viewHolder, ratio, CardConfig.SWIPING_NONE);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">float</span> <span class="title">getThreshold</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recyclerView.getWidth() * getSwipeThreshold(viewHolder);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们加上动画后，来看看效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170307222247.gif" alt="swipe效果图"></p>
<p>发现还是有问题，第一层的卡片滑出去之后第二层的就莫名其妙地偏了。这正是因为 Item View 重用机制“捣鬼”。所以我们应该在 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法中重置一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setRotation(<span class="number">0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大功告成，我们试一下效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170306/20170306234152.gif" alt="swipe效果图"></p>
<p>Perfect !</p>
<p>这正是我们梦寐以求的效果。我们终于实现了！！！</p>
<p>总结一下，在这整个代码流程中我们主要是运用了自定义 LayoutManager 以及 ItemTouchHelper.Callback 。总体来说还是比较简单的，相信你已经会啦。</p>
<p>Goodbye ~~</p>
<p>最后，放上 GitHub 地址：<a href="https://github.com/yuqirong/CardSwipeLayout" target="_blank" rel="external">yuqirong/CardSwipeLayout</a></p>
<p>喜欢的可以来一波 star 哦。@^_^@</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>讲起本篇博客的历史起源，估计有一段“历史”了。</p>
<p>最早可以追溯到我试玩探探这个 APP 。第一次进入软件界面，就被这种通过卡片式滑动来选择“喜欢/不喜欢”的设计所吸引了。当时就非常想通过自己来实现这种仿探探式的效果，然而却没什么思路。不过毋庸置疑的是，这种效果的]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[android-architecture之todo-mvp源码分析]]></title>
    <link href="http://yuqirong.me/2017/02/22/android-architecture%E4%B9%8Btodo-mvp%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    <id>http://yuqirong.me/2017/02/22/android-architecture之todo-mvp源码分析/</id>
    <published>2017-02-22T13:08:02.000Z</published>
    <updated>2017-02-28T15:09:06.682Z</updated>
    <content type="html"><![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 下半年来，MVP 渐渐崛起成为了现在普遍流行的架构模式。但是各种不同实现方式的 MVP 架构层出不穷，也让新手不知所措。而 Google 作为“老大哥”，针对此现象为 Android 架构做出了“规范示例”：<a href="https://github.com/googlesamples/android-architecture" target="_blank" rel="external">android-architecture</a> 。 </p>
<p>目前已有的架构示例如下图所示：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170222230352.png" alt="stable sample"></p>
<p>而今天给大家带来的就是分析 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目的架构。那就快进入正题吧！</p>
<h1 id="todo-mvp"><a href="#todo-mvp" class="headerlink" title="todo-mvp"></a>todo-mvp</h1><p>先来看看项目包的目录结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227212108.png" alt="目录结构"></p>
<p>基本上目录结构可以分为四种：</p>
<ol>
<li>addedittask、statistics、taskdetail、tasks ：可以看出在 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 项目中是按功能来分包的，这些包中的结构都是一致的，待会我们只需要分析其中一个包即可；</li>
<li>data ：该分包下主要是数据层的代码，即 MVP 中的 Model 层；</li>
<li>util ：工具类包，在这里就不展开细讲了；</li>
<li>BaseView、BasePresenter ：MVP 中 View 和 Presenter 的基类。</li>
</ol>
<p>然后是官方给出的 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170228224356.png" alt="MVP"></p>
<h2 id="BaseView__u548C_BasePresenter"><a href="#BaseView__u548C_BasePresenter" class="headerlink" title="BaseView 和 BasePresenter"></a>BaseView 和 BasePresenter</h2><p>这里就先看一下 BaseView 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BaseView</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setPresenter</span><span class="params">(T presenter)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BaseView 是一个泛型接口，里面只有一个抽象方法 <code>setPresenter(T presenter)</code> ，用来设置 Presenter 。</p>
<p>然后是 BasePresenter 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>BasePresenter 接口也只有一个抽象方法 <code>start()</code> ，用于在 Activity/Fragment 的 <code>onResume()</code> 方法中调用。</p>
<h2 id="addedittask_u3001statistics_u3001taskdetail_u3001tasks"><a href="#addedittask_u3001statistics_u3001taskdetail_u3001tasks" class="headerlink" title="addedittask、statistics、taskdetail、tasks"></a>addedittask、statistics、taskdetail、tasks</h2><p>这四个分包从结构上来讲都是一样的，那么在这里我们就分析 tasks 这个分包吧。下面是该分包下的源码文件：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170222/20170227215628.png" alt="task分包的结构"></p>
<p>我们以 <code>TasksContract</code> 为切入点：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TasksContract</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">View</span> <span class="keyword">extends</span> <span class="title">BaseView</span>&lt;<span class="title">Presenter</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">setLoadingIndicator</span><span class="params">(<span class="keyword">boolean</span> active)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTasks</span><span class="params">(List&lt;Task&gt; tasks)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showAddTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">showTaskDetailsUi</span><span class="params">(String taskId)</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">interface</span> <span class="title">Presenter</span> <span class="keyword">extends</span> <span class="title">BasePresenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">result</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">loadTasks</span><span class="params">(<span class="keyword">boolean</span> forceUpdate)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">addNewTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原来 <code>TasksContract</code> 接口其实就是用来定义 <code>View</code> 和 <code>Presenter</code> 的。 <code>View</code> 和 <code>Presenter</code> 继承了 <code>BaseView</code> 和 <code>BasePresenter</code> 。再回头看看上面的 <code>TaskPresenter</code> ，想必大家都猜到了，肯定是继承了 <code>Presenter</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksPresenter</span> <span class="keyword">implements</span> <span class="title">TasksContract</span>.<span class="title">Presenter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksRepository mTasksRepository;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksContract.View mTasksView;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TasksPresenter</span><span class="params">(@NonNull TasksRepository tasksRepository, @NonNull TasksContract.View tasksView)</span> </span>&#123;</span><br><span class="line">        mTasksRepository = checkNotNull(tasksRepository, <span class="string">"tasksRepository cannot be null"</span>);</span><br><span class="line">        mTasksView = checkNotNull(tasksView, <span class="string">"tasksView cannot be null!"</span>);</span><br><span class="line"></span><br><span class="line">        mTasksView.setPresenter(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        loadTasks(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>TasksPresenter</code> 的构造方法中把 <code>tasksRepository</code> 和 <code>tasksView</code> 传入，并且把 <code>TasksPresenter</code> 对象设置给了 <code>mTasksView</code> 。这样，Presenter 就实现了 Model 和 View 的解耦。</p>
<h2 id="data"><a href="#data" class="headerlink" title="data"></a>data</h2><p>data 代表了 MVP 中的 Model 。我们根据上面出现过的 <code>TasksRepository</code> 来分析。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TasksRepository</span> <span class="keyword">implements</span> <span class="title">TasksDataSource</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> TasksRepository INSTANCE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksRemoteDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> TasksDataSource mTasksLocalDataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">TasksRepository</span><span class="params">(@NonNull TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                            @NonNull TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        mTasksRemoteDataSource = checkNotNull(tasksRemoteDataSource);</span><br><span class="line">        mTasksLocalDataSource = checkNotNull(tasksLocalDataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> TasksRepository <span class="title">getInstance</span><span class="params">(TasksDataSource tasksRemoteDataSource,</span><br><span class="line">                                              TasksDataSource tasksLocalDataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (INSTANCE == <span class="keyword">null</span>) &#123;</span><br><span class="line">            INSTANCE = <span class="keyword">new</span> TasksRepository(tasksRemoteDataSource, tasksLocalDataSource);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>TasksRepository</code> 实现了 <code>TasksDataSource</code> 接口，<code>TasksDataSource</code> 接口定义了一些对 <code>Task</code> 的增删改查操作。在 <code>TasksRepository</code> 的构造方法中传入两个 <code>TasksDataSource</code> 对象，其实是模拟了本地数据存储和网络数据存储两种方式。至于其他的就不详细展开了，无非就是对数据读写之类的操作。</p>
<h1 id="End"><a href="#End" class="headerlink" title="End"></a>End</h1><p>到这里，基本上把 <a href="https://github.com/googlesamples/android-architecture/tree/todo-mvp/" target="_blank" rel="external">todo-mvp</a> 架构的代码大致地讲了一遍。本篇博客就不对其他的代码展开分析了，因为我们注重的是该项目中的 MVP 架构实现方式。另外，todo 系列还有其他几种 MVP 实现的方式，只能下次有空再讲了。</p>
<p>就到这吧，Goodbye !</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>Android 架构一直都是热门话题，从一开始的 MVC ，到目前火爆的 MVP ，再到方兴未艾的 MVVM 。并不能说哪一种架构最好，因为这些架构都顺应了当时开发的趋势。在这里就不对这三个架构一一解释了，如果想要了解更多的同学可以自行搜索。</p>
<p>自从 2015 ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android架构" scheme="http://yuqirong.me/tags/Android%E6%9E%B6%E6%9E%84/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[NotificationListenerService的那些事儿]]></title>
    <link href="http://yuqirong.me/2017/02/09/NotificationListenerService%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B%E5%84%BF/"/>
    <id>http://yuqirong.me/2017/02/09/NotificationListenerService的那些事儿/</id>
    <published>2017-02-09T13:00:04.000Z</published>
    <updated>2017-02-11T03:19:31.471Z</updated>
    <content type="html"><![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</code> 支持的事件监听类型中有 <code>TYPE_NOTIFICATION_STATE_CHANGED</code> ，该事件类型就是用来监听通知栏消息状态改变的，众多的抢红包插件利用的就是这个原理。</p>
<p>之后在 Github 上看到了 <a href="https://github.com/lendylongli/qianghongbao" target="_blank" rel="external">qianghongbao</a> 这个抢红包的项目，发现代码里面有一个 <a href="https://github.com/lendylongli/qianghongbao/blob/master/app/src/main/java/com/codeboy/qianghongbao/QHBNotificationService.java" target="_blank" rel="external">QHBNotificationService</a> 继承了 <code>NotificationListenerService</code> ，这个 <code>NotificationListenerService</code> 极大地引起了我的兴趣。查了一下资料，发现 <code>NotificationListenerService</code> 是在 Android 4.3 （API 18）时被加入的，作用就是用来监听通知栏消息。并且官方建议在 Android 4.3 及以上使用 <code>NotificationListenerService</code> 来监听通知栏消息，以此取代 <code>AccessibilityService</code> 。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170209/20170209220914.png" alt="Notification Listener"></p>
<p><code>NotificationListenerService</code> 的使用范围也挺广的，比如我们熟知的抢红包，智能手表同步通知，通知栏去广告工具等，都是利用它来完成的。所以，我也想赶时髦地好好利用这把“利器”。最后方案也就出来了：在 Android 4.3 以下（API &lt; 18）使用 <code>AccessibilityService</code> 来读取新通知，在 Android 4.3 及以上（API &gt;= 18）使用 <code>NotificationListenerService</code> 来满足需求。</p>
<p>这也正是本篇博客诞生的“起源”。</p>
<h1 id="NotificationListenerService"><a href="#NotificationListenerService" class="headerlink" title="NotificationListenerService"></a>NotificationListenerService</h1><p>在这里，我们就做一个小需求：实时检测微信的新通知，如果该通知是微信红包的话，就进入微信聊天页面。</p>
<p>准备好了吗，我们开始吧！</p>
<p>首先创建一个 <code>WeChatNotificationListenerService</code> 继承 <code>NotificationListenerService</code> 。然后在 <code>AndroidManifest.xml</code> 中进行声明相关权限和 <code>&lt;intent-filter&gt;</code> ：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="title">service</span> <span class="attribute">android:name</span>=<span class="value">"com.yuqirong.listenwechatnotification.WeChatNotificationListenerService"</span></span><br><span class="line">          <span class="attribute">android:label</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">          <span class="attribute">android:permission</span>=<span class="value">"android.permission.BIND_NOTIFICATION_LISTENER_SERVICE"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="title">intent-filter</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="title">action</span> <span class="attribute">android:name</span>=<span class="value">"android.service.notification.NotificationListenerService"</span> /&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="title">intent-filter</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="title">service</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>然后一般会重写下面这三个方法：</p>
<ul>
<li><code>onNotificationPosted(StatusBarNotification sbn)</code> ：当有新通知到来时会回调；</li>
<li><code>onNotificationRemoved(StatusBarNotification sbn)</code> ：当有通知移除时会回调；</li>
<li><code>onListenerConnected()</code> ：当 <code>NotificationListenerService</code> 是可用的并且和通知管理器连接成功时回调。</li>
</ul>
<h2 id="onNotificationPosted_28StatusBarNotification_sbn_29"><a href="#onNotificationPosted_28StatusBarNotification_sbn_29" class="headerlink" title="onNotificationPosted(StatusBarNotification sbn)"></a>onNotificationPosted(StatusBarNotification sbn)</h2><p>下面我们来看看 <code>NotificationListenerService</code> 中的重点： <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNotificationPosted</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该通知的包名不是微信，那么 pass 掉</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="string">"com.tencent.mm"</span>.equals(sbn.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Notification notification = sbn.getNotification();</span><br><span class="line">    <span class="keyword">if</span> (notification == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    PendingIntent pendingIntent = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 当 API &gt; 18 时，使用 extras 获取通知的详细信息</span></span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">        Bundle extras = notification.extras;</span><br><span class="line">        <span class="keyword">if</span> (extras != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 获取通知标题</span></span><br><span class="line">            String title = extras.getString(Notification.EXTRA_TITLE, <span class="string">""</span>);</span><br><span class="line">            <span class="comment">// 获取通知内容</span></span><br><span class="line">            String content = extras.getString(Notification.EXTRA_TEXT, <span class="string">""</span>);</span><br><span class="line">            <span class="keyword">if</span> (!TextUtils.isEmpty(content) &amp;&amp; content.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                pendingIntent = notification.contentIntent;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 当 API = 18 时，利用反射获取内容字段</span></span><br><span class="line">        List&lt;String&gt; textList = getText(notification);</span><br><span class="line">        <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp; text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                    pendingIntent = notification.contentIntent;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 发送 pendingIntent 以此打开微信</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            pendingIntent.send();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可知，对于分析 <code>Notification</code> 的内容分为了两种：</p>
<ul>
<li>当 API &gt; 18 时，利用 <code>Notification.extras</code> 来获取通知内容。<code>extras</code> 是在 API 19 时被加入的；</li>
<li>当 API = 18 时，利用反射获取 <code>Notification</code> 中的内容。具体的代码在下方。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;String&gt; <span class="title">getText</span><span class="params">(Notification notification)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">null</span> == notification) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RemoteViews views = notification.bigContentView;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        views = notification.contentView;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (views == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Use reflection to examine the m_actions member of the given RemoteViews object.</span></span><br><span class="line">    <span class="comment">// It's not pretty, but it works.</span></span><br><span class="line">    List&lt;String&gt; text = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Field field = views.getClass().getDeclaredField(<span class="string">"mActions"</span>);</span><br><span class="line">        field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        ArrayList&lt;Parcelable&gt; actions = (ArrayList&lt;Parcelable&gt;) field.get(views);</span><br><span class="line">        <span class="comment">// Find the setText() and setTime() reflection actions</span></span><br><span class="line">        <span class="keyword">for</span> (Parcelable p : actions) &#123;</span><br><span class="line">            Parcel parcel = Parcel.obtain();</span><br><span class="line">            p.writeToParcel(parcel, <span class="number">0</span>);</span><br><span class="line">            parcel.setDataPosition(<span class="number">0</span>);</span><br><span class="line">            <span class="comment">// The tag tells which type of action it is (2 is ReflectionAction, from the source)</span></span><br><span class="line">            <span class="keyword">int</span> tag = parcel.readInt();</span><br><span class="line">            <span class="keyword">if</span> (tag != <span class="number">2</span>) <span class="keyword">continue</span>;</span><br><span class="line">            <span class="comment">// View ID</span></span><br><span class="line">            parcel.readInt();</span><br><span class="line">            String methodName = parcel.readString();</span><br><span class="line">            <span class="keyword">if</span> (<span class="keyword">null</span> == methodName) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (methodName.equals(<span class="string">"setText"</span>)) &#123;</span><br><span class="line">                <span class="comment">// Parameter type (10 = Character Sequence)</span></span><br><span class="line">                parcel.readInt();</span><br><span class="line">                <span class="comment">// Store the actual string</span></span><br><span class="line">                String t = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(parcel).toString().trim();</span><br><span class="line">                text.add(t);</span><br><span class="line">            &#125;</span><br><span class="line">            parcel.recycle();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> text;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>凭着 <code>onNotificationPosted(StatusBarNotification sbn)</code> 方法就已经可以完成监听微信通知并打开的动作了。下面我们来看一下其他关于 <code>NotificationListenerService</code> 的二三事。</p>
<h2 id="u53D6_u6D88_u901A_u77E5"><a href="#u53D6_u6D88_u901A_u77E5" class="headerlink" title="取消通知"></a>取消通知</h2><p>有了监听，<code>NotificationListenerService</code> 自然提供了可以取消通知的方法。取消通知的方法有：</p>
<ul>
<li><code>cancelNotification(String key)</code> ：是 API &gt;= 21 才可以使用的。利用 <code>StatusBarNotification</code> 的 <code>getKey()</code> 方法来获取 <code>key</code> 并取消通知。</li>
<li><code>cancelNotification(String pkg, String tag, int id)</code> ：在 API &lt; 21 时可以使用，在 API &gt;= 21 时使用此方法来取消通知将无效，被废弃。</li>
</ul>
<p>最后，取消通知的方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cancelNotification</span><span class="params">(StatusBarNotification sbn)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) &#123;</span><br><span class="line">        cancelNotification(sbn.getKey());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        cancelNotification(sbn.getPackageName(), sbn.getTag(), sbn.getId());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743"><a href="#u68C0_u6D4B_u901A_u77E5_u76D1_u542C_u670D_u52A1_u662F_u5426_u88AB_u6388_u6743" class="headerlink" title="检测通知监听服务是否被授权"></a>检测通知监听服务是否被授权</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isNotificationListenerEnabled</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    Set&lt;String&gt; packageNames = NotificationManagerCompat.getEnabledListenerPackages(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">if</span> (packageNames.contains(context.getPackageName())) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762"><a href="#u6253_u5F00_u901A_u77E5_u76D1_u542C_u8BBE_u7F6E_u9875_u9762" class="headerlink" title="打开通知监听设置页面"></a>打开通知监听设置页面</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">openNotificationListenSettings</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Intent intent;</span><br><span class="line">        <span class="keyword">if</span> (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP_MR1) &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(Settings.ACTION_NOTIFICATION_LISTENER_SETTINGS);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            intent = <span class="keyword">new</span> Intent(<span class="string">"android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        startActivity(intent);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898"><a href="#u88AB_u6740_u540E_u518D_u6B21_u542F_u52A8_u65F6_uFF0C_u76D1_u542C_u4E0D_u751F_u6548_u7684_u95EE_u9898" class="headerlink" title="被杀后再次启动时，监听不生效的问题"></a>被杀后再次启动时，监听不生效的问题</h2><p>这个问题来源于知乎问题： <a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></p>
<p>从问题的回答中可以了解到，是因为 <code>NotificationListenerService</code> 被杀后再次启动时，并没有去 <code>bindService</code> ，所以导致监听效果无效。</p>
<p>最后，在回答中还给出了解决方案：利用 <code>NotificationListenerService</code> 先 disable 再 enable ，重新触发系统的 rebind 操作。代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">toggleNotificationListenerService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PackageManager pm = getPackageManager();</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_DISABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">    pm.setComponentEnabledSetting(<span class="keyword">new</span> ComponentName(<span class="keyword">this</span>, com.fanwei.alipaynotification.ui.AlipayNotificationListenerService.class),</span><br><span class="line">            PackageManager.COMPONENT_ENABLED_STATE_ENABLED, PackageManager.DONT_KILL_APP);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该方法使用前提是 <code>NotificationListenerService</code> 已经被用户授予了权限，否则无效。另外，在自己的小米手机上实测，重新完成 rebind 操作需要等待 10 多秒（我的手机测试过大概在 13 秒左右）。幸运的是，官方也已经发现了这个问题，在 API 24 中提供了 <code>requestRebind(ComponentName componentName)</code> 方法来支持重新绑定。</p>
<h1 id="AccessibilityService"><a href="#AccessibilityService" class="headerlink" title="AccessibilityService"></a>AccessibilityService</h1><p>讲完了 <code>NotificationListenerService</code> 之后，按照前面说的那样，在 API &lt; 18 的时候使用 <code>AccessibilityService</code> 。</p>
<p>同样，创建一个 <code>WeChatAccessibilityService</code> ，并且在 <code>AndroidManifest.xml</code> 中进行声明：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;service</span><br><span class="line">    android:name="com.yuqirong.listenwechatnotification.WeChatAccessibilityService"</span><br><span class="line">    android:label="@string/app_name"</span><br><span class="line">    android:permission="android.permission.BIND_ACCESSIBILITY_SERVICE"&gt;</span><br><span class="line">    &lt;intent-filter&gt;</span><br><span class="line">        &lt;action android:name="android.accessibilityservice.AccessibilityService" /&gt;</span><br><span class="line">    &lt;/intent-filter&gt;</span><br><span class="line">    &lt;meta-data</span><br><span class="line">        android:name="android.accessibilityservice"</span><br><span class="line">        android:resource="@xml/accessible_service_config" /&gt;</span><br><span class="line">&lt;/service&gt;</span><br></pre></td></tr></table></figure>
<p>声明之后，还要对 <code>WeChatAccessibilityService</code> 进行配置。需要在 res 目录下新建一个 xml 文件夹，在里面新建一个 accessible_service_config.xml 文件：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="pi">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="title">accessibility-service</span> <span class="attribute">xmlns:android</span>=<span class="value">"http://schemas.android.com/apk/res/android"</span></span><br><span class="line">    <span class="attribute">android:accessibilityEventTypes</span>=<span class="value">"typeNotificationStateChanged"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFeedbackType</span>=<span class="value">"feedbackAllMask"</span></span><br><span class="line">    <span class="attribute">android:accessibilityFlags</span>=<span class="value">"flagIncludeNotImportantViews"</span></span><br><span class="line">    <span class="attribute">android:canRetrieveWindowContent</span>=<span class="value">"true"</span></span><br><span class="line">    <span class="attribute">android:description</span>=<span class="value">"@string/app_name"</span></span><br><span class="line">    <span class="attribute">android:notificationTimeout</span>=<span class="value">"100"</span></span><br><span class="line">    <span class="attribute">android:packageNames</span>=<span class="value">"com.tencent.mm"</span> /&gt;</span></span><br></pre></td></tr></table></figure>
<p>最后就是代码了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WeChatAccessibilityService</span> <span class="keyword">extends</span> <span class="title">AccessibilityService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAccessibilityEvent</span><span class="params">(AccessibilityEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &lt; <span class="number">18</span>) &#123;</span><br><span class="line">            Notification notification = (Notification) event.getParcelableData();</span><br><span class="line">            List&lt;String&gt; textList = getText(notification);</span><br><span class="line">            <span class="keyword">if</span> (textList != <span class="keyword">null</span> &amp;&amp; textList.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (String text : textList) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!TextUtils.isEmpty(text) &amp;&amp;</span><br><span class="line">                            text.contains(<span class="string">"[微信红包]"</span>)) &#123;</span><br><span class="line">                        <span class="keyword">final</span> PendingIntent pendingIntent = notification.contentIntent;</span><br><span class="line">                        <span class="keyword">try</span> &#123;</span><br><span class="line">                            <span class="keyword">if</span> (pendingIntent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                pendingIntent.send();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">catch</span> (PendingIntent.CanceledException e) &#123;</span><br><span class="line">                            e.printStackTrace();</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看了一圈 <code>WeChatAccessibilityService</code> 的代码，发现和 <code>WeChatNotificationListenerService</code> 在 API &lt; 18 时处理的逻辑是一样的，<code>getText(notification)</code> 方法就是上面那个，在这里就不复制粘贴了，基本没什么好讲的了。</p>
<p>有了 <code>WeChatAccessibilityService</code> 之后，在 API &lt; 18 的情况下也能监听通知啦。\(^ο^)/</p>
<p>我们终于实现了当初许下的那个需求了。 cry …</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>除了监听通知之外，<code>AccessibilityService</code> 还可以进行模拟点击、检测界面变化等功能。具体的可以在 GitHub 上搜索抢红包有关的 Repo 进行深入学习。</p>
<p>而 <code>NotificationListenerService</code> 的监听通知功能更加强大，也更加专业。在一些设备上，如果 <code>NotificationListenerService</code> 被授予了权限，那么可以做到该监听进程不死的效果，也算是另类的进程保活。</p>
<p>今天就到这儿了，拜拜！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170209/ListenWeChatNotification.rar" target="_blank" rel="external">ListenWeChatNotification.rar</a></p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/about/versions/android-4.3.html#NotificationListener" target="_blank" rel="external">Android 4.3 APIs</a></li>
<li><a href="https://developer.android.google.cn/reference/android/service/notification/NotificationListenerService.html" target="_blank" rel="external">NotificationListenerService</a></li>
<li><a href="https://www.zhihu.com/question/33540416" target="_blank" rel="external">NotificationListenerService不能监听到通知，研究了一天不知道是什么原因？</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在公司时接到一个需求：需要实时监听设备的通知栏消息，并可以捕获到通知的内容，然后进行对应的操作。刚看到这个需求的时候，脑子里第一反应就是使用 <code>AccessibilityService</code> 。 <code>AccessibilityService</]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[RecyclerView实现拖拽排序和侧滑删除]]></title>
    <link href="http://yuqirong.me/2017/02/03/RecyclerView%E5%AE%9E%E7%8E%B0%E6%8B%96%E6%8B%BD%E6%8E%92%E5%BA%8F%E5%92%8C%E4%BE%A7%E6%BB%91%E5%88%A0%E9%99%A4/"/>
    <id>http://yuqirong.me/2017/02/03/RecyclerView实现拖拽排序和侧滑删除/</id>
    <published>2017-02-03T07:23:59.000Z</published>
    <updated>2017-02-06T15:00:50.672Z</updated>
    <content type="html"><![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提供了相应的功能。</p>
<p>接下来，我们就来看一下怎么用系统 API 来实现排序和删除的效果。</p>
<h2 id="u521B_u5EFA_ItemTouchHelper"><a href="#u521B_u5EFA_ItemTouchHelper" class="headerlink" title="创建 ItemTouchHelper"></a>创建 ItemTouchHelper</h2><p>创建一个 <code>ItemTouchHelper</code> 对象，然后其调用 <code>attachToRecyclerView</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RecyclerView recyclerView = (RecyclerView) findViewById(R.id.recyclerView);</span><br><span class="line">recyclerView.setLayoutManager(<span class="keyword">new</span> LinearLayoutManager(<span class="keyword">this</span>, LinearLayoutManager.VERTICAL, <span class="keyword">false</span>));</span><br><span class="line">RecyclerViewAdapter adapter = <span class="keyword">new</span> RecyclerViewAdapter();</span><br><span class="line">ItemTouchHelper helper = <span class="keyword">new</span> ItemTouchHelper(<span class="keyword">new</span> MyItemTouchCallback(adapter));</span><br><span class="line">helper.attachToRecyclerView(recyclerView);</span><br></pre></td></tr></table></figure>
<p>在创建 <code>ItemTouchHelper</code> 对象时候，需要我们传入一个实现了 <code>ItemTouchHelper.Callback</code> 接口的对象。而排序和删除的逻辑都封装在了这个 <code>ItemTouchHelper.Callback</code> 的对象里面了。</p>
<h2 id="u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3"><a href="#u5B9E_u73B0_ItemTouchHelper-Callback__u63A5_u53E3" class="headerlink" title="实现 ItemTouchHelper.Callback 接口"></a>实现 ItemTouchHelper.Callback 接口</h2><p>创建 <code>MyItemTouchCallback</code> 类，实现 <code>ItemTouchHelper.Callback</code> 接口：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyItemTouchCallback</span> <span class="keyword">extends</span> <span class="title">ItemTouchHelper</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> RecyclerViewAdapter adapter;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyItemTouchCallback</span><span class="params">(RecyclerViewAdapter adapter)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adapter = adapter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSwiped</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> direction)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实现 <code>ItemTouchHelper.Callback</code> 接口后有三个方法需要重写：</p>
<ol>
<li><code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> ：设置滑动类型的标记。需要设置两种类型的 flag ，即 <code>dragFlags</code> 和 <code>swipeFlags</code> ，分别代表着拖拽标记和滑动标记。最后需要调用 <code>makeMovementFlags(dragFlags, swipeFlags)</code> 方法来合成返回。</li>
<li><code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> ：当用户拖拽列表某个 item 时会回调。很明显，拖拽排序的代码应该在这个方法中实现。</li>
<li><code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> ：当用户滑动列表某个 item 时会回调。所以侧滑删除的代码应该在这个方法中实现。</li>
</ol>
<h2 id="u91CD_u5199_u65B9_u6CD5"><a href="#u91CD_u5199_u65B9_u6CD5" class="headerlink" title="重写方法"></a>重写方法</h2><p>我们先来看看 <code>getMovementFlags(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMovementFlags</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dragFlag;</span><br><span class="line">    <span class="keyword">int</span> swipeFlag;</span><br><span class="line">    RecyclerView.LayoutManager layoutManager = recyclerView.getLayoutManager();</span><br><span class="line">    <span class="keyword">if</span> (layoutManager <span class="keyword">instanceof</span> GridLayoutManager) &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP</span><br><span class="line">                | ItemTouchHelper.RIGHT | ItemTouchHelper.LEFT;</span><br><span class="line">        swipeFlag = <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        dragFlag = ItemTouchHelper.DOWN | ItemTouchHelper.UP;</span><br><span class="line">        swipeFlag = ItemTouchHelper.END;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> makeMovementFlags(dragFlag, swipeFlag);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中根据 <code>layoutManager</code> 分为了两种情况：</p>
<ol>
<li>如果是 <code>GridLayoutManager</code> ，那么拖拽排序就可以细分为上下左右四个方向了，而且 <code>GridLayoutManager</code> 没有侧滑删除的功能；</li>
<li>若是其他的 <code>LayoutManager</code> ，比如说 <code>LinearLayoutManager</code> ，那么拖拽排序就只有上下两个方向了，并且设置 <code>swipeFlag</code> 为 <code>ItemTouchHelper.END</code> 类型；</li>
<li>对于其他自定义类型的 <code>LayoutManager</code> 可以自己根据自身情况补充。</li>
</ol>
<p>下面就是 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">onMove</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fromPosition = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">int</span> toPosition = target.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (fromPosition &lt; toPosition) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &lt; toPosition; i++) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = fromPosition; i &gt; toPosition; i--) &#123;</span><br><span class="line">            Collections.swap(adapter.getDataList(), i, i - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    recyclerView.getAdapter().notifyItemMoved(fromPosition, toPosition);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>之前说过了，<code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法是用户在拖拽 item 的时候会回调。所以关于列表排序的代码应该写在这里。方法参数中的 <code>viewHolder</code> 代表的是用户当前拖拽的 item ，而 <code>target</code> 代表的是被用户拖拽所覆盖的那个 item 。所以在 <code>onMove(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder, RecyclerView.ViewHolder target)</code> 方法中的逻辑就是把 <code>fromPosition</code> 至 <code>toPosition</code> 为止改变它们的位置。</p>
<p>最后就是 <code>onSwiped(RecyclerView.ViewHolder viewHolder, int direction)</code> 方法了：</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> void onSwiped(RecyclerView.ViewHolder viewHolder, <span class="built_in">int</span> direction) &#123;</span><br><span class="line">    <span class="built_in">int</span> <span class="keyword">position</span> = viewHolder.getAdapterPosition();</span><br><span class="line">    <span class="keyword">if</span> (direction == ItemTouchHelper.<span class="keyword">END</span>) &#123;</span><br><span class="line">        adapter.getDataList().remove(<span class="keyword">position</span>);</span><br><span class="line">        adapter.notifyItemRemoved(<span class="keyword">position</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个方法在用户进行侧滑删除操作的时候会回调，其中的逻辑就是得到当前用户进行侧滑删除操作的 item ，然后将其删除。</p>
<p>到了这里，大功告成了。那么来看看效果吧：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170206222813.gif" alt="效果图"></p>
<h2 id="u6539_u5584_u7528_u6237_u4F53_u9A8C"><a href="#u6539_u5584_u7528_u6237_u4F53_u9A8C" class="headerlink" title="改善用户体验"></a>改善用户体验</h2><p>我们发现还有一些不完美的地方：比如当用户在拖拽排序的时候，可以改变当前拖拽 item 的透明度，这样就可以和其他 item 区分开来了。那么，我们需要去重写 <code>onSelectedChanged(RecyclerView.ViewHolder viewHolder, int actionState)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSelectedChanged</span><span class="params">(RecyclerView.ViewHolder viewHolder, <span class="keyword">int</span> actionState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onSelectedChanged(viewHolder, actionState);</span><br><span class="line">    <span class="keyword">if</span> (actionState == ItemTouchHelper.ACTION_STATE_DRAG) &#123;</span><br><span class="line">        viewHolder.itemView.setBackgroundColor(Color.BLUE);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相对应地，当用户手指从拖拽 item 中抬起的时候，我们需要把 item 的透明度复原。需要我们重写 <code>clearView(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clearView</span><span class="params">(RecyclerView recyclerView, RecyclerView.ViewHolder viewHolder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.clearView(recyclerView, viewHolder);</span><br><span class="line">    viewHolder.itemView.setBackgroundColor(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了，来看看改进之后的效果：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170206/20170203223341.gif" alt="改进效果图"></p>
<p>今天就这样吧，拜拜啦！！</p>
<p>源码下载：<a href="http://ofytl4mzu.bkt.clouddn.com/20170206/TestRV.rar" target="_blank" rel="external">TestRV.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在平时开发应用的时候，经常会遇到列表排序、滑动删除的需求。如果列表效果采用的是 <code>ListView</code> 的话，需要经过自定义 View 才能实现效果；但是如果采用的是 <code>RecyclerView</code> 的话，系统 API 就已经为我们提]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="RecyclerView" scheme="http://yuqirong.me/tags/RecyclerView/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于使用AlarmManager的注意事项]]></title>
    <link href="http://yuqirong.me/2017/01/21/%E5%85%B3%E4%BA%8E%E4%BD%BF%E7%94%A8AlarmManager%E7%9A%84%E6%B3%A8%E6%84%8F%E4%BA%8B%E9%A1%B9/"/>
    <id>http://yuqirong.me/2017/01/21/关于使用AlarmManager的注意事项/</id>
    <published>2017-01-21T15:25:16.000Z</published>
    <updated>2017-01-23T15:34:02.880Z</updated>
    <content type="html"><![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任务，比如设置闹铃、发送心跳包等。也许有人会有疑问：为什么不能使用相同具有定时效果的 <code>Timer</code> 和 <code>Handler</code> 呢？</p>
<p>其实答案非常简单，相对于 <code>Handler</code> 来说，使用 <code>sendEmptyMessageDelayed</code> 方法是依赖于 <code>Handler</code> 所在的线程的，如果线程结束，就起不到定时任务的效果；而 <code>AlarmManager</code> 依赖的是 Android 系统的服务，具备唤醒机制。比起 <code>Handler</code> 也就更合适了。</p>
<p>而至于 <code>Timer</code> 可以精确地做到定时操作，但是相比于 <code>AlarmManager</code> 而言还是差了一截。同理，如果手机关屏后长时间不使用， CPU 就会进入休眠模式。这个使用如果使用 <code>Timer</code> 来执行定时任务就会失败，因为 <code>Timer</code> 无法唤醒 CPU 。</p>
<p>所以，综上所述，<code>AlarmManager</code> 就成为了最佳选择。</p>
<h1 id="SDK_API__26lt_3B_19"><a href="#SDK_API__26lt_3B_19" class="headerlink" title="SDK API &lt; 19"></a>SDK API &lt; 19</h1><p>一般情况下，使用 <code>AlarmManager</code> 来执行重复定时任务的代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p>或者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alarmManager.setRepeating(AlarmManager.RTC_WAKEUP, System.currentTimeMillis(), TIME_INTERVAL, pendingIntent);</span><br></pre></td></tr></table></figure>
<p><code>setRepeating</code> 该方法用于设置重复定时任务。</p>
<ul>
<li>第一个参数表示闹钟类型：一般为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> 或者 <code>AlarmManager.RTC_WAKEUP</code> 。它们之间的区别就是前者是从手机开机后的时间，包含了手机睡眠时间；而后者使用的就是手机系统设置中的时间。所以如果设置为 <code>AlarmManager.RTC_WAKEUP</code> ，那么可以通过修改手机系统的时间来提前触发定时事件。另外，对于相似的 <code>AlarmManager.ELAPSED_REALTIME</code> 和 <code>AlarmManager.RTC</code> 来说，它们不会唤醒 CPU 。所以使用的频率较少；</li>
<li>第二个参数表示任务首次执行时间：与第一个参数密切相关。第一个参数若为 <code>AlarmManager.ELAPSED_REALTIME_WAKEUP</code> ，那么当前时间就为 <code>SystemClock.elapsedRealtime()</code> ；若为 <code>AlarmManager.RTC_WAKEUP</code> ，那么当前时间就为 <code>System.currentTimeMillis()</code> ；</li>
<li>第三个参数表示两次执行的间隔时间：这个参数没什么好讲的，一般为常量；</li>
<li>第四个参数表示对应的响应动作：一般都是去发送广播，然后在广播接收 <code>onReceive(Context context, Intent intent)</code> 中做相关操作。</li>
</ul>
<p>至此，一切顺利，畅通无阻。</p>
<h1 id="SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23"><a href="#SDK_API__26gt_3B_3D_19__26amp_3B_26amp_3B_SDK_API__26lt_3B_23" class="headerlink" title="SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23"></a>SDK API &gt;= 19 &amp;&amp; SDK API &lt; 23</h1><p>当你写好代码、满心欢喜地将程序跑在手机上的时候，傻眼了！你会发现在 Android 4.4 及以上版本的定时任务不是按照规定时间间隔来执行的。比如你设置了每隔 3 分钟发出一个 HTTP 请求，结果你一看莫名其妙地变成了隔 5 分钟发一次。</p>
<p>What the fuck?</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122224816.png" alt="what the fuck"></p>
<p>然后你查阅 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a> 会看到如下几句话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122225322.png" alt="Android 4.4 API"></p>
<p>恍然大悟！原来是 Google 为了追求系统省电，所以“偷偷加工”了一下唤醒的时间间隔。但也正如上面官网中所说的那样，如果在 Android 4.4 及以上的设备还要追求精准的闹钟定时任务，要使用 <code>setExact()</code> 方法。</p>
<p>所以，相应的代码就变成了这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当你写好了“加强版”的 <code>AlarmManager</code> 之后，内心肯定无比小激动。这下总应该行了吧？运行一下，果然没错！在 Android 4.4 上的确按照规定的时间间隔在执行任务。哈哈，这下大功告成了！！！</p>
<h1 id="SDK_API__26gt_3B_3D_23"><a href="#SDK_API__26gt_3B_3D_23" class="headerlink" title="SDK API &gt;= 23"></a>SDK API &gt;= 23</h1><p>在 Android 4.4 上品尝到胜利的甜头后，你顺便在 Android 6.0 的设备上测试了一下。结果。。。。。。你又 TMD 傻眼了！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122232341.png" alt="What the fuck"></p>
<p>发现在设备关屏静止一段时间后， <code>AlarmManager</code> 又又又不能正常工作了。相必此时你连日狗的心都有了吧！强忍着泪水，再次打开 Android 官网中关于 <a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a> ，发现在 Android 6.0 中引入了低电耗模式和应用待机模式。然后接着往下看 <a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a> ，发现会有下面一段话：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20170122/20170122234141.png" alt="Android 6.0 API"></p>
<p>啊啊啊啊啊啊！之前在 Android 4.4 上能用的 <code>setExact()</code> 方法在 Android 6.0 上因为低电耗模式又不能正常使用了。但是，Google 又又又提供了新的方法 <code>setExactAndAllowWhileIdle()</code> 来解决在低电耗模式下的闹钟触发。</p>
<p>所以，Attention！相关的代码又被改写为这样：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// pendingIntent 为发送广播</span></span><br><span class="line"><span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">    alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">    alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), pendingIntent);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    alarmManager.setRepeating(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime(), TIME_INTERVAL, pendingIntent);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> BroadcastReceiver alarmReceiver = <span class="keyword">new</span> BroadcastReceiver() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 重复定时任务</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">            alarmManager.setExactAndAllowWhileIdle(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.KITKAT) &#123;</span><br><span class="line">            alarmManager.setExact(AlarmManager.ELAPSED_REALTIME_WAKEUP, SystemClock.elapsedRealtime() + TIME_INTERVAL, pendingIntent);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// to do something</span></span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>到了这里，总算是把因 Android 版本差异导致 <code>AlarmManager</code> 的“坑”填完了。这份代码已经可以满足日常的重复定时任务了。</p>
<p>好了，该讲的都讲完了，上床睡觉。仓促地结尾，预祝大家新年快乐！</p>
<p>Goodbye ！</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="https://developer.android.google.cn/reference/android/app/AlarmManager.html" target="_blank" rel="external">AlarmManager</a></li>
<li><a href="https://developer.android.google.cn/about/versions/android-4.4.html" target="_blank" rel="external">Android 4.4 API</a></li>
<li><a href="https://developer.android.google.cn/about/versions/marshmallow/android-6.0-changes.html" target="_blank" rel="external">Android 6.0 变更</a></li>
<li><a href="https://developer.android.google.cn/training/monitoring-device-state/doze-standby.html" target="_blank" rel="external">对低电耗模式和应用待机模式进行针对性优化</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>快过年了，更新春节前的最后一篇博客。</p>
<p>最近在做一个需求：客户端按照规定的时间间隔向服务端发送定位。一看到这个需求就想到了使用 <code>AlarmManager</code> 来实现。 <code>AlarmManager</code> 经常被用来执行定时任]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Say Hello To 2017]]></title>
    <link href="http://yuqirong.me/2017/01/14/Say%20Hello%20To%202017/"/>
    <id>http://yuqirong.me/2017/01/14/Say Hello To 2017/</id>
    <published>2017-01-14T07:53:56.000Z</published>
    <updated>2017-01-14T08:47:28.645Z</updated>
    <content type="html"><![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>2016</h1><p>现在回望 2016 年，发现过得也是浑浑噩噩，时间总是在不知不觉中流逝。自从 2016 年的 6 月份毕业开始，算是真正地踏上社会了。尽管万般不情愿，但还是离开了温暖的校园生活，这也意味着自己需要承担更多的责任和义务，加油！</p>
<p>在工作上也并不是一帆风顺，经历过之前八月份的贸然离职后，也懂得了做任何事都需要理性思考，而不是凭着自己的“任性”，不然迟早会付出惨痛的代价。这也教导我要学会珍惜现在，才能放眼于未来。</p>
<p>在过去的 2016 一年里，自己对于 Android 的学习也从“表面”进入到“里面”。不再满足于常规、机械地使用 API ，而是乐于探究其中内在的原理，这也是 Android 进阶开发的必经之路。对于每一位做技术的人员而言，更多地要求自己寻求积累和沉淀，而不应该是盲目地处于一种“会用就好”的状态。</p>
<h1 id="2017"><a href="#2017" class="headerlink" title="2017"></a>2017</h1><p>新的 2017 年，做一个更好的自己。</p>
<p>学习计划：</p>
<ol>
<li>继续深入学习 Android ，理解其中的原理以及解析热门的第三方框架源码，书籍《深入理解 Android 》系列、《 Android 系统源代码情景分析》等；</li>
<li>学习 React JS ，学会利用 React Native 框架开发 APP 。并适当地深入理解其中的原理；</li>
<li>重温 Java ，书籍：《Java编程思想》 、《Effective Java》等；</li>
<li>学习设计模式以及数据结构和算法等，书籍《 Head First 设计模式》等。</li>
<li>更多。。。</li>
</ol>
<p>不念过去，不畏将来。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>时隔半个月才想起要写一篇年度总结（主要是太懒懒懒了\(╯-╰)/），这么快 2016 年又过去，而 2017 年却已经来临了。</p>
<h1 id="2016"><a href="#2016" class="headerlink" title="2016"></a>201]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[EventBus源码解析]]></title>
    <link href="http://yuqirong.me/2016/12/20/EventBus%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/20/EventBus源码解析/</id>
    <published>2016-12-20T15:46:27.000Z</published>
    <updated>2017-01-08T04:28:26.103Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码。那就正好今天来说说 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的那些事儿。</p>
<p>EventBus 是什么呢（相信地球人都知道→_→）？</p>
<p>EventBus is a publish/subscribe event bus optimized for Android.</p>
<p>这是官方给的介绍，简洁、明了、霸气。翻译过来就是：<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一种为 Android 而优化设计的发布/订阅事件总线。这官方的套词可能有些人看了还是不懂。。。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20161226232951.jpg" alt="???"></p>
<p>简单地举了栗子，<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 就好像一辆公交车（快上车，老司机要飙车 乀(ˉεˉ乀) ）。相对应的，发布事件就可以类比为乘客，订阅事件就好似接站服务的人。乘客想要到达指定目的地就必须上车乘坐该公交车，公交车会做统一配置管理每位乘客（发布事件流程）。达到目的地后，打开下车门，把乘客交任给接站服务的人做相应的处理（订阅事件流程）。不知道这个栗子你们懂不懂，反正我是懂了(￣ε ￣)。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170107005159.jpg" alt="快上车"></p>
<p>所以总的来说，对于一个事件，你只要关心发送和接收就行了，而其中的收集、分发等都交给 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 来处理，你不需要做任何事。不得不说这太方便了，能让代码更见简洁，大大降低了模块之间的耦合性。</p>
<h1 id="0002B__u4F7F_u7528_u65B9_u6CD5"><a href="#0002B__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0002B 使用方法"></a>0002B 使用方法</h1><p>现在，来看一下 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的使用方法，直接复制粘贴 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 中的例子：</p>
<ol>
<li><p>第一步，定义一个事件类 <code>MessageEvent</code> :</p>
<pre><code>public static class MessageEvent { 
    /* Additional fields if needed */ 
}
</code></pre></li>
<li><p>定义一个订阅方法，可以使用 <code>@Subscribe</code> 注解来指定订阅方法所在的线程：</p>
<pre><code>@Subscribe(threadMode = ThreadMode.MAIN)  
public void onMessageEvent(MessageEvent event) {
    /* Do something */
};
</code></pre><p> 注册和反注册你的订阅方法。比如在 Android 中，Activity 和 Fragment 通常在如下的生命周期中进行注册和反注册：</p>
<pre><code>@Override
public void onStart() {
    super.onStart();
    EventBus.getDefault().register(this);
}

@Override
public void onStop() {
    super.onStop();
    EventBus.getDefault().unregister(this);
}
</code></pre></li>
</ol>
<p>3.发送事件：</p>
<pre><code>EventBus.getDefault().post(new MessageEvent());
</code></pre><p>可以看出 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 使用起来很简单，就这么几行代码解决了许多我们备受困扰的问题。那么接下来我们就深入 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 的源码内部，一探究竟。</p>
<h1 id="0003B_EventBus"><a href="#0003B_EventBus" class="headerlink" title="0003B EventBus"></a>0003B EventBus</h1><p>在 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">GitHub</a> 上对于 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 整体有一张示意图，很明确地画出了整个框架的设计原理：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161226/20170102003651.png" alt="EventBus示意图"></p>
<p>那么依据这张图，我们先从 “Publisher” 开始讲起吧。PS : 本文分析的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 源码版本为 3.0.0 。</p>
<h2 id="EventBus-getDefault_28_29"><a href="#EventBus-getDefault_28_29" class="headerlink" title="EventBus.getDefault()"></a>EventBus.getDefault()</h2><p>来看一下 <code>EventBus.getDefault()</code> 的源码（文件路径：org/greenrobot/eventbus/EventBus.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> EventBusBuilder DEFAULT_BUILDER = <span class="keyword">new</span> EventBusBuilder();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, CopyOnWriteArrayList&lt;Subscription&gt;&gt; subscriptionsByEventType;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Object, List&lt;Class&lt;?&gt;&gt;&gt; typesBySubscriber;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Object&gt; stickyEvents;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> EventBus <span class="title">getDefault</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (EventBus.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (defaultInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                defaultInstance = <span class="keyword">new</span> EventBus();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> defaultInstance;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Creates a new EventBus instance; each instance is a separate scope in which events are delivered. To use a</span><br><span class="line"> * central bus, consider &#123;<span class="doctag">@link</span> #getDefault()&#125;.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">EventBus</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_BUILDER);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EventBus(EventBusBuilder builder) &#123;</span><br><span class="line">    <span class="comment">// key 为事件的类型，value 为所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    subscriptionsByEventType = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// key 为某个订阅者，value 为该订阅者所有的事件类型</span></span><br><span class="line">    typesBySubscriber = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 粘性事件的集合，key 为事件的类型，value 为该事件的对象</span></span><br><span class="line">    stickyEvents = <span class="keyword">new</span> ConcurrentHashMap&lt;&gt;();</span><br><span class="line">    <span class="comment">// 主线程事件发送者</span></span><br><span class="line">    mainThreadPoster = <span class="keyword">new</span> HandlerPoster(<span class="keyword">this</span>, Looper.getMainLooper(), <span class="number">10</span>);</span><br><span class="line">    <span class="comment">// 子线程事件发送者</span></span><br><span class="line">    backgroundPoster = <span class="keyword">new</span> BackgroundPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 异步线程事件发送者</span></span><br><span class="line">    asyncPoster = <span class="keyword">new</span> AsyncPoster(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// 索引类的数量</span></span><br><span class="line">    indexCount = builder.subscriberInfoIndexes != <span class="keyword">null</span> ? builder.subscriberInfoIndexes.size() : <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 订阅方法查找者</span></span><br><span class="line">    subscriberMethodFinder = <span class="keyword">new</span> SubscriberMethodFinder(builder.subscriberInfoIndexes,</span><br><span class="line">            builder.strictMethodVerification, builder.ignoreGeneratedIndex);</span><br><span class="line">    <span class="comment">// 是否打印订阅者异常的日志，默认为 true</span></span><br><span class="line">    logSubscriberExceptions = builder.logSubscriberExceptions;</span><br><span class="line">    <span class="comment">// 是否打印没有订阅者的异常日志，默认为 true</span></span><br><span class="line">    logNoSubscriberMessages = builder.logNoSubscriberMessages;</span><br><span class="line">    <span class="comment">// 是否允许发送 SubscriberExceptionEvent ，默认为 true</span></span><br><span class="line">    sendSubscriberExceptionEvent = builder.sendSubscriberExceptionEvent;</span><br><span class="line">    <span class="comment">// 是否允许发送 sendNoSubscriberEvent ，默认为 true</span></span><br><span class="line">    sendNoSubscriberEvent = builder.sendNoSubscriberEvent;</span><br><span class="line">    <span class="comment">// 是否允许抛出订阅者的异常，默认是 false</span></span><br><span class="line">    throwSubscriberException = builder.throwSubscriberException;</span><br><span class="line">    <span class="comment">// 是否支持事件继承，默认是 true</span></span><br><span class="line">    eventInheritance = builder.eventInheritance;</span><br><span class="line">    <span class="comment">// 创建线程池</span></span><br><span class="line">    executorService = builder.executorService;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中可以看出，平时的我们经常调用的 <code>EventBus.getDefault()</code> 代码，其实是获取了 <code>EventBus</code> 类的单例。若该单例未实例化，那么会根据 <code>DEFAULT_BUILDER</code> 采用构造者模式去实例化该单例。在 <code>EventBus</code> 构造器中初始化了一堆的成员变量，这些都会在下面中使用到。</p>
<h2 id="register_28Object_subscriber_29"><a href="#register_28Object_subscriber_29" class="headerlink" title="register(Object subscriber)"></a>register(Object subscriber)</h2><p>事件订阅者必须调用 <code>register(Object subscriber)</code> 方法来进行注册，一起来看看在 <code>register(Object subscriber)</code> 中到底做了一些什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅者的类 class</span></span><br><span class="line">    Class&lt;?&gt; subscriberClass = subscriber.getClass();</span><br><span class="line">    <span class="comment">// 找到该 class 下所有的订阅方法</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = subscriberMethodFinder.findSubscriberMethods(subscriberClass);</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (SubscriberMethod subscriberMethod : subscriberMethods) &#123;		</span><br><span class="line">            subscribe(subscriber, subscriberMethod);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>register(Object subscriber)</code> 中，利用 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法找到订阅者 class 下所有的订阅方法，然后用 <code>for</code> 循环建立订阅关系。其中 <code>subscriberMethodFinder.findSubscriberMethods</code> 方法我们暂时先不看了，跳过。在这里只要知道作用是找到该订阅者所有的订阅方法就好了。具体 <code>SubscriberMethodFinder</code> 的代码会在后面的章节中详细分析。</p>
<p>而 <code>SubscriberMethod</code> 其实就是订阅方法的包装类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubscriberMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 订阅的方法</span></span><br><span class="line">    <span class="keyword">final</span> Method method;</span><br><span class="line">    <span class="comment">// 订阅所在的线程</span></span><br><span class="line">    <span class="keyword">final</span> ThreadMode threadMode;</span><br><span class="line">    <span class="comment">// 订阅事件的类型</span></span><br><span class="line">    <span class="keyword">final</span> Class&lt;?&gt; eventType;</span><br><span class="line">    <span class="comment">// 优先级</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> priority;</span><br><span class="line">    <span class="comment">// 订阅是否是粘性的</span></span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">boolean</span> sticky;</span><br><span class="line">    <span class="comment">// 特定字符串，用来比较两个 SubscriberMethod 是否为同一个</span></span><br><span class="line">    String methodString;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后就是轮到了 <code>subscribe(subscriber, subscriberMethod)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Object subscriber, SubscriberMethod subscriberMethod)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到订阅方法的事件类型</span></span><br><span class="line">    Class&lt;?&gt; eventType = subscriberMethod.eventType;</span><br><span class="line"></span><br><span class="line">    Subscription newSubscription = <span class="keyword">new</span> Subscription(subscriber, subscriberMethod);</span><br><span class="line">    <span class="comment">// 根据订阅方法的事件类型得到所有订阅该事件类型的订阅者集合</span></span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscriptions = <span class="keyword">new</span> CopyOnWriteArrayList&lt;&gt;();</span><br><span class="line">        subscriptionsByEventType.put(eventType, subscriptions);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 subscriptions 已经包含了，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (subscriptions.contains(newSubscription)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriber.getClass() + <span class="string">" already registered to event "</span></span><br><span class="line">                    + eventType);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 根据该 subscriberMethod 优先级插入到 subscriptions 中</span></span><br><span class="line">    <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= size; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i == size || subscriberMethod.priority &gt; subscriptions.get(i).subscriberMethod.priority) &#123;</span><br><span class="line">            subscriptions.add(i, newSubscription);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 放入 subscribedEvents 中，key：订阅者  value：该订阅者的所有订阅事件的类型</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedEvents = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedEvents == <span class="keyword">null</span>) &#123;</span><br><span class="line">        subscribedEvents = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        typesBySubscriber.put(subscriber, subscribedEvents);</span><br><span class="line">    &#125;</span><br><span class="line">    subscribedEvents.add(eventType);</span><br><span class="line">    <span class="comment">// 如果订阅的方法支持 sticky</span></span><br><span class="line">    <span class="keyword">if</span> (subscriberMethod.sticky) &#123;</span><br><span class="line">        <span class="comment">// 如果支持事件继承</span></span><br><span class="line">        <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">            <span class="comment">// Existing sticky events of all subclasses of eventType have to be considered.</span></span><br><span class="line">            <span class="comment">// Note: Iterating over all events may be inefficient with lots of sticky events,</span></span><br><span class="line">            <span class="comment">// thus data structure should be changed to allow a more efficient lookup</span></span><br><span class="line">            <span class="comment">// (e.g. an additional map storing sub classes of super classes: Class -&gt; List&lt;Class&gt;).</span></span><br><span class="line">            Set&lt;Map.Entry&lt;Class&lt;?&gt;, Object&gt;&gt; entries = stickyEvents.entrySet();</span><br><span class="line">            <span class="comment">// 遍历 stickyEvents</span></span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;Class&lt;?&gt;, Object&gt; entry : entries) &#123;</span><br><span class="line">                Class&lt;?&gt; candidateEventType = entry.getKey();</span><br><span class="line">                <span class="comment">// 判断 eventType 类型是否是 candidateEventType 的父类</span></span><br><span class="line">                <span class="keyword">if</span> (eventType.isAssignableFrom(candidateEventType)) &#123;</span><br><span class="line">                    <span class="comment">// 得到对应 eventType 的子类事件，类型为 candidateEventType</span></span><br><span class="line">                    Object stickyEvent = entry.getValue();</span><br><span class="line">                    <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">                    checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 拿到之前 sticky 的事件，然后发送给 newSubscription</span></span><br><span class="line">            Object stickyEvent = stickyEvents.get(eventType);</span><br><span class="line">            <span class="comment">// 发送粘性事件给 newSubscription</span></span><br><span class="line">            checkPostStickyEventToSubscription(newSubscription, stickyEvent);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>subscribe(subscriber, subscriberMethod)</code> 方法主要就做了三件事：</p>
<ol>
<li>得到 <code>subscriptions</code> ，然后根据优先级把 <code>subscriberMethod</code> 插入到 <code>subscriptions</code> 中；</li>
<li>将 <code>eventType</code> 放入到 <code>subscribedEvents</code> 中；</li>
<li>如果订阅方法支持 <code>sticky</code> ，那么发送相关的粘性事件。</li>
</ol>
<p>粘性事件发送调用了 <code>checkPostStickyEventToSubscription(newSubscription, stickyEvent);</code> 。从方法的命名上来看，知道应该是事件发送到订阅者相关的代码。那么继续跟进代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkPostStickyEventToSubscription</span><span class="params">(Subscription newSubscription, Object stickyEvent)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stickyEvent != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// If the subscriber is trying to abort the event, it will fail (event is not tracked in posting state)</span></span><br><span class="line">        <span class="comment">// --&gt; Strange corner case, which we don't take care of here.</span></span><br><span class="line">        postToSubscription(newSubscription, stickyEvent, Looper.getMainLooper() == Looper.myLooper());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postToSubscription</span><span class="params">(Subscription subscription, Object event, <span class="keyword">boolean</span> isMainThread)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据不同的线程模式执行对应</span></span><br><span class="line">    <span class="keyword">switch</span> (subscription.subscriberMethod.threadMode) &#123;</span><br><span class="line">        <span class="keyword">case</span> POSTING: <span class="comment">// 和发送事件处于同一个线程</span></span><br><span class="line">            invokeSubscriber(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> MAIN: <span class="comment">// 主线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mainThreadPoster.enqueue(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BACKGROUND: <span class="comment">// 子线程</span></span><br><span class="line">            <span class="keyword">if</span> (isMainThread) &#123;</span><br><span class="line">                backgroundPoster.enqueue(subscription, event);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                invokeSubscriber(subscription, event);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> ASYNC: <span class="comment">// 和发送事件处于不同的线程</span></span><br><span class="line">            asyncPoster.enqueue(subscription, event);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>: <span class="comment">// 抛出异常</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unknown thread mode: "</span> + subscription.subscriberMethod.threadMode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">invokeSubscriber</span><span class="params">(Subscription subscription, Object event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 通过反射执行订阅方法</span></span><br><span class="line">        subscription.subscriberMethod.method.invoke(subscription.subscriber, event);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">        handleSubscriberException(subscription, event, e.getCause());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Unexpected exception"</span>, e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>checkPostStickyEventToSubscription(Subscription newSubscription, Object stickyEvent)</code> 方法的内部调用了 <code>postToSubscription(Subscription subscription, Object event, boolean isMainThread)</code> 。主要的操作都在 <code>postToSubscription</code> 中。根据 <code>threadMode</code> 共分为四种：</p>
<ol>
<li>同一个线程：表示订阅方法所处的线程和发布事件的线程是同一个线程；</li>
<li>主线程：如果发布事件的线程是主线程，那么直接执行订阅方法；否则利用 Handler 回调主线程来执行；</li>
<li>子线程：如果发布事件的线程是主线程，那么调用线程池中的子线程来执行订阅方法；否则直接执行；</li>
<li>异步线程：无论发布事件执行在主线程还是子线程，都利用一个异步线程来执行订阅方法。</li>
</ol>
<p>这四种线程模式其实最后都会调用 <code>invokeSubscriber(Subscription subscription, Object event)</code> 方法通过反射来执行。至此，关于粘性事件的发送就告一段落了。</p>
<p>另外，在这里因篇幅原因就不对 <code>mainThreadPoster</code> 和 <code>backgroundPoster</code> 等细说了，可以自行回去看相关源码，比较简单。</p>
<h2 id="unregister_28Object_subscriber_29"><a href="#unregister_28Object_subscriber_29" class="headerlink" title="unregister(Object subscriber)"></a>unregister(Object subscriber)</h2><p>看完 <code>register(Object subscriber)</code> ，接下来顺便看看 <code>unregister(Object subscriber)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">unregister</span><span class="params">(Object subscriber)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 通过 subscriber 来找到 subscribedTypes</span></span><br><span class="line">    List&lt;Class&lt;?&gt;&gt; subscribedTypes = typesBySubscriber.get(subscriber);</span><br><span class="line">    <span class="keyword">if</span> (subscribedTypes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Class&lt;?&gt; eventType : subscribedTypes) &#123;</span><br><span class="line">            <span class="comment">// 解除每个订阅的事件类型</span></span><br><span class="line">            unsubscribeByEventType(subscriber, eventType);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 从 typesBySubscriber 中移除</span></span><br><span class="line">        typesBySubscriber.remove(subscriber);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Log.w(TAG, <span class="string">"Subscriber to unregister was not registered before: "</span> + subscriber.getClass());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unsubscribeByEventType</span><span class="params">(Object subscriber, Class&lt;?&gt; eventType)</span> </span>&#123;</span><br><span class="line">    List&lt;Subscription&gt; subscriptions = subscriptionsByEventType.get(eventType);</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> size = subscriptions.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">            Subscription subscription = subscriptions.get(i);</span><br><span class="line">            <span class="keyword">if</span> (subscription.subscriber == subscriber) &#123;</span><br><span class="line">                subscription.active = <span class="keyword">false</span>;</span><br><span class="line">                subscriptions.remove(i);</span><br><span class="line">                i--;</span><br><span class="line">                size--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>瞟了一眼 <code>unregister(Object subscriber)</code> 方法，我们基本上就已经知道其中做了什么。在之前 <code>register(Object subscriber)</code> 中 <code>subscriptionsByEventType</code> 和 <code>typesBySubscriber</code> 会对 <code>subscriber</code> 间接进行绑定。而在 <code>unregister(Object subscriber)</code> 会对其解绑，这样就防止了造成内存泄露的危险。</p>
<h2 id="post_28Object_event_29"><a href="#post_28Object_event_29" class="headerlink" title="post(Object event)"></a>post(Object event)</h2><p>最后，我们来分析下发送事件 <code>post(Object event)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ThreadLocal&lt;PostingThreadState&gt; currentPostingThreadState = <span class="keyword">new</span> ThreadLocal&lt;PostingThreadState&gt;() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> PostingThreadState <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> PostingThreadState();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">post</span><span class="params">(Object event)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到当前线程的 postingState</span></span><br><span class="line">    PostingThreadState postingState = currentPostingThreadState.get();</span><br><span class="line">    <span class="comment">// 加入到队列中</span></span><br><span class="line">    List&lt;Object&gt; eventQueue = postingState.eventQueue;</span><br><span class="line">    eventQueue.add(event);</span><br><span class="line">    <span class="comment">// 如果没有持续在发送事件，那么开始发送事件并一直保持发送ing</span></span><br><span class="line">    <span class="keyword">if</span> (!postingState.isPosting) &#123;</span><br><span class="line">        postingState.isMainThread = Looper.getMainLooper() == Looper.myLooper();</span><br><span class="line">        postingState.isPosting = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (postingState.canceled) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Internal error. Abort state was not reset"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (!eventQueue.isEmpty()) &#123;</span><br><span class="line">                <span class="comment">// 发送单个事件</span></span><br><span class="line">                postSingleEvent(eventQueue.remove(<span class="number">0</span>), postingState);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            postingState.isPosting = <span class="keyword">false</span>;</span><br><span class="line">            postingState.isMainThread = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>post(Object event)</code> 中，首先根据 <code>currentPostingThreadState</code> 获取当前线程状态 <code>postingState</code> 。<code>currentPostingThreadState</code> 其实就是一个 <code>ThreadLocal</code> 类的对象，不同的线程根据自己独有的索引值可以得到相应属于自己的 <code>postingState</code> 数据。</p>
<p>然后把事件 <code>event</code> 加入到 <code>eventQueue</code> 队列中排队。只要 <code>eventQueue</code> 不为空，就不间断地发送事件。而发送单个事件的代码在 <code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中，我们跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">postSingleEvent</span><span class="params">(Object event, PostingThreadState postingState)</span> <span class="keyword">throws</span> Error </span>&#123;</span><br><span class="line">    <span class="comment">// 得到事件的类型</span></span><br><span class="line">    Class&lt;?&gt; eventClass = event.getClass();</span><br><span class="line">    <span class="comment">// 是否找到订阅者</span></span><br><span class="line">    <span class="keyword">boolean</span> subscriptionFound = <span class="keyword">false</span>;</span><br><span class="line">    <span class="comment">// 如果支持事件继承</span></span><br><span class="line">    <span class="keyword">if</span> (eventInheritance) &#123;</span><br><span class="line">        <span class="comment">// 查找 eventClass 的所有父类和接口</span></span><br><span class="line">        List&lt;Class&lt;?&gt;&gt; eventTypes = lookupAllEventTypes(eventClass);</span><br><span class="line">        <span class="keyword">int</span> countTypes = eventTypes.size();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> h = <span class="number">0</span>; h &lt; countTypes; h++) &#123;</span><br><span class="line">            Class&lt;?&gt; clazz = eventTypes.get(h);</span><br><span class="line">            <span class="comment">// 依次向订阅方法类型为 eventClass 的父类或接口的发送事件</span></span><br><span class="line">            <span class="comment">// 只要其中有一个 postSingleEventForEventType 返回 true ，那么 subscriptionFound 就为 true</span></span><br><span class="line">            subscriptionFound |= postSingleEventForEventType(event, postingState, clazz);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 发送事件</span></span><br><span class="line">        subscriptionFound = postSingleEventForEventType(event, postingState, eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有订阅者</span></span><br><span class="line">    <span class="keyword">if</span> (!subscriptionFound) &#123;</span><br><span class="line">        <span class="keyword">if</span> (logNoSubscriberMessages) &#123;</span><br><span class="line">            Log.d(TAG, <span class="string">"No subscribers registered for event "</span> + eventClass);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (sendNoSubscriberEvent &amp;&amp; eventClass != NoSubscriberEvent.class &amp;&amp;</span><br><span class="line">                eventClass != SubscriberExceptionEvent.class) &#123;</span><br><span class="line">            <span class="comment">// 发送 NoSubscriberEvent 事件，可以自定义接收</span></span><br><span class="line">            post(<span class="keyword">new</span> NoSubscriberEvent(<span class="keyword">this</span>, event));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>postSingleEvent(Object event, PostingThreadState postingState)</code> 中的代码逻辑还是比较清晰的，会根据 <code>eventInheritance</code> 分成两种：</p>
<ol>
<li>支持事件继承：得到 <code>eventClass</code> 的所有父类和接口，然后循环依次发送事件；</li>
<li>不支持事件继承：直接发送事件。</li>
</ol>
<p>另外，若找不到订阅者，在默认配置下还会发送 <code>NoSubscriberEvent</code> 事件。需要开发者自定义订阅方法接收这个事件。</p>
<p>关于发送的具体操作还是要到 <code>postSingleEventForEventType(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</code> 中去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">postSingleEventForEventType</span><span class="params">(Object event, PostingThreadState postingState, Class&lt;?&gt; eventClass)</span> </span>&#123;</span><br><span class="line">    CopyOnWriteArrayList&lt;Subscription&gt; subscriptions;</span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">        <span class="comment">// 得到订阅者</span></span><br><span class="line">        subscriptions = subscriptionsByEventType.get(eventClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriptions != <span class="keyword">null</span> &amp;&amp; !subscriptions.isEmpty()) &#123;</span><br><span class="line">        <span class="comment">// 依次遍历订阅者</span></span><br><span class="line">        <span class="keyword">for</span> (Subscription subscription : subscriptions) &#123;</span><br><span class="line">            postingState.event = event;</span><br><span class="line">            postingState.subscription = subscription;</span><br><span class="line">            <span class="keyword">boolean</span> aborted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 发送事件</span></span><br><span class="line">                postToSubscription(subscription, event, postingState.isMainThread);</span><br><span class="line">                <span class="comment">// 是否被取消了</span></span><br><span class="line">                aborted = postingState.canceled;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                postingState.event = <span class="keyword">null</span>;</span><br><span class="line">                postingState.subscription = <span class="keyword">null</span>;</span><br><span class="line">                postingState.canceled = <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果被取消，则跳出循环</span></span><br><span class="line">            <span class="keyword">if</span> (aborted) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>仔细看上面的代码，我们应该能发现一个重要的线索—— <code>postToSubscription</code> 。没错，就是上面讲解发送粘性事件中的 <code>postToSubscription</code> 方法。神奇地绕了一圈又绕回来了。</p>
<p>而 <code>postSingleEventForEventType</code> 方法做的事情只不过是遍历了订阅者，然后一个个依次调用 <code>postToSubscription</code> 方法，之后就是进入 <code>switch</code> 四种线程模式（<code>POSTING</code> 、<code>MAIN</code> 、<code>BACKGROUND</code> 和 <code>ASYNC</code>）并执行订阅者的订阅方法的逻辑了。这里就不重复讲了，具体可以查看上面发送粘性事件中的分析。</p>
<p>至此，整个 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 发布/订阅的原理就讲完了。<a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 是一款典型的运行观察者模式的开源框架，设计巧妙，代码也通俗易懂，值得我们学习。</p>
<p>别以为到这里就本文结束了，可不要忘了，在前面我们还留下一个坑没填—— <code>SubscriberMethodFinder</code> 。想不想知道 <code>SubscriberMethodFinder</code> 到底是如何工作的呢？那还等什么，我们赶快进入下一章节。</p>
<h1 id="0004B_SubscriberMethodFinder"><a href="#0004B_SubscriberMethodFinder" class="headerlink" title="0004B SubscriberMethodFinder"></a>0004B SubscriberMethodFinder</h1><p><code>SubscriberMethodFinder</code> 的作用说白了其实就是寻找订阅者的订阅方法。正如在上面的代码中提到的那样， <code>findSubscriberMethods</code> 方法可以返回指定订阅者中的所有订阅方法。</p>
<h2 id="findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findSubscriberMethods_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findSubscriberMethods(Class&lt;?&gt; subscriberClass)"></a>findSubscriberMethods(Class&lt;?&gt; subscriberClass)</h2><p>我们看下内部的源码（文件路径：org/greenrobot/eventbus/SubscriberMethodFinder.java）：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List&lt;SubscriberMethod&gt; <span class="title">findSubscriberMethods</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先从缓存中获取</span></span><br><span class="line">    List&lt;SubscriberMethod&gt; subscriberMethods = METHOD_CACHE.get(subscriberClass);</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (ignoreGeneratedIndex) &#123;</span><br><span class="line">        <span class="comment">// 如果忽略索引，就根据反射来获取</span></span><br><span class="line">        subscriberMethods = findUsingReflection(subscriberClass);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则使用索引</span></span><br><span class="line">        subscriberMethods = findUsingInfo(subscriberClass);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberMethods.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"Subscriber "</span> + subscriberClass</span><br><span class="line">                + <span class="string">" and its super classes have no public methods with the @Subscribe annotation"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 放入缓存中</span></span><br><span class="line">        METHOD_CACHE.put(subscriberClass, subscriberMethods);</span><br><span class="line">        <span class="keyword">return</span> subscriberMethods;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部有两种途径获取：<code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 和 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 。另外，还有缓存可以提高索引效率。</p>
<h2 id="findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingReflection_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingReflection(Class&lt;?&gt; subscriberClass)"></a>findUsingReflection(Class&lt;?&gt; subscriberClass)</h2><p>那么我们先来看看 <code>findUsingReflection(Class&lt;?&gt; subscriberClass)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingReflection</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    <span class="comment">// 做初始化操作</span></span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 通过反射查找订阅方法</span></span><br><span class="line">        findUsingReflectionInSingleClass(findState);</span><br><span class="line">        <span class="comment">// 查找 clazz 的父类</span></span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 返回 findState 中的 subscriberMethods</span></span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里出现一个新的类 <code>FindState</code> ，而 <code>FindState</code> 的作用可以对订阅方法做一些校验，以及查找到的所有订阅方法也是封装在 <code>FindState.subscriberMethods</code> 中的。另外，在 <code>SubscriberMethodFinder</code> 类内部还维持着一个 <code>FIND_STATE_POOL</code> ，可以循环利用，节省内存。</p>
<p>接着往下看，就发现了一个关键的方法： <code>findUsingReflectionInSingleClass(FindState findState)</code> 。根据这方法名可以知道反射获取订阅方法的操作就在这儿：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">findUsingReflectionInSingleClass</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    Method[] methods;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// This is faster than getMethods, especially when subscribers are fat classes like Activities</span></span><br><span class="line">        methods = findState.clazz.getDeclaredMethods();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        <span class="comment">// Workaround for java.lang.NoClassDefFoundError, see https://github.com/greenrobot/EventBus/issues/149</span></span><br><span class="line">        methods = findState.clazz.getMethods();</span><br><span class="line">        findState.skipSuperClasses = <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (Method method : methods) &#123;</span><br><span class="line">        <span class="keyword">int</span> modifiers = method.getModifiers();</span><br><span class="line">        <span class="comment">// 方法的修饰符只能为 public 并且不能是 static 和 abstract</span></span><br><span class="line">        <span class="keyword">if</span> ((modifiers &amp; Modifier.PUBLIC) != <span class="number">0</span> &amp;&amp; (modifiers &amp; MODIFIERS_IGNORE) == <span class="number">0</span>) &#123;</span><br><span class="line">            Class&lt;?&gt;[] parameterTypes = method.getParameterTypes();</span><br><span class="line">            <span class="comment">// 订阅方法的参数只能有一个</span></span><br><span class="line">            <span class="keyword">if</span> (parameterTypes.length == <span class="number">1</span>) &#123;</span><br><span class="line">                <span class="comment">// 得到 @Subscribe 注解，如果注解不为空那就认为是订阅方法</span></span><br><span class="line">                Subscribe subscribeAnnotation = method.getAnnotation(Subscribe.class);</span><br><span class="line">                <span class="keyword">if</span> (subscribeAnnotation != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    Class&lt;?&gt; eventType = parameterTypes[<span class="number">0</span>];</span><br><span class="line">                    <span class="comment">// 将该 method 做校验</span></span><br><span class="line">                    <span class="keyword">if</span> (findState.checkAdd(method, eventType)) &#123;</span><br><span class="line">                        <span class="comment">// 解析 @Subscribe 注解中的 threadMode</span></span><br><span class="line">                        ThreadMode threadMode = subscribeAnnotation.threadMode();</span><br><span class="line">                        <span class="comment">// 加入到 findState.subscriberMethods 中</span></span><br><span class="line">                        findState.subscriberMethods.add(<span class="keyword">new</span> SubscriberMethod(method, eventType, threadMode,</span><br><span class="line">                                subscribeAnnotation.priority(), subscribeAnnotation.sticky()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">                String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(<span class="string">"@Subscribe method "</span> + methodName +</span><br><span class="line">                        <span class="string">"must have exactly 1 parameter but has "</span> + parameterTypes.length);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (strictMethodVerification &amp;&amp; method.isAnnotationPresent(Subscribe.class)) &#123;</span><br><span class="line">            String methodName = method.getDeclaringClass().getName() + <span class="string">"."</span> + method.getName();</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> EventBusException(methodName +</span><br><span class="line">                    <span class="string">" is a illegal @Subscribe method: must be public, non-static, and non-abstract"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过一个个循环订阅者中的方法，筛选得到其中的订阅方法后，保存在 <code>findState.subscriberMethods</code> 中。最后在 <code>getMethodsAndRelease(FindState findState)</code> 方法中把 <code>findState.subscriberMethods</code> 返回。（这里就不对 <code>getMethodsAndRelease(FindState findState)</code> 做解析了，可以下去自己看代码，比较简单 *^ο^* ）</p>
<h2 id="findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29"><a href="#findUsingInfo_28Class_26lt_3B_3F_26gt_3B_subscriberClass_29" class="headerlink" title="findUsingInfo(Class&lt;?&gt; subscriberClass)"></a>findUsingInfo(Class&lt;?&gt; subscriberClass)</h2><p>最后，剩下另外一种获取订阅方法的途径还没讲。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> List&lt;SubscriberMethod&gt; <span class="title">findUsingInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">    FindState findState = prepareFindState();</span><br><span class="line">    findState.initForSubscriber(subscriberClass);</span><br><span class="line">    <span class="keyword">while</span> (findState.clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">        findState.subscriberInfo = getSubscriberInfo(findState);</span><br><span class="line">        <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 直接获取 subscriberInfo 中的 SubscriberMethods</span></span><br><span class="line">            SubscriberMethod[] array = findState.subscriberInfo.getSubscriberMethods();</span><br><span class="line">            <span class="keyword">for</span> (SubscriberMethod subscriberMethod : array) &#123;</span><br><span class="line">                <span class="keyword">if</span> (findState.checkAdd(subscriberMethod.method, subscriberMethod.eventType)) &#123;</span><br><span class="line">                    findState.subscriberMethods.add(subscriberMethod);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果 subscriberInfo 没有，就通过反射的方式</span></span><br><span class="line">            findUsingReflectionInSingleClass(findState);</span><br><span class="line">        &#125;</span><br><span class="line">        findState.moveToSuperclass();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> getMethodsAndRelease(findState);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(FindState findState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (findState.subscriberInfo != <span class="keyword">null</span> &amp;&amp; findState.subscriberInfo.getSuperSubscriberInfo() != <span class="keyword">null</span>) &#123;</span><br><span class="line">        SubscriberInfo superclassInfo = findState.subscriberInfo.getSuperSubscriberInfo();</span><br><span class="line">        <span class="keyword">if</span> (findState.clazz == superclassInfo.getSubscriberClass()) &#123;</span><br><span class="line">            <span class="keyword">return</span> superclassInfo;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (subscriberInfoIndexes != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 使用 SubscriberInfoIndex 来获取 SubscriberInfo</span></span><br><span class="line">        <span class="keyword">for</span> (SubscriberInfoIndex index : subscriberInfoIndexes) &#123;</span><br><span class="line">            SubscriberInfo info = index.getSubscriberInfo(findState.clazz);</span><br><span class="line">            <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">return</span> info;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 <code>findUsingInfo(Class&lt;?&gt; subscriberClass)</code> 中是通过 <code>SubscriberInfo</code> 类来获取订阅方法的；如果没有 <code>SubscriberInfo</code> ，就直接通过反射的形式来获取。那么 <code>SubscriberInfo</code> 又是如何得到的呢？还要继续跟踪到 <code>getSubscriberInfo(FindState findState)</code> 方法中。然后又有一个新的类蹦出来—— <code>SubscriberInfoIndex</code> 。那么 <code>SubscriberInfoIndex</code> 又是什么东东啊（文件路径：org/greenrobot/eventbus/meta/SubscriberInfoIndex.java）？</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="function">SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>点进去后发现 <code>SubscriberInfoIndex</code> 只是一个接口而已，是不是感到莫名其妙。What the hell is it!</p>
<p>我们把这个疑问先放在心里，到 <code>EventBusPerformance</code> 这个 module 中，进入 build/generated/source/apt/debug/org/greenrobot/eventbusperf 目录下，发现有一个类叫 <code>MyEventBusIndex</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** This class is generated by EventBus, do not edit. */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyEventBusIndex</span> <span class="keyword">implements</span> <span class="title">SubscriberInfoIndex</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        SUBSCRIBER_INDEX = <span class="keyword">new</span> HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.SubscribeClassEventBusDefault.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEvent"</span>, TestEvent.class),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(TestRunnerActivity.class, <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestFinishedEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscriberClassEventBusAsync.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventAsync"</span>, TestEvent.class, ThreadMode.ASYNC),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusBackground.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventBackgroundThread"</span>, TestEvent.class, ThreadMode.BACKGROUND),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">        putIndex(<span class="keyword">new</span> SimpleSubscriberInfo(org.greenrobot.eventbusperf.testsubject.PerfTestEventBus.SubscribeClassEventBusMain.class,</span><br><span class="line">                <span class="keyword">true</span>, <span class="keyword">new</span> SubscriberMethodInfo[] &#123;</span><br><span class="line">            <span class="keyword">new</span> SubscriberMethodInfo(<span class="string">"onEventMainThread"</span>, TestEvent.class, ThreadMode.MAIN),</span><br><span class="line">        &#125;));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">putIndex</span><span class="params">(SubscriberInfo info)</span> </span>&#123;</span><br><span class="line">        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SubscriberInfo <span class="title">getSubscriberInfo</span><span class="params">(Class&lt;?&gt; subscriberClass)</span> </span>&#123;</span><br><span class="line">        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);</span><br><span class="line">        <span class="keyword">if</span> (info != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> info;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从代码中可知，<code>MyEventBusIndex</code> 其实是 <code>SubscriberInfoIndex</code> 的实现类，并且是 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 自动生成的（根据注释可知这点）。而 <code>getSubscriberInfo(Class&lt;?&gt; subscriberClass)</code> 方法已经实现了，内部维持着一个 <code>SUBSCRIBER_INDEX</code> 的 <code>HashMap</code> ，用来保存订阅类的相关信息 <code>info</code> 。然后在需要的时候可以通过 <code>info</code> 快速返回 <code>SubscriberMethod</code> 。这样就达到了不用反射获取订阅方法的目的，提高了执行效率。</p>
<p>到了这里我们明白了上面关于 <code>SubscriberInfoIndex</code> 的疑问，但是又有一个新的疑问产生了：<code>MyEventBusIndex</code> 到底是如何生成的？想要解开这个疑问，我们就要去 <code>EventBusAnnotationProcessor</code> 类中寻找答案了。</p>
<h1 id="0005B_EventBusAnnotationProcessor"><a href="#0005B_EventBusAnnotationProcessor" class="headerlink" title="0005B EventBusAnnotationProcessor"></a>0005B EventBusAnnotationProcessor</h1><p>一看到 <code>EventBusAnnotationProcessor</code> ，菊花一紧，料想肯定逃不了注解。我们可以猜出个大概： <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 在编译时通过 <code>EventBusAnnotationProcessor</code> 寻找到所有标有 <code>@Subscribe</code> 注解的订阅方法，然后依据这些订阅方法自动生成像 <code>MyEventBusIndex</code> 一样的索引类代码，以此提高索引效率。</p>
<p>总体来说，这种注解的思路和 <a href="https://github.com/square/dagger" target="_blank" rel="external">Dagger</a> 、<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 等框架类似。想要了更多，可以阅读我的上一篇博客<a href="/2016/12/18/ButterKnife源码解析/">《ButterKnife源码分析》</a>。</p>
<p>在这里由于篇幅的原因只能简单粗略地解析 <code>EventBusAnnotationProcessor</code> 的源码了，还请多多谅解。</p>
<h2 id="process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)"></a>process(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env)</h2><p>我们简单地来分析一下 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">    Messager messager = processingEnv.getMessager();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        ... <span class="comment">// 省略一堆代码</span></span><br><span class="line">        <span class="comment">// 根据 @Subscribe 的注解得到所有订阅方法</span></span><br><span class="line">        collectSubscribers(annotations, env, messager);</span><br><span class="line">        <span class="comment">// 校验这些订阅方法，过滤掉不符合的</span></span><br><span class="line">        checkForSubscribersToSkip(messager, indexPackage);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!methodsByClass.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 生成索引类，比如 MyEventBusIndex</span></span><br><span class="line">            createInfoIndexFile(index);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            messager.printMessage(Diagnostic.Kind.WARNING, <span class="string">"No @Subscribe annotations found"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writerRoundDone = <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RuntimeException e) &#123;</span><br><span class="line">        <span class="comment">// IntelliJ does not handle exceptions nicely, so log and print a message</span></span><br><span class="line">        e.printStackTrace();</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Unexpected error in EventBusAnnotationProcessor: "</span> + e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实在 <code>process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env)</code> 方法中重要的代码就这么几行，其他不重要的代码都省略了。那现在我们顺着一个一个方法来看。</p>
<h2 id="collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29"><a href="#collectSubscribers_28Set_26lt_3B_3FextendsTypeElement_26gt_3B_annotations_2C_RoundEnvironment_env_2C_Messager_messager_29" class="headerlink" title="collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)"></a>collectSubscribers(Set&lt;?extendsTypeElement&gt; annotations, RoundEnvironment env, Messager messager)</h2><p>我们先从 <code>collectSubscribers(annotations, env, messager);</code> 开始入手：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">collectSubscribers</span><span class="params">(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment env, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement annotation : annotations) &#123;</span><br><span class="line">        <span class="comment">// 根据注解去获得 elements</span></span><br><span class="line">        Set&lt;? extends Element&gt; elements = env.getElementsAnnotatedWith(annotation);</span><br><span class="line">        <span class="keyword">for</span> (Element element : elements) &#123;</span><br><span class="line">            <span class="keyword">if</span> (element <span class="keyword">instanceof</span> ExecutableElement) &#123;</span><br><span class="line">                ExecutableElement method = (ExecutableElement) element;</span><br><span class="line">                <span class="keyword">if</span> (checkHasNoErrors(method, messager)) &#123;</span><br><span class="line">                    TypeElement classElement = (TypeElement) method.getEnclosingElement();</span><br><span class="line">                    <span class="comment">// 添加该订阅方法</span></span><br><span class="line">                    methodsByClass.putElement(classElement, method);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"@Subscribe is only valid for methods"</span>, element);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkHasNoErrors</span><span class="params">(ExecutableElement element, Messager messager)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法不能是 static 的</span></span><br><span class="line">    <span class="keyword">if</span> (element.getModifiers().contains(Modifier.STATIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must not be static"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 方法要是 public 的</span></span><br><span class="line">    <span class="keyword">if</span> (!element.getModifiers().contains(Modifier.PUBLIC)) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must be public"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 参数只能有一个</span></span><br><span class="line">    List&lt;? extends VariableElement&gt; parameters = ((ExecutableElement) element).getParameters();</span><br><span class="line">    <span class="keyword">if</span> (parameters.size() != <span class="number">1</span>) &#123;</span><br><span class="line">        messager.printMessage(Diagnostic.Kind.ERROR, <span class="string">"Subscriber method must have exactly 1 parameter"</span>, element);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码做的事情就是根据注解获取了对应的方法，然后初步筛选了一些方法，放入 <code>methodsByClass</code> 中。</p>
<h2 id="checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29"><a href="#checkForSubscribersToSkip_28Messager_messager_2C_String_myPackage_29" class="headerlink" title="checkForSubscribersToSkip(Messager messager, String myPackage)"></a>checkForSubscribersToSkip(Messager messager, String myPackage)</h2><p>得到这些初选的订阅方法后，就要进入 <code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 环节：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">checkForSubscribersToSkip</span><span class="params">(Messager messager, String myPackage)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement skipCandidate : methodsByClass.keySet()) &#123;</span><br><span class="line">        TypeElement subscriberClass = skipCandidate;</span><br><span class="line">        <span class="keyword">while</span> (subscriberClass != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果该订阅类是 public 的，可以通过</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是 private 或者 protected 的，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="comment">// 如果该订阅类是默认修饰符，但是订阅类的包和索引类的包不是同一个包，会被加入到 classesToSkip 中</span></span><br><span class="line">            <span class="keyword">if</span> (!isVisible(myPackage, subscriberClass)) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                    String msg;</span><br><span class="line">                    <span class="keyword">if</span> (subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because class is not public"</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        msg = <span class="string">"Falling back to reflection because "</span> + skipCandidate +</span><br><span class="line">                                <span class="string">" has a non-public super class"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    messager.printMessage(Diagnostic.Kind.NOTE, msg, subscriberClass);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberClass);</span><br><span class="line">            <span class="keyword">if</span> (methods != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 校验订阅方法是否合格</span></span><br><span class="line">                <span class="keyword">for</span> (ExecutableElement method : methods) &#123;</span><br><span class="line">                    String skipReason = <span class="keyword">null</span>;</span><br><span class="line">                    VariableElement param = method.getParameters().get(<span class="number">0</span>);</span><br><span class="line">                    TypeMirror typeMirror = getParamTypeMirror(param, messager);</span><br><span class="line">                    <span class="keyword">if</span> (!(typeMirror <span class="keyword">instanceof</span> DeclaredType) ||</span><br><span class="line">                            !(((DeclaredType) typeMirror).asElement() <span class="keyword">instanceof</span> TypeElement)) &#123;</span><br><span class="line">                        skipReason = <span class="string">"event type cannot be processed"</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        TypeElement eventTypeElement = (TypeElement) ((DeclaredType) typeMirror).asElement();</span><br><span class="line">                        <span class="keyword">if</span> (!isVisible(myPackage, eventTypeElement)) &#123;</span><br><span class="line">                            skipReason = <span class="string">"event type is not public"</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (skipReason != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">boolean</span> added = classesToSkip.add(skipCandidate);</span><br><span class="line">                        <span class="keyword">if</span> (added) &#123;</span><br><span class="line">                            String msg = <span class="string">"Falling back to reflection because "</span> + skipReason;</span><br><span class="line">                            <span class="keyword">if</span> (!subscriberClass.equals(skipCandidate)) &#123;</span><br><span class="line">                                msg += <span class="string">" (found in super class for "</span> + skipCandidate + <span class="string">")"</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            messager.printMessage(Diagnostic.Kind.NOTE, msg, param);</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 查找父类</span></span><br><span class="line">            subscriberClass = getSuperclass(subscriberClass);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用一句话来概括，<code>checkForSubscribersToSkip(Messager messager, String myPackage)</code> 做的事情就是如果这些订阅类中牵扯到不可见状态，那么就会被加入到 <code>classesToSkip</code> 中，导致后面生成索引类中跳过这些订阅类。</p>
<h2 id="createInfoIndexFile_28String_index_29"><a href="#createInfoIndexFile_28String_index_29" class="headerlink" title="createInfoIndexFile(String index)"></a>createInfoIndexFile(String index)</h2><p>经过筛选后，<code>EventBusAnnotationProcessor</code> 最终要生成一个索引类，具体的代码就在 <code>createInfoIndexFile(String index)</code> 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">createInfoIndexFile</span><span class="params">(String index)</span> </span>&#123;</span><br><span class="line">    BufferedWriter writer = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        JavaFileObject sourceFile = processingEnv.getFiler().createSourceFile(index);</span><br><span class="line">        <span class="keyword">int</span> period = index.lastIndexOf(<span class="string">'.'</span>);</span><br><span class="line">        String myPackage = period &gt; <span class="number">0</span> ? index.substring(<span class="number">0</span>, period) : <span class="keyword">null</span>;</span><br><span class="line">        String clazz = index.substring(period + <span class="number">1</span>);</span><br><span class="line">        writer = <span class="keyword">new</span> BufferedWriter(sourceFile.openWriter());</span><br><span class="line">        <span class="comment">// 下面都是自动生成的代码</span></span><br><span class="line">        <span class="keyword">if</span> (myPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">            writer.write(<span class="string">"package "</span> + myPackage + <span class="string">";\n\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SimpleSubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberMethodInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfo;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.meta.SubscriberInfoIndex;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import org.greenrobot.eventbus.ThreadMode;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.HashMap;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"import java.util.Map;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"/** This class is generated by EventBus, do not edit. */\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"public class "</span> + clazz + <span class="string">" implements SubscriberInfoIndex &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static final Map&lt;Class&lt;?&gt;, SubscriberInfo&gt; SUBSCRIBER_INDEX;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    static &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX = new HashMap&lt;Class&lt;?&gt;, SubscriberInfo&gt;();\n\n"</span>);</span><br><span class="line">        writeIndexLines(writer, myPackage);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    private static void putIndex(SubscriberInfo info) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SUBSCRIBER_INDEX.put(info.getSubscriberClass(), info);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    @Override\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    public SubscriberInfo getSubscriberInfo(Class&lt;?&gt; subscriberClass) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        SubscriberInfo info = SUBSCRIBER_INDEX.get(subscriberClass);\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        if (info != null) &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return info;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125; else &#123;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"            return null;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"        &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"    &#125;\n"</span>);</span><br><span class="line">        writer.write(<span class="string">"&#125;\n"</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Could not write source for "</span> + index, e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (writer != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                writer.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">//Silent</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">writeIndexLines</span><span class="params">(BufferedWriter writer, String myPackage)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (TypeElement subscriberTypeElement : methodsByClass.keySet()) &#123;</span><br><span class="line">        <span class="comment">// 如果是被包含在 classesToSkip 中的，就跳过</span></span><br><span class="line">        <span class="keyword">if</span> (classesToSkip.contains(subscriberTypeElement)) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 生成对应的 index</span></span><br><span class="line">        String subscriberClass = getClassString(subscriberTypeElement, myPackage);</span><br><span class="line">        <span class="keyword">if</span> (isVisible(myPackage, subscriberTypeElement)) &#123;</span><br><span class="line">            writeLine(writer, <span class="number">2</span>,</span><br><span class="line">                    <span class="string">"putIndex(new SimpleSubscriberInfo("</span> + subscriberClass + <span class="string">".class,"</span>,</span><br><span class="line">                    <span class="string">"true,"</span>, <span class="string">"new SubscriberMethodInfo[] &#123;"</span>);</span><br><span class="line">            List&lt;ExecutableElement&gt; methods = methodsByClass.get(subscriberTypeElement);</span><br><span class="line">            writeCreateSubscriberMethods(writer, methods, <span class="string">"new SubscriberMethodInfo"</span>, myPackage);</span><br><span class="line">            writer.write(<span class="string">"        &#125;));\n\n"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            writer.write(<span class="string">"        // Subscriber not visible to index: "</span> + subscriberClass + <span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的这几行代码应该很眼熟吧，<code>MyEventBusIndex</code> 就是从这个模子里“刻”出来的，都是写死的代码。不同的是在 <code>writeIndexLines(BufferedWriter writer, String myPackage)</code> 中会把之前包含在 <code>classesToSkip</code> 里的跳过，其他的都自动生成 index 。最后就能得到一个像 <code>MyEventBusIndex</code> 一样的索引类了。</p>
<p>另外补充一句，如果你想使用像 <code>MyEventBusIndex</code> 一样的索引类，需要在初始化 <code>EventBus</code> 时通过 <code>EventBus.builder().addIndex(new MyEventBusIndex()).build();</code> 形式来将索引类配置进去。</p>
<p>话已至此，整个 <code>EventBusAnnotationProcessor</code> 我们大致地分析了一遍。利用编译时注解的特性来生成索引类是一种很好的解决途径，避免了程序在运行时利用反射去获取订阅方法，提高了运行效率的同时又提高了逼格。</p>
<h1 id="0006B__u603B_u7ED3"><a href="#0006B__u603B_u7ED3" class="headerlink" title="0006B 总结"></a>0006B 总结</h1><p>从头到尾分析下来，发现 EventBus 真的是一款不错的开源框架，完美诠释了观察者模式。从之前的 2.0 版本到现在的 3.0 版本，加入了注解的同时也减少了反射，提高了性能，为此增添了不少的色彩。</p>
<p>与 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 相似的还有 <a href="https://github.com/square/otto" target="_blank" rel="external">Otto</a> 框架，当然现在业内也有不少使用 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 来实现具备发布/订阅功能的 “RxBus” 。对此我的看法是，如果是小型项目，可以使用 RxBus 来代替 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> ，但是一旦项目成熟起来，涉及到模块之前通信和解耦，那么还是使用更加专业的 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 吧。毕竟若是新手想上手 <a href="https://github.com/ReactiveX/RxJava" target="_blank" rel="external">RxJava</a> 还是需要一段时间的。</p>
<p>今天就到这了，对 <a href="https://github.com/greenrobot/EventBus" target="_blank" rel="external">EventBus</a> 有问题的同学可以留言，bye bye ！</p>
<h1 id="0007B_References"><a href="#0007B_References" class="headerlink" title="0007B References"></a>0007B References</h1><ul>
<li><a href="http://www.jianshu.com/p/f057c460c77e" target="_blank" rel="external">EventBus 3.0 源码分析</a></li>
<li><a href="https://segmentfault.com/a/1190000005089229?utm_source=tuicool&amp;utm_medium=referral#articleHeader11" target="_blank" rel="external">老司机教你 “飙” EventBus 3</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>时近年末，但是也没闲着。最近正好在看 <a href="https://github.com/greenrobot/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[ButterKnife源码分析]]></title>
    <link href="http://yuqirong.me/2016/12/18/ButterKnife%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/12/18/ButterKnife源码解析/</id>
    <published>2016-12-18T15:19:02.000Z</published>
    <updated>2016-12-18T16:58:46.683Z</updated>
    <content type="html"><![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而程序员一般都是懒惰了（懒惰促使人进步 ^ο^ ），所以就出现了很多可以减少重复工作的框架或者工具。比如今天要分析的主角—— <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> ，如果你做 Android 开发却没有听说过 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 那就 Out 啦。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 使用依赖注入的方式来减少程序员去编写一堆 <code>findViewById</code> 的代码，使用起来很方便。那么接下来就一步步地带你深入理解 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 框架。PS：最近写的博客篇幅都有点长，请耐心阅读！Logo 图镇楼！</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161208143552.png" alt="butterknife_logo"></p>
<h1 id="0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5"><a href="#0x02_ButterKnife__u7684_u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="0x02 ButterKnife 的使用方法"></a>0x02 ButterKnife 的使用方法</h1><p>我们先讲下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法：</p>
<ol>
<li><p>在 <code>app/build.gradle</code> 中添加依赖：</p>
<pre><code>dependencies {
  compile &apos;com.jakewharton:butterknife:8.4.0&apos;
  annotationProcessor &apos;com.jakewharton:butterknife-compiler:8.4.0&apos;
}
</code></pre></li>
<li><p>在 <code>Activity</code> 中添加注解：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> </span>&#123;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.user)</span><br><span class="line">  EditText username;</span><br><span class="line">  <span class="annotation">@BindView</span>(R.id.pass)</span><br><span class="line">  EditText password;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@OnClick</span>(R.id.submit)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// TODO onClick View...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">    setContentView(R.layout.simple_activity);</span><br><span class="line">    ButterKnife.bind(<span class="keyword">this</span>);</span><br><span class="line">    <span class="comment">// TODO Use fields...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>使用方法非常简单，不得不赞叹 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 实在是太方便了。彻底跟 <code>findViewById</code> say goodbye 啦。但是我们也认识到，如果一个框架使用起来越简单，那么这个框架内部做的事情就越多。所以在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 内部一定做了很多事情。</p>
<p>今天我们主要分析下 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的三个部分：Annotation 、ButterKnifeProcessor 和 ButterKnife 。这三个部分就把整个 View 依赖注入的原理串联起来了。</p>
<p>准备好了吗？下面我们就一探究竟。（PS：本文分析的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 源码为 8.4.0 版本）</p>
<h1 id="0x03_Annotation"><a href="#0x03_Annotation" class="headerlink" title="0x03 Annotation"></a>0x03 Annotation</h1><p>我们先来看一下其中的注解部分。<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的注解都在 butterknife-annotations 模块下：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161218/20161210153211.png" alt="butterknife注解"></p>
<p>发现我们平时常用的 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 都在里面。我们就挑 <code>@BindView</code> (路径：butterknife-annotations/butterknife/BindView.java) 来看一下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Retention</span>(CLASS)</span><br><span class="line"><span class="annotation">@Target</span>(FIELD)</span><br><span class="line"><span class="keyword">public</span> <span class="annotation">@interface</span> BindView &#123;</span><br><span class="line">  <span class="comment">/** View ID to which the field will be bound. */</span></span><br><span class="line">  <span class="annotation">@IdRes</span> <span class="function"><span class="keyword">int</span> <span class="title">value</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注解都是用 <code>@interface</code> 来表示。在 BindView 注解的上面还有 <code>@Retention</code> 和 <code>@Target</code> 。</p>
<ul>
<li><code>@Retention</code> ：表示注解的保留时间，可选值 SOURCE（源码时），CLASS（编译时），RUNTIME（运行时），默认为 CLASS ；</li>
<li><code>@Target</code> ：表示可以用来修饰哪些程序元素，如 TYPE, METHOD, CONSTRUCTOR, FIELD, PARAMETER 等，未标注则表示可修饰所有。</li>
</ul>
<p>所以我们可知，<code>@BindView</code> 是用来修饰 field 的，并且保留至编译时刻。内部有一个默认属性 <code>value</code> ，用来表示 View 的 id ，即平时程序中的 <code>R.id.xxx</code> 。</p>
<h1 id="0x04_ButterKnifeProcessor"><a href="#0x04_ButterKnifeProcessor" class="headerlink" title="0x04 ButterKnifeProcessor"></a>0x04 ButterKnifeProcessor</h1><p>如果只有 <code>@BindView</code> 是不行的，我们还需要去解析注解。如何去解析编译时的注解呢？我们可以创建一个继承自 <code>AbstractProcessor</code> 的注解处理器，然后实现相关方法。在 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 中 <code>ButterKnifeProcessor</code> (路径：butterknife-compiler/butterknife/compiler/ButterKnifeProcessor.java) 就是用来解析这些注解的注解处理器。</p>
<h2 id="init_28ProcessingEnvironment_env_29"><a href="#init_28ProcessingEnvironment_env_29" class="headerlink" title="init(ProcessingEnvironment env)"></a>init(ProcessingEnvironment env)</h2><p>我们先来看看 <code>ButterKnifeProcessor</code> 中的 <code>init(ProcessingEnvironment env)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ProcessingEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">super</span>.init(env);</span><br><span class="line">	</span><br><span class="line">	String sdk = env.getOptions().get(OPTION_SDK_INT);</span><br><span class="line">	<span class="keyword">if</span> (sdk != <span class="keyword">null</span>) &#123;</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    <span class="keyword">this</span>.sdk = Integer.parseInt(sdk);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (NumberFormatException e) &#123;</span><br><span class="line">	    env.getMessager()</span><br><span class="line">	        .printMessage(Kind.WARNING, <span class="string">"Unable to parse supplied minSdk option '"</span></span><br><span class="line">	            + sdk</span><br><span class="line">	            + <span class="string">"'. Falling back to API 1 support."</span>);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 得到一些有用的工具类</span></span><br><span class="line">	elementUtils = env.getElementUtils();</span><br><span class="line">	typeUtils = env.getTypeUtils();</span><br><span class="line">	filer = env.getFiler();</span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">	  trees = Trees.instance(processingEnv);</span><br><span class="line">	&#125; <span class="keyword">catch</span> (IllegalArgumentException ignored) &#123;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>init</code> 中主要根据 <code>env</code> 得到一些工具类。其中的 <code>filter</code> 主要是用来生成 Java 代码，而 <code>elementUtils</code> 和 <code>typeUtils</code> 会在下面源码中用到。</p>
<h2 id="getSupportedAnnotationTypes_28_29"><a href="#getSupportedAnnotationTypes_28_29" class="headerlink" title="getSupportedAnnotationTypes()"></a>getSupportedAnnotationTypes()</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> List&lt;Class&lt;? extends Annotation&gt;&gt; LISTENERS = Arrays.asList(<span class="comment">//</span></span><br><span class="line">	OnCheckedChanged.class, <span class="comment">//</span></span><br><span class="line">	OnClick.class, <span class="comment">//</span></span><br><span class="line">	OnEditorAction.class, <span class="comment">//</span></span><br><span class="line">	OnFocusChange.class, <span class="comment">//</span></span><br><span class="line">	OnItemClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnItemSelected.class, <span class="comment">//</span></span><br><span class="line">	OnLongClick.class, <span class="comment">//</span></span><br><span class="line">	OnPageChange.class, <span class="comment">//</span></span><br><span class="line">	OnTextChanged.class, <span class="comment">//</span></span><br><span class="line">	OnTouch.class <span class="comment">//</span></span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> Set&lt;String&gt; <span class="title">getSupportedAnnotationTypes</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 返回注解处理器支持处理的注解</span></span><br><span class="line">	Set&lt;String&gt; types = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	<span class="keyword">for</span> (Class&lt;? extends Annotation&gt; annotation : getSupportedAnnotations()) &#123;</span><br><span class="line">	  types.add(annotation.getCanonicalName());</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> types;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 得到所有的注解</span></span><br><span class="line"><span class="keyword">private</span> Set&lt;Class&lt;? extends Annotation&gt;&gt; getSupportedAnnotations() &#123;</span><br><span class="line">	Set&lt;Class&lt;? extends Annotation&gt;&gt; annotations = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	annotations.add(BindArray.class);</span><br><span class="line">	annotations.add(BindBitmap.class);</span><br><span class="line">	annotations.add(BindBool.class);</span><br><span class="line">	annotations.add(BindColor.class);</span><br><span class="line">	annotations.add(BindDimen.class);</span><br><span class="line">	annotations.add(BindDrawable.class);</span><br><span class="line">	annotations.add(BindFloat.class);</span><br><span class="line">	annotations.add(BindInt.class);</span><br><span class="line">	annotations.add(BindString.class);</span><br><span class="line">	annotations.add(BindView.class);</span><br><span class="line">	annotations.add(BindViews.class);</span><br><span class="line">	annotations.addAll(LISTENERS);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> annotations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>getSupportedAnnotationTypes()</code> 方法的作用就是返回该注解处理器所支持处理的注解集合。在 <code>getSupportedAnnotations()</code> 中我们可以看到一些熟悉的注解，比如 <code>@BindView</code> 、<code>@OnClick</code> 和 <code>@OnItemClick</code> 等。</p>
<h2 id="process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29"><a href="#process_28Set_26lt_3B_3F_extends_TypeElement_26gt_3B_elements_2C_RoundEnvironment_env_29" class="headerlink" title="process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)"></a>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</h2><p>接下来就是重头戏了，注解处理器中最重要的方法 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 。<code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 的代码看上去没几行，其实大部分都写在其他私有方法中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">process</span><span class="params">(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// 扫描所有注解，最后生成 map</span></span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = findAndParseTargets(env);</span><br><span class="line">	<span class="comment">// 遍历 bindingMap 并且通过 Filer 生成 Java 代码</span></span><br><span class="line">	<span class="keyword">for</span> (Map.Entry&lt;TypeElement, BindingSet&gt; entry : bindingMap.entrySet()) &#123;</span><br><span class="line">	  TypeElement typeElement = entry.getKey();</span><br><span class="line">	  BindingSet binding = entry.getValue();</span><br><span class="line">	</span><br><span class="line">	  JavaFile javaFile = binding.brewJava(sdk);</span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    javaFile.writeTo(filer);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">	    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage());</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>总体来看 <code>process</code> 方法就干了两件事情：</p>
<ol>
<li>扫描所有的注解，然后生成以 <code>TypeElement</code> 为 key ，<code>BindingSet</code> 为 value 的 Map ；</li>
<li>根据生成的 Map ，遍历后通过 Filter 来生成对应的辅助类源码。PS：<a href="">ButterKnife</a> 使用了 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 来生成 Java 源码。如果对 <a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 不太熟悉，可以先阅读这篇文章 <a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">《javapoet——让你从重复无聊的代码中解放出来》</a> 。</li>
</ol>
<p>我们慢慢来看，先来分析一下 <code>findAndParseTargets(env)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 扫描所有的ButterKnife注解，并且生成以TypeElement为键，BindingSet为值的HashMap</span></span><br><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line">	Map&lt;TypeElement, BindingSet.Builder&gt; builderMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	Set&lt;TypeElement&gt; erasedTargetNames = <span class="keyword">new</span> LinkedHashSet&lt;&gt;();</span><br><span class="line">	</span><br><span class="line">	scanForRClasses(env);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// 省略一堆解析各种注解的源码，这些源码做的事情和下面这个 for 循环一样</span></span><br><span class="line">	<span class="comment">// 所以只要看这个解析 @BindView 就够了</span></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">	<span class="comment">// Process each @BindView element.</span></span><br><span class="line">	<span class="comment">// 遍历所有被 @BindView 标注的元素</span></span><br><span class="line">	<span class="keyword">for</span> (Element element : env.getElementsAnnotatedWith(BindView.class)) &#123;</span><br><span class="line">	  <span class="comment">// we don't SuperficialValidation.validateElement(element)</span></span><br><span class="line">	  <span class="comment">// so that an unresolved View type can be generated by later processing rounds</span></span><br><span class="line">	  <span class="keyword">try</span> &#123;</span><br><span class="line">	    parseBindView(element, builderMap, erasedTargetNames);</span><br><span class="line">	  &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">	    logParsingError(element, BindView.class, e);</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	... </span><br><span class="line">	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>先来看关于 <code>BindView</code> 的那个 for 循环，它会遍历所有被 <code>@BindView</code> 注解的属性，然后调用 <code>parseBindView</code> 方法。那么我们就先看到 <code>findAndParseTargets</code> 的前半段，一起跟进 <code>parseBindView</code> 的方法中去。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseBindView</span><span class="params">(Element element, Map&lt;TypeElement, BindingSet.Builder&gt; builderMap,</span><br><span class="line">      Set&lt;TypeElement&gt; erasedTargetNames)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到注解 @BindView 元素所在的类元素</span></span><br><span class="line">    TypeElement enclosingElement = (TypeElement) element.getEnclosingElement();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Start by verifying common generated code restrictions.</span></span><br><span class="line">    <span class="comment">// ---------- 类型校验逻辑 start ---------------</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在属性上，如果该属性是被 private 或者 static 修饰的，则出错</span></span><br><span class="line">    <span class="comment">// 判断是否被注解在错误的包中，若包名以“android”或者“java”开头，则出错</span></span><br><span class="line">    <span class="keyword">boolean</span> hasError = isInaccessibleViaGeneratedCode(BindView.class, <span class="string">"fields"</span>, element)</span><br><span class="line">        || isBindingInWrongPackage(BindView.class, element);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Verify that the target type extends from View.</span></span><br><span class="line">    TypeMirror elementType = element.asType();</span><br><span class="line">    <span class="keyword">if</span> (elementType.getKind() == TypeKind.TYPEVAR) &#123;</span><br><span class="line">      TypeVariable typeVariable = (TypeVariable) elementType;</span><br><span class="line">      elementType = typeVariable.getUpperBound();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断元素是不是View及其子类或者Interface</span></span><br><span class="line">    <span class="keyword">if</span> (!isSubtypeOfType(elementType, VIEW_TYPE) &amp;&amp; !isInterface(elementType)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (elementType.getKind() == TypeKind.ERROR) &#123;</span><br><span class="line">        note(element, <span class="string">"@%s field with unresolved type (%s) "</span></span><br><span class="line">                + <span class="string">"must elsewhere be generated as a View or interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), elementType, enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        error(element, <span class="string">"@%s fields must extend from View or be an interface. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), enclosingElement.getQualifiedName(),</span><br><span class="line">            element.getSimpleName());</span><br><span class="line">        hasError = <span class="keyword">true</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有错误 不执行下面代码</span></span><br><span class="line">    <span class="keyword">if</span> (hasError) &#123;</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//---------------- 类型校验逻辑 end -----------------</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// Assemble information on the field.  //得到被注解的注解值，即 R.id.xxx</span></span><br><span class="line">    <span class="keyword">int</span> id = element.getAnnotation(BindView.class).value();</span><br><span class="line">    <span class="comment">// 根据所在的类元素去查找 builder</span></span><br><span class="line">    BindingSet.Builder builder = builderMap.get(enclosingElement);</span><br><span class="line">    <span class="comment">// 如果相应的 builder 已经存在</span></span><br><span class="line">    <span class="keyword">if</span> (builder != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="comment">// 得到相对应的 View 绑定的属性名</span></span><br><span class="line">      String existingBindingName = builder.findExistingBindingName(getId(id));</span><br><span class="line">      <span class="comment">// 若该属性名已经存在，则说明之前已经绑定过，会报错</span></span><br><span class="line">      <span class="keyword">if</span> (existingBindingName != <span class="keyword">null</span>) &#123;</span><br><span class="line">        error(element, <span class="string">"Attempt to use @%s for an already bound ID %d on '%s'. (%s.%s)"</span>,</span><br><span class="line">            BindView.class.getSimpleName(), id, existingBindingName,</span><br><span class="line">            enclosingElement.getQualifiedName(), element.getSimpleName());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 如果没有对应的 builder ，就通过 getOrCreateBindingBuilder 方法生成，并且放入 builderMap 中</span></span><br><span class="line">      builder = getOrCreateBindingBuilder(builderMap, enclosingElement);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到注解名</span></span><br><span class="line">    String name = element.getSimpleName().toString();</span><br><span class="line">    <span class="comment">// 得到注解元素的类型</span></span><br><span class="line">    TypeName type = TypeName.get(elementType);</span><br><span class="line">    <span class="keyword">boolean</span> required = isFieldRequired(element);</span><br><span class="line">    <span class="comment">// 根据 id ，添加相对应的 Field 的绑定信息</span></span><br><span class="line">    builder.addField(getId(id), <span class="keyword">new</span> FieldViewBinding(name, type, required));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Add the type-erased version to the valid binding targets set.</span></span><br><span class="line">    <span class="comment">// 添加到待 unbind 的序列中</span></span><br><span class="line">    erasedTargetNames.add(enclosingElement);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>parseBindView</code> 方法中基本上都加了注释，在方法的开头会对该 <code>element</code> 去做校验。如果校验没通过的话，就没有下面代码的什么事了。若校验通过之后，生成该 <code>element</code> 所在的类元素对应的 builder ，builder 中添加相应的 Field 绑定信息，最后添加到待 unbind 的序列中去。</p>
<p>现在，我们回过头来看看 <code>findAndParseTargets(env)</code> 方法的后半段：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;TypeElement, BindingSet&gt; findAndParseTargets(RoundEnvironment env) &#123;</span><br><span class="line"></span><br><span class="line">	... <span class="comment">// 省略前半部分源码</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// Associate superclass binders with their subclass binders. This is a queue-based tree walk</span></span><br><span class="line">	<span class="comment">// which starts at the roots (superclasses) and walks to the leafs (subclasses).</span></span><br><span class="line">	Deque&lt;Map.Entry&lt;TypeElement, BindingSet.Builder&gt;&gt; entries =</span><br><span class="line">	    <span class="keyword">new</span> ArrayDeque&lt;&gt;(builderMap.entrySet());</span><br><span class="line">	Map&lt;TypeElement, BindingSet&gt; bindingMap = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">	<span class="keyword">while</span> (!entries.isEmpty()) &#123;</span><br><span class="line">	  <span class="comment">// 一个个取出遍历</span></span><br><span class="line">	  Map.Entry&lt;TypeElement, BindingSet.Builder&gt; entry = entries.removeFirst();</span><br><span class="line">	  <span class="comment">// 得到对应的 key 和 value</span></span><br><span class="line">	  TypeElement type = entry.getKey();</span><br><span class="line">	  BindingSet.Builder builder = entry.getValue();</span><br><span class="line">	  <span class="comment">// 找到该类元素的父元素</span></span><br><span class="line">	  TypeElement parentType = findParentType(type, erasedTargetNames);</span><br><span class="line">	  <span class="keyword">if</span> (parentType == <span class="keyword">null</span>) &#123;</span><br><span class="line">	    <span class="comment">// 生成 BindingSet ，放入 Map 中</span></span><br><span class="line">	    bindingMap.put(type, builder.build());</span><br><span class="line">	  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	    BindingSet parentBinding = bindingMap.get(parentType);</span><br><span class="line">	    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">	      <span class="comment">// 设置父元素的 BindingSet</span></span><br><span class="line">	      builder.setParent(parentBinding);</span><br><span class="line">	      bindingMap.put(type, builder.build());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	      <span class="comment">// Has a superclass binding but we haven't built it yet. Re-enqueue for later.</span></span><br><span class="line">	      <span class="comment">// 有父元素，但是父元素的 BindingSet 还没有被 build 出来，</span></span><br><span class="line">	      <span class="comment">// 所以再放入 entries 中等待遍历 </span></span><br><span class="line">	      entries.addLast(entry);</span><br><span class="line">	    &#125;</span><br><span class="line">	  &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// 解析结果都会存放在 bindingMap 中</span></span><br><span class="line">	<span class="keyword">return</span> bindingMap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>findAndParseTargets(env)</code> 方法的后半段中，主要就是把之前的 <code>builderMap</code> 转换为了 <code>bindingMap</code> 并返回。</p>
<p>到了这里，我们把 <code>process(Set&lt;? extends TypeElement&gt; elements, RoundEnvironment env)</code> 做的第一件事情搞清楚了，下面就接着来看第二件事情了。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">// 遍历 <span class="keyword">bindingMap </span>并且通过 Filer 生成 Java 代码</span><br><span class="line"><span class="label">for</span> (<span class="preprocessor">Map</span>.Entry&lt;TypeElement, <span class="keyword">BindingSet&gt; </span><span class="preprocessor">entry</span> : <span class="keyword">bindingMap.entrySet()) </span>&#123;</span><br><span class="line">  TypeElement typeElement = <span class="preprocessor">entry</span>.getKey()<span class="comment">;</span></span><br><span class="line">  <span class="keyword">BindingSet </span><span class="keyword">binding </span>= <span class="preprocessor">entry</span>.getValue()<span class="comment">;</span></span><br><span class="line"></span><br><span class="line">  JavaFile javaFile = <span class="keyword">binding.brewJava(sdk);</span><br><span class="line"></span>  try &#123;</span><br><span class="line">    javaFile.writeTo(filer)<span class="comment">;</span></span><br><span class="line">  &#125; catch (IOException e) &#123;</span><br><span class="line">    error(typeElement, <span class="string">"Unable to write binding for type %s: %s"</span>, typeElement, e.getMessage())<span class="comment">;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="brewJava_28int_sdk_29"><a href="#brewJava_28int_sdk_29" class="headerlink" title="brewJava(int sdk)"></a>brewJava(int sdk)</h2><p>从上面可以看到，遍历了之前得到的 <code>bindingMap</code> ，然后利用 <code>binding</code> 中的信息生成相应的 Java 源码。所以在 <code>binding.brewJava(sdk)</code> 这个方法是我们重点关注对象。那么就进入 <code>BindingSet</code> (路径：butterknife-compiler/butterknife/compiler/BindingSet.java) 这个类中去看看吧：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">JavaFile <span class="title">brewJava</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成 JavaFile，添加相应的注释</span></span><br><span class="line">    <span class="keyword">return</span> JavaFile.builder(bindingClassName.packageName(), createType(sdk))</span><br><span class="line">            .addFileComment(<span class="string">"Generated code from Butter Knife. Do not modify!"</span>)</span><br><span class="line">            .build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>brewJava(int sdk)</code> 方法的代码竟然这么短 O_o ，就是利用了 <code>JavaFile.builder</code> 生成了一个 <code>JavaFile</code> 对象而已。但是我们发现其中有一个 <code>createType(int sdk)</code> 方法，隐隐约约感觉一定是这个方法在搞大事情。继续跟进去看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> TypeSpec <span class="title">createType</span><span class="params">(<span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 生成类名为 bindingClassName 的公共类，比如 MainActivity_ViewBinding</span></span><br><span class="line">    TypeSpec.Builder result = TypeSpec.classBuilder(bindingClassName.simpleName())</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 是否修饰为 final ，默认是 false</span></span><br><span class="line">    <span class="keyword">if</span> (isFinal) &#123;</span><br><span class="line">        result.addModifiers(FINAL);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果有父类的话，那么要继承父类</span></span><br><span class="line">        result.superclass(parentBinding.bindingClassName);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有父类，那么实现 Unbinder 接口</span></span><br><span class="line">        result.addSuperinterface(UNBINDER);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 增加一个变量名为target，类型为targetTypeName的成员变量</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        result.addField(targetTypeName, <span class="string">"target"</span>, PRIVATE);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果没有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (!constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// Add a delegating constructor with a target type + view signature for reflective use.</span></span><br><span class="line">        <span class="comment">// 该生成的构造方法被 @deprecated ，一般作为反射使用</span></span><br><span class="line">        result.addMethod(createBindingViewDelegateConstructor(targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 生成构造方法，另外 findViewById 类似的代码都在这里生成</span></span><br><span class="line">    <span class="comment">// Xxxx_ViewBinding 一般都是执行这个方法生成构造器</span></span><br><span class="line">    result.addMethod(createBindingConstructor(targetTypeName, sdk));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings() || parentBinding == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">//生成unBind方法</span></span><br><span class="line">        result.addMethod(createBindingUnbindMethod(result, targetTypeName));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> result.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>createType(int sdk)</code> 方法中，基本构建好了一个类的大概，其中对于构造器以及类似 <code>findViewById</code> 的操作都是在 <code>createBindingConstructor(targetTypeName, sdk)</code> 中实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> MethodSpec <span class="title">createBindingConstructor</span><span class="params">(TypeName targetType, <span class="keyword">int</span> sdk)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建构造方法，方法修饰符为 public ，并且添加注解为UiThread</span></span><br><span class="line">    MethodSpec.Builder constructor = MethodSpec.constructorBuilder()</span><br><span class="line">            .addAnnotation(UI_THREAD)</span><br><span class="line">            .addModifiers(PUBLIC);</span><br><span class="line">    <span class="comment">// 如果有方法绑定，比如 @OnClick</span></span><br><span class="line">    <span class="keyword">if</span> (hasMethodBindings()) &#123;</span><br><span class="line">        <span class="comment">// 如果有，那么添加 targetType 类型，final 修饰，参数名为 target 的构造方法参数</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>, FINAL);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果没有，和上面比起来就少了一个 final 修饰符</span></span><br><span class="line">        constructor.addParameter(targetType, <span class="string">"target"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有注解的 View</span></span><br><span class="line">    <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">        <span class="comment">// 那么添加 View source 参数</span></span><br><span class="line">        constructor.addParameter(VIEW, <span class="string">"source"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 否则添加 Context context 参数</span></span><br><span class="line">        constructor.addParameter(CONTEXT, <span class="string">"context"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (hasUnqualifiedResourceBindings()) &#123;</span><br><span class="line">        <span class="comment">// Aapt can change IDs out from underneath us, just suppress since all will work at runtime.</span></span><br><span class="line">        constructor.addAnnotation(AnnotationSpec.builder(SuppressWarnings.class)</span><br><span class="line">                .addMember(<span class="string">"value"</span>, <span class="string">"$S"</span>, <span class="string">"ResourceType"</span>)</span><br><span class="line">                .build());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果有父类，那么会根据不同情况调用不同的 super 语句</span></span><br><span class="line">    <span class="keyword">if</span> (parentBinding != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (parentBinding.constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source)"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, source.getContext())"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"super(target, context)"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有绑定 Field 或者方法，那么添加 this.target = target 语句</span></span><br><span class="line">    <span class="keyword">if</span> (hasTargetField()) &#123;</span><br><span class="line">        constructor.addStatement(<span class="string">"this.target = target"</span>);</span><br><span class="line">        constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果有 View 绑定</span></span><br><span class="line">    <span class="keyword">if</span> (hasViewBindings()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (hasViewLocal()) &#123;</span><br><span class="line">            <span class="comment">// Local variable in which all views will be temporarily stored.</span></span><br><span class="line">            constructor.addStatement(<span class="string">"$T view"</span>, VIEW);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ViewBinding binding : viewBindings) &#123;</span><br><span class="line">            <span class="comment">// 为 View 绑定生成类似于 findViewById 之类的代码</span></span><br><span class="line">            addViewBinding(constructor, binding);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 为 View 的集合或者数组绑定</span></span><br><span class="line">        <span class="keyword">for</span> (FieldCollectionViewBinding binding : collectionBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">            constructor.addCode(<span class="string">"\n"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 绑定 resource 资源的代码</span></span><br><span class="line">    <span class="keyword">if</span> (!resourceBindings.isEmpty()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (constructorNeedsView()) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T context = source.getContext()"</span>, CONTEXT);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (hasResourceBindingsNeedingResource(sdk)) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$T res = context.getResources()"</span>, RESOURCES);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (ResourceBinding binding : resourceBindings) &#123;</span><br><span class="line">            constructor.addStatement(<span class="string">"$L"</span>, binding.render(sdk));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> constructor.build();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>通过上面的代码就生成了构造器，但是我们还是没有看到具体 <code>findViewById</code> 操作的代码。别急，这些代码都在 <code>addViewBinding(constructor, binding)</code> 里会看到：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addViewBinding</span><span class="params">(MethodSpec.Builder result, ViewBinding binding)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (binding.isSingleFieldBinding()) &#123;</span><br><span class="line">        <span class="comment">// Optimize the common case where there's a single binding directly to a field.</span></span><br><span class="line">        FieldViewBinding fieldBinding = binding.getFieldBinding();</span><br><span class="line">        <span class="comment">// 注意这里直接使用了 target. 的形式，所以属性肯定是不能 private 的</span></span><br><span class="line">        CodeBlock.Builder builder = CodeBlock.builder()</span><br><span class="line">                .add(<span class="string">"target.$L = "</span>, fieldBinding.getName());</span><br><span class="line">        <span class="comment">// 下面都是 View 绑定的代码</span></span><br><span class="line">        <span class="keyword">boolean</span> requiresCast = requiresCast(fieldBinding.getType());</span><br><span class="line">        <span class="keyword">if</span> (!requiresCast &amp;&amp; !fieldBinding.isRequired()) &#123;</span><br><span class="line">            builder.add(<span class="string">"source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            builder.add(<span class="string">"$T.find"</span>, UTILS);</span><br><span class="line">            builder.add(fieldBinding.isRequired() ? <span class="string">"RequiredView"</span> : <span class="string">"OptionalView"</span>);</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">"AsType"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">"(source, $L"</span>, binding.getId().code);</span><br><span class="line">            <span class="keyword">if</span> (fieldBinding.isRequired() || requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $S"</span>, asHumanDescription(singletonList(fieldBinding)));</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (requiresCast) &#123;</span><br><span class="line">                builder.add(<span class="string">", $T.class"</span>, fieldBinding.getRawType());</span><br><span class="line">            &#125;</span><br><span class="line">            builder.add(<span class="string">")"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        result.addStatement(<span class="string">"$L"</span>, builder.build());</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;MemberViewBinding&gt; requiredBindings = binding.getRequiredBindings();</span><br><span class="line">    <span class="keyword">if</span> (requiredBindings.isEmpty()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = source.findViewById($L)"</span>, binding.getId().code);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!binding.isBoundToRoot()) &#123;</span><br><span class="line">        result.addStatement(<span class="string">"view = $T.findRequiredView(source, $L, $S)"</span>, UTILS,</span><br><span class="line">                binding.getId().code, asHumanDescription(requiredBindings));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    addFieldBinding(result, binding);</span><br><span class="line">    <span class="comment">// OnClick 等监听事件绑定</span></span><br><span class="line">    addMethodBindings(result, binding);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>至此，整个 <code>ButterKnifeProcessor</code> 解析注解、生成 Java 代码的流程就走完了。我们来看看生成的代码到底长成什么样子：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity_ViewBinding</span>&lt;<span class="title">T</span> <span class="keyword">extends</span> <span class="title">MainActivity</span>&gt; <span class="keyword">implements</span> <span class="title">Unbinder</span> </span>&#123;</span><br><span class="line">  <span class="keyword">protected</span> T target;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> View view2131427413;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@UiThread</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">MainActivity_ViewBinding</span><span class="params">(<span class="keyword">final</span> T target, View source)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.target = target;</span><br><span class="line"></span><br><span class="line">    View view;</span><br><span class="line">    view = Utils.findRequiredView(source, R.id.button, <span class="string">"field 'button' and method 'onClick'"</span>);</span><br><span class="line">    target.button = Utils.castView(view, R.id.button, <span class="string">"field 'button'"</span>, Button.class);</span><br><span class="line">    view2131427413 = view;</span><br><span class="line">    view.setOnClickListener(<span class="keyword">new</span> DebouncingOnClickListener() &#123;</span><br><span class="line">      <span class="annotation">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doClick</span><span class="params">(View p0)</span> </span>&#123;</span><br><span class="line">        target.onClick(p0);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    target.tv = Utils.findRequiredViewAsType(source, R.id.tv, <span class="string">"field 'textView'"</span>, TextView.class);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="annotation">@Override</span></span><br><span class="line">  <span class="annotation">@CallSuper</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unbind</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    T target = <span class="keyword">this</span>.target;</span><br><span class="line">    <span class="keyword">if</span> (target == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Bindings already cleared."</span>);</span><br><span class="line"></span><br><span class="line">    target.button = <span class="keyword">null</span>;</span><br><span class="line">    target.tv = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    view2131427413.setOnClickListener(<span class="keyword">null</span>);</span><br><span class="line">    view2131427413 = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.target = <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不得不赞叹一句，<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 生成的代码跟我们手写的基本上没什么区别。<a href="https://github.com/square/javapoet" target="_blank" rel="external">JavaPoet</a> 实在是太强大了 *^ο^* 。</p>
<h1 id="0x05_ButterKnife"><a href="#0x05_ButterKnife" class="headerlink" title="0x05 ButterKnife"></a>0x05 ButterKnife</h1><h2 id="bind_28_29"><a href="#bind_28_29" class="headerlink" title="bind()"></a>bind()</h2><p>通过之前介绍 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 的使用方法，我们知道 View 绑定是通过调用 <code>ButterKnife.bind()</code> 方法来实现的。下面我们来看看其内部原理 (路径：butterknife/butterknife/ButterKnife.java) ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull Activity target)</span> </span>&#123;</span><br><span class="line">  View sourceView = target.getWindow().getDecorView();</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, sourceView);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@NonNull</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unbinder <span class="title">bind</span><span class="params">(@NonNull View target)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> createBinding(target, target);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<h2 id="createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29"><a href="#createBinding_28@NonNull_Object_target_2C_@NonNull_View_source_29" class="headerlink" title="createBinding(@NonNull Object target, @NonNull View source)"></a>createBinding(@NonNull Object target, @NonNull View source)</h2><p>发现 <code>bind()</code> 方法内都会去调用 <code>createBinding(@NonNull Object target, @NonNull View source)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Unbinder <span class="title">createBinding</span><span class="params">(@NonNull Object target, @NonNull View source)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 target 的类名，比如 MainActivity </span></span><br><span class="line">    Class&lt;?&gt; targetClass = target.getClass();</span><br><span class="line">    <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Looking up binding for "</span> + targetClass.getName());</span><br><span class="line">    <span class="comment">// 找到 target 对应的构造器</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; constructor = findBindingConstructorForClass(targetClass);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (constructor == <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> Unbinder.EMPTY;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//noinspection TryWithIdenticalCatches Resolves to API 19+ only type.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 创建对应的对象</span></span><br><span class="line">      <span class="keyword">return</span> constructor.newInstance(target, source);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IllegalAccessException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InstantiationException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to invoke "</span> + constructor, e);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (InvocationTargetException e) &#123;</span><br><span class="line">      Throwable cause = e.getCause();</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> RuntimeException) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (RuntimeException) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (cause <span class="keyword">instanceof</span> Error) &#123;</span><br><span class="line">        <span class="keyword">throw</span> (Error) cause;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to create binding instance."</span>, cause);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="annotation">@VisibleForTesting</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Map&lt;Class&lt;?&gt;, Constructor&lt;? extends Unbinder&gt;&gt; BINDINGS = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="annotation">@Nullable</span> <span class="annotation">@CheckResult</span> <span class="annotation">@UiThread</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Constructor&lt;? extends Unbinder&gt; findBindingConstructorForClass(Class&lt;?&gt; cls) &#123;</span><br><span class="line">    <span class="comment">// 对构造器的查找进行了缓存，可以直接从 Map 中获取</span></span><br><span class="line">    Constructor&lt;? extends Unbinder&gt; bindingCtor = BINDINGS.get(cls);</span><br><span class="line">    <span class="keyword">if</span> (bindingCtor != <span class="keyword">null</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Cached in binding map."</span>);</span><br><span class="line">      <span class="keyword">return</span> bindingCtor;</span><br><span class="line">    &#125;</span><br><span class="line">    String clsName = cls.getName();</span><br><span class="line">    <span class="keyword">if</span> (clsName.startsWith(<span class="string">"android."</span>) || clsName.startsWith(<span class="string">"java."</span>)) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"MISS: Reached framework class. Abandoning search."</span>);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 得到对应的 class 对象，比如 MainActivity_ViewBinding</span></span><br><span class="line">      Class&lt;?&gt; bindingClass = Class.forName(clsName + <span class="string">"_ViewBinding"</span>);</span><br><span class="line">      <span class="comment">//noinspection unchecked</span></span><br><span class="line">      <span class="comment">// 得到对应的构造器</span></span><br><span class="line">      bindingCtor = (Constructor&lt;? extends Unbinder&gt;) bindingClass.getConstructor(cls, View.class);</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"HIT: Loaded binding class and constructor."</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">      <span class="keyword">if</span> (debug) Log.d(TAG, <span class="string">"Not found. Trying superclass "</span> + cls.getSuperclass().getName());</span><br><span class="line">      bindingCtor = findBindingConstructorForClass(cls.getSuperclass());</span><br><span class="line">    &#125; <span class="keyword">catch</span> (NoSuchMethodException e) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Unable to find binding constructor for "</span> + clsName, e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 进行缓存</span></span><br><span class="line">    BINDINGS.put(cls, bindingCtor);</span><br><span class="line">    <span class="keyword">return</span> bindingCtor;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其实 <code>createBinding(@NonNull Object target, @NonNull View source)</code> 方法做的事情就是根据 <code>target</code> 创建对应的 <code>targetClassName_ViewBinding</code> 。在 <code>targetClassName_ViewBinding</code> 的构造器中会把对应的 View 进行绑定（具体可以查看上面的 <code>MainActivity_ViewBinding</code> ）。而在 <code>findBindingConstructorForClass(Class&lt;?&gt; cls)</code> 方法中也使用了 <code>Class.forName()</code> 反射来查找 <code>Class</code> ，这也是无法避免的。但是仅限于一个类的第一次查找，之后都会从 <code>BINDINGS</code> 缓存中获取。</p>
<h1 id="0x06__u603B_u7ED3"><a href="#0x06__u603B_u7ED3" class="headerlink" title="0x06 总结"></a>0x06 总结</h1><p>总体来说，<a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 是一款十分优秀的依赖注入框架，方便，高效，减少代码量。最重要的是解放程序员的双手，再也不用去写无聊乏味的 <code>findViewById</code> 了 \(╯-╰)/ 。与 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 原理相似的，还有 <a href="https://github.com/androidannotations/androidannotations" target="_blank" rel="external">androidannotations</a> 框架。感兴趣的同学可以自己研究一下。那么，今天的 <a href="https://github.com/JakeWharton/butterknife" target="_blank" rel="external">ButterKnife</a> 解析到这里就结束了。如果对此有问题或疑惑的同学可以留言，欢迎探讨。</p>
<p>Goodbye !~~</p>
<h1 id="0x07_References"><a href="#0x07_References" class="headerlink" title="0x07 References"></a>0x07 References</h1><ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1NjEwMTM4OA==&amp;mid=2651232205&amp;idx=1&amp;sn=6c24e6eef2b18f253284b9dd92ec7efb&amp;chksm=f1d9eaaec6ae63b82fd84f72c66d3759c693f164ff578da5dde45d367f168aea0038bc3cc8e8&amp;scene=0#wechat_redirect" target="_blank" rel="external">浅析ButterKnife</a></li>
<li><a href="http://dev.qq.com/topic/578753c0c9da73584b025875#rd" target="_blank" rel="external">深入理解 ButterKnife，让你的程序学会写代码</a></li>
<li><a href="http://a.codekk.com/detail/Android/Trinea/%E5%85%AC%E5%85%B1%E6%8A%80%E6%9C%AF%E7%82%B9%E4%B9%8B%20Java%20%E6%B3%A8%E8%A7%A3%20Annotation" target="_blank" rel="external">公共技术点之 Java 注解 Annotation</a></li>
<li><a href="http://www.jianshu.com/p/95f12f72f69a" target="_blank" rel="external">javapoet——让你从重复无聊的代码中解放出来</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x01__u524D_u8A00"><a href="#0x01__u524D_u8A00" class="headerlink" title="0x01 前言"></a>0x01 前言</h1><p>在程序开发的过程中，总会有一些场景需要去写重复冗余的代码。而]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android项目中集成React Native]]></title>
    <link href="http://yuqirong.me/2016/12/04/Android%E9%A1%B9%E7%9B%AE%E4%B8%AD%E9%9B%86%E6%88%90React%20Native/"/>
    <id>http://yuqirong.me/2016/12/04/Android项目中集成React Native/</id>
    <published>2016-12-04T13:04:35.000Z</published>
    <updated>2016-12-14T14:52:19.621Z</updated>
    <content type="html"><![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Native的步骤"></a>集成React Native的步骤</h1><ol>
<li><p>运行以下命令 ：</p>
<pre><code>$ npm init
</code></pre><p> 生成 <code>package.json</code> ，下面给出一份 Demo ：</p>
<pre><code>{
  &quot;name&quot;: &quot;HelloWorld&quot;,
  &quot;version&quot;: &quot;0.0.1&quot;,
  &quot;private&quot;: true,
  &quot;main&quot;: &quot;index.android.js&quot;,
  &quot;scripts&quot;: {
    &quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;,
    &quot;test&quot;: &quot;jest&quot;
  },
  &quot;dependencies&quot;: {
    &quot;react&quot;: &quot;^15.4.1&quot;,
    &quot;react-native&quot;: &quot;^0.39.0&quot;
  }
}
</code></pre></li>
<li><p>运行以下命令安装 React Native , Android 项目根目录就生成了 <code>node_modules/</code> 文件夹：</p>
<pre><code>$ npm install --save react react-native
</code></pre><p> 在 <code>.gitignore</code> 中添加：</p>
<pre><code># node.js
node_modules/
npm-debug.log
</code></pre><p> 执行 <code>react-native upgrade</code> 可以更新已有组件。</p>
</li>
<li><p>运行以下命令生成 <code>.flowconfig</code> 文件：</p>
<pre><code>$ curl -o .flowconfig https://raw.githubusercontent.com/facebook/react-native/master/.flowconfig
</code></pre></li>
<li><p>修改 <code>package.json</code> 中 <code>scripts</code> 的 <code>start</code> 部分：</p>
<pre><code>&quot;start&quot;: &quot;node node_modules/react-native/local-cli/cli.js start&quot;
</code></pre></li>
<li><p>在 Android 项目的根目录下新建 <code>index.android.js</code> ：</p>
<pre><code>&apos;use strict&apos;;

import React from &apos;react&apos;;
import {
  AppRegistry,
  StyleSheet,
  Text,
  View
} from &apos;react-native&apos;;

class HelloWorld extends React.Component {
  render() {
    return (
      &lt;View&gt;
        &lt;Text&gt;Hello, World&lt;/Text&gt;
        &lt;Text&gt;Hello, React Native&lt;/Text&gt;
      &lt;/View&gt;
    )
  }
}

AppRegistry.registerComponent(&apos;HelloWorld&apos;, () =&gt; HelloWorld);
</code></pre></li>
<li><p>在 <code>app/build.gradle</code> 中添加：</p>
<pre><code>defaultConfig {
    ...
    ndk {
        abiFilters &quot;armeabi-v7a&quot;, &quot;x86&quot;
    }
}

dependencies {
    ...
    compile &quot;com.facebook.react:react-native:0.39.0&quot; // From node_modules.
}
</code></pre><p> react-native 依赖的版本和 <code>package.json</code> 中保持一致。</p>
</li>
<li><p>在 Android 项目根目录下的 <code>build.gradle</code> 文件添加如下内容：</p>
<pre><code>allprojects {
    repositories {
        maven {
            // All of React Native (JS, Android binaries) is installed from npm
            url &quot;$rootDir/node_modules/react-native/android&quot;
        }
    }
}
</code></pre></li>
<li><p>新建一个 <code>MyApplication</code> 继承自 <code>Application</code> ，在 <code>AndroidManifest.xml</code> 中修改成相应的 <code>MyApplication</code> ：</p>
<pre><code>public class MyApplication extends Application implements ReactApplication {

    private final ReactNativeHost mReactNativeHost = new ReactNativeHost(this) {
        @Override
        protected boolean getUseDeveloperSupport() {
            return BuildConfig.DEBUG;
        }

        @Override
        protected List&lt;ReactPackage&gt; getPackages() {
            return Arrays.&lt;ReactPackage&gt;asList(
                    new MainReactPackage()
            );
        }

    };

    @Override
    public ReactNativeHost getReactNativeHost() {
        return mReactNativeHost;
    }

    @Override
    public void onCreate() {
        super.onCreate();
        SoLoader.init(this, /* native exopackage */ false);
    }

}
</code></pre></li>
<li><p>新建一个 <code>ReactNativeActivity</code> ，用来展示 React Native 的页面：</p>
<pre><code>public class ReactNativeActivity extends ReactActivity {

    @Override
    protected String getMainComponentName() {
        return &quot;HelloWorld&quot;;
    }

}
</code></pre><p> 其中 <code>getMainComponentName()</code> 返回的字符串要和 index.android.js 中的 <code>AppRegistry.registerComponent</code> 中保持一致。</p>
</li>
<li><p>在 <code>AndroidManifest.xml</code> 里需要添加相关内容</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.INTERNET&quot; /&gt;
&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;

&lt;activity android:name=&quot;.ReactNativeActivity&quot; /&gt;
&lt;activity android:name=&quot;com.facebook.react.devsupport.DevSettingsActivity&quot; /&gt;
</code></pre></li>
<li><p>启动服务。debug 模式下需要在 <code>package.json</code> 所在目录下执行 </p>
<pre><code>$ npm start
</code></pre><p>之后按照正常的 Android 程序调试即可。</p>
</li>
<li><p>发布正式包</p>
<p>JS Bundle 打包：</p>
<p>在 <code>app/src/main/</code> 下创建 <code>assets/</code> 文件夹，执行以下命令将 JS Bundle 保存到资源目录下</p>
<pre><code>$ react-native bundle --platform android --dev false --entry-file index.android.js --bundle-output app/src/main/assets/index.android.bundle --assets-dest app/src/main/res/
</code></pre><p>在 <code>app/src/main/assets/</code> 下就会生成 <code>index.android.bundle</code> 文件。图片会生成在 <code>app/sec/main/res/drawable-mdpi/</code> 目录下。之后按照 Android 项目正常打包即可，但别忘了添加 React Native 的混淆：</p>
<pre><code>-dontobfuscate

# React Native

# Keep our interfaces so they can be used by other ProGuard rules.
# See http://sourceforge.net/p/proguard/bugs/466/
-keep,allowobfuscation @interface com.facebook.proguard.annotations.DoNotStrip
-keep,allowobfuscation @interface com.facebook.proguard.annotations.KeepGettersAndSetters
-keep,allowobfuscation @interface com.facebook.common.internal.DoNotStrip

# Do not strip any method/class that is annotated with @DoNotStrip
-keep @com.facebook.proguard.annotations.DoNotStrip class *
-keep @com.facebook.common.internal.DoNotStrip class *
-keepclassmembers class * {
    @com.facebook.proguard.annotations.DoNotStrip *;
    @com.facebook.common.internal.DoNotStrip *;
}

-keepclassmembers @com.facebook.proguard.annotations.KeepGettersAndSetters class * {
  void set*(***);
  *** get*();
}

-keep class * extends com.facebook.react.bridge.JavaScriptModule { *; }
-keep class * extends com.facebook.react.bridge.NativeModule { *; }
-keepclassmembers,includedescriptorclasses class * { native &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.UIProp &lt;fields&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactProp &lt;methods&gt;; }
-keepclassmembers class *  { @com.facebook.react.uimanager.annotations.ReactPropGroup &lt;methods&gt;; }

-dontwarn com.facebook.react.**

# okhttp

-keepattributes Signature
-keepattributes *Annotation*
-keep class okhttp3.** { *; }
-keep interface okhttp3.** { *; }
-dontwarn okhttp3.**

# okio

-keep class sun.misc.Unsafe { *; }
-dontwarn java.nio.file.*
-dontwarn org.codehaus.mojo.animal_sniffer.IgnoreJRERequirement
-dontwarn okio.**
</code></pre></li>
</ol>
<h1 id="u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898"><a href="#u5728_u96C6_u6210React_Native_u4E2D_u9047_u5230_u7684_u95EE_u9898" class="headerlink" title="在集成React Native中遇到的问题"></a>在集成React Native中遇到的问题</h1><h2 id="Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details"><a href="#Warning_3AConflict_with_dependency__u2018com-google-code-findbugs_3Ajsr305_u2019-_Resolved_versions_for_app__283-0-0_29_and_test_app__282-0-1_29_differ-_See_http_3A//g-co/androidstudio/app-test-app-conflict_for_details" class="headerlink" title="Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See http://g.co/androidstudio/app-test-app-conflict for details."></a>Warning:Conflict with dependency ‘com.google.code.findbugs:jsr305’. Resolved versions for app (3.0.0) and test app (2.0.1) differ. See <a href="http://g.co/androidstudio/app-test-app-conflict" target="_blank" rel="external">http://g.co/androidstudio/app-test-app-conflict</a> for details.</h2><p>在 app/build.gradle 中添加如下：</p>
<pre><code>android {
    ...
    configurations.all {
        resolutionStrategy.force &apos;com.google.code.findbugs:jsr305:3.0.0&apos;
    }
}
</code></pre><h2 id="Cannot_find_module__u2018invariant_u2019"><a href="#Cannot_find_module__u2018invariant_u2019" class="headerlink" title="Cannot find module ‘invariant’"></a>Cannot find module ‘invariant’</h2><p>在调用 <code>react-native init Test</code> 初始化某个项目时，抛出如下异常：</p>
<pre><code>$ react-native init Test
This may take some time...
This will walk you through creating a new React Native project in C:\Users\Administrator\Desktop\Test
Installing react-native package from npm...
module.js:327
    throw err;
    ^

Error: Cannot find module &apos;invariant&apos;
    at Function.Module._resolveFilename (module.js:325:15)
    at Function.Module._load (module.js:276:25)                
    at Module.require (module.js:353:17)
    at require (internal/module.js:12:17)
    at Object.&lt;anonymous&gt; (C:/Users/Administrator/Desktop/Test/node_modules/react-native/packager/react-packager/src/node-haste/Module.js:18:19)
    at Module._compile (module.js:409:26)
    at loader (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:144:5)
    at Object.require.extensions.(anonymous function) [as .js] (C:\Users\Administrator\Desktop\Test\node_modules\react-native\node_modules\babel-register\lib\node.js:154:7)
    at Module.load (module.js:343:32)
    at Function.Module._load (module.js:300:12)
</code></pre><p>解决方案：调用 <code>npm i --save-dev invariant</code> 命令，详见 <a href="https://github.com/facebook/react-native/issues/11327" target="_blank" rel="external">Cannot find module ‘invariant’ - react-native-cli</a></p>
<h2 id="java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019"><a href="#java-lang-IllegalAccessError_3A_Method__u2018void_android-support-v4-net-ConnectivityManagerCompat-_28_29_u2019_is_inaccessible_to_class__u2018com-facebook-react-modules-netinfo-NetInfoModule_u2019" class="headerlink" title="java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’"></a>java.lang.IllegalAccessError: Method ‘void android.support.v4.net.ConnectivityManagerCompat.<init\>()’ is inaccessible to class ‘com.facebook.react.modules.netinfo.NetInfoModule’</init\></h2><p>在 React Native 程序运行时，报错：</p>
<pre><code>E/AndroidRuntime: FATAL EXCEPTION: AsyncTask #1
    Process: com.fanwei.reactnativeupdate, PID: 3139
    java.lang.RuntimeException: An error occured while executing doInBackground()
        at android.os.AsyncTask$3.done(AsyncTask.java:304)
        at java.util.concurrent.FutureTask.finishCompletion(FutureTask.java:355)
        at java.util.concurrent.FutureTask.setException(FutureTask.java:222)
        at java.util.concurrent.FutureTask.run(FutureTask.java:242)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231)
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587)
        at java.lang.Thread.run(Thread.java:818)
     Caused by: java.lang.IllegalAccessError: Method &apos;void android.support.v4.net.ConnectivityManagerCompat.&lt;init&gt;()&apos; is inaccessible to class &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; (declaration of &apos;com.facebook.react.modules.netinfo.NetInfoModule&apos; appears in /data/data/com.fanwei.reactnativeupdate/files/instant-run/dex/slice-com.facebook.react-react-native-0.20.1_3b7c8d9b91d5c989075fbd631ac74b192cee741b-classes.dex)
        at com.facebook.react.modules.netinfo.NetInfoModule.&lt;init&gt;(NetInfoModule.java:55)
        at com.facebook.react.shell.MainReactPackage.createNativeModules(MainReactPackage.java:67)
        at com.facebook.react.ReactInstanceManagerImpl.processPackage(ReactInstanceManagerImpl.java:793)
        at com.facebook.react.ReactInstanceManagerImpl.createReactContext(ReactInstanceManagerImpl.java:730)
        at com.facebook.react.ReactInstanceManagerImpl.access$600(ReactInstanceManagerImpl.java:91)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:184)
        at com.facebook.react.ReactInstanceManagerImpl$ReactContextInitAsyncTask.doInBackground(ReactInstanceManagerImpl.java:169)
        at android.os.AsyncTask$2.call(AsyncTask.java:292)
        at java.util.concurrent.FutureTask.run(FutureTask.java:237)
        at android.os.AsyncTask$SerialExecutor$1.run(AsyncTask.java:231) 
        at java.util.concurrent.ThreadPoolExecutor.runWorker(ThreadPoolExecutor.java:1112) 
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:587) 
        at java.lang.Thread.run(Thread.java:818) 
</code></pre><p>解决方案：修改依赖为 <code>com.android.support:appcompat-v7:23.0.1</code> ，详见 <a href="https://github.com/facebook/react-native/issues/6152" target="_blank" rel="external">Android java.lang.IllegalAccessError Method void android.support.v4.net.ConnectivityManagerCompat</a></p>
<h2 id="ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29"><a href="#ERROR_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019__7B_u201Cerrno_u201D_3A-4048_2C_u201Dcode_u201D_3A_u201DEPERM_u201D_2C_u201Dsyscall_u201D_3A_u201Dlstat_u201D_2C_u201Dpath_u201D_3A_u201DC_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u201D_7DError_3A_EPERM_3A_operation_not_permitted_2C_lstat__u2018C_3A_5CUsers_5CAdministrator_5CDesktop_5CReactNativeUpdate_5Capp_5Cbuild_5Cgenerated_5Cassets_5Cshaders_5Cdebug_u2019_at_Error__28native_29" class="headerlink" title="ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)"></a>ERROR EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ {“errno”:-4048,”code”:”EPERM”,”syscall”:”lstat”,”path”:”C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug”}Error: EPERM: operation not permitted, lstat ‘C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug’ at Error (native)</h2><p>在调用命令 <code>npm start</code> 时，出现以下错误：</p>
<pre><code>ERROR  EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
{&quot;errno&quot;:-4048,&quot;code&quot;:&quot;EPERM&quot;,&quot;syscall&quot;:&quot;lstat&quot;,&quot;path&quot;:&quot;C:\\Users\\Administrator\\Desktop\\ReactNativeUpdate\\app\\build\\generated\\assets\\shaders\\debug&quot;}
Error: EPERM: operation not permitted, lstat &apos;C:\Users\Administrator\Desktop\ReactNativeUpdate\app\build\generated\assets\shaders\debug&apos;
    at Error (native)
</code></pre><p>解决方案：打开项目中 <code>node_modules/react-native/local-cli/server/server.js</code> 找到  <code>process.on(&#39;uncaughtException&#39;, error =&gt; {</code> 这个方法，把最后一句 <code>process.exit(11);</code> 注释掉。</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://facebook.github.io/react-native/docs/integration-with-existing-apps.html" target="_blank" rel="external">Integration With Existing Apps</a></li>
<li><a href="http://www.lcode.org/react-native%e7%a7%bb%e6%a4%8d%e5%8e%9f%e7%94%9fandroid%e9%a1%b9%e7%9b%ae-%e5%b7%b2%e6%9b%b4%e6%96%b0%e7%89%88%e6%9c%ac/" target="_blank" rel="external">React Native移植原生Android项目-已更新版本</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u96C6_u6210React_Native_u7684_u6B65_u9AA4"><a href="#u96C6_u6210React_Native_u7684_u6B65_u9AA4" class="headerlink" title="集成React Na]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Volley框架源码解析]]></title>
    <link href="http://yuqirong.me/2016/11/19/Volley%E6%A1%86%E6%9E%B6%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/11/19/Volley框架源码解析/</id>
    <published>2016-11-19T13:19:17.000Z</published>
    <updated>2016-11-30T14:46:18.722Z</updated>
    <content type="html"><![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用于网络请求非常频繁但是数据量并不是特别大的情景，正如它的名字一样。Volley 相比其他网络框架而言，采用了在 Android 2.3 以下使用 HttpClient ，而 Android 2.3 及以上使用 HttpUrlConnection 的方案。这是因为在 Android 2.3 以下时，HttpUrlConnection 并不完善，有很多 bug 存在。因此在 Android 2.3 以下最好使用 HttpClient 来进行网络通信；而在 Android 2.3 及以上，HttpUrlConnection 比起 HttpClient 来说更加简单易用，修复了之前的 bug 。所以在 Android 2.3 及以上我们使用 HttpUrlConnection 来进行网络通信。</p>
<p>除此之外，Volley 框架还具有优先级处理、可扩展性强等特点。虽然现在有 Retrofit 、OkHttp 等十分优秀的网络通信框架，但是深入理解 Volley 框架内部的思想可以大大提高我们自身的技术水平，毕竟仅仅停留在只会使用的阶段是不行的哦。那么，下面就进入我们今天的正题吧！（ ps ：本文篇幅过长，可能会引起不适，请在家长的陪同下观看）</p>
<h1 id="0010B"><a href="#0010B" class="headerlink" title="0010B"></a>0010B</h1><h2 id="Volley__u4F7F_u7528_u65B9_u6CD5"><a href="#Volley__u4F7F_u7528_u65B9_u6CD5" class="headerlink" title="Volley 使用方法"></a>Volley 使用方法</h2><p>在长篇大论地解析 Volley 框架源码之前，我们先来看看平时是怎样使用 Volley 的。（大牛可直接跳过 -_- ）</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">RequestQueue mQueue = Volley.newRequestQueue(context);</span><br><span class="line">JsonObjectRequest request = <span class="keyword">new</span> JsonObjectRequest(url, <span class="keyword">null</span>,</span><br><span class="line">        <span class="keyword">new</span> Response.Listener&lt;JSONObject&gt;() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(JSONObject jsonObject)</span> </span>&#123;</span><br><span class="line">            	<span class="comment">// TODO </span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="keyword">new</span> Response.ErrorListener() &#123;</span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">		<span class="comment">// TODO </span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">mQueue.add(request);</span><br></pre></td></tr></table></figure>
<p>我们通过 <code>Volley.newRequestQueue(context)</code> 来得到一个请求队列的对象 <code>mQueue</code>，在队列中暂存了我们所有 add 进去的 request ，之后一个个取出 request 来进行网络通信。一般来说，在一个应用程序中，只保持一个请求队列的对象。</p>
<p>之后创建了 JsonObjectRequest 对象用来请求 JSON 数据，并把它加入 <code>mQueue</code> 的队列中。Volley 框架的使用方法非常简单，并且有多种 request 请求方式可以选择，使用方法都是和上面类似的。</p>
<h1 id="0011B"><a href="#0011B" class="headerlink" title="0011B"></a>0011B</h1><p>在这先把 Volley 框架中几个重要的类的作用讲一下，以便看源码时能够更加明白：</p>
<ul>
<li>RequestQueue ：这个大家一看都明白，用来缓存 request 的请求队列，根据优先级高低排列；</li>
<li>Request ：表示网络请求，本身是一个抽象类，子类有 StringRequest 、JsonRequest 、ImageRequest 等；</li>
<li>Response ：表示网络请求后的响应，也是一个抽象类。内部定义了 Listener 、ErrorListener 接口；</li>
<li>NetworkResponse ：对返回的 HttpResponse 内容进行了封装，虽然类名和 Response 差不多，但是不是 Response 的子类；</li>
<li>CacheDispatcher ：一个处理请求缓存的线程。不断从 RequestQueue 中取出 Request ，然后取得该 Request 对应的缓存，若缓存存在就调用 ResponseDelivery 做后续分发处理；如果没有缓存或者缓存失效需要进入 NetworkDispatcher 中从网络上获取结果；</li>
<li>NetworkDispatcher ：一个处理网络请求的线程。和 CacheDispatcher 类似，从网络上得到响应后调用 ResponseDelivery 做后续分发处理。而且根据需求判断是否需要做缓存处理；</li>
<li>ResponseDelivery ：用作分发处理。利用 Handler 把结果回调到主线程中，即 Listener 、ErrorListener 接口。主要实现类为 ExecutorDelivery ；</li>
<li>HttpStack ：主要作用就是发起 Http 请求。子类分为 HurlStack 和 HttpClientStack ，分别对应着 HttpUrlConnection 和 HttpClient ；</li>
<li>Network ：处理 Stack 发起的 Http 请求，把 Request 转换为 Response ，主要实现类为 BasicNetwork ；</li>
<li>RetryPolicy ：请求重试策略。主要实现类为 DefaultRetryPolicy ；</li>
<li>Cache ：网络请求的缓存。在 CacheDispatcher 中获取 Cache ，在 NetworkDispatcher 中判断是否保存 Cache 。主要实现类为 DiskBasedCache ，缓存在磁盘中。</li>
</ul>
<h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h2><p>看完了之后，我们就要开始源码解析。我们入手点就是 <code>Volley.newRequestQueue(context)</code> 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Volley</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 默认的磁盘缓存目录名 */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> String DEFAULT_CACHE_DIR = <span class="string">"volley"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context, HttpStack stack)</span> </span>&#123;</span><br><span class="line">        File cacheDir = <span class="keyword">new</span> File(context.getCacheDir(), DEFAULT_CACHE_DIR);</span><br><span class="line">        <span class="comment">// 设置 UA</span></span><br><span class="line">        String userAgent = <span class="string">"volley/0"</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            String packageName = context.getPackageName();</span><br><span class="line">            PackageInfo info = context.getPackageManager().getPackageInfo(packageName, <span class="number">0</span>);</span><br><span class="line">            userAgent = packageName + <span class="string">"/"</span> + info.versionCode;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NameNotFoundException e) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 根据 Android SDK 版本设置 HttpStack ，分为 HurlStack 和 HttpClientStack</span></span><br><span class="line">        <span class="comment">// 分别对应着 HttpUrlConnection 和 HttpClient</span></span><br><span class="line">        <span class="keyword">if</span> (stack == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= <span class="number">9</span>) &#123;</span><br><span class="line">                stack = <span class="keyword">new</span> HurlStack();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// Prior to Gingerbread, HttpUrlConnection was unreliable.</span></span><br><span class="line">                <span class="comment">// See: http://android-developers.blogspot.com/2011/09/androids-http-clients.html</span></span><br><span class="line">                stack = <span class="keyword">new</span> HttpClientStack(AndroidHttpClient.newInstance(userAgent));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 得到 network</span></span><br><span class="line">        Network network = <span class="keyword">new</span> BasicNetwork(stack);</span><br><span class="line">        <span class="comment">// 创建 RequestQueue</span></span><br><span class="line">        RequestQueue queue = <span class="keyword">new</span> RequestQueue(<span class="keyword">new</span> DiskBasedCache(cacheDir), network);</span><br><span class="line">        queue.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> queue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> RequestQueue <span class="title">newRequestQueue</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> newRequestQueue(context, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面 Volley 类的源码中可知，Volley 类主要就是用来创建 RequestQueue 的。我们之前使用的 <code>newRequestQueue(Context context)</code> 方法最终会调用 <code>newRequestQueue(Context context, HttpStack stack)</code> 。Volley 允许我们使用自定义的 HttpStack ，从这也可以看出 Volley 具有很强的扩展性。</p>
<h2 id="RequestQueue"><a href="#RequestQueue" class="headerlink" title="RequestQueue"></a>RequestQueue</h2><p>接下来继续跟踪 RequestQueue 构造方法的代码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 默认线程池数量为 4</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_NETWORK_THREAD_POOL_SIZE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, DEFAULT_NETWORK_THREAD_POOL_SIZE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(cache, network, threadPoolSize,</span><br><span class="line">            <span class="keyword">new</span> ExecutorDelivery(<span class="keyword">new</span> Handler(Looper.getMainLooper())));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">RequestQueue</span><span class="params">(Cache cache, Network network, <span class="keyword">int</span> threadPoolSize,</span><br><span class="line">        ResponseDelivery delivery)</span> </span>&#123;</span><br><span class="line">    mCache = cache;</span><br><span class="line">    mNetwork = network;</span><br><span class="line">    mDispatchers = <span class="keyword">new</span> NetworkDispatcher[threadPoolSize];</span><br><span class="line">    mDelivery = delivery;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在构造方法中创建了 ExecutorDelivery 对象，ExecutorDelivery 中传入的 Handler 为主线程的，方便得到 Response 后回调；NetworkDispatcher[] 数组对象，默认数组的长度为 4 ，也就意味着默认处理请求的线程最多为 4 个。</p>
<p>在 <code>Volley.newRequestQueue(Context context, HttpStack stack)</code> 中创建完 RequestQueue 对象 <code>queue</code> 之后，还调用了 <code>queue.start()</code> 方法。主要用于启动 <code>queue</code> 中的 <code>mCacheDispatcher</code> 和 <code>mDispatchers</code> 。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** 请求缓存队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mCacheQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">/** 网络请求队列 */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt; mNetworkQueue =</span><br><span class="line">    <span class="keyword">new</span> PriorityBlockingQueue&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    stop();  <span class="comment">// 确保当前 RequestQueue 中的 mCacheDispatcher 和 mDispatchers[] 是关闭的</span></span><br><span class="line">    <span class="comment">// 创建 mCacheDispatcher ，并且开启</span></span><br><span class="line">    mCacheDispatcher = <span class="keyword">new</span> CacheDispatcher(mCacheQueue, mNetworkQueue, mCache, mDelivery);</span><br><span class="line">    mCacheDispatcher.start();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据 mDispatchers[] 数组的长度创建 networkDispatcher ，并且开启</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        NetworkDispatcher networkDispatcher = <span class="keyword">new</span> NetworkDispatcher(mNetworkQueue, mNetwork,</span><br><span class="line">                mCache, mDelivery);</span><br><span class="line">        mDispatchers[i] = networkDispatcher;</span><br><span class="line">        networkDispatcher.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关闭当前的 mCacheDispatcher 和 mDispatchers[]</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mCacheDispatcher != <span class="keyword">null</span>) &#123;</span><br><span class="line">        mCacheDispatcher.quit();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; mDispatchers.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (mDispatchers[i] != <span class="keyword">null</span>) &#123;</span><br><span class="line">            mDispatchers[i].quit();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Remove from the set of requests currently being processed.</span></span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">// 从 mCurrentRequests 中移除该 request</span></span><br><span class="line">        mCurrentRequests.remove(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果 request 是可以被缓存的，那么从 mWaitingRequests 中移除，加入到 mCacheQueue 中 	</span></span><br><span class="line">    <span class="keyword">if</span> (request.shouldCache()) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">            String cacheKey = request.getCacheKey();</span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; waitingRequests = mWaitingRequests.remove(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (waitingRequests != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                    VolleyLog.v(<span class="string">"Releasing %d waiting requests for cacheKey=%s."</span>,</span><br><span class="line">                            waitingRequests.size(), cacheKey);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Process all queued up requests. They won't be considered as in flight, but</span></span><br><span class="line">                <span class="comment">// that's not a problem as the cache has been primed by 'request'.</span></span><br><span class="line">                mCacheQueue.addAll(waitingRequests);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么看到这里我们意识到有必要看一下 CacheDispatcher 和 NetworkDispatcher 的代码。我们先暂且放一下，来看看 RequestQueue 的 <code>add</code> 方法。<code>add</code> 方法就是把 Request 加入到 RequestQueue 中了：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Map&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt; mWaitingRequests =</span><br><span class="line">        <span class="keyword">new</span> HashMap&lt;String, Queue&lt;Request&lt;?&gt;&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 当前正在请求的 Set 集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Set&lt;Request&lt;?&gt;&gt; mCurrentRequests = <span class="keyword">new</span> HashSet&lt;Request&lt;?&gt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Request&lt;T&gt; <span class="title">add</span><span class="params">(Request&lt;T&gt; request)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Tag the request as belonging to this queue and add it to the set of current requests.</span></span><br><span class="line">    request.setRequestQueue(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">synchronized</span> (mCurrentRequests) &#123;</span><br><span class="line">        <span class="comment">//加入到当前请求队列中</span></span><br><span class="line">        mCurrentRequests.add(request);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 设置序列号，该序列号为 AtomInteger 自增的值</span></span><br><span class="line">    request.setSequence(getSequenceNumber());</span><br><span class="line">    request.addMarker(<span class="string">"add-to-queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果该 request 不该缓存，则直接加入 mNetworkQueue ，跳过下面的步骤</span></span><br><span class="line">    <span class="keyword">if</span> (!request.shouldCache()) &#123;</span><br><span class="line">        mNetworkQueue.add(request);</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">synchronized</span> (mWaitingRequests) &#123;</span><br><span class="line">        <span class="comment">// 其实 cacheKey 就是 request 的 url</span></span><br><span class="line">        String cacheKey = request.getCacheKey();</span><br><span class="line">        <span class="comment">// 如果该 mWaitingRequests 已经包含了有该 cacheKey</span></span><br><span class="line">        <span class="keyword">if</span> (mWaitingRequests.containsKey(cacheKey)) &#123;</span><br><span class="line">            <span class="comment">// 得到该 cacheKey 对应的 Queue</span></span><br><span class="line">            Queue&lt;Request&lt;?&gt;&gt; stagedRequests = mWaitingRequests.get(cacheKey);</span><br><span class="line">            <span class="keyword">if</span> (stagedRequests == <span class="keyword">null</span>) &#123;</span><br><span class="line">                stagedRequests = <span class="keyword">new</span> LinkedList&lt;Request&lt;?&gt;&gt;();</span><br><span class="line">            &#125;</span><br><span class="line">            stagedRequests.add(request);</span><br><span class="line">            <span class="comment">// 把该 request 加入到 mWaitingRequests</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, stagedRequests);</span><br><span class="line">            <span class="keyword">if</span> (VolleyLog.DEBUG) &#123;</span><br><span class="line">                VolleyLog.v(<span class="string">"Request for cacheKey=%s is in flight, putting on hold."</span>, cacheKey);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果没有，那么将该 request 加入到 mCacheQueue 中</span></span><br><span class="line">            mWaitingRequests.put(cacheKey, <span class="keyword">null</span>);</span><br><span class="line">            mCacheQueue.add(request);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> request;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>add(Request&lt;T&gt; request)</code> 方法中，额外使用了两个集合来维护 Request ，其中 </p>
<ul>
<li>mCurrentRequests ：用来维护正在做请求操作的 Request；</li>
<li>mWaitingRequests ：主要作用是如果当前有一个 Request 正在请求并且是可以缓存的，那么 Volley 会去 mWaitingRequests 中根据该 cacheKey 查询之前有没有一样的 Request 被加入到 mWaitingRequests 中。若有，那么该 Request 就不需要再被缓存了；若没有就加入到 mCacheQueue 中进行后续操作。</li>
</ul>
<p>现在我们来看看 CacheDispatcher 和 NetworkDispatcher 类的源码。</p>
<h2 id="CacheDispatcher"><a href="#CacheDispatcher" class="headerlink" title="CacheDispatcher"></a>CacheDispatcher</h2><p>首先是 CacheDispatcher 的：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 结束当前线程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG) VolleyLog.v(<span class="string">"start new dispatcher"</span>);</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 初始化 mCache ，读取磁盘中的缓存文件，加载到 mCache 中的 map 中</span></span><br><span class="line">        <span class="comment">// 会造成线程阻塞，要在子线程中调用</span></span><br><span class="line">        mCache.initialize();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 从缓存队列中取出 request ，若没有则会阻塞</span></span><br><span class="line">                <span class="keyword">final</span> Request&lt;?&gt; request = mCacheQueue.take();</span><br><span class="line">                request.addMarker(<span class="string">"cache-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 被标记为取消，则跳过该 request ，不分发</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"cache-discard-canceled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 根据 request 的 url 去获得缓存</span></span><br><span class="line">                Cache.Entry entry = mCache.get(request.getCacheKey());</span><br><span class="line">                <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-miss"</span>);</span><br><span class="line">                    <span class="comment">// 没有缓存，把 Request 放入网络请求队列中 </span></span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 若缓存失效，也放入网络请求队列中</span></span><br><span class="line">                <span class="keyword">if</span> (entry.isExpired()) &#123;</span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-expired"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line">                    mNetworkQueue.put(request);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 缓存存在，把缓存转换为 Response</span></span><br><span class="line">                request.addMarker(<span class="string">"cache-hit"</span>);</span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(</span><br><span class="line">                        <span class="keyword">new</span> NetworkResponse(entry.data, entry.responseHeaders));</span><br><span class="line">                request.addMarker(<span class="string">"cache-hit-parsed"</span>);</span><br><span class="line">                <span class="comment">// 判断缓存是否需要刷新</span></span><br><span class="line">                <span class="keyword">if</span> (!entry.refreshNeeded()) &#123;</span><br><span class="line">                    <span class="comment">// 不需要刷新就直接让 mDelivery 分发</span></span><br><span class="line">                    mDelivery.postResponse(request, response);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 需要刷新缓存</span></span><br><span class="line">                    request.addMarker(<span class="string">"cache-hit-refresh-needed"</span>);</span><br><span class="line">                    request.setCacheEntry(entry);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 先设置一个标志，表明该缓存可以先分发，之后需要重新刷新</span></span><br><span class="line">                    response.intermediate = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// 利用 mDelivery 先把 response 分发下去，之后还要把该 request 加入到 mNetworkQueue 重新请求一遍</span></span><br><span class="line">                    mDelivery.postResponse(request, response, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                        <span class="annotation">@Override</span></span><br><span class="line">                        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                            <span class="keyword">try</span> &#123;</span><br><span class="line">                                mNetworkQueue.put(request);</span><br><span class="line">                            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                                <span class="comment">// Not much we can do about this.</span></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>CacheDispatcher 类主要的代码就如上面所示了，在主要的 <code>run()</code> 方法中都添加了注释，阅读起来应该比较简单。那么在这里就贡献一张 CacheDispatcher 类的流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161122231354.png" alt="CacheDispatcher 类的流程图"></p>
<h2 id="NetworkDispatcher"><a href="#NetworkDispatcher" class="headerlink" title="NetworkDispatcher"></a>NetworkDispatcher</h2><p>然后是 NetworkDispatcher 的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NetworkDispatcher</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	...... <span class="comment">// 省略部分源码</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">quit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        mQuit = <span class="keyword">true</span>;</span><br><span class="line">        interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addTrafficStatsTag</span><span class="params">(Request&lt;?&gt; request)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Tag the request (if API &gt;= 14)</span></span><br><span class="line">        <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.ICE_CREAM_SANDWICH) &#123;</span><br><span class="line">            TrafficStats.setThreadStatsTag(request.getTrafficStatsTag());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND);</span><br><span class="line">        Request&lt;?&gt; request;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 取出 request</span></span><br><span class="line">                request = mQueue.take();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// We may have been interrupted because it was time to quit.</span></span><br><span class="line">                <span class="keyword">if</span> (mQuit) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                request.addMarker(<span class="string">"network-queue-take"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 判断是否被取消，和 CacheDispatcher 中的步骤一致</span></span><br><span class="line">                <span class="keyword">if</span> (request.isCanceled()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"network-discard-cancelled"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 设置线程标识</span></span><br><span class="line">                addTrafficStatsTag(request);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 处理网络请求</span></span><br><span class="line">                NetworkResponse networkResponse = mNetwork.performRequest(request);</span><br><span class="line">                request.addMarker(<span class="string">"network-http-complete"</span>);</span><br><span class="line">                </span><br><span class="line">                <span class="comment">// 如果服务端返回 304 并且已经分发了一个响应，那么不再进行二次分发</span></span><br><span class="line">                <span class="keyword">if</span> (networkResponse.notModified &amp;&amp; request.hasHadResponseDelivered()) &#123;</span><br><span class="line">                    request.finish(<span class="string">"not-modified"</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 得到 response</span></span><br><span class="line">                Response&lt;?&gt; response = request.parseNetworkResponse(networkResponse);</span><br><span class="line">                request.addMarker(<span class="string">"network-parse-complete"</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该 request 需要进行缓存，那么保存缓存</span></span><br><span class="line">                <span class="comment">// <span class="doctag">TODO:</span> Only update cache metadata instead of entire record for 304s.</span></span><br><span class="line">                <span class="keyword">if</span> (request.shouldCache() &amp;&amp; response.cacheEntry != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    mCache.put(request.getCacheKey(), response.cacheEntry);</span><br><span class="line">                    request.addMarker(<span class="string">"network-cache-written"</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 标记该 request 对应的 response 正在分发中</span></span><br><span class="line">                request.markDelivered();</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 response</span></span><br><span class="line">                mDelivery.postResponse(request, response);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (VolleyError volleyError) &#123;</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                parseAndDeliverNetworkError(request, volleyError);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                VolleyLog.e(e, <span class="string">"Unhandled exception %s"</span>, e.toString());</span><br><span class="line">                <span class="comment">// 分发该 request 对应的 error</span></span><br><span class="line">                mDelivery.postError(request, <span class="keyword">new</span> VolleyError(e));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">parseAndDeliverNetworkError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        error = request.parseNetworkError(error);</span><br><span class="line">        mDelivery.postError(request, error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的，根据 NetworkDispatcher 我们也可以梳理出一张流程图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161123222635.png" alt="NetworkDispatcher 类的流程图"></p>
<h2 id="Request"><a href="#Request" class="headerlink" title="Request"></a>Request</h2><p>到这里，我们把目光转向 Request 。Request 是一个抽象类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Request</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Request</span>&lt;<span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">	...<span class="comment">// 省略绝大部分源码-_- !</span></span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> Response&lt;T&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">abstract</span> <span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">protected</span> VolleyError <span class="title">parseNetworkError</span><span class="params">(VolleyError volleyError)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">return</span> volleyError;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deliverError</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mErrorListener != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        mErrorListener.onErrorResponse(error);</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// request 完成响应分发后调用 </span></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">finish</span><span class="params">(<span class="keyword">final</span> String tag)</span> </span>&#123;</span><br><span class="line">	    <span class="keyword">if</span> (mRequestQueue != <span class="keyword">null</span>) &#123;</span><br><span class="line">	        <span class="comment">// 跳转到 RequestQueue.finish 方法</span></span><br><span class="line">	        mRequestQueue.finish(<span class="keyword">this</span>);</span><br><span class="line">	    &#125;</span><br><span class="line">	    <span class="keyword">if</span> (MarkerLog.ENABLED) &#123;</span><br><span class="line">	        <span class="keyword">final</span> <span class="keyword">long</span> threadId = Thread.currentThread().getId();</span><br><span class="line">	        <span class="keyword">if</span> (Looper.myLooper() != Looper.getMainLooper()) &#123;</span><br><span class="line">	            <span class="comment">// If we finish marking off of the main thread, we need to</span></span><br><span class="line">	            <span class="comment">// actually do it on the main thread to ensure correct ordering.</span></span><br><span class="line">	            Handler mainThread = <span class="keyword">new</span> Handler(Looper.getMainLooper());</span><br><span class="line">	            mainThread.post(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">	                <span class="annotation">@Override</span></span><br><span class="line">	                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">	                    mEventLog.add(tag, threadId);</span><br><span class="line">	                    mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	                &#125;</span><br><span class="line">	            &#125;);</span><br><span class="line">	            <span class="keyword">return</span>;</span><br><span class="line">	        &#125;</span><br><span class="line">	</span><br><span class="line">	        mEventLog.add(tag, threadId);</span><br><span class="line">	        mEventLog.finish(<span class="keyword">this</span>.toString());</span><br><span class="line">	    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	        <span class="keyword">long</span> requestTime = SystemClock.elapsedRealtime() - mRequestBirthTime;</span><br><span class="line">	        <span class="keyword">if</span> (requestTime &gt;= SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">	            VolleyLog.d(<span class="string">"%d ms: %s"</span>, requestTime, <span class="keyword">this</span>.toString());</span><br><span class="line">	        &#125;</span><br><span class="line">	    &#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Request&lt;T&gt; other)</span> </span>&#123;</span><br><span class="line">	    Priority left = <span class="keyword">this</span>.getPriority();</span><br><span class="line">	    Priority right = other.getPriority();</span><br><span class="line">	</span><br><span class="line">	    <span class="comment">// request 优先级高的比低的排在队列前面，优先被请求</span></span><br><span class="line">	    <span class="comment">// 如果优先级一样，按照 FIFO 的原则排列</span></span><br><span class="line">	    <span class="keyword">return</span> left == right ?</span><br><span class="line">	            <span class="keyword">this</span>.mSequence - other.mSequence :</span><br><span class="line">	            right.ordinal() - left.ordinal();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Request 实现了 Comparable 接口，这是因为 Request 是有优先级的，优先级高比优先级低的要先响应，排列在前。默认有四种优先级：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Priority &#123;</span><br><span class="line">    LOW,</span><br><span class="line">    NORMAL,</span><br><span class="line">    HIGH,</span><br><span class="line">    IMMEDIATE</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，子类继承 Request 还要实现两个抽象方法：</p>
<ul>
<li>parseNetworkResponse ：把 NetworkResponse 转换为合适类型的 Response；</li>
<li>deliverResponse ：把解析出来的类型分发给监听器回调。</li>
</ul>
<p>另外，Request 还支持八种请求方式：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * Supported request methods.</span><br><span class="line"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Method</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> DEPRECATED_GET_OR_POST = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> GET = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> POST = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> PUT = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">int</span> DELETE = <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">int</span> HEAD = <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">int</span> OPTIONS = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> TRACE = <span class="number">6</span>;</span><br><span class="line">    <span class="keyword">int</span> PATCH = <span class="number">7</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 Volley 中，Request 的子类众多，有 StringRequest 、JsonObjectRequest(继承自  JsonRequest ) 、JsonArrayRequest(继承自  JsonRequest ) 和 ImageRequest 等。当然这些子类并不能满足全部的场景要求，而这就需要我们开发者自己动手去扩展了。</p>
<p>下面我就分析一下 StringRequest 的源码，其他子类的源码都是类似的，可以回去自行研究。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringRequest</span> <span class="keyword">extends</span> <span class="title">Request</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Listener&lt;String&gt; mListener;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(<span class="keyword">int</span> method, String url, Listener&lt;String&gt; listener,</span><br><span class="line">            ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(method, url, errorListener);</span><br><span class="line">        mListener = listener;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">StringRequest</span><span class="params">(String url, Listener&lt;String&gt; listener, ErrorListener errorListener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(Method.GET, url, listener, errorListener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">deliverResponse</span><span class="params">(String response)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 得到相应的 response 后，回调 Listener 的接口</span></span><br><span class="line">        mListener.onResponse(response);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> Response&lt;String&gt; <span class="title">parseNetworkResponse</span><span class="params">(NetworkResponse response)</span> </span>&#123;</span><br><span class="line">        String parsed;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 把字节数组转化为字符串</span></span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data, HttpHeaderParser.parseCharset(response.headers));(response.headers));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (UnsupportedEncodingException e) &#123;</span><br><span class="line">            parsed = <span class="keyword">new</span> String(response.data);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> Response.success(parsed, HttpHeaderParser.parseCacheHeaders(response));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现 StringRequest 的源码十分简洁。在 <code>parseNetworkResponse</code> 方法中主要把 response 中的 data 转化为对应的 String 类型。然后回调 <code>Response.success</code> 即可。</p>
<p>看完了 Request 之后，我们来分析一下 Network 。</p>
<h2 id="Network"><a href="#Network" class="headerlink" title="Network"></a>Network</h2><p>Network 是一个接口，里面就一个方法 <code>performRequest(Request&lt;?&gt; request)</code> :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>光看这个方法的定义就知道这个方法是用来干什么了！就是根据传入的 Request 执行，转换为对应的 NetworkResponse 的，并且该 NetworkResponse 不为空。我们就跳到它的实现类中看看该方法具体是怎么样的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BasicNetwork</span> <span class="keyword">implements</span> <span class="title">Network</span> </span>&#123;</span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> DEBUG = VolleyLog.DEBUG;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> SLOW_REQUEST_THRESHOLD_MS = <span class="number">3000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> DEFAULT_POOL_SIZE = <span class="number">4096</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> HttpStack mHttpStack;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> ByteArrayPool mPool;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用 ByteArrayPool 可以实现复用，节约内存</span></span><br><span class="line">        <span class="keyword">this</span>(httpStack, <span class="keyword">new</span> ByteArrayPool(DEFAULT_POOL_SIZE));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BasicNetwork</span><span class="params">(HttpStack httpStack, ByteArrayPool pool)</span> </span>&#123;</span><br><span class="line">        mHttpStack = httpStack;</span><br><span class="line">        mPool = pool;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> NetworkResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> requestStart = SystemClock.elapsedRealtime();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            HttpResponse httpResponse = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents = <span class="keyword">null</span>;</span><br><span class="line">            Map&lt;String, String&gt; responseHeaders = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 得到请求头</span></span><br><span class="line">                Map&lt;String, String&gt; headers = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">                <span class="comment">// 添加缓存头部信息</span></span><br><span class="line">                addCacheHeaders(headers, request.getCacheEntry());</span><br><span class="line">                httpResponse = mHttpStack.performRequest(request, headers);</span><br><span class="line">                <span class="comment">// 得到响应行</span></span><br><span class="line">                StatusLine statusLine = httpResponse.getStatusLine();</span><br><span class="line">                <span class="keyword">int</span> statusCode = statusLine.getStatusCode();</span><br><span class="line">                <span class="comment">// 转化得到响应头</span></span><br><span class="line">                responseHeaders = convertHeaders(httpResponse.getAllHeaders());</span><br><span class="line">                <span class="comment">// 如果返回的状态码是304（即：HttpStatus.SC_NOT_MODIFIED）</span></span><br><span class="line">                <span class="comment">// 那么说明服务端的数据没有变化，就直接从之前的缓存中取</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode == HttpStatus.SC_NOT_MODIFIED) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(HttpStatus.SC_NOT_MODIFIED,</span><br><span class="line">                            request.getCacheEntry() == <span class="keyword">null</span> ? <span class="keyword">null</span> : request.getCacheEntry().data,</span><br><span class="line">                            responseHeaders, <span class="keyword">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// Some responses such as 204s do not have content.  We must check.</span></span><br><span class="line">                <span class="comment">// 有一些响应可能没有内容，比如，所以要判断一下</span></span><br><span class="line">                <span class="keyword">if</span> (httpResponse.getEntity() != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">// 把 entiity 转为 byte[]</span></span><br><span class="line">                  responseContents = entityToBytes(httpResponse.getEntity());</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// Add 0 byte response as a way of honestly representing a</span></span><br><span class="line">                  <span class="comment">// no-content request.</span></span><br><span class="line">                  responseContents = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">0</span>];</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// 如果该请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS(即 3000ms) ，会打印相应的日志</span></span><br><span class="line">                <span class="keyword">long</span> requestLifetime = SystemClock.elapsedRealtime() - requestStart;</span><br><span class="line">                logSlowRequests(requestLifetime, request, responseContents, statusLine);</span><br><span class="line">                <span class="comment">// 响应码不是在 200-299 之间就抛异常</span></span><br><span class="line">                <span class="keyword">if</span> (statusCode &lt; <span class="number">200</span> || statusCode &gt; <span class="number">299</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> IOException();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> NetworkResponse(statusCode, responseContents, responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SocketTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"socket"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (ConnectTimeoutException e) &#123;</span><br><span class="line">                <span class="comment">// 启动重试策略, 超时错误</span></span><br><span class="line">                attemptRetryOnException(<span class="string">"connection"</span>, request, <span class="keyword">new</span> TimeoutError());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (MalformedURLException e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"Bad URL "</span> + request.getUrl(), e);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="keyword">int</span> statusCode = <span class="number">0</span>;</span><br><span class="line">                NetworkResponse networkResponse = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">if</span> (httpResponse != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    statusCode = httpResponse.getStatusLine().getStatusCode();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NoConnectionError(e);</span><br><span class="line">                &#125;</span><br><span class="line">                VolleyLog.e(<span class="string">"Unexpected response code %d for %s"</span>, statusCode, request.getUrl());</span><br><span class="line">                <span class="keyword">if</span> (responseContents != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    networkResponse = <span class="keyword">new</span> NetworkResponse(statusCode, responseContents,</span><br><span class="line">                            responseHeaders, <span class="keyword">false</span>);</span><br><span class="line">                    <span class="keyword">if</span> (statusCode == HttpStatus.SC_UNAUTHORIZED ||</span><br><span class="line">                            statusCode == HttpStatus.SC_FORBIDDEN) &#123;</span><br><span class="line">                        <span class="comment">// 启动重试策略, 认证错误</span></span><br><span class="line">                        attemptRetryOnException(<span class="string">"auth"</span>,</span><br><span class="line">                                request, <span class="keyword">new</span> AuthFailureError(networkResponse));</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="comment">// <span class="doctag">TODO:</span> Only throw ServerError for 5xx status codes.</span></span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> ServerError(networkResponse);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> NetworkError(networkResponse);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 如果请求的响应时间超过 SLOW_REQUEST_THRESHOLD_MS ，就打印相应的日志</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">logSlowRequests</span><span class="params">(<span class="keyword">long</span> requestLifetime, Request&lt;?&gt; request,</span><br><span class="line">            <span class="keyword">byte</span>[] responseContents, StatusLine statusLine)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (DEBUG || requestLifetime &gt; SLOW_REQUEST_THRESHOLD_MS) &#123;</span><br><span class="line">            VolleyLog.d(<span class="string">"HTTP response for request=&lt;%s&gt; [lifetime=%d], [size=%s], "</span> +</span><br><span class="line">                    <span class="string">"[rc=%d], [retryCount=%s]"</span>, request, requestLifetime,</span><br><span class="line">                    responseContents != <span class="keyword">null</span> ? responseContents.length : <span class="string">"null"</span>,</span><br><span class="line">                    statusLine.getStatusCode(), request.getRetryPolicy().getCurrentRetryCount());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 进行重试策略，如果不满足重试的条件会抛出异常</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">attemptRetryOnException</span><span class="params">(String logPrefix, Request&lt;?&gt; request,</span><br><span class="line">            VolleyError exception)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">        RetryPolicy retryPolicy = request.getRetryPolicy();</span><br><span class="line">        <span class="keyword">int</span> oldTimeout = request.getTimeoutMs();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            retryPolicy.retry(exception);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (VolleyError e) &#123;</span><br><span class="line">            request.addMarker(</span><br><span class="line">                    String.format(<span class="string">"%s-timeout-giveup [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">        request.addMarker(String.format(<span class="string">"%s-retry [timeout=%s]"</span>, logPrefix, oldTimeout));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在请求行中添加缓存相关</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">addCacheHeaders</span><span class="params">(Map&lt;String, String&gt; headers, Cache.Entry entry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// If there's no cache entry, we're done.</span></span><br><span class="line">        <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.etag != <span class="keyword">null</span>) &#123;</span><br><span class="line">            headers.put(<span class="string">"If-None-Match"</span>, entry.etag);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (entry.serverDate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            Date refTime = <span class="keyword">new</span> Date(entry.serverDate);</span><br><span class="line">            headers.put(<span class="string">"If-Modified-Since"</span>, DateUtils.formatDate(refTime));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">logError</span><span class="params">(String what, String url, <span class="keyword">long</span> start)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> now = SystemClock.elapsedRealtime();</span><br><span class="line">        VolleyLog.v(<span class="string">"HTTP ERROR(%s) %d ms to fetch %s"</span>, what, (now - start), url);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**把 HttpEntity 的内容读取到 byte[] 中. */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">byte</span>[] entityToBytes(HttpEntity entity) <span class="keyword">throws</span> IOException, ServerError &#123;</span><br><span class="line">        PoolingByteArrayOutputStream bytes =</span><br><span class="line">                <span class="keyword">new</span> PoolingByteArrayOutputStream(mPool, (<span class="keyword">int</span>) entity.getContentLength());</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            InputStream in = entity.getContent();</span><br><span class="line">            <span class="keyword">if</span> (in == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> ServerError();</span><br><span class="line">            &#125;</span><br><span class="line">            buffer = mPool.getBuf(<span class="number">1024</span>);</span><br><span class="line">            <span class="keyword">int</span> count;</span><br><span class="line">            <span class="keyword">while</span> ((count = in.read(buffer)) != -<span class="number">1</span>) &#123;</span><br><span class="line">                bytes.write(buffer, <span class="number">0</span>, count);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> bytes.toByteArray();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// Close the InputStream and release the resources by "consuming the content".</span></span><br><span class="line">                entity.consumeContent();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                <span class="comment">// This can happen if there was an exception above that left the entity in</span></span><br><span class="line">                <span class="comment">// an invalid state.</span></span><br><span class="line">                VolleyLog.v(<span class="string">"Error occured when calling consumingContent"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            mPool.returnBuf(buffer);</span><br><span class="line">            bytes.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 把 Headers[] 转换为 Map&lt;String, String&gt;.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, String&gt; convertHeaders(Header[] headers) &#123;</span><br><span class="line">        Map&lt;String, String&gt; result = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; headers.length; i++) &#123;</span><br><span class="line">            result.put(headers[i].getName(), headers[i].getValue());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把 BasicNetwork 的源码全部看下来，发现 BasicNetwork 干的事情就如下：</p>
<ul>
<li>利用 HttpStack 执行请求，把响应 HttpResponse 封装为 NetworkResponse ;</li>
<li>如果在这过程中出错，会有重试策略。</li>
</ul>
<p>至于 NetworkResponse 的源码在这里就不分析了，主要是一个相对于 HttpResponse 的封装类，可以自己去看其源码。</p>
<p>得到 NetworkResponse 之后，在 NetworkDispatcher 中经过 Request 的 <code>parseNetworkResponse</code> 方法把 NetworkResponse 转化为了 Response 。(具体可参考上面分析的 NetworkDispatcher 和 StringRequest 源码)</p>
<p>那么接下来就把目光转向 Response 吧。</p>
<h2 id="Response"><a href="#Response" class="headerlink" title="Response"></a>Response</h2><p>Response 类的源码比较简单，一起来看看：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Response</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应结果的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Listener</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">        <span class="comment">/** Called when a response is received. */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(T response)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 分发响应错误的接口 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ErrorListener</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span><br><span class="line">         * Callback method that an error has been occurred with the</span><br><span class="line">         * provided error code and optional user-readable message.</span><br><span class="line">         */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onErrorResponse</span><span class="params">(VolleyError error)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 通过这个静态方法构造 Response */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">success</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(result, cacheEntry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过这个静态方法构造错误的 Response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Response&lt;T&gt; <span class="title">error</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Response&lt;T&gt;(error);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Parsed response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> T result;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Cache metadata for this response, or null in the case of error. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> Cache.Entry cacheEntry;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Detailed error information if &lt;code&gt;errorCode != OK&lt;/code&gt;. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span> VolleyError error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** True if this response was a soft-expired one and a second one MAY be coming. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">boolean</span> intermediate = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 是否成功</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSuccess</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> error == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(T result, Cache.Entry cacheEntry)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = result;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = cacheEntry;</span><br><span class="line">        <span class="keyword">this</span>.error = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Response</span><span class="params">(VolleyError error)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.result = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.cacheEntry = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">this</span>.error = error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Response 类主要通过 <code>success</code> 和 <code>error</code> 两个方法分别来构造正确的响应结果和错误的响应结果。另外，在 Response 类中还有 Listener 和 ErrorListener 两个接口。在最终的回调中会使用到它们。</p>
<p>在得到了 Response 之后，就要使用 ResponseDelivery 来分发了。那下面就轮到 ResponseDelivery 了，go on !!</p>
<h2 id="ResponseDelivery"><a href="#ResponseDelivery" class="headerlink" title="ResponseDelivery"></a>ResponseDelivery</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 的response ，runnable 会在分发之后执行</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 分发该 request 错误的 response</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 的接口就定义了三个方法，我们需要在其实现类中看看具体的实现：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExecutorDelivery</span> <span class="keyword">implements</span> <span class="title">ResponseDelivery</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 用来分发 Response , 一般都是在主线程中*/</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Executor mResponsePoster;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 传入的 Handler 为主线程的</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(<span class="keyword">final</span> Handler handler)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Make an Executor that just wraps the handler.</span></span><br><span class="line">        mResponsePoster = <span class="keyword">new</span> Executor() &#123;</span><br><span class="line">            <span class="annotation">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">                handler.post(command);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Creates a new response delivery interface, mockable version</span><br><span class="line">     * for testing.</span><br><span class="line">     * <span class="doctag">@param</span> executor For running delivery tasks</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ExecutorDelivery</span><span class="params">(Executor executor)</span> </span>&#123;</span><br><span class="line">        mResponsePoster = executor;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response)</span> </span>&#123;</span><br><span class="line">        postResponse(request, response, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postResponse</span><span class="params">(Request&lt;?&gt; request, Response&lt;?&gt; response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">        request.markDelivered();</span><br><span class="line">        request.addMarker(<span class="string">"post-response"</span>);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, runnable));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postError</span><span class="params">(Request&lt;?&gt; request, VolleyError error)</span> </span>&#123;</span><br><span class="line">        request.addMarker(<span class="string">"post-error"</span>);</span><br><span class="line">        Response&lt;?&gt; response = Response.error(error);</span><br><span class="line">        mResponsePoster.execute(<span class="keyword">new</span> ResponseDeliveryRunnable(request, response, <span class="keyword">null</span>));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * A Runnable 用来分发 response 到主线程的回调接口中</span><br><span class="line">     */</span></span><br><span class="line">    <span class="annotation">@SuppressWarnings</span>(<span class="string">"rawtypes"</span>)</span><br><span class="line">    <span class="keyword">private</span> <span class="class"><span class="keyword">class</span> <span class="title">ResponseDeliveryRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Request mRequest;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Response mResponse;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> Runnable mRunnable;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ResponseDeliveryRunnable</span><span class="params">(Request request, Response response, Runnable runnable)</span> </span>&#123;</span><br><span class="line">            mRequest = request;</span><br><span class="line">            mResponse = response;</span><br><span class="line">            mRunnable = runnable;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="annotation">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="annotation">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 如果 request 被标记为取消，那么不用分发</span></span><br><span class="line">            <span class="keyword">if</span> (mRequest.isCanceled()) &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"canceled-at-delivery"</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 根据 mResponse 是否成功来分发到不同的方法</span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.isSuccess()) &#123;</span><br><span class="line">                mRequest.deliverResponse(mResponse.result);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.deliverError(mResponse.error);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// If this is an intermediate response, add a marker, otherwise we're done</span></span><br><span class="line">            <span class="comment">// and the request can be finished. </span></span><br><span class="line">            <span class="keyword">if</span> (mResponse.intermediate) &#123;</span><br><span class="line">                mRequest.addMarker(<span class="string">"intermediate-response"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                mRequest.finish(<span class="string">"done"</span>);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 运行 mRunnable</span></span><br><span class="line">            <span class="keyword">if</span> (mRunnable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                mRunnable.run();</span><br><span class="line">            &#125;</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ResponseDelivery 将根据 mResponse 是否成功来调用不同的方法 <code>mRequest.deliverResponse</code> 和 <code>mRequest.deliverError</code> 。在 <code>mRequest.deliverResponse</code> 中会回调 Listener 的 <code>onResponse</code> 方法；而在 <code>mRequest.deliverError</code> 中会回调 ErrorListener 的 <code>onErrorResponse</code> 方法。至此，一个完整的网络请求及响应流程走完了。</p>
<h2 id="HttpStack"><a href="#HttpStack" class="headerlink" title="HttpStack"></a>HttpStack</h2><p>现在回过头来看看 Volley 框架中是如何发起网络请求的。在本文的开头中说过，Volley 是会根据 Android 的版本来选择对应的 HttpStack。那么下面我们来深入看一下 HttpStack 的源码。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HttpStack</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * 通过所给的参数执行请求</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpStack 接口中定义的方法就只有一个。我们要分别来看看 HurlStack 和 HttpClientStack 各自的实现。</p>
<p>HurlStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    String url = request.getUrl();</span><br><span class="line">    HashMap&lt;String, String&gt; map = <span class="keyword">new</span> HashMap&lt;String, String&gt;();</span><br><span class="line">    <span class="comment">// 把请求头放入 map 中</span></span><br><span class="line">    map.putAll(request.getHeaders());</span><br><span class="line">    map.putAll(additionalHeaders);</span><br><span class="line">    <span class="keyword">if</span> (mUrlRewriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">        String rewritten = mUrlRewriter.rewriteUrl(url);</span><br><span class="line">        <span class="keyword">if</span> (rewritten == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"URL blocked by rewriter: "</span> + url);</span><br><span class="line">        &#125;</span><br><span class="line">        url = rewritten;</span><br><span class="line">    &#125;</span><br><span class="line">    URL parsedUrl = <span class="keyword">new</span> URL(url);</span><br><span class="line">    <span class="comment">// 使用 HttpURLConnection 来发起请求</span></span><br><span class="line">    HttpURLConnection connection = openConnection(parsedUrl, request);</span><br><span class="line">    <span class="comment">// 设置请求头</span></span><br><span class="line">    <span class="keyword">for</span> (String headerName : map.keySet()) &#123;</span><br><span class="line">        connection.addRequestProperty(headerName, map.get(headerName));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置请求方法</span></span><br><span class="line">    setConnectionParametersForRequest(connection, request);</span><br><span class="line">    <span class="comment">// Initialize HttpResponse with data from the HttpURLConnection.</span></span><br><span class="line">    ProtocolVersion protocolVersion = <span class="keyword">new</span> ProtocolVersion(<span class="string">"HTTP"</span>, <span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">int</span> responseCode = connection.getResponseCode();</span><br><span class="line">    <span class="keyword">if</span> (responseCode == -<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">// -1 is returned by getResponseCode() if the response code could not be retrieved.</span></span><br><span class="line">        <span class="comment">// Signal to the caller that something was wrong with the connection.</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Could not retrieve response code from HttpUrlConnection."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 把响应封装进 response 中</span></span><br><span class="line">    StatusLine responseStatus = <span class="keyword">new</span> BasicStatusLine(protocolVersion,</span><br><span class="line">            connection.getResponseCode(), connection.getResponseMessage());</span><br><span class="line">    BasicHttpResponse response = <span class="keyword">new</span> BasicHttpResponse(responseStatus);</span><br><span class="line">    response.setEntity(entityFromConnection(connection));</span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;String, List&lt;String&gt;&gt; header : connection.getHeaderFields().entrySet()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (header.getKey() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            Header h = <span class="keyword">new</span> BasicHeader(header.getKey(), header.getValue().get(<span class="number">0</span>));</span><br><span class="line">            response.addHeader(h);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>HttpClientStack ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> HttpResponse <span class="title">performRequest</span><span class="params">(Request&lt;?&gt; request, Map&lt;String, String&gt; additionalHeaders)</span></span><br><span class="line">        <span class="keyword">throws</span> IOException, AuthFailureError </span>&#123;</span><br><span class="line">    <span class="comment">// 根据请求方法生成对应的 HttpUriRequest</span></span><br><span class="line">    HttpUriRequest httpRequest = createHttpRequest(request, additionalHeaders);</span><br><span class="line">    <span class="comment">// 添加请求头</span></span><br><span class="line">    addHeaders(httpRequest, additionalHeaders);</span><br><span class="line">    addHeaders(httpRequest, request.getHeaders());</span><br><span class="line">    onPrepareRequest(httpRequest);</span><br><span class="line">    HttpParams httpParams = httpRequest.getParams();</span><br><span class="line">    <span class="keyword">int</span> timeoutMs = request.getTimeoutMs();</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Reevaluate this connection timeout based on more wide-scale</span></span><br><span class="line">    <span class="comment">// data collection and possibly different for wifi vs. 3G.</span></span><br><span class="line">    HttpConnectionParams.setConnectionTimeout(httpParams, <span class="number">5000</span>);</span><br><span class="line">    HttpConnectionParams.setSoTimeout(httpParams, timeoutMs);</span><br><span class="line">    <span class="keyword">return</span> mClient.execute(httpRequest);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里只给出 HurlStack 和 HttpClientStack 的 <code>performRequest</code> 方法。我们可以看到 HurlStack 和 HttpClientStack 已经把 HttpUrlConnection 和 HttpClient 封装得很彻底了，以后哪里有需要的地方可以直接使用。</p>
<h2 id="RetryPolicy"><a href="#RetryPolicy" class="headerlink" title="RetryPolicy"></a>RetryPolicy</h2><p>RetryPolicy 接口主要的作用就是定制重试策略，我们从下面的源码可以看出该接口有三个抽象方法：</p>
<ul>
<li>getCurrentTimeout ：得到当前超时时间；</li>
<li>getCurrentRetryCount ：得到当前重试的次数；</li>
<li>retry ：是否进行重试，其中的 <code>error</code> 参数为异常的信息。若在 <code>retry</code> 方法中跑出 <code>error</code> 异常，那 Volley 就会停止重试。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RetryPolicy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current timeout (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentTimeout</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Returns the current retry count (used for logging).</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCurrentRetryCount</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Prepares for the next retry by applying a backoff to the timeout.</span><br><span class="line">     * <span class="doctag">@param</span> error The error code of the last attempt.</span><br><span class="line">     * <span class="doctag">@throws</span> VolleyError In the event that the retry could not be performed (for example if we</span><br><span class="line">     * ran out of attempts), the passed in error is thrown.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RetryPolicy 接口有一个默认的实现类 DefaultRetryPolicy ，DefaultRetryPolicy 的构造方法有两个：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The default socket timeout in milliseconds */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_TIMEOUT_MS = <span class="number">2500</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default number of retries */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_MAX_RETRIES = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** The default backoff multiplier */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_BACKOFF_MULT = <span class="number">1f</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(DEFAULT_TIMEOUT_MS, DEFAULT_MAX_RETRIES, DEFAULT_BACKOFF_MULT);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Constructs a new retry policy.</span><br><span class="line"> * <span class="doctag">@param</span> initialTimeoutMs The initial timeout for the policy.</span><br><span class="line"> * <span class="doctag">@param</span> maxNumRetries The maximum number of retries.</span><br><span class="line"> * <span class="doctag">@param</span> backoffMultiplier Backoff multiplier for the policy.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DefaultRetryPolicy</span><span class="params">(<span class="keyword">int</span> initialTimeoutMs, <span class="keyword">int</span> maxNumRetries, <span class="keyword">float</span> backoffMultiplier)</span> </span>&#123;</span><br><span class="line">    mCurrentTimeoutMs = initialTimeoutMs;</span><br><span class="line">    mMaxNumRetries = maxNumRetries;</span><br><span class="line">    mBackoffMultiplier = backoffMultiplier;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，在 Volley 内部已经有一套默认的参数配置了。当然，你也可以通过自定义的形式来设置重试策略。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">retry</span><span class="params">(VolleyError error)</span> <span class="keyword">throws</span> VolleyError </span>&#123;</span><br><span class="line">    <span class="comment">// 重试次数自增</span></span><br><span class="line">    mCurrentRetryCount++;</span><br><span class="line">    <span class="comment">// 超时时间自增，mBackoffMultiplier 为超时时间的因子</span></span><br><span class="line">    mCurrentTimeoutMs += (mCurrentTimeoutMs * mBackoffMultiplier);</span><br><span class="line">    <span class="comment">// 如果超过最大次数，抛出异常</span></span><br><span class="line">    <span class="keyword">if</span> (!hasAttemptRemaining()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> error;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns true if this policy has attempts remaining, false otherwise.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">hasAttemptRemaining</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> mCurrentRetryCount &lt;= mMaxNumRetries;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h2><p>分析完了前面这么多的类，终于轮到了最后的 Cache 。Cache 接口中定义了一个内部类 Entry ，还有定义了几个方法：</p>
<ul>
<li>get(String key) ：根据传入的 <code>key</code> 来获取 entry ；</li>
<li>put(String key, Entry entry) ：增加或者替换缓存；</li>
<li>initialize() ：初始化，是耗时的操作，在子线程中调用；</li>
<li>invalidate(String key, boolean fullExpire) ：根据 <code>key</code> 使之对应的缓存失效；</li>
<li>remove(String key) ：根据 <code>key</code> 移除某个缓存；</li>
<li>clear() ：清空缓存。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Cache</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Retrieves an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@return</span> An &#123;<span class="doctag">@link</span> Entry&#125; or null in the event of a cache miss</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Entry <span class="title">get</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Adds or replaces an entry to the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> entry Data to store and metadata for cache coherency, TTL, etc.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Performs any potentially long-running actions needed to initialize the cache;</span><br><span class="line">     * will be called from a worker thread.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Invalidates an entry in the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     * <span class="doctag">@param</span> fullExpire True to fully expire the entry, false to soft expire</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Removes an entry from the cache.</span><br><span class="line">     * <span class="doctag">@param</span> key Cache key</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">(String key)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * Empties the cache.</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>内部类 Entry ，Entry 中有一个属性为 etag ，上面的源码中也有 etag 的身影。如果你对 ETag 不熟悉，可以查看这篇文章<a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">《Etag与HTTP缓存机制》</a>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> </span>&#123;</span><br><span class="line">    <span class="comment">/** 缓存中数据，即响应中的 body */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">byte</span>[] data;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** HTTP头部的一个定义，允许客户端进行缓存协商 */</span></span><br><span class="line">    <span class="keyword">public</span> String etag;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 服务端响应的时间 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> serverDate;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存过期的时间，若小于当前时间则过期 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> ttl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 缓存的有效时间，若小于当前时间则可以进行刷新操作 */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> softTtl;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 响应的头部信息 */</span></span><br><span class="line">    <span class="keyword">public</span> Map&lt;String, String&gt; responseHeaders = Collections.emptyMap();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否有效，若返回 true 则缓存失效. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isExpired</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.ttl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 判断缓存是否需要刷新 */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">refreshNeeded</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.softTtl &lt; System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>看完了 Cache 接口之后，我们来看一下实现类 DiskBasedCache 。首先是它的构造方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_DISK_USAGE_BYTES = <span class="number">5</span> * <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory, <span class="keyword">int</span> maxCacheSizeInBytes)</span> </span>&#123;</span><br><span class="line">    mRootDirectory = rootDirectory;</span><br><span class="line">    mMaxCacheSizeInBytes = maxCacheSizeInBytes;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">DiskBasedCache</span><span class="params">(File rootDirectory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(rootDirectory, DEFAULT_DISK_USAGE_BYTES);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从构造方法中传入的参数可知，Volley 默认最大磁盘缓存为 5M 。</p>
<p>DiskBasedCache 的 <code>get(String key)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Entry <span class="title">get</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到对应的缓存摘要信息</span></span><br><span class="line">    CacheHeader entry = mEntries.get(key);</span><br><span class="line">    <span class="comment">// if the entry does not exist, return.</span></span><br><span class="line">    <span class="keyword">if</span> (entry == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到缓存文件</span></span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="comment">// CountingInputStream 为自定义的 IO 流，继承自 FilterInputStream</span></span><br><span class="line">    <span class="comment">// 具有记忆已读取的字节数的功能</span></span><br><span class="line">    CountingInputStream cis = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        cis = <span class="keyword">new</span> CountingInputStream(<span class="keyword">new</span> FileInputStream(file));</span><br><span class="line">        CacheHeader.readHeader(cis); <span class="comment">// eat header</span></span><br><span class="line">        <span class="comment">// 得到缓存中的数据 data[] </span></span><br><span class="line">        <span class="keyword">byte</span>[] data = streamToBytes(cis, (<span class="keyword">int</span>) (file.length() - cis.bytesRead));</span><br><span class="line">        <span class="keyword">return</span> entry.toCacheEntry(data);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"%s: %s"</span>, file.getAbsolutePath(), e.toString());</span><br><span class="line">        <span class="comment">// 若出错则移除缓存</span></span><br><span class="line">        remove(key);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                cis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 把 url 分成两半，分别得到对应的 hashcode ，拼接后得到对应的文件名</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> String <span class="title">getFilenameForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> firstHalfLength = key.length() / <span class="number">2</span>;</span><br><span class="line">    String localFilename = String.valueOf(key.substring(<span class="number">0</span>, firstHalfLength).hashCode());</span><br><span class="line">    localFilename += String.valueOf(key.substring(firstHalfLength).hashCode());</span><br><span class="line">    <span class="keyword">return</span> localFilename;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span><br><span class="line"> * Returns a file object for the given cache key.</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> File <span class="title">getFileForKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> File(mRootDirectory, getFilenameForKey(key));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DiskBasedCache 的 <code>putEntry(String key, CacheHeader entry)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(String key, Entry entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 检查磁盘空间是否足够，若不够会删除一些缓存文件</span></span><br><span class="line">    pruneIfNeeded(entry.data.length);</span><br><span class="line">    File file = getFileForKey(key);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        FileOutputStream fos = <span class="keyword">new</span> FileOutputStream(file);</span><br><span class="line">        CacheHeader e = <span class="keyword">new</span> CacheHeader(key, entry);</span><br><span class="line">        e.writeHeader(fos);</span><br><span class="line">        fos.write(entry.data);</span><br><span class="line">        fos.close();</span><br><span class="line">        putEntry(key, e);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> deleted = file.delete();</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not clean up file %s"</span>, file.getAbsolutePath());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">putEntry</span><span class="params">(String key, CacheHeader entry)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 计算总缓存的大小</span></span><br><span class="line">    <span class="keyword">if</span> (!mEntries.containsKey(key)) &#123;</span><br><span class="line">        mTotalSize += entry.size;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        CacheHeader oldEntry = mEntries.get(key);</span><br><span class="line">        mTotalSize += (entry.size - oldEntry.size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 增加或者替换缓存</span></span><br><span class="line">    mEntries.put(key, entry);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>initialize()</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!mRootDirectory.exists()) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!mRootDirectory.mkdirs()) &#123;</span><br><span class="line">            VolleyLog.e(<span class="string">"Unable to create cache dir %s"</span>, mRootDirectory.getAbsolutePath());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 读取缓存文件</span></span><br><span class="line">    <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">        FileInputStream fis = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            fis = <span class="keyword">new</span> FileInputStream(file);</span><br><span class="line">            <span class="comment">// 得到缓存文件的摘要信息</span></span><br><span class="line">            CacheHeader entry = CacheHeader.readHeader(fis);</span><br><span class="line">            entry.size = file.length();</span><br><span class="line">            <span class="comment">// 放入 map 中</span></span><br><span class="line">            putEntry(entry.key, entry);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            <span class="keyword">if</span> (file != <span class="keyword">null</span>) &#123;</span><br><span class="line">               file.delete();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (fis != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fis.close();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ignored) &#123; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>invalidate(String key, boolean fullExpire)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">invalidate</span><span class="params">(String key, <span class="keyword">boolean</span> fullExpire)</span> </span>&#123;</span><br><span class="line">    Entry entry = get(key);</span><br><span class="line">    <span class="keyword">if</span> (entry != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 有效时间置零</span></span><br><span class="line">        entry.softTtl = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (fullExpire) &#123;</span><br><span class="line">            entry.ttl = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        put(key, entry);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>remove(String key)</code> 和 <code>clear()</code> 方法比较简单，就不需要注释了：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> remove(<span class="keyword">String</span> <span class="variable">key</span>) &#123;</span><br><span class="line">    <span class="built_in">boolean</span> deleted = getFileForKey(<span class="variable">key</span>).delete();</span><br><span class="line">    removeEntry(<span class="variable">key</span>);</span><br><span class="line">    <span class="keyword">if</span> (!deleted) &#123;</span><br><span class="line">        VolleyLog.d(<span class="string">"Could not delete cache entry for key=%s, filename=%s"</span>,</span><br><span class="line">                <span class="variable">key</span>, getFilenameForKey(<span class="variable">key</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="built_in">clear</span>() &#123;</span><br><span class="line">    File[] files = mRootDirectory.listFiles();</span><br><span class="line">    <span class="keyword">if</span> (files != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (File file : files) &#123;</span><br><span class="line">            file.delete();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    mEntries.<span class="built_in">clear</span>();</span><br><span class="line">    mTotalSize = <span class="number">0</span>;</span><br><span class="line">    VolleyLog.d(<span class="string">"Cache cleared."</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0100B"><a href="#0100B" class="headerlink" title="0100B"></a>0100B</h1><p>至此，Volley 源码解析差不多已经结束了。基本上在整个 Volley 框架中至关重要的类都讲到了。当然，还有一些 NetworkImageView 、ImageLoader 等源码还没解析。由于本篇文章内容太长了(有史以来写过最长的一篇─=≡Σ((( つ•̀ω•́)つ)，只能等到下次有机会再给大家补上了。</p>
<p>在这还给出了一张整个 Volley 框架大致的网络通信流程图，对上面源码没看懂的童鞋可以参考这张图再看一遍：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161119/20161130214351.png" alt="Volley网络通信流程图"></p>
<p>最后，只剩下总结了。从头到尾分析了一遍，发现 Volley 真的是一款很优秀的框架，面向接口编程在其中发挥到极致。其中有不少值得我们借鉴的地方，但是 Volley 并不是没有缺点的，对于大文件传输 Volley 就很不擅长，搞不好会 OOM 。另外，在源码中还有不少可以继续优化的地方，有兴趣的同学可以自定义一个属于自己的 Volley 。</p>
<p>好了，如果你对本文哪里有问题或者不懂的地方，欢迎留言一起交流。</p>
<h1 id="0101B"><a href="#0101B" class="headerlink" title="0101B"></a>0101B</h1><p>References</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/grumoon/Volley%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">Volley 源码解析</a></li>
<li><a href="http://blog.csdn.net/zoudifei/article/details/45623121" target="_blank" rel="external">volley 框架剖析(四） 之HTTPCache设计</a></li>
<li><a href="http://blog.csdn.net/sinyu890807/article/details/17656437" target="_blank" rel="external">Android Volley完全解析(四)，带你从源码的角度理解Volley  
</a></li>
<li><a href="http://blog.csdn.net/kikikind/article/details/6266101" target="_blank" rel="external">Etag与HTTP缓存机制</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0001B"><a href="#0001B" class="headerlink" title="0001B"></a>0001B</h1><p>在 2013 年的 Google I/O 大会上，Volley 网络通信框架正式发布。Volley 框架被设计为适用]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[热修复框架HotFix源码解析]]></title>
    <link href="http://yuqirong.me/2016/11/06/%E7%83%AD%E4%BF%AE%E5%A4%8D%E6%A1%86%E6%9E%B6HotFix%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/11/06/热修复框架HotFix源码解析/</id>
    <published>2016-11-06T05:15:59.000Z</published>
    <updated>2016-11-06T11:19:23.626Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>讲起 Android 的热修复，相信大家对其都略知一二。热修复可以说是继插件化之后，又一项新的技术。目前的 Android 热修复框架主要分为了两类：</p>
<ul>
<li>基于 Native Hook：使用 JNI 动态改变方法指针，比如有 <a href="https://github.com/alibaba/dexposed" target="_blank" rel="external">Dexposed</a> 、<a href="https://github.com/alibaba/AndFix" target="_blank" rel="external">AndFix</a> 等；</li>
<li>基于 Java Dex 分包：改变 dex 加载顺序，比如有 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 、<a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a> 、<a href="https://github.com/eleme/Amigo" target="_blank" rel="external">Amigo</a> 等；</li>
</ul>
<p>Native Hook 方案有一定的兼容性问题，并且其热修复是基于方法的；而 Java Dex 分包的方案具有很好的兼容性，被大众所接受。其实早在去年年末，<a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 、 <a href="https://github.com/jasonross/Nuwa" target="_blank" rel="external">Nuwa</a> 就已经出现了，并且它们的原理是相同的，都是基于 QQ 空间终端开发团队发布的<a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1031x2ljgSF4xJGlH1xMCJxO&amp;uin=MjAyNzY1NTU%3D&amp;key=04dce534b3b035ef58d8714d714d36bcc6cc7e136bbd64850522b491d143aafceb62c46421c5965e18876433791d16ec&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020201&amp;lang=zh_CN&amp;pass_ticket=7O%2FVfztuLjqu23ED2WEkvy1SJstQD4eLRqX%2B%2BbCY3uE%3D" target="_blank" rel="external">《安卓App热补丁动态修复技术介绍》</a>文中介绍的思路来实现的。如果没有看过这篇文章的童鞋，强烈建议先阅读一遍。</p>
<p>虽然现在 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 框架已经被作者 <a href="https://github.com/dodola" target="_blank" rel="external">dodola</a> 标注了 Deprecated ，但是这并不妨碍我们解析其源码。那么下面我们就开始进入正题。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>首先来看一下 <a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 项目的结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106151939.png" alt="HotFix项目结构"></p>
<p>可以看到项目中主要分为四个 module ：</p>
<ul>
<li>app : 里面有一个 HotFix 用法的 Demo ；</li>
<li>buildSrc : 用于编译打包时代码注入的 Gradle 的 Task ；</li>
<li>hackDex : 只有一个 AntilazyLoad 类，独立打成一个 hack.dex ，防止出现 CLASS_ISPREVERIFIED 相关的问题；</li>
<li>hotfixlib : 热修复框架的 lib ；</li>
</ul>
<p>我们就先从 app 入手吧，先来看看 HotfixApplication :</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HotfixApplication</span> <span class="keyword">extends</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate();</span><br><span class="line">        File dexPath = <span class="keyword">new</span> File(getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE), <span class="string">"hackdex_dex.jar"</span>);</span><br><span class="line">		<span class="comment">// 把 assets 中的 hackdex_dex.jar 复制给 dexPath</span></span><br><span class="line">        Utils.prepareDex(<span class="keyword">this</span>.getApplicationContext(), dexPath, <span class="string">"hackdex_dex.jar"</span>);</span><br><span class="line">        HotFix.patch(<span class="keyword">this</span>, dexPath.getAbsolutePath(), <span class="string">"dodola.hackdex.AntilazyLoad"</span>);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.getClassLoader().loadClass(<span class="string">"dodola.hackdex.AntilazyLoad"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onCreate()</code> 方法中，代码量很少。一开始使用 <code>Utils.prepareDex</code> 把 assets 中的 hackdex_dex.jar 复制到内部存储中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 把 assets 中的 hack_dex 复制到内部存储中</span><br><span class="line"> * <span class="doctag">@param</span> context</span><br><span class="line"> * <span class="doctag">@param</span> dexInternalStoragePath</span><br><span class="line"> * <span class="doctag">@param</span> dex_file</span><br><span class="line"> * <span class="doctag">@return</span></span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">prepareDex</span><span class="params">(Context context, File dexInternalStoragePath, String dex_file)</span> </span>&#123;</span><br><span class="line">    BufferedInputStream bis = <span class="keyword">null</span>;</span><br><span class="line">    OutputStream dexWriter = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        bis = <span class="keyword">new</span> BufferedInputStream(context.getAssets().open(dex_file));</span><br><span class="line">        dexWriter = <span class="keyword">new</span> BufferedOutputStream(<span class="keyword">new</span> FileOutputStream(dexInternalStoragePath));</span><br><span class="line">        <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[BUF_SIZE];</span><br><span class="line">        <span class="keyword">int</span> len;</span><br><span class="line">        <span class="keyword">while</span> ((len = bis.read(buf, <span class="number">0</span>, BUF_SIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            dexWriter.write(buf, <span class="number">0</span>, len);</span><br><span class="line">        &#125;</span><br><span class="line">        dexWriter.close();</span><br><span class="line">        bis.close();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        <span class="keyword">if</span> (dexWriter != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                dexWriter.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ioe.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (bis != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                bis.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException ioe) &#123;</span><br><span class="line">                ioe.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复制完后调用了 <code>HotFix.patch</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">patch</span><span class="params">(Context context, String patchDexFile, String patchClassName)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (patchDexFile != <span class="keyword">null</span> &amp;&amp; <span class="keyword">new</span> File(patchDexFile).exists()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (hasLexClassLoader()) &#123;</span><br><span class="line">                injectInAliyunOs(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (hasDexClassLoader()) &#123;</span><br><span class="line">                injectAboveEqualApiLevel14(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                injectBelowApiLevel14(context, patchDexFile, patchClassName);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable th) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>patch</code> 方法中，分为了三种情况：</p>
<ol>
<li>阿里云系统；</li>
<li>Android 系统 API Level &gt;= 14 的；</li>
<li>Android 系统 API Level &lt; 14 的；</li>
</ol>
<p>其实阿里云的热修复和 Android系统 API &lt; 14 的代码是差不多的，就是把 .dex 修改为了 .lex 。在这里就不分析，主要来看看 Android 系统 API &gt;= 14 和 Android 系统 API &lt; 14 两种情况。</p>
<h2 id="Android__u7CFB_u7EDF_API_Level__26gt_3B_3D_14"><a href="#Android__u7CFB_u7EDF_API_Level__26gt_3B_3D_14" class="headerlink" title="Android 系统 API Level &gt;= 14"></a>Android 系统 API Level &gt;= 14</h2><p>先来分析 <code>injectAboveEqualApiLevel14</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectAboveEqualApiLevel14</span><span class="params">(Context context, String str, String str2)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    PathClassLoader pathClassLoader = (PathClassLoader) context.getClassLoader();</span><br><span class="line">    <span class="comment">// 合并 DexElements[] 数组</span></span><br><span class="line">    Object a = combineArray(getDexElements(getPathList(pathClassLoader)),</span><br><span class="line">        getDexElements(getPathList(</span><br><span class="line">            <span class="keyword">new</span> DexClassLoader(str, context.getDir(<span class="string">"dex"</span>, <span class="number">0</span>).getAbsolutePath(), str, context.getClassLoader()))));</span><br><span class="line">    <span class="comment">// 得到当前 pathClassLoader 中的 pathList</span></span><br><span class="line">   Object a2 = getPathList(pathClassLoader);</span><br><span class="line">    <span class="comment">// 把合并后的 DexElements[] 数组设置给 PathList 中的 dexElements</span></span><br><span class="line">    setField(a2, a2.getClass(), <span class="string">"dexElements"</span>, a);</span><br><span class="line">    pathClassLoader.loadClass(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>得到当前 <code>context</code> 内部的 <code>pathClassLoader</code> ，然后调用 <code>combineArray(getDexElements(getPathList(pathClassLoader)), getDexElements(getPathList(new DexClassLoader(str, context.getDir(&quot;dex&quot;, 0).getAbsolutePath(), str, context.getClassLoader()))))</code> 。这个 <code>combineArray</code> 方法中嵌套了很多层方法，我们一个一个来看。首先是 <code>getPathList</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getPathList</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException,</span><br><span class="line">    IllegalAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到当前 PathClassLoader 中的 pathList 属性</span></span><br><span class="line">    <span class="keyword">return</span> getField(obj, Class.forName(<span class="string">"dalvik.system.BaseDexClassLoader"</span>), <span class="string">"pathList"</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getField</span><span class="params">(Object obj, Class cls, String str)</span></span><br><span class="line">    <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    Field declaredField = cls.getDeclaredField(str);</span><br><span class="line">    declaredField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    <span class="keyword">return</span> declaredField.get(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的源码中知道，其实 getPathList 就是获取 BaseDexClassLoader 类的对象中的 pathList 属性。</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106163934.png" alt="BaseDexClassLoader源码"></p>
<p>PathClassLoader 类继承自 BaseDexClassLoader：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106163627.png" alt="PathClassLoader源码"></p>
<p>得到了 pathList 之后，调用了 <code>getDexElements</code> 。顾名思义，就是获得了 pathList 中的 dexElements 属性。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">getDexElements</span><span class="params">(Object obj)</span> <span class="keyword">throws</span> NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">	<span class="comment">// 得到当前 pathList 中的 dexElements 属性</span></span><br><span class="line">    <span class="keyword">return</span> getField(obj, obj.getClass(), <span class="string">"dexElements"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161106/20161106164537.png" alt="DexPathList源码"></p>
<p>所以在 <code>combineArray</code> 方法中传入的参数都是 Elements[] 。一个是当前应用程序中的 dexElements，另一个是 hackdex_dex.jar 中的 dexElements 。</p>
<p>下面来看看 <code>combineArray</code> 中的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Object <span class="title">combineArray</span><span class="params">(Object obj, Object obj2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 得到 DexElements[] 数组的 class</span></span><br><span class="line">    Class componentType = obj2.getClass().getComponentType();</span><br><span class="line">    <span class="comment">// 得到补丁包中 DexElements[] 数组的长度</span></span><br><span class="line">    <span class="keyword">int</span> length = Array.getLength(obj2);</span><br><span class="line">    <span class="comment">// 全长</span></span><br><span class="line">    <span class="keyword">int</span> length2 = Array.getLength(obj) + length;</span><br><span class="line">    Object newInstance = Array.newInstance(componentType, length2);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length2; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (i &lt; length) &#123;</span><br><span class="line">			<span class="comment">// obj2 中的 Element 顺序在 obj 前面</span></span><br><span class="line">            Array.set(newInstance, i, Array.get(obj2, i));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Array.set(newInstance, i, Array.get(obj, i - length));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>主要干的事情就是把传入的两个 dexElements 合并成一个 dexElements 。但是要注意的是第二个 obj2 中的 dex 要排在 obj 前面，这样才能达到热修复的效果。</p>
<p>最后我们回过头来看看 <code>injectAboveEqualApiLevel14</code> 方法中剩下的代码：</p>
<pre><code>// 得到当前 pathClassLoader 中的 pathList
Object a2 = getPathList(pathClassLoader);
// 把合并后的 DexElements[] 数组设置给 PathList
setField(a2, a2.getClass(), &quot;dexElements&quot;, a);
// 先加载 dodola.hackdex.AntilazyLoad.class
pathClassLoader.loadClass(str2);
</code></pre><p>这几行代码相信大家都能看懂了。这样 <code>injectAboveEqualApiLevel14</code> 整个流程就走完了。剩下，我们就看看 <code>injectBelowApiLevel14</code> 吧。</p>
<h2 id="Android__u7CFB_u7EDF_API_Level__26lt_3B_14"><a href="#Android__u7CFB_u7EDF_API_Level__26lt_3B_14" class="headerlink" title="Android 系统 API Level &lt; 14"></a>Android 系统 API Level &lt; 14</h2><p><code>injectBelowApiLevel14</code> 方法代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(<span class="number">14</span>)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">injectBelowApiLevel14</span><span class="params">(Context context, String str, String str2)</span></span><br><span class="line">    <span class="keyword">throws</span> ClassNotFoundException, NoSuchFieldException, IllegalAccessException </span>&#123;</span><br><span class="line">    PathClassLoader obj = (PathClassLoader) context.getClassLoader();</span><br><span class="line">    DexClassLoader dexClassLoader =</span><br><span class="line">        <span class="keyword">new</span> DexClassLoader(str, context.getDir(<span class="string">"dex"</span>, <span class="number">0</span>).getAbsolutePath(), str, context.getClassLoader());</span><br><span class="line">    <span class="comment">// why load class str2</span></span><br><span class="line">    dexClassLoader.loadClass(str2);</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mPaths"</span>,</span><br><span class="line">        appendArray(getField(obj, PathClassLoader.class, <span class="string">"mPaths"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">                <span class="string">"mRawDexPath"</span>)</span><br><span class="line">        ));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mFiles"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mFiles"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">                <span class="string">"mFiles"</span>)</span><br><span class="line">        ));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mZips"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mZips"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">            <span class="string">"mZips"</span>)));</span><br><span class="line">    setField(obj, PathClassLoader.class, <span class="string">"mDexs"</span>,</span><br><span class="line">        combineArray(getField(obj, PathClassLoader.class, <span class="string">"mDexs"</span>), getField(dexClassLoader, DexClassLoader.class,</span><br><span class="line">            <span class="string">"mDexs"</span>)));</span><br><span class="line">    obj.loadClass(str2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在 API Level &lt; 14 中，流程还是那一套流程，和 API Level &gt;= 14 的一致，只不过要合并的属性变多了。主要因为 ClassLoader 源代码有变更，所以要分版本作出兼容。在这里就不分析了，相信看完 <code>injectAboveEqualApiLevel14</code> 之后对 <code>injectBelowApiLevel14</code> 也一定理解了。</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>在 MainActivity 中，进行了热修复，相关代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//准备补丁,从assert里拷贝到dex里</span></span><br><span class="line">File dexPath = <span class="keyword">new</span> File(getDir(<span class="string">"dex"</span>, Context.MODE_PRIVATE), <span class="string">"path_dex.jar"</span>);</span><br><span class="line">Utils.prepareDex(<span class="keyword">this</span>.getApplicationContext(), dexPath, <span class="string">"path_dex.jar"</span>);</span><br><span class="line"><span class="comment">//                DexInjector.inject(dexPath.getAbsolutePath(), defaultDexOptPath, "dodola.hotfix</span></span><br><span class="line"><span class="comment">// .BugClass");</span></span><br><span class="line"></span><br><span class="line">HotFix.patch(<span class="keyword">this</span>, dexPath.getAbsolutePath(), <span class="string">"dodola.hotfix.BugClass"</span>);</span><br></pre></td></tr></table></figure>
<p>惊奇地发现 MainActivity 中热修复的代码和上面 HotfixApplication 中加载 hackdex_dex.jar 的代码是一模一样的。没错，都是用的同一套流程，所以同样的道理就很容易理解了。</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p><a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 整个逻辑就是上面这样了。但是我们还有一个问题要去解决，那就是我们怎样把 AntilazyLoad 动态引入到构造方法中。<a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 使用 javassist 来做到代码动态注入。具体的代码就是在 buildSrc 中：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span><br><span class="line"> * 植入代码</span><br><span class="line"> * <span class="doctag">@param</span> buildDir 是项目的build class目录,就是我们需要注入的class所在地</span><br><span class="line"> * <span class="doctag">@param</span> lib 这个是hackdex的目录,就是AntilazyLoad类的class文件所在地</span><br><span class="line"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process</span><span class="params">(String buildDir, String lib)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    println(lib)</span><br><span class="line">    ClassPool classes = ClassPool.getDefault()</span><br><span class="line">    classes.appendClassPath(buildDir)</span><br><span class="line">    classes.appendClassPath(lib)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面的操作比较容易理解,在将需要关联的类的构造方法中插入引用代码</span></span><br><span class="line">    CtClass c = classes.getCtClass(<span class="string">"dodola.hotfix.BugClass"</span>)</span><br><span class="line">    <span class="keyword">if</span> (c.isFrozen()) &#123;</span><br><span class="line">        c.defrost()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"====添加构造方法===="</span>)</span><br><span class="line">    def constructor = c.getConstructors()[<span class="number">0</span>];</span><br><span class="line">    constructor.insertBefore(<span class="string">"System.out.println(dodola.hackdex.AntilazyLoad.class);"</span>)</span><br><span class="line">    c.writeFile(buildDir)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    CtClass c1 = classes.getCtClass(<span class="string">"dodola.hotfix.LoadBugClass"</span>)</span><br><span class="line">    <span class="keyword">if</span> (c1.isFrozen()) &#123;</span><br><span class="line">        c1.defrost()</span><br><span class="line">    &#125;</span><br><span class="line">    println(<span class="string">"====添加构造方法===="</span>)</span><br><span class="line">    def constructor1 = c1.getConstructors()[<span class="number">0</span>];</span><br><span class="line">    constructor1.insertBefore(<span class="string">"System.out.println(dodola.hackdex.AntilazyLoad.class);"</span>)</span><br><span class="line">    c1.writeFile(buildDir)</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><p><a href="https://github.com/dodola/HotFix" target="_blank" rel="external">HotFix</a> 框架总体就是这样的了，还是比较简单的。现在作者重新写了一个 <a href="https://github.com/dodola/RocooFix" target="_blank" rel="external">RocooFix</a> 框架，主要解决了 Gradle 1.4 以上无法打包的问题。如果有兴趣的童鞋可以关注一下。</p>
<p>那么今天就到这里了，bye bye ！</p>
<h1 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h1><p>References</p>
<ul>
<li><a href="http://mp.weixin.qq.com/s?__biz=MzI1MTA1MzM2Nw==&amp;mid=400118620&amp;idx=1&amp;sn=b4fdd5055731290eef12ad0d17f39d4a&amp;scene=1&amp;srcid=1031x2ljgSF4xJGlH1xMCJxO&amp;uin=MjAyNzY1NTU%3D&amp;key=04dce534b3b035ef58d8714d714d36bcc6cc7e136bbd64850522b491d143aafceb62c46421c5965e18876433791d16ec&amp;devicetype=iMac+MacBookPro12%2C1+OSX+OSX+10.10.5+build(14F27)&amp;version=11020201&amp;lang=zh_CN&amp;pass_ticket=7O%2FVfztuLjqu23ED2WEkvy1SJstQD4eLRqX%2B%2BbCY3uE%3D" target="_blank" rel="external">安卓App热补丁动态修复技术介绍</a></li>
</ul>
<ul>
<li><a href="http://blog.csdn.net/lmj623565791/article/details/49883661" target="_blank" rel="external">Android 热补丁动态修复框架小结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>讲起 Android 的热修复，相信大家对其都略知一二。热修复可以说是继插件化之后，又一项新的技术。目前的 Android ]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="热修复" scheme="http://yuqirong.me/tags/%E7%83%AD%E4%BF%AE%E5%A4%8D/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React Native热更新集成Code Push]]></title>
    <link href="http://yuqirong.me/2016/11/03/React%20Native%E7%83%AD%E6%9B%B4%E6%96%B0%E9%9B%86%E6%88%90Code%20Push/"/>
    <id>http://yuqirong.me/2016/11/03/React Native热更新集成Code Push/</id>
    <published>2016-11-03T01:30:59.000Z</published>
    <updated>2016-12-14T12:55:50.913Z</updated>
    <content type="html"><![CDATA[<p>Code Push GitHub 地址: <a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">https://github.com/Microsoft/react-native-code-push</a></p>
<h1 id="u57FA_u672C_u5B89_u88C5"><a href="#u57FA_u672C_u5B89_u88C5" class="headerlink" title="基本安装"></a>基本安装</h1><ol>
<li><p>安装 code push cli</p>
<pre><code>npm install -g code-push-cli
</code></pre></li>
<li><p>注册，成功后得到 key 后输入</p>
<pre><code>code-push register
</code></pre></li>
<li><p>在 Code Push 服务器注册 app</p>
<pre><code>code-push app add your_app_name 
</code></pre><p> 查找密钥，有 deployment key 和 staging key 两种</p>
<pre><code>code-push deployment ls your_app_name -k
</code></pre></li>
<li><p>在项目根目录执行以下命令安装react-native-code-push模块</p>
<pre><code>npm install –save react-native-code-push
</code></pre></li>
<li><p>在 Anroid project 中安装插件，CodePush提供了两种方式：RNPM 和 Manual，这里所使用的是RNPM</p>
<pre><code>npm i -g rnpm
</code></pre></li>
<li><p>添加codepush配置，要求输入 deployment key ，可以 ignore</p>
<pre><code>react-native link react-native-code-push
</code></pre><p> 或者<strong>手动配置</strong>，引入项目, 在setting.gradle文件中设置：</p>
<pre><code>include &apos;:react-native-code-push&apos;
project(&apos;:react-native-code-push&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-code-push/android/app&apos;)
</code></pre><p> 在app/build.gradle文件中设置</p>
<pre><code>dependencies {
    ...
    compile project(&apos;:react-native-code-push&apos;)
}
</code></pre><p> 在app/build.gradle文件添加项目依赖：</p>
<pre><code>apply from: &quot;../../node_modules/react-native/react.gradle&quot;
apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot;
</code></pre><p> 在 MainApplication 中添加如下代码：</p>
<pre><code>import com.microsoft.codepush.react.CodePush;

...

@Override

protected String getJSBundleFile() {

    return CodePush.getJSBundleFile();
}
</code></pre></li>
</ol>
<pre><code>@Override

protected List&lt;ReactPackage&gt; getPackages() {

    return Arrays.&lt;ReactPackage&gt;asList(

        new MainReactPackage(),
        // 把 deployment-key-here 替换成你 app 的 key
        new CodePush(&quot;deployment-key-here&quot;, this, BuildConfig.DEBUG)

    );
}
</code></pre><h1 id="JS_u4EE3_u7801"><a href="#JS_u4EE3_u7801" class="headerlink" title="JS代码"></a>JS代码</h1><pre><code>import CodePush from &apos;react-native-code-push&apos;;

CodePush.sync();
</code></pre><h1 id="u4FEE_u6539versionName"><a href="#u4FEE_u6539versionName" class="headerlink" title="修改versionName"></a>修改versionName</h1><p>在 android/app/build.gradle 中有个 android.defaultConfig.versionName 属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数）。</p>
<pre><code>android{
    defaultConfig{
        versionName &quot;1.0.0&quot;
    }
}
</code></pre><h1 id="u6253_u5305_JS_Bundle"><a href="#u6253_u5305_JS_Bundle" class="headerlink" title="打包 JS Bundle"></a>打包 JS Bundle</h1><ol>
<li><p>在工程目录里面新增 bundles 文件：</p>
<pre><code>mkdir bundles
</code></pre></li>
<li><p>运行命令打包 </p>
<pre><code>react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试
</code></pre><p> 例如:</p>
<pre><code>react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false
</code></pre></li>
</ol>
<h1 id="u53D1_u5E03_u66F4_u65B0"><a href="#u53D1_u5E03_u66F4_u65B0" class="headerlink" title="发布更新"></a>发布更新</h1><p>打包bundle结束后，就可以通过CodePush发布更新了。在终端输入</p>
<pre><code>code-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName &lt;更新环境&gt; --description &lt;更新描述&gt;  --mandatory &lt;是否强制更新&gt;
</code></pre><p>例如:</p>
<pre><code>code-push release AwesomeProject ./bundles/index.android.bundle 1.0.0 --deploymentName Staging --description &quot;1.测试更新&quot; --mandatory false
</code></pre><p><strong>注意</strong>：</p>
<ol>
<li><p>Code Push 默认是更新 staging 环境的，如果是 staging ，则不需要填写 deploymentName 。</p>
</li>
<li><p>如果有 mandatory 则 Code Push 会根据 mandatory 是 true 或 false 来控制应用是否强制更新。默认情况下 mandatory 为 false 即不强制更新。</p>
</li>
<li><p>对应的应用版本（targetBinaryVersion）是指当前 app 的版本(对应build.gradle中设置的versionName “1.0.6”)，也就是说此次更新的 js/images 对应的是 app 的那个版本。不要将其理解为这次 js 更新的版本。</p>
<p> 如客户端版本是 1.0.6，那么我们对1.0.6的客户端更新js/images，targetBinaryVersion填的就是1.0.6。</p>
</li>
<li><p>对于对某个应用版本进行多次更新的情况，Code Push 会检查每次上传的 bundle ，如果在该版本下如 1.0.6 已经存在与这次上传完全一样的 bundle (对应一个版本有两个 bundle 的 md5 完全一样)，那么 CodePush 会拒绝此次更新。</p>
</li>
<li><p>在终端输入 <code>code-push deployment history your_app_name Staging</code> 可以看到 staging 版本更新的时间、描述等等属性。</p>
</li>
</ol>
<h1 id="u76F8_u5173_u95EE_u9898"><a href="#u76F8_u5173_u95EE_u9898" class="headerlink" title="相关问题"></a>相关问题</h1><p>进行编译时报错，具体的原因未知。</p>
<p>错误一：</p>
<pre><code>Execution:failed for task &apos;:app:packageDebug&apos;
outDexFolder must be a folder
</code></pre><p>错误二：</p>
<pre><code>Execution:failed for task &apos;:app:packageDebug&apos;
Failed to create \projectName\android\app\buildintermediates\debug\merging
</code></pre><h1 id="React_Native__u83B7_u53D6_u5E94_u7528_u7248_u672C_u53F7"><a href="#React_Native__u83B7_u53D6_u5E94_u7528_u7248_u672C_u53F7" class="headerlink" title="React Native 获取应用版本号"></a>React Native 获取应用版本号</h1><ol>
<li><p>npm install react-native-device-info –save</p>
</li>
<li><p>react-native link react-native-device-info</p>
</li>
<li><p>import com.learnium.RNDeviceInfo.RNDeviceInfo;</p>
</li>
<li><p>获取应用版本号：DeviceInfo.getVersion()</p>
</li>
</ol>
<h1 id="u53C2_u8003_u94FE_u63A5"><a href="#u53C2_u8003_u94FE_u63A5" class="headerlink" title="参考链接"></a>参考链接</h1><ul>
<li><a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">Code Push GitHub</a></li>
<li><a href="http://www.jianshu.com/p/9e3b4a133bcc" target="_blank" rel="external">React Native热更新部署/热更新-CodePush最新集成总结</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>Code Push GitHub 地址: <a href="https://github.com/Microsoft/react-native-code-push" target="_blank" rel="external">https://github.com/Micr]]>
    </summary>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Dynamic-Load-Apk源码解析]]></title>
    <link href="http://yuqirong.me/2016/10/29/Dynamic-Load-Apk%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/10/29/Dynamic-Load-Apk源码解析/</id>
    <published>2016-10-29T13:57:12.000Z</published>
    <updated>2016-11-01T15:12:44.828Z</updated>
    <content type="html"><![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架。<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 是任主席主导开发的一款插件化框架，其中心思想主要就是两个字——<strong>代理</strong>。和我之前分析的 <a href="https://github.com/houkx/android-pluginmgr" target="_blank" rel="external">android-pluginmgr</a> 插件化框架不同的是，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架完全基于在应用层上实现，并不依靠 ActivityThread 、Instrumentation 等。另外，<a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架在插件化发展历程中诞生较早，对后来不断涌现的插件化框架具有深刻的指导意义。</p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><p>注：本文分析的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 为 master 分支，版本为1.0.0；</p>
<p>其实 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的思想很巧妙，大致的思路如下：在宿主中首先申明了一些 ProxyActivity 以及 ProxyService ，插件中的 PluginActivity 要继承指定的 DLBasePluginActivity 。然后启动插件中的 Activity 时，实际上启动的是 ProxyActivity , 之后利用接口回调调用了 PluginActivity 中的生命周期方法。也就是说，PluginActivity 并不是实质上的 Activity ，其实只是一个普通的 Java 类。</p>
<p>在分析源码之前，先在这里简单地说一下 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架的结构：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161029/20161029223619.png" alt="dynamic-load-apk的类结构"></p>
<p>从上面的图中大致可以看出来，整个框架中的 Java 类基本可以分为五种类型：</p>
<ul>
<li><strong>DLPluginManager</strong> ：顾名思义，是整个插件的管理类。主要作用就是加载以及管理插件，启动插件中的Activity、Service等；</li>
<li><strong>DLProxyActivity 、DLProxyFragmentActivity 、DLProxyService</strong> ：代理组件。可以看到有 Activity 、Service 等，在启动插件时实质上启动的是这些代理组件，之后在代理组件中利用接口回调插件的相关“生命周期”；</li>
<li><strong>DLProxyImpl 、DLServiceProxyImpl</strong> ：属于启动插件过程中一些公共逻辑代码。在代理组件连接插件组件时，把一些公共的方法抽取出来放入了这些类中；</li>
<li><strong>DLBasePluginActivity 、DLBasePluginFragmentActivity 、DLBasePluginService</strong> ：插件的基类。用户使用的插件需要继承自这些基类，之后接口才会回调插件的“生命周期”。</li>
<li><strong>DLPlugin 、DLServicePlugin</strong> ：插件“生命周期”定义的接口。在这两个类中定义了 Activity 、Service 相关的生命周期方法。</li>
</ul>
<p>那么接下来我们就一一来解析源码吧。</p>
<h2 id="DLPluginManager-loadApk"><a href="#DLPluginManager-loadApk" class="headerlink" title="DLPluginManager.loadApk"></a>DLPluginManager.loadApk</h2><p>DLPluginManager 是个单例类，我们先来看看它的初始化方法 <code>DLPluginManager.getInstance(Context context)</code> ：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">DLPluginManager</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    mContext = context.getApplicationContext();</span><br><span class="line">    mNativeLibDir = mContext.getDir(<span class="string">"pluginlib"</span>, Context.MODE_PRIVATE).getAbsolutePath();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DLPluginManager <span class="title">getInstance</span><span class="params">(Context context)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (DLPluginManager.class) &#123;</span><br><span class="line">            <span class="keyword">if</span> (sInstance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                sInstance = <span class="keyword">new</span> DLPluginManager(context);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> sInstance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到在构造函数中设置了 .so 文件存储的目录。初始化完成后，通过 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 方法来加载插件：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> DLPluginPackage <span class="title">loadApk</span><span class="params">(<span class="keyword">final</span> String dexPath, <span class="keyword">boolean</span> hasSoLib)</span> </span>&#123;</span><br><span class="line">    mFrom = DLConstants.FROM_EXTERNAL;</span><br><span class="line"></span><br><span class="line">    PackageInfo packageInfo = mContext.getPackageManager().getPackageArchiveInfo(dexPath,</span><br><span class="line">            PackageManager.GET_ACTIVITIES | PackageManager.GET_SERVICES);</span><br><span class="line">    <span class="keyword">if</span> (packageInfo == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="comment">// 得到插件信息封装类</span></span><br><span class="line">    DLPluginPackage pluginPackage = preparePluginEnv(packageInfo, dexPath);</span><br><span class="line">	<span class="comment">// 如果有 .so 文件，则复制到 mNativeLibDir 目录</span></span><br><span class="line">    <span class="keyword">if</span> (hasSoLib) &#123;</span><br><span class="line">        copySoLib(dexPath);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>loadApk(final String dexPath, boolean hasSoLib)</code> 主要做了两件事：</p>
<ol>
<li>在 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法中把插件 packageInfo 封装成 pluginPackage ；</li>
<li>复制 .so 文件到 mNativeLibDir 目录，主要流程就是在 SoLibManager 中利用 I/O 流复制文件。在这里就不讲了，代码比较简单，有兴趣的童鞋可以自己回去看源码；</li>
</ol>
<p>那么我们就跟着主流程来看看 <code>preparePluginEnv(PackageInfo packageInfo, String dexPath)</code> 方法：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> DLPluginPackage <span class="title">preparePluginEnv</span><span class="params">(PackageInfo packageInfo, String dexPath)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 先查看缓存中有没有该 pluginPackage</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageInfo.packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> pluginPackage;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 创建 ClassLoader</span></span><br><span class="line">    DexClassLoader dexClassLoader = createDexClassLoader(dexPath); </span><br><span class="line">    AssetManager assetManager = createAssetManager(dexPath);</span><br><span class="line">    <span class="comment">// 得到插件 res 资源</span></span><br><span class="line">    Resources resources = createResources(assetManager);</span><br><span class="line">    <span class="comment">// create pluginPackage</span></span><br><span class="line">    pluginPackage = <span class="keyword">new</span> DLPluginPackage(dexClassLoader, resources, packageInfo);</span><br><span class="line">    mPackagesHolder.put(packageInfo.packageName, pluginPackage);</span><br><span class="line">    <span class="keyword">return</span> pluginPackage;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据代码可知，在方法中创建了插件的 ClassLoader ，插件的 res 资源。如果你看过我另一篇插件化框架分析的文章<a href="/2016/10/02/插件化框架android-pluginmgr全解析">《插件化框架android-pluginmgr全解析》</a>，那么想必对这其中的原理已经熟知了：</p>
<ol>
<li>插件的类加载器是 DexClassLoader 或其子类，可以指定加载 dex 的目录。对应着上面的 <code>createDexClassLoader(dexPath)</code> 方法；</li>
<li>插件的 res 资源访问主要通过 AssetManager 的 <code>addAssetPath</code> 方法来获取。需要注意的是，<code>addAssetPath</code> 方法是 @hide 的，需要反射来执行。对应着 <code>createAssetManager(dexPath)</code> 方法；</li>
</ol>
<p>createXxxx 方法具体的代码就不在这里贴出来了，想了解的可以查看源码。通过这些 createXxxx 方法，就把插件的 ClassLoader 和 res 资源问题解决了。最后封装成一个 pluginPackage 对象，方便之后使用。</p>
<h2 id="DLPluginManager-startPluginActivityForResult"><a href="#DLPluginManager-startPluginActivityForResult" class="headerlink" title="DLPluginManager.startPluginActivityForResult"></a>DLPluginManager.startPluginActivityForResult</h2><p>加载完插件之后，我们就要着手于如何启动插件了。想要启动插件，就要调用 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法，而 <code>startPluginActivity(Context context, DLIntent dlIntent)</code> 方法内部又是调用 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法的，所以我们直接查看 <code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 的源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">startPluginActivityForResult</span><span class="params">(Context context, DLIntent dlIntent, <span class="keyword">int</span> requestCode)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 是否宿主内部调用</span></span><br><span class="line">    <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">        dlIntent.setClassName(context, dlIntent.getPluginClass());</span><br><span class="line">        performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">        <span class="keyword">return</span> DLPluginManager.START_RESULT_SUCCESS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    String packageName = dlIntent.getPluginPackage();</span><br><span class="line">    <span class="keyword">if</span> (TextUtils.isEmpty(packageName)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"disallow null packageName."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件信息</span></span><br><span class="line">    DLPluginPackage pluginPackage = mPackagesHolder.get(packageName);</span><br><span class="line">    <span class="keyword">if</span> (pluginPackage == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_PKG;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到插件 Activity 的全类名</span></span><br><span class="line">    <span class="keyword">final</span> String className = getPluginActivityFullPath(dlIntent, pluginPackage);</span><br><span class="line">    <span class="comment">// 得到对应的 class</span></span><br><span class="line">    Class&lt;?&gt; clazz = loadPluginClass(pluginPackage.classLoader, className);</span><br><span class="line">    <span class="keyword">if</span> (clazz == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_NO_CLASS;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 根据插件 class 继承的是哪个基类，分别得到对应的代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginActivity ，得到的就是 DLProxyActivity 代理类</span></span><br><span class="line">    <span class="comment">// 若继承的是 DLBasePluginFragmentActivity ，得到的就是 DLProxyFragmentActivity 代理类</span></span><br><span class="line">    Class&lt;? extends Activity&gt; activityClass = getProxyActivityClass(clazz);</span><br><span class="line">    <span class="keyword">if</span> (activityClass == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> START_RESULT_TYPE_ERROR;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 把插件信息传入 Intent 中</span></span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_CLASS, className);</span><br><span class="line">    dlIntent.putExtra(DLConstants.EXTRA_PACKAGE, packageName);</span><br><span class="line">    <span class="comment">// 这里启动的是上面得到的代理类 Activity</span></span><br><span class="line">    dlIntent.setClass(mContext, activityClass);</span><br><span class="line">    <span class="comment">// 启动 Activity</span></span><br><span class="line">    performStartActivityForResult(context, dlIntent, requestCode);</span><br><span class="line">    <span class="keyword">return</span> START_RESULT_SUCCESS;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>startPluginActivityForResult(Context context, DLIntent dlIntent, int requestCode)</code> 方法里基本上都有注释，要明白的是，intent 启动的是代理的 Activity ，并不是我们插件的 Activity 。另外，在 DLPluginManager 里还有启动插件 Service 的相关代码，不过具体的流程和启动插件 Activity 是相似的。如果有想要进一步了解的童鞋可以自行看源码。</p>
<h2 id="DLProxyActivity"><a href="#DLProxyActivity" class="headerlink" title="DLProxyActivity"></a>DLProxyActivity</h2><p>经过上一步之后，我们就启动了代理类 Activity 。代理类 Activity 有两种：DLProxyActivity 和 DLProxyFragmentActivity 。但是其中的逻辑都是一样的。在这里我们只分析 DLProxyActivity 了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLProxyActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> DLPlugin mRemoteActivity;</span><br><span class="line">    <span class="keyword">private</span> DLProxyImpl impl = <span class="keyword">new</span> DLProxyImpl(<span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        impl.onCreate(getIntent());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从类的结构上看到，DLProxyActivity 实现了 DLAttachable 接口。那么 DLAttachable 接口的作用是什么呢：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">DLAttachable</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span><br><span class="line">     * when the proxy impl ( &#123;<span class="doctag">@see</span> DLProxyImpl#launchTargetActivity()&#125; ) launch</span><br><span class="line">     * the plugin activity , dl will call this method to attach the proxy activity</span><br><span class="line">     * and pluginManager to the plugin activity. the proxy activity will load</span><br><span class="line">     * the plugin's resource, so the proxy activity is a resource delegate for</span><br><span class="line">     * plugin activity.</span><br><span class="line">     * </span><br><span class="line">     * <span class="doctag">@param</span> proxyActivity a instance of DLPlugin, &#123;<span class="doctag">@see</span> DLBasePluginActivity&#125;</span><br><span class="line">     *            and &#123;<span class="doctag">@see</span> DLBasePluginFragmentActivity&#125;</span><br><span class="line">     * <span class="doctag">@param</span> pluginManager DLPluginManager instance, manager the plugins</span><br><span class="line">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(DLPlugin proxyActivity, DLPluginManager pluginManager)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据注释的意思是，<code>attach(DLPlugin proxyActivity, DLPluginManager pluginManager)</code> 方法可以在 ProxyImpl 调用 <code>launchTargetActivity()</code> 时把 PluginActivity 和 ProxyActivity 绑定在一起。那样就达到了可以在 ProxyActivity 中使用 PluginActivity 的效果。那么到底在什么时候调用 <code>proxyImpl.launchTargetActivity()</code> 方法呢？我们回到上面的 DLProxyActivity 类中来，看到了 DLProxyActivity 中有一个 <code>impl</code> 成员变量。在 <code>onCreate(Bundle savedInstanceState)</code> 中调用了 <code>impl.onCreate(getIntent())</code> ，我们猜想在 <code>impl.onCreate(getIntent())</code> 的方法里一定会去调用 <code>launchTargetActivity()</code> 方法。下面我们就来看看源码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Intent intent)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// set the extra's class loader</span></span><br><span class="line">    intent.setExtrasClassLoader(DLConfigs.sPluginClassloader);</span><br><span class="line">    <span class="comment">// 得到传过来的插件 Activity 包名和全类名</span></span><br><span class="line">    mPackageName = intent.getStringExtra(DLConstants.EXTRA_PACKAGE);</span><br><span class="line">    mClass = intent.getStringExtra(DLConstants.EXTRA_CLASS);</span><br><span class="line">    Log.d(TAG, <span class="string">"mClass="</span> + mClass + <span class="string">" mPackageName="</span> + mPackageName);</span><br><span class="line">    <span class="comment">// 得到插件相关的信息</span></span><br><span class="line">    mPluginManager = DLPluginManager.getInstance(mProxyActivity);</span><br><span class="line">    mPluginPackage = mPluginManager.getPackage(mPackageName);</span><br><span class="line">    mAssetManager = mPluginPackage.assetManager;</span><br><span class="line">    mResources = mPluginPackage.resources;</span><br><span class="line">    <span class="comment">// 得到要启动插件的 activityInfo，设置插件 Activity 的主题</span></span><br><span class="line">    initializeActivityInfo();</span><br><span class="line">    <span class="comment">// 把 DLProxyActivity 的主题设置为插件 Activity 的主题</span></span><br><span class="line">    handleActivityInfo();</span><br><span class="line">    launchTargetActivity();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在 <code>onCreate(Intent intent)</code> 中得到了之前插件 Activity 相关的信息。然后把 DLProxyActivity 的主题设置为 PluginActivity 的主题。最后调用了  <code>launchTargetActivity()</code> ，说明我们的猜想是正确的。来看看在 <code>launchTargetActivity</code> 方法中到底干了什么：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="annotation">@TargetApi</span>(Build.VERSION_CODES.ICE_CREAM_SANDWICH)</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">launchTargetActivity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="comment">// 得到插件 Activity 的 class</span></span><br><span class="line">        Class&lt;?&gt; localClass = getClassLoader().loadClass(mClass);</span><br><span class="line">        Constructor&lt;?&gt; localConstructor = localClass.getConstructor(<span class="keyword">new</span> Class[] &#123;&#125;);</span><br><span class="line">		<span class="comment">// 创建插件 Activity 的对象</span></span><br><span class="line">        Object instance = localConstructor.newInstance(<span class="keyword">new</span> Object[] &#123;&#125;);</span><br><span class="line">        mPluginActivity = (DLPlugin) instance;</span><br><span class="line">		<span class="comment">// 调用 attach 方法，把插件和代理绑定起来</span></span><br><span class="line">        ((DLAttachable) mProxyActivity).attach(mPluginActivity, mPluginManager);</span><br><span class="line">        Log.d(TAG, <span class="string">"instance = "</span> + instance);</span><br><span class="line">        <span class="comment">// attach the proxy activity and plugin package to the mPluginActivity</span></span><br><span class="line">		<span class="comment">// 手动调用插件的 attach 方法</span></span><br><span class="line">        mPluginActivity.attach(mProxyActivity, mPluginPackage);</span><br><span class="line"></span><br><span class="line">        Bundle bundle = <span class="keyword">new</span> Bundle();</span><br><span class="line">        bundle.putInt(DLConstants.FROM, DLConstants.FROM_EXTERNAL);</span><br><span class="line">		<span class="comment">// 手动调用插件的 onCreate 方法</span></span><br><span class="line">        mPluginActivity.onCreate(bundle);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们发现在方法中使用反射创建了插件 Activity 的对象，又因为插件 Activity 必须继承指定的基类，这些基类是实现了 DLPlugin 接口的。所以插件 Activity 可以强转为 DLPlugin 。DLPlugin 接口定义了一系列的 Activity 生命周期方法，之后手动回调了 <code>attach</code> 和 <code>onCreate</code> 方法。</p>
<p>现在我们再回过头来看看 DLProxyActivity 里的其他生命周期方法，发现都有一句 <code>mRemoteActivity.onXxxxx()</code> 。其中的 mRemoteActivity 就是通过 DLAttachable 接口绑定的插件 Activity 对象。所以每当代理 ProxyActivity 回调生命周期方法时，都调用了 DLPlugin 接口一致的生命周期方法，这样就实现了插件 Activity 也有“生命周期”方法。</p>
<h2 id="DLBasePluginActivity"><a href="#DLBasePluginActivity" class="headerlink" title="DLBasePluginActivity"></a>DLBasePluginActivity</h2><p>讲解了 DLProxyActivity 之后，再来看看 DLBasePluginActivity 就发现轻松多了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DLBasePluginActivity</span> <span class="keyword">extends</span> <span class="title">Activity</span> <span class="keyword">implements</span> <span class="title">DLPlugin</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">	....</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setContentView</span><span class="params">(<span class="keyword">int</span> layoutResID)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.setContentView(layoutResID);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            mProxyActivity.setContentView(layoutResID);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onResume();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="annotation">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (mFrom == DLConstants.FROM_INTERNAL) &#123;</span><br><span class="line">            <span class="keyword">super</span>.onPause();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;	</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DLBasePluginActivity 实现了 DLPlugin 接口，就有了 <code>onCreate()</code> 、<code>onResume()</code> 这些“生命周期”方法。另外在重写的方法中会判断当前否被代理，以此来确定直接走父类逻辑还是代理 Activity 或是空逻辑。</p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><p>讲到这里，整个启动插件 Activity 的流程就走完了。除此之外，还有启动插件 Service 其实也是相似的流程。现在的 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 框架如果实际使用起来可能有比较多的问题，作者也基本上很早就停止更新了。但是这并不妨碍我们分析源码，学习其中的精髓。我想大部分人看完源码都会体会到 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 的核心思想——代理，这也正是和其他插件化框架不同的地方。在这里感谢那些为 <a href="https://github.com/singwhatiwanna/dynamic-load-apk" target="_blank" rel="external">Dynamic-Load-Apk</a> 作出贡献的人。</p>
<p>如果有问题可以留言，Goodbye !</p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><p>Reference：</p>
<ul>
<li><a href="http://a.codekk.com/detail/Android/FFish/DynamicLoadApk%20%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90" target="_blank" rel="external">DynamicLoadApk 源码解析</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><p>趁着今天是周末，无所事事，来讲讲 <a href="https://github.com/singwhatiwanna/dy]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="开源框架" scheme="http://yuqirong.me/tags/%E5%BC%80%E6%BA%90%E6%A1%86%E6%9E%B6/"/>
    
      <category term="插件化" scheme="http://yuqirong.me/tags/%E6%8F%92%E4%BB%B6%E5%8C%96/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[关于Gradle配置的小结]]></title>
    <link href="http://yuqirong.me/2016/10/23/%E5%85%B3%E4%BA%8EGradle%E9%85%8D%E7%BD%AE%E7%9A%84%E5%B0%8F%E7%BB%93/"/>
    <id>http://yuqirong.me/2016/10/23/关于Gradle配置的小结/</id>
    <published>2016-10-23T07:34:50.000Z</published>
    <updated>2016-11-01T15:12:04.741Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免的，比如配置签名、引入依赖等。那么 Gradle 到底是什么东西呢？ Gradle 是一个基于 Apache Ant 和 Apache Maven 概念的项目自动化建构工具。它使用一种基于 Groovy 的特定领域语言 (DSL) 来声明项目设置，抛弃了基于 XML 的各种繁琐配置 (此定义来自于百度百科-_- !) 。啰里啰唆一堆，幸运的是，一般来说 Android 开发者只要会配置 Gradle 就可以了，并不需要深入了解。那么下面我们就来揭开 Gradle 的面纱吧。</p>
<h1 id="Gradle__u914D_u7F6E"><a href="#Gradle__u914D_u7F6E" class="headerlink" title="Gradle 配置"></a>Gradle 配置</h1><p>首先贴出一张自己项目的文件目录结构图：</p>
<p><img src="http://ofyt9w4c2.bkt.clouddn.com/20161023/20161023155409.png" alt="文件目录结构图"></p>
<p>从上图中我们可以看到，与 Gradle 有关的文件基本上分为四种：</p>
<ol>
<li>app 下的 build.gradle (当然其他 module 下也有)；</li>
<li>根目录下的 gradle 文件夹；</li>
<li>根目录下的 build.gradle ；</li>
<li>根目录下的 settings.gradle ；</li>
</ol>
<p>也许有人会说根目录下还有一个 config.gradle 文件呢，其实这是我自定义的 gradle 文件，自定义 Gradle 文件会在下面中讲解，这里先搁置一下。好了，那么我们一个一个地来看看他们的作用吧。</p>
<h2 id="app__u4E0B_u7684_build-gradle"><a href="#app__u4E0B_u7684_build-gradle" class="headerlink" title="app 下的 build.gradle"></a>app 下的 build.gradle</h2><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion <span class="number">23</span> <span class="comment">// 编译sdk版本</span></span><br><span class="line">    buildToolsVersion <span class="string">"23.0.2"</span> <span class="comment">// 构建工具版本</span></span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            minifyEnabled <span class="keyword">true</span> <span class="comment">// 开启混淆</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span> <span class="comment">// 对齐zip</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span> <span class="comment">// 删除无用资源</span></span><br><span class="line">            debuggable <span class="keyword">false</span> <span class="comment">// 是否debug</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span> <span class="comment">// 版本命名后缀</span></span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span> <span class="comment">// 混淆文件</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一句 <code>apply plugin: &#39;com.android.application&#39;</code> 主要用来申明这是一个 Android 程序。而 dependencies 用于引入依赖，这个相信大家都比较了解了。其他的配置比较简单都有注释，就不展开讲了。</p>
<p>当然除了上面的配置之外，还有很多配置也常常写入到 app/build.gradle 中。我们慢慢往下看。</p>
<ul>
<li>签名配置：</li>
</ul>
<figure class="highlight d"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">	</span><br><span class="line">    release &#123; <span class="comment">// 正式版本的签名</span></span><br><span class="line">        storeFile file(<span class="string">"../koku.jks"</span>) <span class="comment">// 密钥文件位置</span></span><br><span class="line">        storePassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 密钥密码</span></span><br><span class="line">        keyAlias <span class="string">"koku"</span> <span class="comment">// 密钥别名</span></span><br><span class="line">        keyPassword <span class="string">"xxxxxxxxx"</span> <span class="comment">// 别名密码</span></span><br><span class="line">    &#125;</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">debug</span> &#123; <span class="comment">// debug版本的签名</span></span><br><span class="line">        <span class="comment">// no keystore</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用时只要在 buildTypes 的 release 中加一句 <code>signingConfig signingConfigs.release</code> 就好了。</p>
<p>如果你觉得把密钥密码和别名密码放在 app/build.gradle 里不安全，那么可以把相关密码放到不加入版本控制系统的 gradle.properties 文件：</p>
<pre><code>KEYSTORE_PASSWORD=xxxxxxxxxx
KEY_PASSWORD=xxxxxxxxx
</code></pre><p>对应的 signingConfigs 配置：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">signingConfigs &#123;</span><br><span class="line">    release &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword KEYSTORE_PASSWORD</span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword KEY_PASSWORD</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (ex) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InvalidUserDataException(<span class="string">"You should define KEYSTORE_PASSWORD and KEY_PASSWORD in gradle.properties."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Java 编译版本配置：</li>
</ul>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">compileOptions &#123; <span class="comment">// java 版本</span></span><br><span class="line">    <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里需要注意下，如果 Java 编译版本为1.8的话，另外在 defaultConfig 里要配置 Jack 编译器：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">jackOptions</span> &#123;</span><br><span class="line">    <span class="title">enabled</span> <span class="built_in">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>Lint 检查配置：</li>
</ul>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="title">lintOptions</span> &#123;</span><br><span class="line">    <span class="title">abortOnError</span> <span class="built_in">false</span> // 是否忽略lint报错</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>多渠道信息配置：</li>
</ul>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">productFlavors</span> &#123;</span><br><span class="line">    <span class="tag">xiaomi</span> &#123;&#125;</span><br><span class="line">    <span class="tag">googleplay</span> &#123;&#125;</span><br><span class="line">    <span class="tag">wandoujia</span> &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>整个 app/build.gradle 文件配置如下所示：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">apply plugin: <span class="string">'com.android.application'</span></span><br><span class="line"></span><br><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId <span class="string">"com.yuqirong.koku"</span> <span class="comment">// 应用包名</span></span><br><span class="line">        minSdkVersion <span class="number">15</span> <span class="comment">// 最低适用sdk版本</span></span><br><span class="line">        targetSdkVersion <span class="number">23</span> <span class="comment">// 目标sdk版本</span></span><br><span class="line">        versionCode <span class="number">1</span> <span class="comment">// 版本号</span></span><br><span class="line">        versionName <span class="string">"1.0"</span> <span class="comment">// 版本名称</span></span><br><span class="line">        testInstrumentationRunner <span class="string">"android.support.test.runner.AndroidJUnitRunner"</span></span><br><span class="line">        <span class="comment">// 默认是umeng的渠道</span></span><br><span class="line">        manifestPlaceholders = [UMENG_CHANNEL_VALUE: <span class="string">"umeng"</span>]</span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    java 版本</span><br><span class="line">    compileOptions &#123;</span><br><span class="line">        <span class="keyword">sourceCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">        <span class="keyword">targetCompatibility</span> JavaVersion.VERSION_1_8</span><br><span class="line">    &#125;</span><br><span class="line">    signingConfigs &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            storeFile <span class="keyword">file</span>(<span class="string">"../koku.jks"</span>)</span><br><span class="line">            storePassword <span class="string">"xxxxxx"</span></span><br><span class="line">            keyAlias <span class="string">"koku"</span></span><br><span class="line">            keyPassword <span class="string">"xxxxxx"</span></span><br><span class="line">        &#125;</span><br><span class="line">        debug &#123;</span><br><span class="line">            <span class="comment">// no keystore</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    buildTypes &#123;</span><br><span class="line">        release &#123;</span><br><span class="line">            <span class="comment">// 开启混淆</span></span><br><span class="line">            minifyEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 对齐zip</span></span><br><span class="line">            zipAlignEnabled <span class="keyword">true</span></span><br><span class="line">            <span class="comment">// 删除无用资源</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 是否debug</span></span><br><span class="line">            debuggable <span class="keyword">false</span></span><br><span class="line">            <span class="comment">// 命名后缀</span></span><br><span class="line">            versionNameSuffix <span class="string">"_release"</span></span><br><span class="line">            <span class="comment">// 签名</span></span><br><span class="line">            signingConfig signingConfigs.release</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">            applicationVariants.all &#123; variant -&gt;</span><br><span class="line">                variant.outputs.<span class="keyword">each</span> &#123; output -&gt;</span><br><span class="line">                    <span class="keyword">def</span> outputFile = output.outputFile</span><br><span class="line">                    <span class="keyword">if</span> (outputFile != <span class="keyword">null</span> &amp;&amp; outputFile.name.endsWith(<span class="string">'.apk'</span>)) &#123;</span><br><span class="line">                        <span class="comment">// 输出apk名称为koku_v1.0_2015-01-15_wandoujia.apk</span></span><br><span class="line">                        <span class="keyword">def</span> fileName = <span class="string">"koku_v$&#123;defaultConfig.versionName&#125;_$&#123;releaseTime()&#125;_$&#123;variant.productFlavors[0].name&#125;.apk"</span></span><br><span class="line">                        output.outputFile = <span class="keyword">new</span> <span class="keyword">File</span>(outputFile.parent, fileName)</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        debug &#123;</span><br><span class="line">            zipAlignEnabled <span class="keyword">false</span></span><br><span class="line">            shrinkResources <span class="keyword">false</span></span><br><span class="line">            minifyEnabled <span class="keyword">false</span></span><br><span class="line">            versionNameSuffix <span class="string">"_debug"</span></span><br><span class="line">            signingConfig signingConfigs.debug</span><br><span class="line">            proguardFiles getDefaultProguardFile(<span class="string">'proguard-android.txt'</span>), <span class="string">'proguard-rules.pro'</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lintOptions &#123;</span><br><span class="line">        abortOnError <span class="keyword">false</span></span><br><span class="line">    &#125;</span><br><span class="line">    productFlavors &#123;</span><br><span class="line">        xiaomi &#123;&#125;</span><br><span class="line">        googleplay &#123;&#125;</span><br><span class="line">        wandoujia &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//针对很多渠道</span></span><br><span class="line">    productFlavors.all &#123;</span><br><span class="line">        flavor -&gt; flavor.manifestPlaceholders = [UMENG_CHANNEL_VALUE: name]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    testCompile <span class="string">'junit:junit:4.12'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:appcompat-v7:23.2.1'</span></span><br><span class="line">    <span class="keyword">compile</span> <span class="string">'com.android.support:design:23.2.1'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> releaseTime() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Date().format(<span class="string">"yyyy-MM-dd"</span>, TimeZone.getTimeZone(<span class="string">"UTC"</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再多嘴一句，有了以上的 build.gradle 配置之后，如果想使用 Gradle 多渠道打包，需要在 AndroidManifest.xml 中申明：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta-data <span class="string">android:</span>name=<span class="string">"UMENG_CHANNEL"</span> <span class="string">android:</span>value=<span class="string">"$&#123;UMENG_CHANNEL_VALUE&#125;"</span> /&gt;</span><br></pre></td></tr></table></figure>
<p>最后使用命令 <code>gradlew assembleRelease</code> 打包即可。</p>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_gradle__u6587_u4EF6_u5939" class="headerlink" title="根目录下的 gradle 文件夹"></a>根目录下的 gradle 文件夹</h2><p>gradle 文件夹中主要是 gradle-wrapper.properties 文件比较重要，主要用来声明 Gradle 目录以及 Gradle 下载路径等：</p>
<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="setting">distributionBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">distributionPath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">zipStoreBase=<span class="value">GRADLE_USER_HOME</span></span></span><br><span class="line"><span class="setting">zipStorePath=<span class="value">wrapper/dists</span></span></span><br><span class="line"><span class="setting">distributionUrl=<span class="value">https\://services.gradle.org/distributions/gradle-<span class="number">2.14</span>.<span class="number">1</span>-all.zip</span></span></span><br></pre></td></tr></table></figure>
<h2 id="u6839_u76EE_u5F55_u4E0B_u7684_build-gradle"><a href="#u6839_u76EE_u5F55_u4E0B_u7684_build-gradle" class="headerlink" title="根目录下的 build.gradle"></a>根目录下的 build.gradle</h2><p>根目录下的 build.gradle 主要作用就是定义项目中公共属性，比如有依赖仓库、 Gradle 构建版本等：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">dependencies</span> &#123;</span><br><span class="line">        <span class="keyword">classpath</span> <span class="string">'com.android.tools.build:gradle:2.2.1'</span></span><br><span class="line">        <span class="comment">// <span class="doctag">NOTE:</span> Do not place your application dependencies here; they belong</span></span><br><span class="line">        <span class="comment">// in the individual module build.gradle files</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">allprojects</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">        mavenCentral()</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">task</span> clean(type: <span class="keyword">Delete</span>) &#123;</span><br><span class="line">    <span class="keyword">delete</span> rootProject.buildDir</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="setting-gradle"><a href="#setting-gradle" class="headerlink" title="setting.gradle"></a>setting.gradle</h2><p>setting.gradle 的作用就是一些模块被包含后，会在这里进行申明：</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">include</span> <span class="string">':app'</span></span><br></pre></td></tr></table></figure>
<h2 id="u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6"><a href="#u81EA_u5B9A_u4E49_Gradle__u6587_u4EF6" class="headerlink" title="自定义 Gradle 文件"></a>自定义 Gradle 文件</h2><p>在上面我们留了一个悬念，就是如何添加我们自定义的 Gradle 文件。接下来我们就动手来实践一下。在项目根目录下创建文件 config.gradle 。然后在根目录下的 build.gradle 开头添加一句 <code>apply from: &quot;config.gradle&quot;</code> ：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">apply <span class="keyword">from</span>: <span class="string">"config.gradle"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">buildscript</span> &#123;</span><br><span class="line">    <span class="keyword">repositories</span> &#123;</span><br><span class="line">        jcenter()</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>这句话就代表着把 config.gradle 添加进来了。然后我们可以在 config.gradle 中申明一些配置：</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">ext &#123;</span><br><span class="line"></span><br><span class="line">    android = [</span><br><span class="line"><span class="label">            compileSdkVersion:</span> <span class="number">23</span>,</span><br><span class="line"><span class="label">            buildToolsVersion:</span> <span class="string">"23.0.3"</span>,</span><br><span class="line">            <span class="string">applicationId    :</span> <span class="string">"com.yuqirong.koku"</span>,</span><br><span class="line">            <span class="string">minSdkVersion    :</span> <span class="number">14</span>,</span><br><span class="line">            <span class="string">targetSdkVersion :</span> <span class="number">23</span>,</span><br><span class="line">            <span class="string">versionCode      :</span> <span class="number">3</span>,</span><br><span class="line">            <span class="string">versionName      :</span> <span class="string">"1.4"</span></span><br><span class="line">    ]</span><br><span class="line"></span><br><span class="line">    dependencies = [</span><br><span class="line">            <span class="string">"appcompat-v7"</span>            : <span class="string">'com.android.support:appcompat-v7:23.0.1'</span>,</span><br><span class="line">            <span class="string">"recyclerview-v7"</span>         : <span class="string">'com.android.support:recyclerview-v7:24.2.1'</span>,</span><br><span class="line">            <span class="string">"design"</span>                  : <span class="string">'com.android.support:design:23.0.1'</span></span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后在 app/build.gradle 中去使用：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">android &#123;</span><br><span class="line">    compileSdkVersion rootProject.ext.android.compileSdkVersion</span><br><span class="line">    buildToolsVersion rootProject.ext.android.buildToolsVersion</span><br><span class="line">    defaultConfig &#123;</span><br><span class="line">        applicationId rootProject.ext.android.applicationId</span><br><span class="line">        minSdkVersion rootProject.ext.android.minSdkVersion</span><br><span class="line">        targetSdkVersion rootProject.ext.android.targetSdkVersion</span><br><span class="line">        versionCode rootProject.ext.android.versionCode</span><br><span class="line">        versionName rootProject.ext.android.versionName</span><br><span class="line"></span><br><span class="line">        jackOptions &#123;</span><br><span class="line">            enabled <span class="keyword">true</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">	...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">dependencies</span> &#123;</span><br><span class="line">    <span class="keyword">compile</span> <span class="keyword">fileTree</span>(dir: <span class="string">'libs'</span>, <span class="keyword">include</span>: [<span class="string">'*.jar'</span>])</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"appcompat-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"recyclerview-v7"</span>]</span><br><span class="line">    <span class="keyword">compile</span> rootProject.ext.<span class="keyword">dependencies</span>[<span class="string">"design"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面可以看到，我们把一些固定的配置“拎”出来放到 config.gradle 中，这样以后直接更改 config.gradle 就行了，方便多人协作开发。</p>
<h1 id="u7ED3_u675F"><a href="#u7ED3_u675F" class="headerlink" title="结束"></a>结束</h1><p>关于 Gradle 的平时经常使用方法基本上就上面这些了。其他的一些比如 <code>buildConfigField</code> 之类的可以自行百度，相信聪明的你很快就会了。但是 Gradle 并没有以上讲得那么简单，还需要童鞋们继续努力学习了。</p>
<p>如果对本文有不明白的地方，欢迎留言。</p>
<p>Goodbye !</p>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://stormzhang.com/android/2016/07/02/gradle-for-android-beginners/" target="_blank" rel="external">给 ANDROID 初学者的 GRADLE 知识普及</a></li>
<li><a href="http://stormzhang.com/android/2016/07/15/android-gradle-config/" target="_blank" rel="external">ANDROID 开发你需要了解的 GRADLE 配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>使用 Android Studio 来开发 Android 工程的过程中，接触 Gradle 是不可避免]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Gradle" scheme="http://yuqirong.me/tags/Gradle/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[React Native环境安装流程]]></title>
    <link href="http://yuqirong.me/2016/10/15/React%20Native%E7%8E%AF%E5%A2%83%E5%AE%89%E8%A3%85%E6%B5%81%E7%A8%8B/"/>
    <id>http://yuqirong.me/2016/10/15/React Native环境安装流程/</id>
    <published>2016-10-15T00:52:40.000Z</published>
    <updated>2016-12-14T13:00:25.324Z</updated>
    <content type="html"><![CDATA[<h1 id="React_Native__u73AF_u5883_u5B89_u88C5"><a href="#React_Native__u73AF_u5883_u5B89_u88C5" class="headerlink" title="React Native 环境安装"></a>React Native 环境安装</h1><ol>
<li><p>安装 Java 、 Android SDK 。这个应该不用讲了，不会的直接自己百度吧。</p>
</li>
<li><p>安装 Node</p>
<p> React Native 需要使用 Node JS 来做服务器，可以去 Node JS 的官网下载安装：</p>
<p> 下载地址：<a href="https://nodejs.org/en/" target="_blank" rel="external">https://nodejs.org/en/</a></p>
<p> 使用 <code>node -v</code> 可以查看 Node JS 安装的版本。</p>
</li>
<li><p>安装 Git</p>
<p> 下载地址：<a href="https://git-scm.com/downloads" target="_blank" rel="external">https://git-scm.com/downloads</a></p>
<p> 配置好环境变量后从 GitHub 把 React Native 仓库 clone 下来。</p>
<p> React Native GitHub 地址：<a href="https://github.com/facebook/react-native.git" target="_blank" rel="external">https://github.com/facebook/react-native.git</a></p>
</li>
</ol>
<ol>
<li><p>安装 React Native 命令行工具 react-native-cli</p>
<p> 打开 clone 下来的 React Native 仓库，进入 /react-native-cli 目录，输入命令 <code>npm install -g</code> 安装</p>
</li>
<li><p>创建 React Native 项目</p>
<p> 进入你希望创建项目的目录后，输入 <code>react-native init [项目名]</code> 创建新项目，比如 <code>react-native init AwesomeProject</code>，等待一段时间项目会创建完成。</p>
</li>
<li><p>运行打包的 Node JS 服务器</p>
<p> 在命令行中进入项目目录，输入 <code>react-native start</code> ，等待一段时间即可。</p>
</li>
<li><p>运行项目</p>
<p> 第六步的服务端不要关闭，重新启动一个新的命令行，进入项目目录，输入 <code>react-native run-android</code> 运行 Android 项目。同理，输入 <code>react-native run-ios</code> 运行 iOS 项目。</p>
</li>
</ol>
<h1 id="References"><a href="#References" class="headerlink" title="References"></a>References</h1><ul>
<li><a href="http://www.lcode.org/%e5%8f%b2%e4%b8%8a%e6%9c%80%e8%af%a6%e7%bb%86windows%e7%89%88%e6%9c%ac%e6%90%ad%e5%bb%ba%e5%ae%89%e8%a3%85react-native%e7%8e%af%e5%a2%83%e9%85%8d%e7%bd%ae/" target="_blank" rel="external">史上最详细Windows版本搭建安装React Native环境配置</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="React_Native__u73AF_u5883_u5B89_u88C5"><a href="#React_Native__u73AF_u5883_u5B89_u88C5" class="headerlink" title="React Native 环境安装"]]>
    </summary>
    
      <category term="React Native" scheme="http://yuqirong.me/tags/React-Native/"/>
    
      <category term="React Native Blog" scheme="http://yuqirong.me/categories/React-Native-Blog/"/>
    
  </entry>
  
</feed>
