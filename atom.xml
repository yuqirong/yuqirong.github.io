<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title><![CDATA[Qirong Yu's Blog]]></title>
  
  <link href="/atom.xml" rel="self"/>
  <link href="http://yuqirong.me/"/>
  <updated>2016-04-18T09:20:33.697Z</updated>
  <id>http://yuqirong.me/</id>
  
  <author>
    <name><![CDATA[俞其荣]]></name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title><![CDATA[带你实现仿美团的下拉刷新]]></title>
    <link href="http://yuqirong.me/2016/04/18/%E5%B8%A6%E4%BD%A0%E5%AE%9E%E7%8E%B0%E4%BB%BF%E7%BE%8E%E5%9B%A2%E7%9A%84%E4%B8%8B%E6%8B%89%E5%88%B7%E6%96%B0/"/>
    <id>http://yuqirong.me/2016/04/18/带你实现仿美团的下拉刷新/</id>
    <published>2016-04-18T07:34:03.000Z</published>
    <updated>2016-04-18T09:20:33.697Z</updated>
    <content type="html"><![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="这里写图片描述"></p>
<p>我们可以大致地分析一下：首先根据下拉改变的 paddingTop 来动态地缩放“绿色椭圆物”,然后当 headerView 的 paddingTop 大于0时，播放美团小人出现的帧动画，最后就是手指松开时播放刷新中的帧动画了。</p>
<p>基本上思路就是上面分析的那样了，那么我们下面一步就是要获取帧动画的素材了。我们先下载好美团的 apk ，解压后在 res/drawable-xhdpi-v4 里，我们可以得到相关的图片了。如果嫌麻烦，文末有本 Demo 的下载链接，里面就有素材图片。</p>
<p>有了图片后我们先写个帧动画的 drawable.xml ：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;animation-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;

    &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_01&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_02&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_03&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_04&quot; android:duration=&quot;100&quot;/&gt;
    &lt;item android:drawable=&quot;@drawable/pull_end_image_frame_05&quot; android:duration=&quot;100&quot;/&gt;

&lt;/animation-list&gt;
</code></pre><p>一共有两个 drawable.xml ，另外一个和这个类似，就不贴出来了。</p>
<p>现在开始编写代码了，创建一个 MeiTuanListView ，继承自 ListView :</p>
<pre><code>public class MeiTuanListView extends ListView {

    // 普通状态模式
    private static final int NONE_MODE = 0;
    // 下拉刷新模式
    private static final int PULL_DOWN_MODE = 1;
    // 可松开刷新模式
    private static final int RELEASE_REFRESH_MODE = 2;
    // 刷新中模式
    private static final int REFRESHING_MODE = 3;
    // 模式
    private int mode = NONE_MODE;
    // 阻值
    private static final int RATIO = 3;
    // 下拉刷新头部
    private View headerRefreshView;
    // 头部高度
    private int refreshViewHeight;
    // 手指按下的Y值
    private float downY;
    // 刷新监听器
    private OnRefreshListener listener;
    // “绿色椭圆物”的自定义View
    private MeiTuanOvalView mtOvalView;
    // 帧动画的ImageView
    private ImageView aniImageView;
    // 动画是否已经开始
    private boolean isStart;
    // 只有在listview顶端时下拉才可以刷新
    private boolean canRefresh;

    private static final String TAG = &quot;MeiTuanListView&quot;;

    public MeiTuanListView(Context context) {
        this(context, null);
    }

    public MeiTuanListView(Context context, AttributeSet attrs) {
        this(context, attrs, 0);
    }

    public MeiTuanListView(Context context, AttributeSet attrs, int defStyleAttr) {
        super(context, attrs, defStyleAttr);
        initView();
    }

    private void initView() {
        setOverScrollMode(View.OVER_SCROLL_NEVER);
        headerRefreshView = LayoutInflater.from(getContext()).inflate(R.layout.layout_header, null);
        mtOvalView = (MeiTuanOvalView) headerRefreshView.findViewById(R.id.mtFirstView);
        aniImageView = (ImageView) headerRefreshView.findViewById(R.id.iv);
        // 去测量
        headerRefreshView.measure(0, 0);
        refreshViewHeight = headerRefreshView.getMeasuredHeight();
        headerRefreshView.setPadding(0, -refreshViewHeight, 0, 0);
        addHeaderView(headerRefreshView, null, false);
    }
</code></pre><p>在<code>initView()</code>中，初始化了下拉刷新的头部，并且设置了 setPadding (关于 ListView 下拉刷新的原理大家应该都懂吧？！)。</p>
<p>layout_header.xml 的布局如下：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:gravity=&quot;center&quot;&gt;

    &lt;com.yuqirong.meituanlistview.view.MeiTuanOvalView
        android:id=&quot;@+id/mtFirstView&quot;
        android:layout_width=&quot;45dp&quot;
        android:layout_height=&quot;wrap_content&quot; /&gt;

    &lt;ImageView
        android:id=&quot;@+id/iv_anim&quot;
        android:layout_width=&quot;45dp&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:visibility=&quot;gone&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>MeiTuanOvalView 这个是关于“绿色椭圆物”的自定义View，会根据 <code>headerView.getPaddingTop()</code> 的值自动缩放，这里就不讲解了，源码还是比较简单的，相关代码可以下载 Demo 查看。而 <code>iv_anim</code> 主要是用来播放帧动画的 ImageView 。</p>
<p>下拉刷新的主要代码都在 <code>onTouchEvent(MotionEvent ev)</code> 里：</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            // 在listview顶端时才可下拉刷新
            if (getFirstVisiblePosition() == 0) {
                Log.i(TAG, &quot;canRefresh : &quot; + canRefresh);
                // 记录手指按下的Y坐标
                downY = ev.getY();
                canRefresh = true;
            }
            break;
        case MotionEvent.ACTION_MOVE:
            if (mode != REFRESHING_MODE &amp;&amp; canRefresh) {
                float moveY = ev.getY();
                float offsetY = moveY - downY;
                // 动态改变paddingTop值
                headerRefreshView.setPadding(0, (int) (headerRefreshView.getPaddingTop() + offsetY / RATIO), 0, 0);
                if (headerRefreshView.getPaddingTop() &lt;= 0) {
                    mode = PULL_DOWN_MODE;
                    mtOvalView.setVisibility(VISIBLE);
                    aniImageView.setVisibility(GONE);
                    mtOvalView.setScale((refreshViewHeight + headerRefreshView.getPaddingTop()) * 1f / refreshViewHeight);
                    isStart = false;
                } else {
                    mode = RELEASE_REFRESH_MODE;
                    if (!isStart) {
                        mtOvalView.setVisibility(GONE);
                        aniImageView.setVisibility(VISIBLE);
                        aniImageView.setImageResource(R.drawable.pull_end_imag_frame);
                        AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();
                        // 只执行一次动画
                        animationDrawable.setOneShot(true);
                        animationDrawable.start();
                        isStart = true;
                    }
                }
                downY = moveY;
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mode != REFRESHING_MODE &amp;&amp; canRefresh) {
                if (headerRefreshView.getPaddingTop() &gt; 0) {
                    mode = REFRESHING_MODE;
                    headerRefreshView.setPadding(0, 0, 0, 0);
                    aniImageView.setImageResource(R.drawable.refreshing_image_frame);
                    AnimationDrawable animationDrawable = (AnimationDrawable) aniImageView.getDrawable();
                    animationDrawable.start();
                    if (listener != null) {
                        listener.refreshing();
                    }
                } else {
                    mode = NONE_MODE;
                    headerRefreshView.setPadding(0, -refreshViewHeight, 0, 0);
                    mtOvalView.setScale(0f);
                    isStart = false;
                    canRefresh = false;
                }
            }
            break;
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>里面的代码逻辑还是比较简单的：</p>
<ul>
<li>ACTION_DOWN ：首先判断了当 ListView 在顶端时才可以下拉刷新，并且记录了手指按下的Y坐标；</li>
<li>ACTION_MOVE ：根据滑动的 offsetY 来动态地设置 headerView 的 paddingTop 。我们可以看到在 <code>if (headerRefreshView.getPaddingTop() &lt;= 0)</code> 里面根据 paddingTop 的值来动态地设置 <code>mtOvalView</code> 的 scale ，并且在 <code>setScale()</code> 方法里面会调用 <code>invalidate()</code> ，从而让 <code>mtOvalView</code> 去重绘。不然 <code>headerRefreshView.getPaddingTop()</code> 大于0时就播放了美团小人出场的动画。</li>
<li>ACTION_UP ：当手指松开的时候，还是判断了 <code>headerRefreshView.getPaddingTop()</code> 的值。若大于0则把 headerView 全部显示出来，播放刷新中的动画，并且回调了刷新监听器的接口；小于0则把 headerView 重新隐藏起来。并重置相关的值。</li>
</ul>
<p>要注意的一点是，在 <code>onTouchEvent(MotionEvent ev)</code> 里要返回 <code>super.onTouchEvent(ev)</code> 。不能是直接返回 <code>true</code> 。因为在 <code>super.onTouchEvent(ev)</code> 里处理了 ListView 滑动的相关逻辑。</p>
<p>当获取到最新数据后，可以调用<code>notifyRefreshFinished()</code>方法完成下拉刷新：</p>
<pre><code>public interface OnRefreshListener {
    void refreshing();
}

public void setOnRefreshListener(OnRefreshListener listener) {
    this.listener = listener;
}

// 刷新完成后调用
public void notifyRefreshFinished() {
    mode = NONE_MODE;
    headerRefreshView.setPadding(0, -refreshViewHeight, 0, 0);
    aniImageView.setVisibility(GONE);
    mtOvalView.setVisibility(VISIBLE);
    isStart = false;
    canRefresh = false;
}
</code></pre><p>最后就是附上效果图了：</p>
<p><img src="/uploads/20160418/20160418165251.gif" alt="这里写图片描述"></p>
<p>到这里整体就讲解得差不多了，至于 MeiTuanListView 的使用示例以及 MeiTuanOvalView 的源码可以在 Demo 里查看。</p>
<p>Demo下载链接：</p>
<p><a href="/uploads/20160418/MeiTuanListView.rar">MeiTuanListView.rar</a></p>
<p>good bye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有一段时间没更新博客了，近来都在做毕业设计，今天空出时间来更新一发。给大家带来的是仿美团的下拉刷新。相信美团大家都用过，下面就贴出了美团的下拉刷新效果：</p>
<p><img src="/uploads/20160418/20160418160532.gif" alt="]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[FloatingActionButton在滚动时显示或隐藏]]></title>
    <link href="http://yuqirong.me/2016/04/10/FloatingActionButton%E5%9C%A8%E6%BB%9A%E5%8A%A8%E6%97%B6%E6%98%BE%E7%A4%BA%E6%88%96%E9%9A%90%E8%97%8F/"/>
    <id>http://yuqirong.me/2016/04/10/FloatingActionButton在滚动时显示或隐藏/</id>
    <published>2016-04-10T11:51:22.000Z</published>
    <updated>2016-04-13T12:27:55.483Z</updated>
    <content type="html"><![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>其实关于FAB的显示和隐藏，Google官方就提供了其中一种方案：<code>fab.hidden()</code>和<code>fab.show()</code>。但是自带的是FAB缩放的效果。并不是上下移动的效果。</p>
<p>那么我们就来看看如何实现FAB上下移动的效果吧！</p>
<p>首先在你想要滑动的View(比如说RecyclerView等)的布局上加上：</p>
<pre><code>app:layout_behavior=&quot;@string/appbar_scrolling_view_behavior&quot;
</code></pre><p>然后再附上FAB的xml：</p>
<pre><code>&lt;android.support.design.widget.FloatingActionButton
   android:id=&quot;@+id/fab&quot;
   android:layout_width=&quot;wrap_content&quot;
   android:layout_height=&quot;wrap_content&quot;
   android:layout_gravity=&quot;bottom|end&quot;
   android:layout_margin=&quot;@dimen/fab_margin&quot;
   app:layout_behavior=&quot;com.yuqirong.rxnews.ui.view.ScrollAwareFABBehavior&quot;
   android:src=&quot;@android:drawable/ic_dialog_email&quot; /&gt;
</code></pre><p>注意其中的layout_behavior，是我们自己实现的一个类：</p>
<pre><code>public class ScrollAwareFABBehavior extends FloatingActionButton.Behavior {

    private static final Interpolator INTERPOLATOR = new FastOutSlowInInterpolator();
    private boolean mIsAnimatingOut = false;

    public ScrollAwareFABBehavior(Context context, AttributeSet attrs) {
        super();
    }

    @Override
    public boolean onStartNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child,
                                       final View directTargetChild, final View target, final int nestedScrollAxes) {
        // Ensure we react to vertical scrolling
        return nestedScrollAxes == ViewCompat.SCROLL_AXIS_VERTICAL
                || super.onStartNestedScroll(coordinatorLayout, child, directTargetChild, target, nestedScrollAxes);
    }

    @Override
    public void onNestedScroll(final CoordinatorLayout coordinatorLayout, final FloatingActionButton child,
                               final View target, final int dxConsumed, final int dyConsumed,
                               final int dxUnconsumed, final int dyUnconsumed) {
        super.onNestedScroll(coordinatorLayout, child, target, dxConsumed, dyConsumed, dxUnconsumed, dyUnconsumed);
        if (dyConsumed &gt; 0 &amp;&amp; !this.mIsAnimatingOut &amp;&amp; child.getVisibility() == View.VISIBLE) {
            // User scrolled down and the FAB is currently visible -&gt; hide the FAB
            animateOut(child);
        } else if (dyConsumed &lt; 0 &amp;&amp; child.getVisibility() != View.VISIBLE) {
            // User scrolled up and the FAB is currently not visible -&gt; show the FAB
            animateIn(child);
        }
    }

    // Same animation that FloatingActionButton.Behavior uses to hide the FAB when the AppBarLayout exits
    private void animateOut(final FloatingActionButton button) {
        if (Build.VERSION.SDK_INT &gt;= 14) {
            ViewCompat.animate(button).translationY(button.getHeight() + getMarginBottom(button)).setInterpolator(INTERPOLATOR).withLayer()
                    .setListener(new ViewPropertyAnimatorListener() {
                        public void onAnimationStart(View view) {
                            ScrollAwareFABBehavior.this.mIsAnimatingOut = true;
                        }

                        public void onAnimationCancel(View view) {
                            ScrollAwareFABBehavior.this.mIsAnimatingOut = false;
                        }

                        public void onAnimationEnd(View view) {
                            ScrollAwareFABBehavior.this.mIsAnimatingOut = false;
                            view.setVisibility(View.GONE);
                        }
                    }).start();
        } else {
            button.hide();
        }
    }

    // Same animation that FloatingActionButton.Behavior uses to show the FAB when the AppBarLayout enters
    private void animateIn(FloatingActionButton button) {
        button.setVisibility(View.VISIBLE);
        if (Build.VERSION.SDK_INT &gt;= 14) {
            ViewCompat.animate(button).translationY(0)
                    .setInterpolator(INTERPOLATOR).withLayer().setListener(null)
                    .start();
        } else {
            button.show();
        }
    }

    private int getMarginBottom(View v) {
        int marginBottom = 0;
        final ViewGroup.LayoutParams layoutParams = v.getLayoutParams();
        if (layoutParams instanceof ViewGroup.MarginLayoutParams) {
            marginBottom = ((ViewGroup.MarginLayoutParams) layoutParams).bottomMargin;
        }
        return marginBottom;
    }

}
</code></pre><p>我们主要看<code>onNestedScroll()</code>这个方法，在方法里主要判断了一下是向上滑还是向下滑。再分别去调用<code>animateOut()</code>和<code>animateIn()</code>。那我们就来看看<code>animateOut()</code>。(<code>animateIn()</code>和<code>animateOut()</code>的原理一样的，我们只看<code>animateOut()</code>吧)</p>
<p>在<code>animateOut()</code>根据SDK的版本判断，若大于或等于14使用属性动画；不然就是使用了自带的<code>hide()</code>方法。代码还是比较简单的，相信大家都能看得懂。当然如下想在SDK 14以下使用上下移动的效果，那就要用NineOldAndroids这个库了。</p>
<p>效果就是如下所示了：</p>
<p><img src="/uploads/20160413/20160413202356.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这了。bye！</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在Material Design中，FloatingActionButton(即FAB)是一个很重要的元素。而通常在列表向下滚动的时候，FAB应该会隐藏；而在向上滚动时，FAB应该会显示出来。本篇就记录其中一种实现FAB显示或隐藏的方案，主要应用了属性动画。</p>
<p>]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[深入解析Scroller滚动原理]]></title>
    <link href="http://yuqirong.me/2016/04/05/%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90Scroller%E6%BB%9A%E5%8A%A8%E5%8E%9F%E7%90%86/"/>
    <id>http://yuqirong.me/2016/04/05/深入解析Scroller滚动原理/</id>
    <published>2016-04-05T12:21:10.000Z</published>
    <updated>2016-04-05T16:04:28.032Z</updated>
    <content type="html"><![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括为“三部曲”：</p>
<ol>
<li><p>创建一个Scroller对象，一般在View的构造器中创建：</p>
<pre><code>public ScrollViewGroup(Context context) {
    this(context, null);
}

public ScrollViewGroup(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public ScrollViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    mScroller = new Scroller(context);
}
</code></pre></li>
<li><p>重写View的computeScroll()方法，下面的代码基本是不会变化的：</p>
<pre><code>@Override
public void computeScroll() {
    super.computeScroll();
    if (mScroller.computeScrollOffset()) {
        scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
        postInvalidate();
    }
}
</code></pre></li>
<li><p>调用startScroll()方法，startX和startY为开始滚动的坐标点，dx和dy为对应的偏移量：</p>
<pre><code>mScroller.startScroll (int startX, int startY, int dx, int dy);
invalidate();
</code></pre></li>
</ol>
<p>上面的三步就是Scroller的基本用法了。那接下来的任务就是解析Scroller的滚动原理了。</p>
<p>而在这之前，我们还有一件事要办，那就是搞清楚scrollTo()和scrollBy()的原理。scrollTo()和scrollBy()的区别我这里就不重复叙述了，不懂的可以自行google或百度。下面贴出scrollTo()的源码：</p>
<pre><code>public void scrollTo(int x, int y) {
    if (mScrollX != x || mScrollY != y) {
        int oldX = mScrollX;
        int oldY = mScrollY;
        mScrollX = x;
        mScrollY = y;
        invalidateParentCaches();
        onScrollChanged(mScrollX, mScrollY, oldX, oldY);
        if (!awakenScrollBars()) {
            postInvalidateOnAnimation();
        }
    }
}
</code></pre><p>设置好mScrollX和mScrollY之后，调用了<code>onScrollChanged(mScrollX, mScrollY, oldX, oldY);</code>，View就会被重新绘制。这样就达到了滑动的效果。</p>
<p>下面我们再来看看scrollBy()：</p>
<pre><code>public void scrollBy(int x, int y) {
    scrollTo(mScrollX + x, mScrollY + y);
}
</code></pre><p>这样简短的代码相信大家都懂了，原来scrollBy()内部是调用了scrollTo()的。但是scrollTo()/scrollBy()的滚动都是瞬间完成的，怎么样才能实现平滑滚动呢。</p>
<p>不知道大家有没有这样一种想法：如果我们把要滚动的偏移量分成若干份小的偏移量，当然这份量要大。然后用scrollTo()/scrollBy()每次都滚动小份的偏移量。在一定的时间内，不就成了平滑滚动了吗？没错，Scroller正是借助这一原理来实现平滑滚动的。下面我们就来看看源码吧！</p>
<p>根据“三部曲”中第一部，先来看看Scroller的构造器：</p>
<pre><code>public Scroller(Context context, Interpolator interpolator, boolean flywheel) {
    mFinished = true;
    if (interpolator == null) {
        mInterpolator = new ViscousFluidInterpolator();
    } else {
        mInterpolator = interpolator;
    }
    mPpi = context.getResources().getDisplayMetrics().density * 160.0f;
    mDeceleration = computeDeceleration(ViewConfiguration.getScrollFriction());
    mFlywheel = flywheel;

    mPhysicalCoeff = computeDeceleration(0.84f); // look and feel tuning
}
</code></pre><p>在构造器中做的主要就是指定了插补器，如果没有指定插补器，那么就用默认的ViscousFluidInterpolator。</p>
<p>我们再来看看Scroller的startScroll()：</p>
<pre><code>public void startScroll(int startX, int startY, int dx, int dy, int duration) {
    mMode = SCROLL_MODE;
    mFinished = false;
    mDuration = duration;
    mStartTime = AnimationUtils.currentAnimationTimeMillis();
    mStartX = startX;
    mStartY = startY;
    mFinalX = startX + dx;
    mFinalY = startY + dy;
    mDeltaX = dx;
    mDeltaY = dy;
    mDurationReciprocal = 1.0f / (float) mDuration;
}
</code></pre><p>我们发现，在startScroll()里面并没有开始滚动，而是设置了一堆变量的初始值，那么到底是什么让View开始滚动的？我们应该把目标集中在startScroll()的下一句<code>invalidate();</code>身上。我们可以这样理解：首先在startScroll()设置好了一堆初始值，之后调用了<code>invalidate();</code>让View重新绘制，这里又有一个很重要的点，在draw()中会调用<code>computeScroll()</code>这个方法！</p>
<p>源码太长了，在这里就不贴出来了。想看的童鞋在View类里面搜<code>boolean draw(Canvas canvas, ViewGroup parent, long drawingTime)</code>这个方法就能看到了。通过ViewGroup.drawChild()方法就会调用子View的draw()方法。而在View类里面的<code>computeScroll()</code>是一个空的方法，需要我们去实现：</p>
<pre><code> /**
 * Called by a parent to request that a child update its values for mScrollX
 * and mScrollY if necessary. This will typically be done if the child is
 * animating a scroll using a {@link android.widget.Scroller Scroller}
 * object.
 */
public void computeScroll() {
}
</code></pre><p>而在上面“三部曲”的第二部中，我们就已经实现了<code>computeScroll()</code>。首先判断了<code>computeScrollOffset()</code>，我们来看看相关源码：</p>
<pre><code>/**
 * Call this when you want to know the new location.  If it returns true,
 * the animation is not yet finished.
 */ 
public boolean computeScrollOffset() {
    if (mFinished) {
        return false;
    }

    int timePassed = (int)(AnimationUtils.currentAnimationTimeMillis() - mStartTime);

    if (timePassed &lt; mDuration) {
        switch (mMode) {
        case SCROLL_MODE:
            final float x = mInterpolator.getInterpolation(timePassed * mDurationReciprocal);
            mCurrX = mStartX + Math.round(x * mDeltaX);
            mCurrY = mStartY + Math.round(x * mDeltaY);
            break;
        case FLING_MODE:
            final float t = (float) timePassed / mDuration;
            final int index = (int) (NB_SAMPLES * t);
            float distanceCoef = 1.f;
            float velocityCoef = 0.f;
            if (index &lt; NB_SAMPLES) {
                final float t_inf = (float) index / NB_SAMPLES;
                final float t_sup = (float) (index + 1) / NB_SAMPLES;
                final float d_inf = SPLINE_POSITION[index];
                final float d_sup = SPLINE_POSITION[index + 1];
                velocityCoef = (d_sup - d_inf) / (t_sup - t_inf);
                distanceCoef = d_inf + (t - t_inf) * velocityCoef;
            }

            mCurrVelocity = velocityCoef * mDistance / mDuration * 1000.0f;

            mCurrX = mStartX + Math.round(distanceCoef * (mFinalX - mStartX));
            // Pin to mMinX &lt;= mCurrX &lt;= mMaxX
            mCurrX = Math.min(mCurrX, mMaxX);
            mCurrX = Math.max(mCurrX, mMinX);

            mCurrY = mStartY + Math.round(distanceCoef * (mFinalY - mStartY));
            // Pin to mMinY &lt;= mCurrY &lt;= mMaxY
            mCurrY = Math.min(mCurrY, mMaxY);
            mCurrY = Math.max(mCurrY, mMinY);

            if (mCurrX == mFinalX &amp;&amp; mCurrY == mFinalY) {
                mFinished = true;
            }

            break;
        }
    }
    else {
        mCurrX = mFinalX;
        mCurrY = mFinalY;
        mFinished = true;
    }
    return true;
}
</code></pre><p>这个方法的返回值有讲究，若返回true则说明Scroller的滑动没有结束；若返回false说明Scroller的滑动结束了。再来看看内部的代码：先是计算出了已经滑动的时间，若已经滑动的时间小于总滑动的时间，则说明滑动没有结束；不然就说明滑动结束了，设置标记<code>mFinished = true;</code>。而在滑动未结束里面又分为了两个mode，不过这两个mode都干了差不多的事，大致就是根据刚才的时间<code>timePassed</code>和插补器来计算出该时间点滚动的距离<code>mCurrX</code>和<code>mCurrY</code>。也就是上面“三部曲”中第二部的mScroller.getCurrX(), mScroller.getCurrY()的值。</p>
<p>然后在第二部曲中调用scrollTo()方法滚动到指定点(即上面的<code>mCurrX</code>, <code>mCurrY</code>)。之后又调用了<code>postInvalidate();</code>，让View重绘并重新调用<code>computeScroll()</code>以此循环下去，一直到View滚动到指定位置为止，至此Scroller滚动结束。</p>
<p>其实Scroller的原理还是比较通俗易懂的。我们再来理清一下思路，以一张图的形式来终结今天的Scroller解析：</p>
<p><img src="/uploads/20160405/20160405235023.png" alt="这里写图片描述"></p>
<p>好了，如果有什么问题可以在下面留言。</p>
<p>Goodbye!</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在看《Android开发艺术探索》这本书，不得不赞一句主席写得真好，受益匪浅。在书中的相关章节有介绍用Scroller来实现平滑滚动的效果。而我们今天就来探究一下为什么Scroller能够实现平滑滚动。</p>
<p>首先我们先来看一下Scroller的用法，基本可概括]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[Android安全机制之反编译]]></title>
    <link href="http://yuqirong.me/2016/04/03/Android%E5%AE%89%E5%85%A8%E6%9C%BA%E5%88%B6%E4%B9%8B%E5%8F%8D%E7%BC%96%E8%AF%91/"/>
    <id>http://yuqirong.me/2016/04/03/Android安全机制之反编译/</id>
    <published>2016-04-02T16:59:11.000Z</published>
    <updated>2016-04-03T05:30:16.355Z</updated>
    <content type="html"><![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米修斯方法”以及“宙斯类”(不得不感慨开发小哥的智商)。之后就是在阅读《Android群英传》时也有相关反编译的内容，觉得有必要记录一下。所以这就是本片写博文的起源了。</p>
<p>首先关于反编译，我们先要准备几个工具：</p>
<ul>
<li>apktool：aoktool主要是用来反编译资源文件的，也就是XML了。</li>
<li>Dex2jar：Dex2jar就是反编译源代码的，会把源代码反编译成一个jar包。</li>
<li>jd-gui ：在上面Dex2jar反编译出来的jar包，放入jd-gui中，就可以查看源代码了。</li>
</ul>
<p>关于上面的三个工具，我会在文末放出下载链接，大家可以去下载。</p>
<p>好了，那接下来我们就开始反编译之旅吧！</p>
<p>至于要反编译的apk，我只能选择自己的<a href="https://github.com/yuqirong/Koku" target="_blank" rel="external">Koku</a>了，<a href="http://www.wandoujia.com/apps/com.yuqirong.koku/download" target="_blank" rel="external">点击此处下载</a>。</p>
<p>我们把上面下载下来的apk用winrar打开(当然你也可以用其他的解压工具)，我们可以看到里面的文件内容如下图所示：</p>
<p><img src="/uploads/20160403/20160403112646.png" alt="这里写图片描述"></p>
<p>我们发现classes.dex这个文件，其实classes.dex反编译出来就是源代码。然后我们把Dex2jar解压出来，发现里面有d2j-dex2jar.bat，这就是主角了。</p>
<p><img src="/uploads/20160403/20160403124449.png" alt="这里写图片描述"></p>
<p>在Dex2jar解压出来的目录下，打开命令提示符输入：</p>
<pre><code>d2j-dex2jar.bat classes.dex所在的路径
</code></pre><p>比如：</p>
<p><img src="/uploads/20160403/20160403124911.png" alt="这里写图片描述"></p>
<p>运行后，我们发现在Dex2jar解压出来的目录下多了一个classes-dex2jar.jar。</p>
<p><img src="/uploads/20160403/20160403125136.png" alt="这里写图片描述"></p>
<p>然后我们把下载下来的jd-gui.zip解压，里面会有jd-gui.exe。相信大家都懂吧。用jd-gui.exe打开上面的classes-dex2jar.jar，你会惊喜地发现源代码就在你眼前！</p>
<p><img src="/uploads/20160403/20160403125619.png" alt="这里写图片描述"></p>
<p>看上面的代码截图，我们会发现比如说<code>setContentView()</code>里面是一串数字。不过别怕，我们都知道R文件是用来关联资源文件的，把上面的那串数字复制下来，再打开R.class，查找一下：</p>
<p><img src="/uploads/20160403/20160403130002.png" alt="这里写图片描述"></p>
<p>原来那串数字就代表了activity_my_favorite.xml这个layout。那么问题来了，我们如何反编译XML文件呢？那就要用到上面的apktool了。</p>
<p>打开apktool的所在目录，把koku.apk移动到apktool的同一目录下，输入命令符：</p>
<pre><code>java -jar apktool_2.1.0.jar d koku.apk
</code></pre><p>如果你配置了Java环境变量，则可以直接输入：</p>
<pre><code>apktool_2.1.0.jar d koku.apk
</code></pre><p>运行完成之后，我们可以发现在目录下多了一个名字叫koku的文件夹，而这就是我们反编译出来的XML文件了。</p>
<p><img src="/uploads/20160403/20160403131154.png" alt="这里写图片描述"></p>
<p>我们打开里面的AndroidManifest.xml：</p>
<p><img src="/uploads/20160403/20160403131326.png" alt="这里写图片描述"></p>
<p>里面真的有<uses-permission\>、<activity\>等信息！然后我们打开res里面的layout文件夹，会发现里面有我们上面提到的activity_my_favorite.xml：</activity\></uses-permission\></p>
<p><img src="/uploads/20160403/20160403131658.png" alt="这里写图片描述"></p>
<p>里面的布局一目了然。到这里，这样一个apk的基本的源代码我们都可以看得到。当然，反编译别人的apk应该是以学习为主，而不是恶意地二次打包以及破坏。</p>
<p>在这里额外多说一句，如果要反编译的apk经过了代码混淆，那么反编译出来的就变成了a.class、b.class、c.class等等，所以代码混淆可以有效地阻止apk反编译。</p>
<p>而如果你想要将代码混淆，只要打开项目中的build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能。proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><p>好了，差不多该讲的都讲完了，今天就到这里了。</p>
<p>下面给出反编译工具的下载链接：</p>
<p><a href="/uploads/20160403/apktool_2.1.0.jar">apktool_2.1.0.jar</a></p>
<p><a href="/uploads/20160403/dex2jar-2.0.zip">dex2jar-2.0.zip</a></p>
<p><a href="/uploads/20160403/jd-gui-0.3.5.windows.zip">jd-gui-0.3.5.windows.zip</a></p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天我们就来探讨一下反编译，其实反编译在我一开始学习Android的时候就听说过，但是一直没有去尝试。初次接触应该就是那次“蜻蜓FM v5.0.1 apk”事件了( 此处应有掌声(¯ □ ¯) )。那时根据网上的教程第一次反编译了“蜻蜓FM”的apk，看到了传说中的“普罗米]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android开发艺术探索》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/03/31/%E3%80%8AAndroid%E5%BC%80%E5%8F%91%E8%89%BA%E6%9C%AF%E6%8E%A2%E7%B4%A2%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/03/31/《Android开发艺术探索》笔记(上)/</id>
    <published>2016-03-31T11:49:28.000Z</published>
    <updated>2016-04-14T12:32:57.356Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="第一章：Activity的生命周期和启动模式"></a>第一章：Activity的生命周期和启动模式</h1><h2 id="1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790"><a href="#1-1_Activity_u7684_u751F_u547D_u5468_u671F_u5168_u9762_u5206_u6790" class="headerlink" title="1.1 Activity的生命周期全面分析"></a>1.1 Activity的生命周期全面分析</h2><p><strong>典型情况下的生命周期分析</strong></p>
<p>onStart()和onStop()是从Activity是否可见这个角度来回调的，而onResume()和onPause()是从Activity是否位于前台这个角度来回调的。</p>
<p>Activity A打开Activity B时，为了不影响B的显示，最好不要在Activity A的onPause()里执行一些耗时操作，可以考虑将这些操作放到onStop()里，这时B已经可见了。</p>
<p><strong>异常情况下的生命周期分析</strong></p>
<p>由于Activity是在异常情况下终止的，系统会调用onSaveInstanceState()来保存当前Activity的状态。这个方法的调用时机是在onStop()之前，但它和onPause()没有既定的时序关系，它既可能在onPause()之前调用，也可能在onPause()之后调用。需要强调的一点是，这个方法只会出现在Activity被异常终止的情况下，正常情况下系统不会调用onSaveInstanceState()这个方法。</p>
<p>当Activity被重新创建后，系统会调用onRestoreInstanceState()，并且把Activity销毁时onSaveInstanceState()方法所保存的Bundle对象作为参数同时传递给onRestoreInstanceState()和onCreate()方法。因此我们可以通过onRestoreInstanceState()和onCreate()方法来判断Activity是否重建了。如果被重建了，那么我们就可以取出之前保存的数据并恢复，从时序上来说，onRestoreInstanceState的调用时机在onStart()之后。</p>
<p>和Activity一样，每个View都有onSaveInstanceState()和onRestoreInstanceState()这两个方法。关于保存和恢复View层次结构，系统的工作流程是这样的：首先Activity会委托Window去保存数据，接着Window再委托它上面的顶级容器去保存数据。顶层容器是一个ViewGroup，一般来说它很可能是DecorWindow。最后顶层容器再去一一通知它的子元素来保存数据，这样整个数据保存过程就完成了。可以发现，这是一种典型的委托思想，上层委托下层、父层委托子元素去处理一件事情。至于数据恢复过程也是类似的，这里就不再重复介绍了。</p>
<p>Activity按照优先级从高到低，可以分为如下三种：</p>
<ul>
<li>前台Activity——正在和用户交互的Activity，优先级最高。</li>
<li>可见但非前台Activity——比如Activity中弹出了一个对话框，导致Activity可见但是位于后台无法和用户直接交互。</li>
<li>后台Activity——已经被暂停的Activity，比如说执行了onStop，优先级最低。</li>
</ul>
<p>如果不想Activity在屏幕旋转的时候重新创建，则：</p>
<pre><code>android:configChanges=&quot;orientation&quot;
</code></pre><p>另外，若minSdkVersion和targetSdkVersion其中有一个低于13，则要在上面的基础上，加上screenSize，即：</p>
<pre><code>android:configChanges=&quot;orientation|screenSize&quot;
</code></pre><h2 id="1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F"><a href="#1-2_Activity_u7684_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="1.2 Activity的启动模式"></a>1.2 Activity的启动模式</h2><p><strong>Activity的launchMode</strong></p>
<ul>
<li><p>standard 标准模式。每次启动会重新创建新的实例，谁启动了这个Activity，这个Activity就运行在启动仪它的那个Activity所在的栈里。另外要注意的是，当我们用ApplicationContext去启动standard模式的Activity的时候会报错，错误如下</p>
<pre><code>E/AndroidRuntime(674):andriod.util.AndroidRuntimeException: Calling startActivity from outside of an Activity context requires the FLAG_ACTIVITY_NEW_TASK flag.Is this really what you want?
</code></pre><p>  这是因为standard模式的Activity默认会进入启动它的Activity所属的任务栈中，但是由于非Activity类型的Context(如ApplicationContext)并没有所谓的任务栈，所以这就有问题了。解决这个问题的方法是为待启动Activity指定FLAG_ACTIVITY_NEW_TASK标记位，这样启动的时候就会为它创建一个新的任务栈，这个时候待启动Activity实际上是以singleTask模式启动的。</p>
</li>
<li><p>singleTop 栈顶复用模式。若该Activity已经位于任务栈的栈顶，那么该Activity不会被重新创建，同时它的onNewIntent()方法会被回调，通过此方法的参数我们可以取出当前请求的信息。而且它的onCreate()和onStart()并不会被调用。执行的是onPause() –&gt; onNewIntent() –&gt; onResume()。 如果该Activity已存在但不是位于栈顶，则该Activity仍然会被重新创建。</p>
</li>
<li><p>singleTask 栈内复用模式。这是一种单实例模式，在这种模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，和singleTop一样，系统也会回调其onNewsIntent()。具体一点，当一个具有singleTask模式的Activity请求启动后，比如说Activity A，系统首先会寻找是否存在A想要的任务栈，如果不存在，就重新创建一个任务栈，然后创建A的实例后把A放到栈中。如果存在把A所需的任务栈，这时要看A是否在栈中有实例存在，如果有实例存在，那么系统就会把A调到栈顶(会把在栈中所有处于A之上的Activity全部出栈)并调用它的onNewsIntent()方法，如果实例不存在，就创建A的实例并把A压入栈中。</p>
<p>  设ActivityA的 android:launchMode=”singleTask” 方式，且ActivityA正处于栈中，但不是栈顶，栈顶为ActivityB，点击按钮启动ActivityA，则：<br>  B: onPause() -&gt; A: onNewIntent() -&gt; A:onRestart() -&gt; A: onStart() -&gt; A:onResume() -&gt; B: onStop() -&gt; B: onDestroy()</p>
</li>
<li><p>singleInstance 单实例模式。这是一种加强的singleTask模式，它除了具有singleTask模式的所有特性外，还加强了一点，那就是具有此种模式的Activity只能单独地位于一个任务栈中。换句话说，比如Activity A是singleInstance模式，当A启动后，系统会为它创建一个新的任务栈，然后A独自在这个新的任务栈中，由于栈内复用的特性，后续的请求均不会创建新的Activity。除非这个独特的任务栈被系统销毁了。</p>
</li>
</ul>
<p><code>android:taskAffinity</code>：可以翻译为任务相关性。这个参数标识了一个Activity所需要的任务栈的名字，默认情况下，所有Activity所需的任务栈的名字为报名。当然，我们可以为每个Activity都单独制定TaskAffinity属性，这个属性必须不能和包名相同，否则就相当于没有指定。TaskAffinity属性主要和singleTask启动模式或者allowTaskReparenting属性配对使用，在其他情况下没有意义。另外，任务栈分为前台任务栈和后台任务栈，后台任务栈中的Activity位于暂停状态，用户可以通过切换将后台任务栈再次调到前台。</p>
<ul>
<li><p>当TaskAffinity和singleTask启动模式配对使用的时候，它是具有该模式的Activity的目前任务栈的名字，待启动的Activity会运行在名字和TaskAffinity相同的任务栈中。</p>
</li>
<li><p>当TaskAffinity和allowTaskReparenting结合的时候，这种情况比较复杂，会产生特殊的效果。当一个应用A启动了应用B的某个Activity后，如果这个Activity的allowTaskReparenting属性为true的话，那么当应用B被启动后，此Activity会直接从应用A的任务栈转移到应用B的任务栈中。</p>
</li>
</ul>
<p><strong>Activity的Flags</strong></p>
<ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：为Activity指定“singleTask”启动模式，其效果和在XML中指定该启动模式相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：具有此标记位的Activity，当它启动时，在同一个任务栈中所有位于它上面的Activity都要出栈。这个模式一般需要和FLAG_ACTIVITY_NEW_TASK配合使用。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：具有这个标记的Activity不会出现在历史Activity的列表中，当某些情况下我们不希望用户通过历史列表回到我们的Activity的时候这个标记比较有用。它等同于在XML中指定Activity的属性<code>android:excludeFromRecents=&quot;true&quot;</code>。</p>
</li>
</ul>
<h2 id="1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219"><a href="#1-3_IntentFilter_u7684_u5339_u914D_u89C4_u5219" class="headerlink" title="1.3 IntentFilter的匹配规则"></a>1.3 IntentFilter的匹配规则</h2><ul>
<li>action匹配规则：要求intent中的action 存在 且 必须和过滤规则中的其中一个相同 区分大小写；</li>
<li>category匹配规则：系统会默认加上一个android.intent.category.DEAFAULT，所以intent中可以不存在category，但如果存在就必须匹配其中一个；</li>
<li>data匹配规则：data由两部分组成，mimeType和URI，要求和action相似。如果没有指定URI，URI但默认值为content和file（schema）。如果要为intent指定完整的data，必须要调用setDataAndType方法。</li>
</ul>
<h1 id="u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236"><a href="#u7B2C_u4E8C_u7AE0_uFF1AIPC_u673A_u5236" class="headerlink" title="第二章：IPC机制"></a>第二章：IPC机制</h1><h2 id="2-1_Android_IPC_u7B80_u4ECB"><a href="#2-1_Android_IPC_u7B80_u4ECB" class="headerlink" title="2.1 Android IPC简介"></a>2.1 Android IPC简介</h2><h2 id="2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F"><a href="#2-2_Android_u4E2D_u7684_u591A_u8FDB_u7A0B_u6A21_u5F0F" class="headerlink" title="2.2 Android中的多进程模式"></a>2.2 Android中的多进程模式</h2><p><strong>开启多进程模式</strong></p>
<p>在Android中使用多进程只有一个办法，那就是给四大组件(Activity、Service、Receiver、ContentProvider)在AndroidMenifest中指定android:process属性。另外还有一种非常规的多进程方法，那就是通过JNI在native层去fork一个新的进程。</p>
<p>进程名以“:”开头的进程属于当前应用的私有进程，其他应用的组件不可以和它跑在同一个进程中，而进程名不以“:”开头的进程属于全局过程，其他应用可以通过ShareUID方式和它跑在同一个进程中。</p>
<p>我们知道Android系统会为每个应用分配一个唯一的UID，具有相同UID的应用才能共享数据。这里要说明的是，两个应用通过ShareUID跑在同一个进程中是有要求的，需要这两个应用有相同的ShareUID并且签名相同才可以。在这种情况下，它们可以互相访问对方的私有数据，比如data目录、组件信息等，不管它们是否跑在同一个进程中。当然如果它们跑在同一个进程中，那么除了能共享data目录、组件信息，还可以共享内存数据，或者说他们看起来就像是一个应用的两个部分。</p>
<p><strong>多进程模式的运行机制</strong></p>
<p>Android会为每一个应用分配一个独立的虚拟机，或者说为每个进程都分配一个独立的虚拟机，不同的虚拟机在内存分配上有不同的地址空间，这就导致在不同的虚拟机中访问同一个类的对象会产生多份副本。</p>
<p>一般来说，使用多进程会造成如下几方面的问题：</p>
<ol>
<li>静态成员和单例模式完全失效；</li>
<li>线程同步机制完全失效；</li>
<li>SharedPreferences的可靠性下降；</li>
<li>Application会多次创建。</li>
</ol>
<h2 id="2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD"><a href="#2-3_IPC_u57FA_u7840_u6982_u5FF5_u4ECB_u7ECD" class="headerlink" title="2.3 IPC基础概念介绍"></a>2.3 IPC基础概念介绍</h2><p><strong>Serializable接口</strong></p>
<p>通过Serializable来实现对象的序列化和反序列化(User类实现了Serializable接口)：</p>
<pre><code>// 序列化过程
User user = new User(0,&quot;jake&quot;,true);
ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(&quot;cache.txt&quot;));
out.writeObject(user);
out.close();

// 反序列化过程
ObjectInputStream in = new ObjectInputStream(new FileInputStream(&quot;cache.txt&quot;))；
User newUser = (User)in.readObject();
in.close();
</code></pre><p>恢复的对象newUser和user的内容完全一样，但是两者并不是同一个对象。</p>
<p>原则上序列化后的数据中的serialVerionUID只有和当前类的serialVersionUID相同才能够正常地被反序列化。</p>
<p>有两个需要注意一下：</p>
<ul>
<li>静态成员变量属于类不属于对像，所以不会参与序列化过程；</li>
<li>用transient关键字标记的成员变量不参与序列化过程。</li>
</ul>
<p><strong>Parcelable接口</strong></p>
<p>Serializable是Java中的序列化接口，其使用起来简单但是开销很大，序列化和反序列化过程需要大量I/O操作。而Parcelable是Android中的序列化方式，因此更适合在Android平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高，因此推荐使用Parcelable。</p>
<p><strong>Binder</strong></p>
<p>// TODO</p>
<h1 id="u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB"><a href="#u7B2C_u4E09_u7AE0_uFF1AView_u7684_u4E8B_u4EF6_u4F53_u7CFB" class="headerlink" title="第三章：View的事件体系"></a>第三章：View的事件体系</h1><h2 id="3-1_View_u57FA_u7840_u77E5_u8BC6"><a href="#3-1_View_u57FA_u7840_u77E5_u8BC6" class="headerlink" title="3.1 View基础知识"></a>3.1 View基础知识</h2><p><strong>View的位置参数</strong></p>
<ul>
<li>View的宽高和坐标关系：width = right - left，height = top - bottom。</li>
<li>View在平移过程中，top和left表示的是原始左上角的位置信息，其值不会改变，发生改变的是x、y、translationX、translationY这四个参数。x是View左上角的坐标，translation是view移动后相对于父容器的偏移量，所以有x = left + translationX。y的原理相同。</li>
</ul>
<p><strong>MotionEvent和TouchSlop</strong></p>
<p>TouchSlop是系统所能识别出的被认为是滑动的最小距离。这是一个常量，和设备有关，在不同设备上这个值可能是不同的，通过如下方式即可获取这个常量：<code>ViewConfiguration.get(getContext()).getScaledTouchSlop()</code>。当两次滑动事件的滑动距离小于TouchSlop时就可以认为不是滑动。</p>
<p><strong>VelocityTracker、GestureDetector和Scroller</strong></p>
<p>1.VelocityTracker</p>
<p>速度追踪。用于追踪手指在滑动过程中的速度，包括水平和竖直方向的速度。首先，在View的onTouchEvent方法中追踪当前单击事件的速度。</p>
<pre><code>VelocityTracker velocityTracker = VelocityTracker.obtain();
velocityTracker.addMovement(event);
</code></pre><p>获取当前的速度：</p>
<pre><code>velocityTracker.computeCurrentVelocity(1000); //表示的是一个时间单元或者说时间间隔
int xVelocity = (int) velocityTracker.getXVelocity();
int yVelocity = (int) velocityTracker.getYVelocity();
</code></pre><p>当不用它的时候，需要调用clear()方法来重置并回收内存：</p>
<pre><code>velocityTracker.clear();
velocityTracker.recycle();
</code></pre><p>2.GestureDetector</p>
<p>手势检测，用于辅助检测用户的单击、滑动、长按、双击等行动。</p>
<p>首先，需要创建一个GestureDetector对象并实现OnGestureListener接口，根据需要我们还可以实现OnDoubleTapListener从而能够监听双击行为：</p>
<pre><code>GestureDetector mGestureDetector = new GestureDetector(this);
// 解决长按屏幕后无法拖动的现象
mGestureDetector.setIsLongpressEnabled(false)；
</code></pre><p>接着，接管目标View的onTouchEvent方法，在待监听View的onTouchEvent方法中添加如下实现：</p>
<pre><code>boolean consume = mGestureDetector.onTouchEvent(event);
return consume;
</code></pre><p>做完了上面两步，我们就可以有选择地实现OnGestureListener和OnDoubleTapListener中的方法了。</p>
<p>3.Scroller</p>
<p>在3.2节中详细介绍。</p>
<h2 id="3-2_View_u7684_u6ED1_u52A8"><a href="#3-2_View_u7684_u6ED1_u52A8" class="headerlink" title="3.2 View的滑动"></a>3.2 View的滑动</h2><ul>
<li><p>使用scrollTo/scrollBy：操作简单，适合对View内容的滑动</p>
</li>
<li><p>使用动画：操作简单，主要适用于没有交互的View和实现复杂的动画效果</p>
</li>
<li><p>改变布局参数：操作稍微复杂，使用于有交互的View</p>
</li>
</ul>
<h2 id="3-3__u5F39_u6027_u6ED1_u52A8"><a href="#3-3__u5F39_u6027_u6ED1_u52A8" class="headerlink" title="3.3 弹性滑动"></a>3.3 弹性滑动</h2><ul>
<li><p>使用Scroller</p>
</li>
<li><p>通过动画</p>
</li>
<li><p>使用Handler延时策略</p>
</li>
</ul>
<h2 id="3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236"><a href="#3-4_View_u7684_u4E8B_u4EF6_u5206_u53D1_u673A_u5236" class="headerlink" title="3.4 View的事件分发机制"></a>3.4 View的事件分发机制</h2><p>当一个点击事件产生后，它的传递过程遵循如下顺序：Activity-&gt;Window-&gt;View。即事件总是先传递给Activity，Activity再传递给Window，最后Window再传递给顶级View。顶级View接收到事件后，就会按照事件分发机制去分发事件。</p>
<p>主要过程：Activity的dispatchTouchEvent–&gt;Window的superDispatchTouchEvent(Window实际上是一个抽象类，而它的实现类为PhoneWindow)–&gt;DecorView的superDispatchTouchEvent(DecorView是继承自FrameLayout，是Activity的根View)–&gt;分发到子View中(即分发到contentView中)。</p>
<p>注意点：</p>
<ul>
<li><p>如果一个View的onTouchEvent返回false，那么它的父容器的onTouchEvent将会被调用，依此类推。如果所有的元素都不处理这个事件，那么这个事件将会最终传递给Activity处理，即Activity的onTouchEvent方法会被调用。</p>
</li>
<li><p>某个view一旦开始处理事件，如果它不消耗ACTION_DOWN事件，那么同一事件序列的其他事件都不会再交给它来处理，并且事件将重新交给它的父容器去处理(调用父容器的onTouchEvent方法)；如果它消耗ACTION_DOWN事件，但是不消耗其他类型事件，那么这个点击事件会消失，父容器的onTouchEvent方法不会被调用，当前view依然可以收到后续的事件，但是这些事件最后都会传递给Activity处理。</p>
</li>
<li><p>View的enable属性不影响onTouchEvent的默认返回值。哪怕一个view是disable状态，只要它的clickable或者longClickable有一个是true，那么它的onTouchEvent就会返回true。</p>
</li>
<li><p>通过requestDisallowInterceptTouchEvent方法可以在子元素中干预父元素的事件分发过程，但是ACTION_DOWN事件除外。</p>
</li>
<li><p>ViewGroup的dispatchTouchEvent方法中有一个标志位FLAG_DISALLOW_INTERCEPT，这个标志位就是通过子view调用requestDisallowInterceptTouchEvent方法来设置的，一旦设置为true，那么ViewGroup不会拦截该事件。</p>
</li>
</ul>
<h2 id="3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81"><a href="#3-5_View_u7684_u6ED1_u52A8_u51B2_u7A81" class="headerlink" title="3.5 View的滑动冲突"></a>3.5 View的滑动冲突</h2><p><strong>常见的滑动冲突场景</strong></p>
<p>常见的滑动冲突场景可以简单分为如下三种：</p>
<ul>
<li>场景1——外部滑动方向和内部滑动方向不一致</li>
<li>场景2——外部滑动方向和内部滑动方向一致</li>
<li>场景3——上面两种情况的嵌套</li>
</ul>
<p><strong>滑动冲突处理规则</strong></p>
<p>可以根据滑动距离和水平方向形成的夹角；或者根绝水平和竖直方向滑动的距离差；或者两个方向上的速度差等</p>
<p><strong>滑动冲突的解决方式</strong></p>
<p>外部拦截法：点击事件都先经过父容器的拦截处理，如果父容器需要此事件就拦截，如果不需要就不拦截。该方法需要重写父容器的onInterceptTouchEvent方法，在内部做相应的拦截即可，其他均不需要做修改。</p>
<p>伪代码如下：</p>
<pre><code>public boolean onInterceptTouchEvent(MotionEvent event) {
    boolean intercepted = false;
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        intercepted = false;
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastXIntercept;
        int deltaY = y - mLastYIntercept;
        if (父容器需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            intercepted = true;
        } else {
            intercepted = false;
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        intercepted = false;
        break;
    }
    default:
        break;
    }

    mLastXIntercept = x;
    mLastYIntercept = y;

    return intercepted;
}
</code></pre><p>内部拦截法：父容器不拦截任何事件，所有的事件都传递给子元素，如果子元素需要此事件就直接消耗掉，否则就交给父容器来处理。这种方法和Android中的事件分发机制不一致，需要配合requestDisallowInterceptTouchEvent方法才能正常工作。</p>
<p>伪代码如下：</p>
<p>子元素：</p>
<pre><code>public boolean dispatchTouchEvent(MotionEvent event) {
    int x = (int) event.getX();
    int y = (int) event.getY();

    switch (event.getAction()) {
    case MotionEvent.ACTION_DOWN: {
        getParent().requestDisallowInterceptTouchEvent(true);
        break;
    }
    case MotionEvent.ACTION_MOVE: {
        int deltaX = x - mLastX;
        int deltaY = y - mLastY;
        if (当前view需要拦截当前点击事件的条件，例如：Math.abs(deltaX) &gt; Math.abs(deltaY)) {
            getParent().requestDisallowInterceptTouchEvent(false);
        }
        break;
    }
    case MotionEvent.ACTION_UP: {
        break;
    }
    default:
        break;
    }

    mLastX = x;
    mLastY = y;
    return super.dispatchTouchEvent(event);
}
</code></pre><p>父元素：</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent event) {
    int action = event.getAction();
    if(action == MotionEvent.ACTION_DOWN){
        return false;
    }else{
        return true;
    }
}
</code></pre><h1 id="u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406"><a href="#u7B2C_u56DB_u7AE0_uFF1AView_u7684_u5DE5_u4F5C_u539F_u7406" class="headerlink" title="第四章：View的工作原理"></a>第四章：View的工作原理</h1><h2 id="4-1__u521D_u8BC6ViewRoot_u548CDecorView"><a href="#4-1__u521D_u8BC6ViewRoot_u548CDecorView" class="headerlink" title="4.1 初识ViewRoot和DecorView"></a>4.1 初识ViewRoot和DecorView</h2><p>ViewRoot对应于ViewRootImpl类，它是连接WindowManager和DecorView的纽带，View的三大流程均是通过ViewRoot来完成。在ActivityThread中，当Activity对象被创建完毕后，会将DecorView添加到Window中，同时会创建ViewRootImpl对象，并将ViewRootImpl对象和DecorView建立关联，这个过程可参看如下源码：</p>
<pre><code>root = new ViewRootImpl(view.getContext(), display);
root.setView(view, wparams, panelParentView);
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E00_u7AE0_uFF1AActivity_u7684_u751F_u547D_u5468_u671F_u548C_u542F_u52A8_u6A21_u5F0F"><a href="#u7B2C_u4E00_u7AE0_uFF1AActivi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android艺术开发探索》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E8%89%BA%E6%9C%AF%E5%BC%80%E5%8F%91%E6%8E%A2%E7%B4%A2%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[初探MD式转场动画]]></title>
    <link href="http://yuqirong.me/2016/03/23/%E5%88%9D%E6%8E%A2MD%E5%BC%8F%E8%BD%AC%E5%9C%BA%E5%8A%A8%E7%94%BB/"/>
    <id>http://yuqirong.me/2016/03/23/初探MD式转场动画/</id>
    <published>2016-03-23T08:44:22.000Z</published>
    <updated>2016-04-13T12:30:31.327Z</updated>
    <content type="html"><![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是Google在SDK中已经给我们提供了。<code>ActivityOptions</code>是 Android 5.0 及以上使用的，但是也提供了<code>ActivityOptionsCompat</code>向下兼容。</p>
<p>下面我们就来看看吧：</p>
<p>layout_item.xml(ListView的item布局)：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;@android:color/white&quot;
    android:padding=&quot;10dp&quot;&gt;

    &lt;ImageView
        android:id=&quot;@+id/iv_img&quot;
        android:layout_width=&quot;90dip&quot;
        android:layout_height=&quot;65dip&quot;
        android:transitionName=&quot;photos&quot;
        android:padding=&quot;1dp&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_title&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:layout_marginTop=&quot;2dp&quot;
        android:layout_toRightOf=&quot;@id/iv_img&quot;
        android:singleLine=&quot;true&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Subhead&quot;
        android:textColor=&quot;?android:attr/textColorPrimary&quot;
        tools:text=&quot;标题&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_content&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_below=&quot;@id/tv_title&quot;
        android:layout_marginLeft=&quot;8dp&quot;
        android:layout_marginTop=&quot;8dp&quot;
        android:layout_toRightOf=&quot;@id/iv_img&quot;
        android:maxLines=&quot;2&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Small&quot;
        android:textColor=&quot;?android:attr/textColorPrimary&quot;
        tools:text=&quot;标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题标题&quot; /&gt;

    &lt;TextView
        android:id=&quot;@+id/tv_time&quot;
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:layout_alignParentRight=&quot;true&quot;
        android:layout_below=&quot;@+id/tv_content&quot;
        android:maxLines=&quot;1&quot;
        android:text=&quot;2016-02-25 11:22:23&quot;
        android:textAppearance=&quot;@style/TextAppearance.AppCompat.Small&quot;
        android:textColor=&quot;?android:attr/textColorSecondary&quot;
        android:textSize=&quot;12sp&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>我们会注意到在ImageView里有<code>android:transitionName=&quot;photos&quot;</code>，这正是后面需要用到的。在这里的<code>photos</code>可以任意取名。也就是说你想让哪个View在转场时表现出动画，就在哪个View的xml中添加<code>android:transitionName</code>。</p>
<p>之后就是我们点击Item时应该跳转到另一个Activity中(这里就跳转到NewsDetailActivity了)，这其中的逻辑如下：</p>
<pre><code>// Android 5.0 使用转场动画
if (android.os.Build.VERSION.SDK_INT &gt;= android.os.Build.VERSION_CODES.LOLLIPOP) {
    ActivityOptions options = ActivityOptions
            .makeSceneTransitionAnimation(getActivity(),
                    itemView.findViewById(R.id.iv_img), &quot;photos&quot;);
    startActivity(NewsDetailActivity.class, bundle, options.toBundle());
} else {
    //让新的Activity从一个小的范围扩大到全屏
    ActivityOptionsCompat options = ActivityOptionsCompat
            .makeScaleUpAnimation(itemView, itemView.getWidth() / 2,
                    itemView.getHeight() / 2, 0, 0);
    startActivity(NewsDetailActivity.class, bundle, options.toBundle());
}
</code></pre><p>可以看到在Android 5.0时使用的<code>makeSceneTransitionAnimation()</code>方法中的第三个参数正是上面的<code>&quot;photos&quot;</code>。当然在5.0版本以下我们只能使用兼容的<code>ActivityOptionsCompat</code>了。</p>
<p>最后在要跳转的Activity的布局中也添加<code>android:transitionName=&quot;photos&quot;</code>，这样就形成了一个MD式转场动画了。</p>
<p>以下是NewsDetailActivity的布局xml(只截取了部分)：</p>
<pre><code>&lt;ImageView
    android:id=&quot;@+id/iv_album&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;256dp&quot;
    android:scaleType=&quot;centerCrop&quot;
    android:src=&quot;@drawable/thumbnail_default&quot;
    android:transitionName=&quot;photos&quot;
    app:layout_collapseMode=&quot;parallax&quot;
    app:layout_collapseParallaxMultiplier=&quot;0.7&quot; /&gt;
</code></pre><p>好了，这样就完成了，如果你需要在NewsDetailActivity执行finish时也出现转场动画，你只需要这样做(这里只给出了<code>onBackPressed()</code>的样例)：</p>
<pre><code>@Override
public void onBackPressed() {
    super.onBackPressed();
    if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.LOLLIPOP) {
        finishAfterTransition();
    }
}
</code></pre><p>其实关于<code>ActivityOptions</code>和<code>ActivityOptionsCompat</code>转场动画还有更多选择，可以深入研究一下。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.lxway.com/895445426.htm" target="_blank" rel="external">你所不知道的Activity转场动画——ActivityOptions</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>最近在做MD设计风格的APP，所以在转场动画上当然也得符合MD了。下面就是效果图：</p>
<p><img src="/uploads/20160323/20160323165423.gif" alt="这里写图片描述"></p>
<p>一开始并未了解过这种转场动画，原来是]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Material Design" scheme="http://yuqirong.me/tags/Material-Design/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[快速打造仿Android联系人界面]]></title>
    <link href="http://yuqirong.me/2016/03/22/%E5%BF%AB%E9%80%9F%E6%89%93%E9%80%A0%E4%BB%BFAndroid%E8%81%94%E7%B3%BB%E4%BA%BA%E7%95%8C%E9%9D%A2/"/>
    <id>http://yuqirong.me/2016/03/22/快速打造仿Android联系人界面/</id>
    <published>2016-03-22T07:53:24.000Z</published>
    <updated>2016-03-22T13:24:29.627Z</updated>
    <content type="html"><![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这里写图片描述"></p>
<p>我们可以看到在右侧有一个支持快速索引的栏。接下来，我们就要实现这种索引栏。</p>
<p>首先是<code>attrs.xml</code>，定义了三个自定义属性：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;QuickIndexBar&quot;&gt;
        // 字体的颜色
        &lt;attr name=&quot;font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 选中时字体的颜色
        &lt;attr name=&quot;selected_font_color&quot; format=&quot;color|reference&quot;&gt;&lt;/attr&gt;
        // 字体的大小
        &lt;attr name=&quot;font_size&quot; format=&quot;dimension|reference&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们创建一个类继承自<code>View</code>，类名就叫<code>QuickIndexBar</code>：</p>
<pre><code>// 默认字体颜色
private int defaultFontColor = Color.WHITE;
// 默认选中字体颜色
private int defaultSelectedFontColor = Color.GRAY;
// 字体颜色
private int fontColor;
// 选中字体颜色
private int selectedFontColor;
 // 字体大小
private float fontSize;
// 默认字体大小
private float defaultfontSize = 12;
// 上次触摸的字母单元格
int lastSelected = -1;
// 这次触摸的字母单元格
int selected = -1;

public QuickIndexBar(Context context) {
    this(context, null);
}

public QuickIndexBar(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public QuickIndexBar(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);

    TypedArray a = getContext().obtainStyledAttributes(attrs, R.styleable.QuickIndexBar);
    fontColor = a.getColor(R.styleable.QuickIndexBar_font_color, defaultFontColor);
    selectedFontColor = a.getColor(R.styleable.QuickIndexBar_selected_font_color, defaultSelectedFontColor);
    fontSize = a.getDimension(R.styleable.QuickIndexBar_font_size,
            TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_SP, defaultfontSize,
                    getContext().getResources().getDisplayMetrics()));
    a.recycle();
    mPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
    mPaint.setColor(fontColor);
    mPaint.setTypeface(Typeface.DEFAULT_BOLD);
    mPaint.setTextSize(fontSize);

}
</code></pre><p>上面的代码就是在构造器中初始化了自定义属性，大家应该都能看懂。</p>
<pre><code>// 快速索引的字母
public static final String[] INDEX_ARRAYS = new String[]{&quot;#&quot;, &quot;A&quot;, &quot;B&quot;,
        &quot;C&quot;, &quot;D&quot;, &quot;E&quot;, &quot;F&quot;, &quot;G&quot;, &quot;H&quot;, &quot;I&quot;, &quot;J&quot;, &quot;K&quot;, &quot;L&quot;, &quot;M&quot;, &quot;N&quot;, &quot;O&quot;,
        &quot;P&quot;, &quot;Q&quot;, &quot;R&quot;, &quot;S&quot;, &quot;T&quot;, &quot;U&quot;, &quot;V&quot;, &quot;W&quot;, &quot;X&quot;, &quot;Y&quot;, &quot;Z&quot;};
// 控件的宽度
private int width;
// 控件的高度
private int height;
// 字母单元格的宽度
private float cellHeight;

/**
 * 得到控件的大小
 */
@Override
protected void onSizeChanged(int w, int h, int oldw, int oldh) {
    super.onSizeChanged(w, h, oldw, oldh);
    width = getMeasuredWidth();
    height = getMeasuredHeight();
    //  得到字母单元格的高度
    cellHeight = height * 1.0f / INDEX_ARRAYS.length;
}
</code></pre><p>然后在<code>onSizeChanged(int w, int h, int oldw, int oldh)</code>中获取<code>width</code>和<code>height</code>。还要计算<code>cellHeight</code>,也就是<code>INDEX_ARRAYS</code>中每个字符串所占用的高度，以便在<code>onDraw(Canvas canvas)</code>中使用。</p>
<p>我们来看看<code>onDraw(Canvas canvas)</code>：</p>
<pre><code>@Override
protected void onDraw(Canvas canvas) {
    // 遍历画出index
    for (int i = 0; i &lt; INDEX_ARRAYS.length; i++) {
        // 测出字体的宽度
        float x = width / 2 - mPaint.measureText(INDEX_ARRAYS[i]) / 2;
        // 得到字体的高度
        Paint.FontMetrics fm = mPaint.getFontMetrics();
        double fontHeight = Math.ceil(fm.descent - fm.ascent);

        float y = (float) ((i + 1) * cellHeight - cellHeight / 2 + fontHeight / 2);
        if (i == selected) {
            mPaint.setColor(lastSelected == -1 ? fontColor : selectedFontColor);
        } else {
            mPaint.setColor(fontColor);
        }
        // 绘制索引的字母 (x,y)为字母左下角的坐标
        canvas.drawText(INDEX_ARRAYS[i], x, y, mPaint);
    }

}
</code></pre><p>在代码中去遍历<code>INDEX_ARRAYS</code>，测量出字母的宽度和高度。这里要注意的是，<code>canvas.drawText(String text, float x, float y, Paint paint)</code>中的 x,y 指的是字母左下角的坐标，并不是“原点”。</p>
<p>别忘了我们还要对<code>QuickIndexBar</code>的触摸事件作出处理。所以我们要重写onTouchEvent(MotionEvent event)：</p>
<pre><code>/**
 * 设置当索引改变的监听器
 */
public interface OnIndexChangeListener {
    /**
     * 当索引改变
     *
     * @param selectIndex 索引值
     */
    void onIndexChange(int selectIndex);

    /**
     * 当手指抬起
     */
    void onActionUp();
}

public void setOnIndexChangeListener(OnIndexChangeListener listener) {
    this.listener = listener;
}

@Override
public boolean onTouchEvent(MotionEvent event) {
    float y;
    switch (event.getAction()) {
        case MotionEvent.ACTION_DOWN:
        case MotionEvent.ACTION_MOVE:
            y = event.getY();
            // 计算出触摸的是哪个字母单元格
            selected = (int) (y / cellHeight);
            if (selected &gt;= 0 &amp;&amp; selected &lt; INDEX_ARRAYS.length) {
                if (selected != lastSelected) {
                    if (listener != null) {
                        listener.onIndexChange(selected); // 回调监听器的方法
                    }
                    Log.i(TAG, INDEX_ARRAYS[selected]);
                }
                lastSelected = selected;
            }
            break;
        case MotionEvent.ACTION_UP:
            // 把上次的字母单元格重置
            lastSelected = -1;
            listener.onActionUp();
            break;
    }
    invalidate(); // 重绘视图
    return true;
}
</code></pre><p>在<code>ACTION_DOWN</code>和<code>ACTION_MOVE</code>计算出了触摸的y值对应的是索引中的哪个字母，然后回调了监听器；而在<code>ACTION_UP</code>中重置了<code>lastSelected</code>，回调了监听器。</p>
<p>这样，我们就把<code>QuickIndexBar</code>写好了，关于<code>QuickIndexBar</code>使用的代码就不贴出来了，太长了。如果有需要，可以下载下面的Demo，里面都有注释。Demo的效果图如下：</p>
<p><img src="/uploads/20160322/20160322211942.gif" alt="这里写图片描述"></p>
<p>好了，今天就到这里了。have fun!</p>
<p>源码下载：</p>
<p><a href="/uploads/20160322/ContactPicker.rar">ContactPicker.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/ContactPicker" target="_blank" rel="external">ContactPicker</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>有段时间没写博客了，趁今天有空就写了一篇。今天的主题就是仿联系人界面。相信大家在平时都见过，就是可以实现快速索引的侧边栏。比如在美团中选择城市的界面：</p>
<p><img src="/uploads/20160322/20160322200035.png" alt="这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[夜半一忆]]></title>
    <link href="http://yuqirong.me/2016/03/17/%E5%A4%9C%E5%8D%8A%E4%B8%80%E5%BF%86/"/>
    <id>http://yuqirong.me/2016/03/17/夜半一忆/</id>
    <published>2016-03-17T15:13:58.000Z</published>
    <updated>2016-04-03T06:20:46.659Z</updated>
    <content type="html"><![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈何岁月，流于昨日。雁过一鸣，惊于何人？花开花谢，润土无声。</p>
<p>繁华落尽，只道是人间凄凉。穷极一生，只为还清一世业障。</p>
<p>高山流水，静谧成寂。秋风落叶，随风飘散。</p>
<p>别时易，相逢难，烈酒灼心，忆似水年华。</p>
<p>乍暖还寒，大梦初醒，此夜无眠。</p>
<p>仰天大笑，岂是蓬蒿人？</p>
<p>————记于开题答辩之日</p>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width="330" height="86" src="http://music.163.com/outchain/player?type=2&id=29436904&auto=0&height=66"></iframe>]]></content>
    <summary type="html">
    <![CDATA[<blockquote class="blockquote-center"><p>素什锦年，稍纵即逝<br>半载青春，流转指间</p>
</blockquote>
<p>冬去春来，又一载。</p>
<p>曾几何时，一身白衣，穿行多少过往；几经周转，茫与人海之中。</p>
<p>奈]]>
    </summary>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/tags/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
      <category term="岁月如歌" scheme="http://yuqirong.me/categories/%E5%B2%81%E6%9C%88%E5%A6%82%E6%AD%8C/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(下)]]></title>
    <link href="http://yuqirong.me/2016/03/08/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8B)/"/>
    <id>http://yuqirong.me/2016/03/08/《Android群英传》笔记(下)/</id>
    <published>2016-03-08T12:22:27.000Z</published>
    <updated>2016-04-01T14:26:56.726Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7" class="headerlink" title="第六章：Android绘图机制与处理技巧"></a>第六章：Android绘图机制与处理技巧</h1><h2 id="6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F"><a href="#6-1__u5C4F_u5E55_u7684_u5C3A_u5BF8_u4FE1_u606F" class="headerlink" title="6.1 屏幕的尺寸信息"></a>6.1 屏幕的尺寸信息</h2><p>系统屏幕密度如下</p>
<ul>
<li>ldpi—120—240X320分辨率</li>
<li>mdpi—160—320X480分辨率</li>
<li>hdpi—240—480X800分辨率</li>
<li>xhdpi—320—720X1280分辨率</li>
<li>xxhdpi—480—1080X1920分辨率</li>
</ul>
<p>Android系统使用mdpi即密度值为160的屏幕作为标准，在这屏幕上1px = 1dp。</p>
<p>所以各个分辨率直接的换算比例，即ldpi:mdpi:hdpi:xhdpi:xxhdpi=3:4:6:8:12</p>
<p>下面给出单位转换的源码：</p>
<pre><code>public class DisplayUtil {

    /**
     * 把px值转换为dip或dp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2dip(Context context, float pxValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (pxValue / scale + 0.5f);
    }

    /**
     * 把dip值或dp值转换为px值
     *
     * @param context
     * @param dipValue
     * @return
     */
    public static int dip2px(Context context, float dipValue) {
        final float scale = context.getResources().getDisplayMetrics().density;
        return (int) (dipValue * scale + 0.5f);
    }

    /**
     * 将px值转换为sp值
     *
     * @param context
     * @param pxValue
     * @return
     */
    public static int px2sp(Context context, float pxValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (pxValue / fontScale + 0.5f);
    }

    /**
     * 将sp值转换为px值
     * @param context
     * @param spValue
     * @return
     */
    public static int sp2px(Context context, float spValue) {
        final float fontScale = context.getResources().getDisplayMetrics().scaledDensity;
        return (int) (spValue * fontScale + 0.5f);
    }

}
</code></pre><h2 id="6-2_2D_u7ED8_u56FE_u57FA_u7840"><a href="#6-2_2D_u7ED8_u56FE_u57FA_u7840" class="headerlink" title="6.2 2D绘图基础"></a>6.2 2D绘图基础</h2><p>Paint类的一些属性和对应的功能：</p>
<ul>
<li>setAntiAlias(); //设置画笔的锯齿效果</li>
<li>setColor(); //设置画笔的颜色</li>
<li>setARGB(); //设置画笔的A,R,G,B的值</li>
<li>setAlpha(); //设置画笔的Alpha值</li>
<li>setTextSize(); //设置字体的尺寸</li>
<li>setStyle(); //设置画笔的风格（空心或者实心）</li>
<li>setStrokeWidth(); //设置空心边框的宽度</li>
</ul>
<p>Canvas类主要的绘画功能：</p>
<ul>
<li>canvas.drawPoint(x,y,paint); //绘制点</li>
<li>canvas.drawLine(startX,startY,endX,endY,paint); //绘制直线</li>
<li>canvas.drawRect(left,top,right,bottom,paint); //绘制矩形</li>
<li>canvas.drawRoundRect(left,top,right,bottom,radiusX,radiusY,paint); //绘制圆角矩形</li>
<li>canvas.drawCircle(circleX,circleY,radius,paint); //绘制圆</li>
<li>canvas.drawOval(left,top,right,bottom,paint); //通过椭圆的外接矩形来绘制椭圆</li>
<li>canvas.drawText(text,startX,startY,paint); //绘制文字</li>
<li>canvas.drawPosText(text,new float[]{x1,y1,…,xn,yn},paint); //指定位置绘制文本</li>
</ul>
<h2 id="6-3_Android_XML_u7ED8_u56FE"><a href="#6-3_Android_XML_u7ED8_u56FE" class="headerlink" title="6.3 Android XML绘图"></a>6.3 Android XML绘图</h2><ul>
<li><p>Bitmap：</p>
<pre><code>&lt;bitmap xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:src=&quot;@drawable/ic_launcher&quot;/&gt;
</code></pre><p>  这样就能直接将图片转成bitmap在程序中使用了。</p>
</li>
<li><p>Shape:</p>
<pre><code>&lt;shape xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
  android:shape=&quot;line|oval|ring|rectangle&quot;&gt;
  &lt;!--默认为rectangle--&gt;
  &lt;corners
      android:bottomLeftRadius=&quot;integer&quot;
      android:bottomRightRadius=&quot;integer&quot;
      android:radius=&quot;integer&quot;
      android:topLeftRadius=&quot;integer&quot;
      android:topRightRadius=&quot;integer&quot; /&gt;
  &lt;!--当shape为rectangle时才有，radius默认为1dp--&gt;

  &lt;gradient
      android:angle=&quot;integer&quot;
      android:centerColor=&quot;color&quot;
      android:centerX=&quot;integer&quot;
      android:centerY=&quot;integer&quot;
      android:endColor=&quot;color&quot;
      android:gradientRadius=&quot;integer&quot;
      android:startColor=&quot;color&quot;
      android:type=&quot;linear|radial|sweep&quot;
      android:useLevel=&quot;boolean&quot; /&gt;

  &lt;padding
      android:bottom=&quot;integer&quot;
      android:left=&quot;integer&quot;
      android:right=&quot;integer&quot;
      android:top=&quot;integer&quot; /&gt;

  &lt;size
      android:width=&quot;integer&quot;
      android:height=&quot;integer&quot; /&gt;
  &lt;!--指定大小，一般用在imageview配合scaleType使用--&gt;

  &lt;solid android:color=&quot;color&quot; /&gt;
  &lt;!--填充颜色--&gt;
  &lt;stroke
      android:width=&quot;integer&quot;
      android:color=&quot;color&quot;
      android:dashGap=&quot;integer&quot;
      android:dashWidth=&quot;integer&quot; /&gt;
  &lt;!--边框,dashGap为虚线间隔宽度，dashWidth为虚线宽度--&gt;
&lt;/shape&gt;
</code></pre></li>
<li><p>Layer:实现类似Photoshop中图层的概念。</p>
<pre><code>&lt;layer-list xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:drawable=&quot;@mipmap/ic_launcher&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;10dp&quot;
      android:top=&quot;10dp&quot; /&gt;
  &lt;item
      android:drawable=&quot;@mipmap/ic_launcher&quot;
      android:left=&quot;20dp&quot;
      android:top=&quot;20dp&quot; /&gt;
&lt;/layer-list&gt;
</code></pre></li>
<li><p>Selector：通常用于view的触摸反馈。</p>
<pre><code>&lt;selector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;&gt;
  &lt;item android:state_pressed=&quot;true&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#334444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
  &lt;item android:state_pressed=&quot;false&quot;&gt;
      &lt;shape android:shape=&quot;rectangle&quot;&gt;
          &lt;solid android:color=&quot;#444444&quot; /&gt;
      &lt;/shape&gt;
  &lt;/item&gt;
&lt;/selector&gt;
</code></pre></li>
</ul>
<h2 id="6-4_Android_u7ED8_u56FE_u6280_u5DE7"><a href="#6-4_Android_u7ED8_u56FE_u6280_u5DE7" class="headerlink" title="6.4 Android绘图技巧"></a>6.4 Android绘图技巧</h2><ul>
<li><p>Canvas.save():保存画布。它的作用就是将之前的所有已绘制图像保存起来，让后续的操作就好像在一个新的图层上操作一样。</p>
</li>
<li><p>Canvas.restore():合并图层操作。它的作用就是将我们在save()之后绘制的所有图像与save()之前的图像进行合并。</p>
</li>
<li><p>Canvas.translate():画布平移，可理解为坐标系的平移。如在之前绘制的坐标系原点在(0,0)。在translate(x,y)之后，坐标原点在(x,y)。</p>
</li>
<li><p>Canvas.rotate():画布翻转，可理解为坐标系的翻转。canvas.rotate(30);为按照坐标系的原点顺时针旋转30度。canvas.rotate(30,x,y);为按照坐标系的(x,y)点顺时针旋转30度。</p>
</li>
<li><p>Canvas.saveLayer()、Canvas.saveLayerAlpha():将一个图层入栈。</p>
</li>
<li><p>Canvas.restore()、Canvas.restoreToCount():将一个图层出栈。</p>
</li>
</ul>
<h2 id="6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406"><a href="#6-5_Android_u56FE_u50CF_u5904_u7406_u4E4B_u8272_u5F69_u7279_u6548_u5904_u7406" class="headerlink" title="6.5 Android图像处理之色彩特效处理"></a>6.5 Android图像处理之色彩特效处理</h2><ul>
<li><p>色调：<code>setRotate(int axis,float degree)</code>设置颜色的色调。第一个参数，系统分别使用0、1、2来代表Red、Green、Blue三种颜色的处理。而第二个参数就是需要处理的值。</p>
<pre><code>ColorMatrix hueMatrix = new ColorMatrix();
hueMatrix.setRotate(0, hue0);
hueMatrix.setRotate(1, hue1);
hueMatrix.setRotate(2, hue2);
</code></pre></li>
</ul>
<p>通过上面的方法，可以为RGB三种颜色分量分别重新设置了不同的色调值。</p>
<ul>
<li><p>饱和度：<code>setSaturation(float sat)</code>方法来设置颜色的饱和度，参数即代表设置颜色饱和度的值，代码如下所示。当饱和度为0时，图像就变成灰色图像了。</p>
<pre><code>ColorMatrix saturationMatrix = new ColorMatrix();
saturationMatrix.setSaturation(saturation);
</code></pre></li>
<li><p>亮度：当三原色以相同的比例进行混合的时候，就会显示出白色。系统也正是使用这个原理来改变一个图像的亮度的，代码如下所示。当亮度为0时，图像就变成全黑了。</p>
<pre><code>ColorMatrix lumMatrix = new ColorMatrix();
lumMatrix.setScale(lum,lum,lum,1);
</code></pre></li>
<li><p><code>postConcat()</code>方法将矩阵的作用效果混合，从而叠加处理效果，代码如下：</p>
<pre><code>ColorMatrix imageMatrix = new ColorMatrix();
imageMatrix.postConcat(hueMatrix);
imageMatrix.postConcat(saturationMatrix);
imageMatrix.postConcat(lumMatrix);
</code></pre></li>
</ul>
<h2 id="6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406"><a href="#6-6_Android_u56FE_u50CF_u5904_u7406_u4E4B_u56FE_u5F62_u7279_u6548_u5904_u7406" class="headerlink" title="6.6 Android图像处理之图形特效处理"></a>6.6 Android图像处理之图形特效处理</h2><ul>
<li>matrix.setRotate()——旋转变换</li>
<li>matrix.setTranslate()——平移变换</li>
<li>matrix.setScale()——缩放变换</li>
<li>matrix.setSkew()——错切变换</li>
<li>pre()和post()——提供矩阵的前乘和后乘运算</li>
</ul>
<h2 id="6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406"><a href="#6-7_Android_u56FE_u50CF_u5904_u7406_u4E4B_u753B_u7B14_u7279_u6548_u5904_u7406" class="headerlink" title="6.7 Android图像处理之画笔特效处理"></a>6.7 Android图像处理之画笔特效处理</h2><pre><code>mPaint.setXfermode(new PorterDuffXfermode(PorterDuff.Mode.SRC_IN));
</code></pre><p>可以实现圆形ImageView。</p>
<p>// TODO</p>
<p><strong>Shader</strong></p>
<p>Shader又称之为着色器、渲染器，它用来实现一系列的渐变、渲染效果。在Android中的Shader包括以下几种：</p>
<ul>
<li>BitmapShader 位图Shader</li>
<li>LinearGradient 线性Shader</li>
<li>RadialGradient 光束Shader</li>
<li>SweepGradient 梯度Shader</li>
<li>ComposeShader 混合Shader</li>
</ul>
<p>除第一个Shader以外 其他Shader都实现了名副其实的渐变。BitmapShader产生的是一个位图，它的作用就是通过Paint对画布进行指定Bitmap的填充，填充有以下几种模式可以选择：</p>
<ul>
<li>CLAMP拉伸——拉伸的是图片最后一个像素 不断重复</li>
<li>REPEAT重复——横向纵向不断重复</li>
<li>MIRROR镜像——横向不断翻转重复，纵向不断翻转重复</li>
</ul>
<p><strong>PathEffect</strong></p>
<p>PathEffect是指用各种笔触效果来绘制一个路径。</p>
<ul>
<li>ConrnerPathEffect 就是将拐角变得圆滑，具体圆滑的程度，则由参数决定</li>
<li>DiscretePathEffect 使用这个效果后，线段上就会产生许多杂点。</li>
<li>DashPathEffect 这个效果可以用来绘制虚线，用一个数组来设置各个点之间的间隔。另一个参数phase则用来控制绘制时数组的一个偏移量。通常可以通过设置值来实现路径的动态效果。</li>
<li>PathDashPathEffect 与前面的DashPathEffect类似，只不过它的功能更加强大，可以设置显示点的图形，即方形点的虚线，圆形点的虚线。</li>
<li>ComposePathEffect 组合PathEffect，将任意两种路径特性组合起来形成一种新的效果。</li>
</ul>
<h2 id="6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView"><a href="#6-8_View_u4E4B_u5B6A_u751F_u5144_u5F1F_u2014_u2014SurfaceView" class="headerlink" title="6.8 View之孪生兄弟——SurfaceView"></a>6.8 View之孪生兄弟——SurfaceView</h2><p>SurfaceView与view的区别：  </p>
<ul>
<li>View主要适用于主动更新的情况下，而SurfaceView 主要适用于被动更新，例如频繁的刷新。</li>
<li>View在主线程中对画面进行刷新，而SurfaceView通常会通过一个子线程来进行页面刷新。 </li>
<li>View在绘图时没有使用双缓冲机制，而SurfaceView在底层实现机制中就已经实现了双缓冲。</li>
</ul>
<p>总结成一句话就是，如果你的自定义View需要频繁刷新，或者刷新时数据处理量比较大，那你就可以考虑使用SurfaceView来取代View了。</p>
<p>SurfaceView模版代码：</p>
<pre><code>public class MySurfaceView extends SurfaceView implements Runnable, SurfaceHolder.Callback {
  //SurfaceHolder
  private SurfaceHolder mSurfaceHolder;
  //用于绘图的Canvas
  private Canvas mCanvas;
  //子线程标志位
  private boolean mIsDrawing;

  public MySurfaceView(Context context) {
      super(context);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs) {
      super(context, attrs);
      init();
  }
  public MySurfaceView(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      init();
  }
  private void init() {
      mSurfaceHolder = getHolder();
      mSurfaceHolder.addCallback(this);
      setFocusable(true);
      setFocusableInTouchMode(true);
      this.setKeepScreenOn(true);
      //mSurfaceHolder.setFormat(PixelFormat.OPAQUE);
  }
  @Override
  public void surfaceCreated(SurfaceHolder holder) {
      mIsDrawing = true;
      new Thread(this).start();
  }
  @Override
  public void surfaceChanged(SurfaceHolder holder, int format, int width, int height) {
  }
  @Override
  public void surfaceDestroyed(SurfaceHolder holder) {
      mIsDrawing = false;
  }
  @Override
  public void run() {
      while (mIsDrawing) {
          draw();
      }
  }
  private void draw() {
      try {
          //每次获得的canvas对象都是上次的 因此上次的绘画操作都会保存
          mCanvas = mSurfaceHolder.lockCanvas();
          //draw here
      } catch (Exception e) {

      } finally {
          if (mCanvas != null) {
              // 对画布内容进行提交
              mSurfaceHolder.unlockCanvasAndPost(mCanvas);
          }
      }

  }
}
</code></pre><h1 id="u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u4E03_u7AE0_uFF1AAndroid_u52A8_u753B_u673A_u5236_u4E0E_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第七章：Android动画机制与使用技巧"></a>第七章：Android动画机制与使用技巧</h1><h2 id="7-1_Android_View_u52A8_u753B_u6846_u67B6"><a href="#7-1_Android_View_u52A8_u753B_u6846_u67B6" class="headerlink" title="7.1 Android View动画框架"></a>7.1 Android View动画框架</h2><p>Animation框架定义了透明度、旋转、缩放和位移几种常见的动画，而且控制的是整个View，实现的原理是绘制视图时 View 所在的 ViewGroup 中的 drawChild 函数获取该View的Animation的Transformation值，然后调用canvas.concat(transformToApply.getMatrix()),通过矩阵运算完成动画帧。如果动画没有完成，就继续调用invalidate()函数，启动下次绘制来驱动动画，从而完成整个动画的绘制。</p>
<ul>
<li>透明度动画：AlphaAnimation</li>
<li>旋转动画：RotateAnimation</li>
<li>位移动画：TranslateAnimation</li>
<li>缩放动画：ScaleAnimation</li>
</ul>
<p>动画集合：AnimationSet</p>
<p>动画监听器：setAnimationListener(new Animation.AnimationListener(){…})</p>
<h2 id="7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790"><a href="#7-2_Android_u5C5E_u6027_u52A8_u753B_u5206_u6790" class="headerlink" title="7.2 Android属性动画分析"></a>7.2 Android属性动画分析</h2><p><strong>ObjectAnimator</strong>：属性动画框架中最重要的实行类。</p>
<p>用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.setDuration(300);
animator.start();
</code></pre><p>注意：操纵的属性(即上面的“translationX”)必须具有get、set方法，不然ObjectAnimator就无法起效。因为内部会通过Java反射机制来调用set函数修改对象属性值。</p>
<p>常用属性值：</p>
<ul>
<li>translationX和translationY</li>
<li>rotation、rotationX和rotationY</li>
<li>scaleX和scaleY</li>
<li>pivotX和pivotY</li>
<li>x和y</li>
<li>alpha</li>
</ul>
<p><strong>PropertyValuesHolder</strong>：类似于视图动画中的AnimationSet。在属性动画中，如果针对同一个对象的多个属性，要同时作用多种动画，可以使用PropertyValuesHolder来实现。</p>
<p>用法：</p>
<pre><code>PropertyValuesHolder pvh1 = PropertyValuesHolder.ofFloat(&quot;translationX&quot;,300f);
PropertyValuesHolder pvh2 = PropertyValuesHolder.ofFloat(&quot;scaleX&quot;,1f,0,1f);
PropertyValuesHolder pvh3 = PropertyValuesHolder.ofFloat(&quot;scaleY&quot;,1f,0,1f);
ObjectAnimator.ofPropertyValuesHolder(view,pvh1,pvh2,pvh3).setDuration(1000).start();
</code></pre><p><strong>ValueAnimator</strong>：ValueAnimator本身不提供任何动画效果，它更像一个数值发生器，用来产生具有一定规律的数字，从而让调用者来控制动画的实现过程。</p>
<p>用法：</p>
<pre><code>ValueAnimator animator = ValueAnimator.ofFloat(0,100);
animator.setTarget(view);
animator.setDuration(1000).start();
animator.addUpdateListener(new ValueAnimator.AnimatorUpdateListener() {
    @Override
    public void onAnimationUpdate(ValueAnimator animation) {
        Float value = (Float) animation.getAnimatedValue();
        // TODO use the value
    }
});
</code></pre><p>在ValueAnimator的AnimatorUpdateListener中监听数值的变换，从而完成动画的变换。</p>
<p><strong>AnimatorListener和AnimatorListenerAdapter</strong>：动画事件的监听。</p>
<p>AnimatorListener用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new Animator.AnimatorListener() {
    @Override
    public void onAnimationStart(Animator animation) {

    }

    @Override
    public void onAnimationEnd(Animator animation) {

    }

    @Override
    public void onAnimationCancel(Animator animation) {

    }

    @Override
    public void onAnimationRepeat(Animator animation) {

    }
});
</code></pre><p>AnimatorListenerAdapter用法：</p>
<pre><code>ObjectAnimator animator = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
animator.addListener(new AnimatorListenerAdapter() {
    @Override
    public void onAnimationEnd(Animator animation) {
        super.onAnimationEnd(animation);
    }
});
</code></pre><p><strong>AnimatorSet</strong>：AnimatorSet不仅能实现一个属性同时作用多个属性动画效果，同时也能实现更为精确的顺序控制。</p>
<p>用法(实现上面使用PropertyValuesHolder的动画效果)：</p>
<pre><code>ObjectAnimator animator1 = ObjectAnimator.ofFloat(view,&quot;translationX&quot;,300);
    ObjectAnimator animator2 = ObjectAnimator.ofFloat(view,&quot;scaleX&quot;,1f,0f,1f);
    ObjectAnimator animator3 = ObjectAnimator.ofFloat(view,&quot;scaleY&quot;,1f,0f,1f);
    AnimatorSet set = new AnimatorSet();
    set.setDuration(1000);
    set.playTogether(animator1,animator2,animator3);
    set.start();
</code></pre><p>还有playTogether()、playSequentially()、animSet.play()、with()、before()、after()来协同工作。</p>
<p><strong>在XML中使用属性动画</strong>：在res里新建文件夹animator。</p>
<p>anim_scalex.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;objectAnimator xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:duration=&quot;1000&quot;
    android:propertyName=&quot;scaleX&quot;
    android:valueFrom=&quot;1.0&quot;
    android:valueTo=&quot;2.0&quot;
    android:valueType=&quot;floatType&quot;&gt;
&lt;/objectAnimator&gt; 
</code></pre><p>在代码中加载xml属性动画：</p>
<pre><code>public void scaleX(View view) {
    Animator anim = AnimatorInflater.loadAnimator(this, R.animator.anim_scalex);  
    anim.setTarget(view);  
    anim.start();
}
</code></pre><p>另附 XML文件中定义两个objectAnimator：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;  
&lt;set xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;  
    android:ordering=&quot;together&quot; &gt;  

    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleX&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  
    &lt;objectAnimator  
        android:duration=&quot;1000&quot;  
        android:propertyName=&quot;scaleY&quot;  
        android:valueFrom=&quot;1&quot;  
        android:valueTo=&quot;0.5&quot; &gt;  
    &lt;/objectAnimator&gt;  

&lt;/set&gt; 
</code></pre><p><strong>View的animate方法</strong>：可以认为是属性动画的一种简写方式。</p>
<p>用法：</p>
<pre><code>view.animate()
    .alpha(0)
    .y(300)
    .setDuration(300)
    .withStartAction(new Runnable() {
        @Override
        public void run() {

        }
    }).withEndAction(new Runnable() {
        @Override
        public void run() {
            runOnUiThread(new Runnable() {
                @Override
                public void run() {

                }
            });
        }
    }).start();
</code></pre><h2 id="7-3_Android_u5E03_u5C40_u52A8_u753B"><a href="#7-3_Android_u5E03_u5C40_u52A8_u753B" class="headerlink" title="7.3 Android布局动画"></a>7.3 Android布局动画</h2><p>最简单的布局动画是在ViewGroup的XML中，使用以下打开布局动画。<br><code>android:animateLayoutChanges=&quot;true&quot;</code><br>通过上面的代码，当ViewGroup添加View时，子View会呈现逐渐显示的过渡效果，是Android默认的显示的过渡效果。</p>
<p><strong>LayoutAnimationController</strong></p>
<pre><code>LinearLayout ll = (LinearLayout)findViewById(R.id.ll);
// 设置过渡动画
ScaleAnimation scaleAnimation = new ScaleAnimation(0,1,0,1);
scaleAnimation.setDuration(2000);
// 设置布局动画的显示属性
LayoutAnimationController lac = new LayoutAnimationController(scaleAnimation,0.5f);
lac.setOrder(LayoutAnimationController.ORDER_NORMAL);
ll.setLayoutAnimation(lac);
</code></pre><p>LayoutAnimationController的第一个参数是作用的动画，第二个参数是每个View显示的delay时间。当delay时间不为0时，可以设置子View显示的顺序，如下所示。</p>
<ul>
<li>LayoutAnimationController.ORDER_NORMAL  顺序</li>
<li>LayoutAnimationController.ORDER_RANDOM  随机</li>
<li>LayoutAnimationController.ORDER_REVERSE 反序</li>
</ul>
<h2 id="7-4_Interpolators_28_u63D2_u503C_u5668_29"><a href="#7-4_Interpolators_28_u63D2_u503C_u5668_29" class="headerlink" title="7.4 Interpolators(插值器)"></a>7.4 Interpolators(插值器)</h2><h2 id="7-5__u81EA_u5B9A_u4E49_u52A8_u753B"><a href="#7-5__u81EA_u5B9A_u4E49_u52A8_u753B" class="headerlink" title="7.5 自定义动画"></a>7.5 自定义动画</h2><p>首先继承Animation类，实现<code>applyTransformation(float interpolatedTime, Transformation t)</code>的逻辑。不过通常情况下，还要覆盖父类的<code>initialize(int width, int height, int parentWidth, int parentHeight)</code>实现一些初始化的工作。</p>
<p><code>applyTransformation(float interpolatedTime, Transformation t)</code>第一个参数是插值器的时间因子，这个因子由动画当前完成的百分比和当前时间所对应的插值所计算得来的，取值为0到1.0。第二个参数是矩阵的封装类，一般使用这个类来获取当前的矩阵对象，代码如下：</p>
<pre><code>final Matrix matrix = t.getMatrix();
</code></pre><p>下面给出电视机关闭效果的动画：</p>
<pre><code>@Override
protected void applyTransformation(float interpolatedTime, Transformation t) {
    final Matrix matrix = t.getMatrix();
    matrix.preScale(1, 1 - interpolatedTime, mCenterWidth, mCenterHeight);
}
</code></pre><p>//TODO</p>
<h2 id="7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236"><a href="#7-6_Android_5-X_SVG__u77E2_u91CF_u52A8_u753B_u673A_u5236" class="headerlink" title="7.6 Android 5.X SVG 矢量动画机制"></a>7.6 Android 5.X SVG 矢量动画机制</h2><p>Google在Android 5.X中提供了下面两个新的API来帮助支持SVG：</p>
<ul>
<li>VectorDrawable</li>
<li>AnimatedVectorDrawable</li>
</ul>
<p>下面给出SVG图形：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;vector xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:width=&quot;200dp&quot;
    android:height=&quot;200dp&quot;
    android:viewportHeight=&quot;100&quot;
    android:viewportWidth=&quot;100&quot;&gt;

    &lt;group
        android:name=&quot;test&quot;
        android:rotation=&quot;0&quot;&gt;
        &lt;path
            android:fillColor=&quot;@android:color/holo_blue_light&quot;
            android:pathData=&quot;M 25 50
            a 25,25 0 1,0 50,0&quot; /&gt;
    &lt;/group&gt;

&lt;/vector&gt;
</code></pre><p> //TODO</p>
<h1 id="u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790"><a href="#u7B2C_u516B_u7AE0_uFF1AActivity_u4E0EActivity_u8C03_u7528_u6808_u5206_u6790" class="headerlink" title="第八章：Activity与Activity调用栈分析"></a>第八章：Activity与Activity调用栈分析</h1><h2 id="8-1_Activity"><a href="#8-1_Activity" class="headerlink" title="8.1 Activity"></a>8.1 Activity</h2><p>Activity的形态：</p>
<ul>
<li><p>Active/Running : 这时候Activity处于Activity栈的最顶层，可见，并与用户进行交互。</p>
</li>
<li><p>Paused : 当Activity失去焦点，被一个新的非全屏的Activity或者一个透明的Activity放置在栈顶时，Activity就转化为Paused形态。但它只是失去了与用户交互的能力，所有状态信息、成员变量都还保持着，只有在系统内存极低的情况下，才会被系统回收掉。</p>
</li>
<li><p>Stopped : 如果一个Activity被另一个Activity完全覆盖，那么Activity就会进入Stopped形态，此时，它不再可见，但却依然保持了所有状态信息和成员变量。</p>
</li>
<li><p>Killed : 当Activity被系统回收掉或者Activity从来没有创建过，Activity就处于Killed状态。</p>
</li>
</ul>
<p>Activity启动与销毁过程：</p>
<ul>
<li><p>onCreate() ： 创建基本的UI元素。</p>
</li>
<li><p>onPause()和onStop() ： 清除Activity的资源，避免浪费。</p>
</li>
<li><p>onDestory() ： 因为引用会在Activity销毁的时候销毁，而线程不会，所以清除开启的线程。</p>
</li>
</ul>
<p>Activity的暂停与恢复过程：</p>
<ul>
<li><p>onPause() ： 释放系统资源，如Camera、sensor、receivers。</p>
</li>
<li><p>onResume() ： 需要重新初始化在onPause()中释放资源。</p>
</li>
</ul>
<p>Activity的停止过程：</p>
<ul>
<li><p>由部分不可见到完全不可见 ： onPause() -&gt; onStop()</p>
</li>
<li><p>由部分不可见到可见： onPause() -&gt; onStop() -&gt; onRestart() -&gt; onStart() -&gt; onResume()</p>
</li>
</ul>
<p>Activity的重新创建过程：</p>
<p>如果用户finish()方法结束了Activity，则不会调用onSaveInstanceState()。</p>
<h2 id="8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB"><a href="#8-2_Android_u4EFB_u52A1_u6808_u7B80_u4ECB" class="headerlink" title="8.2 Android任务栈简介"></a>8.2 Android任务栈简介</h2><p>一个Task中的Activity可以来自不同的App，同一个App的Activity也可能不在一个Task中。</p>
<h2 id="8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F"><a href="#8-3_AndroidMainifest_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.3 AndroidMainifest启动模式"></a>8.3 AndroidMainifest启动模式</h2><ul>
<li><p>standard ： 默认的启动模式，每次都会创建新的实例</p>
</li>
<li><p>singleTop ：   通常适用于接收到消息后显示的界面</p>
</li>
<li><p>singleTask ： 通常可以用来退出整个应用：将主Activity设为singleTask模式，然后在要退出的Activity中转到主Activity，从而将主Activity之上的Activity都清除，然后重写主Activity的onNewIntent()方法，在方法中加上一句finish()，将最后一个Activity结束掉。</p>
</li>
<li><p>singleInstance ： 申明为singleInstance的Activity会出现在一个新的任务栈中，而且该任务栈中只存在这一个Activity。举个例子，如果应用A的任务栈中创建了MainActivity的实例，且启动模式为singleInstance，如果应用B的也要激活MainActivity，则不需要创建，两个应用共享该Activity实例。这种启动模式常用于需要与程序分离的界面。</p>
</li>
</ul>
<p>关于singleTop和singleInstance这两种启动模式还有一点需要特殊说明：如果在一个singleTop或者singleInstance的Activity A中通过startActivityForResult()方法来启动另一个Activity B，那么直接返回Activity.RESULT_CANCELED而不会再去等待返回。这是由于系统在Framework层做了对这两种启动模式的限制，因为Android开发者认为，不同Task之间，默认是不能传递数据的，如果一定要传递，那么只能通过Intent来绑定数据。</p>
<h2 id="8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F"><a href="#8-4_Intent_Flag_u542F_u52A8_u6A21_u5F0F" class="headerlink" title="8.4 Intent Flag启动模式"></a>8.4 Intent Flag启动模式</h2><ul>
<li><p>Intent.FLAG_ACTIVITY_NEW_TASK：使用一个新的Task来启动一个Activity，但启动的每个Activity都将在一个新的Task中。该Flag通常使用在从Service中启动Activity的场景，由于在Service中并不存在Activity栈，所以使用该Flag来创建一个新的Activity栈，并创建新的Activity实例。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_SINGLE_TOP：使用singleTop模式来启动一个Activity，与指定android:launchMode=”singleTop”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_CLEAR_TOP：使用singleTask模式来启动一个Activity，与指定android:launchMode=”singleTask”效果相同。</p>
</li>
<li><p>Intent.FLAG_ACTIVITY_NO_HISTORY：使用这种模式启动Activity，当该Activity启动其他Activity后，该Activity就消失了，不会保留在Activity栈中。例如A-B，B中以这种模式启动C，C再启动D，则当前Activity栈为ABD。</p>
</li>
</ul>
<h2 id="8-5__u6E05_u7A7A_u4EFB_u52A1_u6808"><a href="#8-5__u6E05_u7A7A_u4EFB_u52A1_u6808" class="headerlink" title="8.5 清空任务栈"></a>8.5 清空任务栈</h2><ul>
<li><p>clearTaskOnLaunch：每次返回该Activity时，都将该Activity之上的所有Activity都清除。通过这个属性，可以让这个Task每次在初始化的时候，都只有这一个Activity。</p>
</li>
<li><p>finishOnTaskLaunch：finishOnTaskLaunch属性与clearTaskOnLaunch属性类似，只不过clearTaskOnLaunch作用在别人身上，而finishOnTaskLaunch作用在自己身上。通过这个属性，当离开这个Activity所处的Task，那么用户再返回时，该Activity就会被finish掉。</p>
</li>
<li><p>alwaysRetainTaskState：如果将Activity的这个属性设置为True，那么该Activity所在的Task将不接受任何清理命令，一直保持当前Task状态。</p>
</li>
</ul>
<h1 id="u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236"><a href="#u7B2C_u4E5D_u7AE0_uFF1AAndroid_u7CFB_u7EDF_u4FE1_u606F_u4E0E_u5B89_u5168_u673A_u5236" class="headerlink" title="第九章：Android系统信息与安全机制"></a>第九章：Android系统信息与安全机制</h1><h2 id="9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6"><a href="#9-1_Android_u7CFB_u7EDF_u4FE1_u606F_u83B7_u53D6" class="headerlink" title="9.1 Android系统信息获取"></a>9.1 Android系统信息获取</h2><p>要获取系统的配置信息，通常可以从以下两个方面获取：</p>
<ul>
<li>android.os.Build</li>
<li>SystemProperty</li>
</ul>
<p>下面列举了android.os.Build一些常用的信息：</p>
<ul>
<li>Build.BOARD // 主板</li>
<li>Build.BRAND // Android系统定制商</li>
<li>Build.SUPPORTED_ABIS // CPU指令集</li>
<li>Build.DEVICE // 设备参数</li>
<li>Build.DISPLAY // 显示屏参数</li>
<li>Build.FINGERPRINT // 唯一编号</li>
<li>Build.SERIAL // 硬件序列号</li>
<li>Build.ID // 修订版本列表</li>
<li>Build.MANUFACTURER // 硬件制造商</li>
<li>Build.MODEL // 版本</li>
<li>Build.HARDWARE // 硬件名</li>
<li>Build.PRODUCT // 手机产品名</li>
<li>Build.TAGS // 描述Build的标签</li>
<li>Build.TYPE // Builder类型</li>
<li>Build.VERSION.CODENAME // 当前开发代号</li>
<li>Build.VERSION.INCREMENTAL // 源码控制版本号</li>
<li>Build.VERSION.RELEASE // 版本字符串</li>
<li>Build.VERSION.SDK_INT // 版本号</li>
<li>Build.HOST // Host值</li>
<li>Build.USER // User名</li>
<li>Build.TIME // 编译时间</li>
</ul>
<p>下面列举了SystemProperty常用的信息：</p>
<ul>
<li>os.version // OS版本</li>
<li>os.name // OS名称</li>
<li>os.arch // OS架构</li>
<li>user.home // Home属性</li>
<li>user.name // Name属性</li>
<li>user.dir //Dir属性</li>
<li>user.timezone // 时区</li>
<li>path.separator // 路径分隔符</li>
<li>line.separator // 行分隔符</li>
<li>file.separator // 文件分隔符</li>
<li>java.vendor.url // Java Vendor URL 属性</li>
<li>java.class.path // Java Class 路径</li>
<li>java.class.version Java Class 版本</li>
<li>java.vendor // Java Vendor 属性</li>
<li>java.version // Java 版本</li>
<li>java.home // Java Home 属性</li>
</ul>
<p>我们可以访问到系统的属性值，代码如下所示：</p>
<pre><code>String board = Build.BOARD;
String brand = Build.BRAND;

String os_version = System.getProperty(&quot;os.version&quot;);
String os_name = System.getProperty(&quot;os.name&quot;);
</code></pre><h2 id="9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager"><a href="#9-2_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BPackageManager" class="headerlink" title="9.2 Android Apk应用信息获取之PackageManager"></a>9.2 Android Apk应用信息获取之PackageManager</h2><p>Android系统提供了PackageManager来负责管理所有已安装的App。其中封装的信息如下：</p>
<ul>
<li>ActivityInfo：Mainfest文件中<activity\></activity\>和<receiver\></receiver\>之间的所有信息，包括name、icon、label、launchmode等。</li>
<li>ServiceInfo：封装了<service\></service\>之间的所有信息。</li>
<li>ApplicationInfo：封装了<application\></application\>之间的信息，不过特别的是，Application包含很多Flag，FLAG_SYSTEM表示为系统应用，FLAG_EXTERNAL_STORAGE表示为安装在SDCard上的应用等，通过这些Flag，可以很方便的判断应用类型。</li>
<li>PackageInfo：PackageInfo与前面三个Info类似，都是用于封装Mainfest文件的相关节点信息，而它包含了所以Activity、Service等信息。</li>
<li>ResolveInfo：封装的是包含<intent\>信息的上一级信息，所以它可以返回ActivityInfo，ServiceInfo等包含<intent\>的信息，它经常用来帮助我们找到那些包含特定Intent条件的信息，如带分享功能、播放功能的应用。</intent\></intent\></li>
</ul>
<p>PackageManager常用方法如下：</p>
<ul>
<li>getPackageManager：通过调用这个方法返回一个PackageManager对象。</li>
<li>getApplicationInfo：以ApplicationInfo的形式返回指定包名的ApplicationInfo。</li>
<li>getApplicationIcon：返回指定包名的Icon。</li>
<li>getInstallApplication：以ApplicationInfo的形式返回安装的应用。</li>
<li>getInstalledPackages：以PackageInfo的形式返回安装的应用。</li>
<li>queryIntentActivities：返回指定intent的ResolveInfo对象、Activity集合。</li>
<li>queryIntentServices：返回指定intent的ResolveInfo对象、Service集合。</li>
<li>resolveActivity：返回指定Intent的Activity。</li>
<li>resolveService：返回指定Intent的Service。</li>
</ul>
<p>判断App类型的依据，就是利用ApplicationInfo中的FLAG_SYSTEM来进行判断，代码如下所示：</p>
<pre><code>app.flags &amp; ApplicationInfo.FLAG_SYSTEM
</code></pre><ul>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM != 0</code>则为系统应用；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_SYSTEM &lt;= 0</code>则为第三方应用；</li>
<li>特殊的，当系统应用经过升级后，也将成为第三方应用：<code>flags &amp; ApplicationInfo.FLAG_UPDATED_SYSTEM_APP != 0</code>；</li>
<li>如果当前应用的<code>flags &amp; ApplicationInfo.FLAG_EXTERNAL_STORAGE != 0</code>则为安装在SDCard上的应用。</li>
</ul>
<h2 id="9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager"><a href="#9-3_Android_Apk_u5E94_u7528_u4FE1_u606F_u83B7_u53D6_u4E4BActivityManager" class="headerlink" title="9.3 Android Apk应用信息获取之ActivityManager"></a>9.3 Android Apk应用信息获取之ActivityManager</h2><p>ActivityManager可以获得在运行的应用程序信息。其中封装的信息如下：</p>
<ul>
<li>ActivityManager.MemoryInfo：MemoryInfo有几个非常重要的字段，availMem–系统可用内存，totalMem–总内存，threshold–低内存的阈值，即区分是否低内存的临界值，lowMemory–是否处于低内存。</li>
<li>Debug.MemoryInfo：ActivityManager.MemoryInfo用于统计全局的内存信息，而Debug.MemoryInfo用于统计进程下的内存信息。</li>
<li>RunningAppProcessInfo：进程相关的信息，processName–进程名，pid–进程pid，uid–进程uid，pkgList–该进程下的所有包。</li>
<li>RunningServiceInfo：用于封装运行的服务信息，在它里面包含一些服务进程的信息，同时还有一些其他信息。activeSince–第一次被激活的时间、方式，foreground–服务是否在后台执行。</li>
</ul>
<h2 id="9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F"><a href="#9-4__u89E3_u6790Packages-xml_u83B7_u53D6_u7CFB_u7EDF_u4FE1_u606F" class="headerlink" title="9.4 解析Packages.xml获取系统信息"></a>9.4 解析Packages.xml获取系统信息</h2><p>packages.xml在 data/system/目录下。</p>
<h2 id="9-5_Android_u5B89_u5168_u673A_u5236"><a href="#9-5_Android_u5B89_u5168_u673A_u5236" class="headerlink" title="9.5 Android安全机制"></a>9.5 Android安全机制</h2><p>反编译：</p>
<ul>
<li>apktool(反编译XML) ： <code>java -jar apktool_2.1.0.jar d test.apk</code></li>
<li>apktool(重新打包) ： <code>java -jar apktool_2.1.0.jar b test</code></li>
<li>Dex2jar、jd-gui ：<code>d2j-dex2jar.bat classes.dex</code></li>
</ul>
<p>Android Apk 加密：</p>
<p>打开build.gradle(Module:app)文件，minifyEnabled为true则说明打开混淆功能，proguard-rules.pro为项目自定义的混淆文件，在项目app文件夹下找到这个文件，在这个文件里可以定义引入的第三方依赖包的混淆规则。</p>
<pre><code>buildTypes {
    release {
        minifyEnabled true
        proguardFiles getDefaultProguardFile(&apos;proguard-android.txt&apos;), &apos;proguard-rules.pro&apos;
    }
}
</code></pre><h1 id="u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316"><a href="#u7B2C_u5341_u7AE0_uFF1AAndroid_u6027_u80FD_u4F18_u5316" class="headerlink" title="第十章：Android性能优化"></a>第十章：Android性能优化</h1><h2 id="10-1__u5E03_u5C40_u4F18_u5316"><a href="#10-1__u5E03_u5C40_u4F18_u5316" class="headerlink" title="10.1 布局优化"></a>10.1 布局优化</h2><ul>
<li><p>Android UI渲染机制</p>
<p>  在Android中，系统通过VSYNC信号出发对UI的渲染、重绘，其间隔时间是16ms。这个16ms其实就是1000ms中显示60帧画面的单位时间（玩游戏的就该知道，大于等于60帧就感觉不到卡顿）。Android系统提供了检测UI渲染时间的工具，打开“开发者选项”，选择“Profile GPU Rendering”（我的手机是“GPU呈现模式分析”），选中“On screen as bars”（我的为“在屏幕上显示为条形图”）。每一条柱状线都包括三部分，蓝色代表测量绘制Display List的时间，红色代表OpenGL渲染Display List所需要的时间，黄色代表CPU等待GPU处理的时间，中间绿色横线代表VSYNC时间16ms，需要尽量将所有条形图都控制在这条绿线之下。</p>
</li>
<li><p>避免Overdraw</p>
<p>  过渡绘制会浪费很多CPU、GPU资源，例如系统默认会绘制Activity的背景，而如果再给布局绘制了重叠的背景，那么默认Activity的背景就属于无效的过渡绘制。Android系统在开发者选项中提供了这样一个检测工具–“Enable GPU Overdraw”。借助它可以判断Overdraw的次数。尽量增大蓝色的区域，减少红色的区域。</p>
</li>
<li><p>优化布局层级</p>
<p>  在Android中系统对View的测量、布局和绘制都是通过遍历View树来进行的，如果View树太高，就会影响其速度，Google也建议View树的高度不宜超过10层。</p>
</li>
<li><p>避免嵌套过多无用布局</p>
<ul>
<li>使用<include\>标签重用Layout</include\></li>
<li><p>使用<viewstub\>实现View的延迟加载</viewstub\></p>
<p><viewstub\>是个非常轻量级的组件，不仅不可视而且大小为0。这个布局在初始化时不需要显示，只有在某些情况下才显示出来。下面是实例代码：</viewstub\></p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;TextView
      android:id=&quot;@+id/tv&quot;
      android:layout_width=&quot;wrap_content&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:text=&quot;not often use&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>使用<viewstub\>：</viewstub\></p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;.MainActivity&quot;&gt;
    &lt;ViewStub
      android:id=&quot;@+id/view_stub&quot;
      android:layout_width=&quot;match_parent&quot;
      android:layout_height=&quot;wrap_content&quot;
      android:layout_centerInParent=&quot;true&quot;
      android:layout=&quot;@layout/test&quot; /&gt;
&lt;/RelativeLayout&gt;
</code></pre><p>在<code>onCreate(Bundle savedInstanceState)</code>中：</p>
<pre><code>ViewStub viewStub= (ViewStub) findViewById(R.id.view_stub);
//下面两个方法都是用来实现延迟加载的，区别是inflate()方法会返回引用的布局。
viewStub.setVisibility(View.VISIBLE); // 第一种方法

View view=viewStub.inflate(); // 第二种方法
TextView tv= (TextView) view.findViewById(R.id.tv);
</code></pre><p><viewstub\>标签与设置View.GONE这种方式的区别在于<viewstub\>标签只在显示时渲染整个布局，而设置View.GONE这种方式在初始化布局树时就已经添加在布局树上了，所以相比之下<viewstub>更有效率。</viewstub></viewstub\></viewstub\></p>
</li>
</ul>
</li>
<li><p>Hierarchy Viewer</p>
</li>
</ul>
<p>这是个用来测试布局冗余的工具。<a href="http://blog.csdn.net/xyz_lmn/article/details/14222975" target="_blank" rel="external">可点击此处</a></p>
<h2 id="10-2__u5185_u5B58_u4F18_u5316"><a href="#10-2__u5185_u5B58_u4F18_u5316" class="headerlink" title="10.2 内存优化"></a>10.2 内存优化</h2><ul>
<li><p>什么是内存</p>
<ul>
<li>寄存器：速度最快的存储场所，因为寄存器位于处理器内部，在程序中无法控制。</li>
<li>栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中。</li>
<li>堆：堆内存用来存放由new创建的对象和数组，在堆中分配的内存，由Java虚拟机的自动垃圾回收器(GC)来管理。</li>
<li>静态存储区域：是指在固定的位置存放应用程序运行时一直存在的数据，Java在内存中专门划分了一个静态存储区域来管理一些特殊的数据变量如静态的数据变量。</li>
<li><p>常量池：就是该类型所用到常量的一个有序集合，包括直接常量（基本类型，String）和对其他类型、字段和方法的符号引用。</p>
<p>在程序中，可以使用如下所示的代码来获得堆的大小，所谓的内存分析，正是分析Heap中的内存状态</p>
<pre><code>ActivityManager manager = (ActivityManager)getSystemService(Context.ACTIVITY_SERVICE)；
int heapSize = manager.getLargeMemoryClass();
</code></pre></li>
</ul>
</li>
<li><p>获取Android系统内存信息</p>
<ul>
<li><p>进程状态</p>
<pre><code>adb shell dumpsys procstats
</code></pre></li>
<li><p>内存信息</p>
<pre><code>adb shell dumpsys meminfo
</code></pre></li>
</ul>
</li>
<li><p>内存优化实例</p>
<ul>
<li><p>Bitmap优化</p>
<p>Bitmap是造成内存占用过高甚至是OOM的最大威胁，可以通过以下技巧进行优化</p>
<p>① 使用适当分辨率和大小的图片：例如在图片列表界面可以使用图片的缩略图thumbnails，而在显示详细图片的时候再显示原图；或者在对图像要求不高的地方，尽量降低图片的精度。</p>
<p>② 及时回收内存：一旦使用完Bitmap后，一定要及时使用bitmap.recycle()方法释放内存资源。自Android3.0后，由于Bitmap被放到了堆中，其内存由GC管理，就不需要释放了。</p>
<p>③ 通过内存缓存LruCache和DiskLruCache可以更好地使用Bitmap。</p>
</li>
<li><p>代码优化</p>
<p>任何Java类都将占用大约500字节的内存空间，创建一个类的实例会消耗大约15字节内存。从代码的实现上，也可以对内存进行优化。</p>
<p>① 对常量使用static修饰符。</p>
<p>② 使用静态方法，静态方法会比普通方法提高15%左右的访问速度。</p>
<p>③ 减少不必要的成员变量，这点在Android Lint工具上已经集成检测了。</p>
<p>④ 减少不必要对象，使用基础类型会比使用对象更加节省资源，同时更应该避免频繁创建短作用域的变量。</p>
<p>⑤ 尽量不要使用枚举、少用迭代器。</p>
<p>⑥ 对Cursor、Receiver、Sensor、File等对象，要非常注意对它们的创建、回收和注册、反注册。</p>
<p>⑦ 避免使用IOC框架，IOC通常使用注解、反射来进行实现，大量使用反射会带来性能的下降。</p>
<p>⑧ 使用RenderScript、OpenGL来进行非常复杂的绘图操作。</p>
<p>⑨ 使用SurfaceView来代替View进行大量、频繁的绘图操作。</p>
<p>⑩ 尽量使用视图缓存，而不是每次都执行inflate()解析视图。</p>
</li>
</ul>
</li>
</ul>
<h2 id="10-3_Lint_u5DE5_u5177"><a href="#10-3_Lint_u5DE5_u5177" class="headerlink" title="10.3 Lint工具"></a>10.3 Lint工具</h2><h2 id="10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177"><a href="#10-4__u4F7F_u7528Android_Studio_u7684Memory_Monitor_u5DE5_u5177" class="headerlink" title="10.4 使用Android Studio的Memory Monitor工具"></a>10.4 使用Android Studio的Memory Monitor工具</h2><h2 id="10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD"><a href="#10-5__u4F7F_u7528TraceView_u5DE5_u5177_u4F18_u5316App_u6027_u80FD" class="headerlink" title="10.5 使用TraceView工具优化App性能"></a>10.5 使用TraceView工具优化App性能</h2><h2 id="10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001"><a href="#10-6__u4F7F_u7528MAT_u5DE5_u5177_u5206_u6790App_u5185_u5B58_u72B6_u6001" class="headerlink" title="10.6 使用MAT工具分析App内存状态"></a>10.6 使用MAT工具分析App内存状态</h2><h2 id="10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001"><a href="#10-7__u4F7F_u7528Dumpsys_u547D_u4EE4_u5206_u6790_u7CFB_u7EDF_u72B6_u6001" class="headerlink" title="10.7 使用Dumpsys命令分析系统状态"></a>10.7 使用Dumpsys命令分析系统状态</h2>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8_u56FE_u673A_u5236_u4E0E_u5904_u7406_u6280_u5DE7"><a href="#u7B2C_u516D_u7AE0_uFF1AAndroid_u7ED8]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现WebView中JS和App之间的交互]]></title>
    <link href="http://yuqirong.me/2016/03/07/%E5%AE%9E%E7%8E%B0WebView%E4%B8%ADJS%E5%92%8CApp%E4%B9%8B%E9%97%B4%E7%9A%84%E4%BA%A4%E4%BA%92/"/>
    <id>http://yuqirong.me/2016/03/07/实现WebView中JS和App之间的交互/</id>
    <published>2016-03-07T11:53:12.000Z</published>
    <updated>2016-03-07T15:04:30.507Z</updated>
    <content type="html"><![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img src="/uploads/20160307/20160307200816.png" alt="这里写图片的描述"></p>
<p>之后在脑海中回想到 WebView 中的JS可以和app产生交互，于是搜索了一下，果然网上有类似的实现效果。看了一下，在这里就做一个简单的笔记了以便之后查看。</p>
<p>在 WebView 中想要JS和app产生交互，就不得不提一个方法，那就是<code>addJavascriptInterface(Object object, String name)</code>：</p>
<ul>
<li>第一个参数：绑定到 JavaScript 的类实例。</li>
<li>第二个参数：用来显示 JavaScript 中的实例的名称。</li>
</ul>
<p>这里只是给出了参数的解释，如果你没看懂，那接下来就告诉你答案。</p>
<p>那就开始吧，在创建新的 project 之前，我们先把要加载的 test.html 写好，放在 assets 目录下：</p>
<pre><code>&lt;html&gt;
    &lt;head&gt;
        &lt;title&gt;WebView Test&lt;/title&gt;
        &lt;script type=&quot;text/javascript&quot;&gt;
        function btnShowToast(){
            window.testJS.showToast();
        }

        function btnGoActivity(){
            window.testJS.goActivity();
        }
        &lt;/script&gt;
    &lt;/head&gt;
    &lt;body&gt;
        &lt;p&gt;This is a website&lt;/p&gt;
        &lt;br&gt;
        &lt;button onclick=&apos;btnShowToast();&apos;&gt;show Toast&lt;/button&gt;
        &lt;button onclick=&apos;btnGoActivity();&apos;&gt;go Activity&lt;/button&gt;
    &lt;/body&gt;
&lt;/html&gt;
</code></pre><p>上面的 html 很简单，相信有点基础的同学都能看得懂。要注意的是在JS函数中的 testJS 是要和 WebView 约定好的，这里就取名叫 testJS 吧，在下面会用到。还有<code>showToast()</code>和<code>goActivity()</code>也是约定好的函数名。我们预期的效果是点击 show Toast 按钮会显示Toast，而点击 go Activity 按钮会跳转到另外一个 Activity 上。</p>
<p>下面创建了一个 project ，名叫 WebViewDemo ，工程中 MainActivity 的 layout.xml 就只有一个 WebView 了：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    tools:context=&quot;com.yuqirong.webviewdemo.MainActivity&quot;&gt;

    &lt;WebView
        android:id=&quot;@+id/mWebView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>MainActivity 的代码很短，就直接贴出来了：</p>
<pre><code>public class MainActivity extends AppCompatActivity {

    private WebView mWebView;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        mWebView = (WebView) findViewById(R.id.mWebView);
        // 设置支持JS
        mWebView.getSettings().setJavaScriptEnabled(true);
        // 增加JS交互的接口
        mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);
        mWebView.setWebViewClient(new WebViewClient() {
            @Override
            public boolean shouldOverrideUrlLoading(WebView view, String url) {
                return false;
            }
        });
        String url = &quot;file:///android_asset/test.html&quot;;
        mWebView.loadUrl(url);
    }
}
</code></pre><p>我们可以看到，如果想要和JS交互，那么<code>mWebView.getSettings().setJavaScriptEnabled(true);</code>这句是必不可少的，再看到下面一行代码：<code>mWebView.addJavascriptInterface(new AndroidJSInterface(this), &quot;testJS&quot;);</code>，这里注意一下第二个参数，没错，就是在 html 中的 testJS ！</p>
<p>再看回第一个参数，发现 new 了一个 AndroidJSInterface 类，下面就是 AndroidJSInterface 的代码：</p>
<pre><code>public class AndroidJSInterface {

    private Context context;

    public AndroidJSInterface(Context context) {
        this.context = context;
    }

    @JavascriptInterface
    public void goActivity() {
        context.startActivity(new Intent(context, SecondActivity.class));
    }

    @JavascriptInterface
    public void showToast() {
        Toast.makeText(context, &quot;hello js&quot;, Toast.LENGTH_SHORT).show();
    }

}
</code></pre><p>我们可以看到上面的<code>showToast()</code>和<code>goActivity()</code>方法名和 html 里面的一定要一样，不然无法触发了。然后在方法的内部实现你想要的逻辑。</p>
<p>经过上面的步骤，就可以实现和JS交互了，一起来看看效果吧：</p>
<p><img src="/uploads/20160307/20160307225743.gif" alt="这里写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160307/WebViewDemo.rar">WebViewDemo.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>今天被问到了一个问题：在 WebView 中加载了一个网页，点击网页中的按钮，如何跳转到指定 Activity ？当时听到后脸上就写了大大的“懵逼”两个字，一时词穷，没回答上来。之前对 WebView 也没有更深入地了解，只是简单地用来加载网页而已。</p>
<p><img]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="WebView" scheme="http://yuqirong.me/tags/WebView/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[《Android群英传》笔记(上)]]></title>
    <link href="http://yuqirong.me/2016/02/28/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B%E7%AC%94%E8%AE%B0(%E4%B8%8A)/"/>
    <id>http://yuqirong.me/2016/02/28/《Android群英传》笔记(上)/</id>
    <published>2016-02-28T12:20:04.000Z</published>
    <updated>2016-03-31T06:28:41.641Z</updated>
    <content type="html"><![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3" class="headerlink" title="第三章：Android控件架构与自定义控件详解"></a>第三章：Android控件架构与自定义控件详解</h1><h2 id="3-1_Android_u63A7_u4EF6_u67B6_u6784"><a href="#3-1_Android_u63A7_u4EF6_u67B6_u6784" class="headerlink" title="3.1 Android控件架构"></a>3.1 Android控件架构</h2><p>控件分为两类：View和ViewGroup，通过ViewGroup整个界面形成一个树形结构，并且ViewGroup负责对子View的测量与绘制以及传递交互事件。通常在Activity中使用的findViewById()方法，就是在控件树中以树的深度优先遍历来查找对应元素。在每颗控件树的顶部，都有一个ViewParent对象，这就是整棵树的控制核心，所有的交互管理事件都由它来统一调度和分配。</p>
<p><img src="/uploads/20160228/20160228230641.png" alt="这里写图片描述"></p>
<p>如上图所示，每个Activity都包含一个Window对象，在Android中Window对象通常由PhoneWindow来实现。PhoneWindow对象又将一个DecorView设置为整个应用的根View。DecorView作为了窗口界面的顶层视图，封装了一些窗口操作的通用方法。可以说，DecorView将要显示的具体内容呈现在了PhoneWindow上，这里所有View的监听事件，都通过WindowManagerService来接收，并通过Activity对象来回调onClickListener。DecorView在显示上分为TitleView和ContentView两部分。ContentView是一个ID为content的FrameLayout，activity_main.xml就是设置在这样一个FrameLayout里。可以通过如下代码获得ContentView：</p>
<pre><code>FrameLayout content = (FrameLayout)findViewById(android.R.id.content);
</code></pre><p><img src="/uploads/20160228/20160228232837.png" alt="这里写图片描述"></p>
<p>而在代码中，当程序在onCreate()方法中调用setContentView()方法后，ActivityManagerService会回调onResume()方法，此时系统才会把整个DecorView添加到PhoneWindow中，并让其显示出来，从而最终完成界面的绘制。</p>
<h2 id="3-2_View_u7684_u6D4B_u91CF"><a href="#3-2_View_u7684_u6D4B_u91CF" class="headerlink" title="3.2 View的测量"></a>3.2 View的测量</h2><p>View的测量在onMeasure中进行，系统提供了MeasureSpec类，是一个32位的int值，其高2位为测量模式，低30位为测量的大小。测量模式有以下三种：</p>
<ul>
<li><p>EXACTLY：精确模式，当控件指定精确值（例如android:layout_width=”50dp”）或者指定为match_parent属性时系统使用该模式。</p>
</li>
<li><p>AT_MOST：最大值模式，指定wrap_content时系统使用该属性。控件大小一般随着控件的子空间或内容的变化而变化，此时控件的尺寸只要不超过父控件允许的最大尺寸即可。View类默认只支持EXACTLY，如果想使用wrap_content需自己在onMeasure中实现。</p>
</li>
<li><p>UNSPECIFIED：自定义模式，View想多大就多大，通常在绘制自定义View的时候才使用。</p>
</li>
</ul>
<p>下面是onMeasure的示例代码：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);// 获取宽度模式
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);// 获取宽度值
    int width = 0;
    if (widthMode == MeasureSpec.EXACTLY) {
        width = widthSize;
    } else {
        width = 200;// 自定义的默认wrap_content值
        if (widthMode == MeasureSpec.AT_MOST) {
                width = Math.min(widthSize, width);
        }

    }
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);// 获取高度模式
    int heightSize = MeasureSpec.getSize(heightMeasureSpec);// 获取高度值
    int height = 0;
    if (heightMode == MeasureSpec.EXACTLY) {
        height = heightSize;
    } else {
        height = 200;// 自定义的默认wrap_content值
        if (heightMode == MeasureSpec.AT_MOST) {
            height = Math.min(heightSize, height);
        }
    }
    setMeasuredDimension(width, height);// 最终将测量的值传入该方法完成测量
}
</code></pre><h2 id="3-3_View_u7684_u7ED8_u5236"><a href="#3-3_View_u7684_u7ED8_u5236" class="headerlink" title="3.3 View的绘制"></a>3.3 View的绘制</h2><p>View的绘制是通过onDraw()方法实现的，具体是通过对onDraw()方法中Canvas参数操作执行绘图。在其他地方，则需要自己创建Canvas对象，创建时需传入一个bitmap对象，这个过程我们称之为装载画布。bitmap是用来存储所有绘制在Canvas上的像素信息，当你通过这种方式创建了Canvas对象后，后面调用所有的Canvas.drawXXX方法都发生在这个bitmap上。</p>
<h2 id="3-4_ViewGroup_u7684_u6D4B_u91CF"><a href="#3-4_ViewGroup_u7684_u6D4B_u91CF" class="headerlink" title="3.4 ViewGroup的测量"></a>3.4 ViewGroup的测量</h2><p>当ViewGroup的大小为wrap_content时，它就会遍历所有子View，以便获得所有子View的大小，从而来决定自身的大小，而在其他模式下则通过指定值来设置自身的大小。</p>
<p>然后当子View测量完毕以后，ViewGroup会执行它的Layout方法，同样是遍历子View并调用其Layout方法来确定布局位置。</p>
<p>在自定义ViewGroup时，通常会重写onLayout()方法来控制子View显示位置，若需支持wrap_content还需重写onMeasure()方法，这点与View是相同的。</p>
<h2 id="3-5_ViewGroup_u7684_u7ED8_u5236"><a href="#3-5_ViewGroup_u7684_u7ED8_u5236" class="headerlink" title="3.5 ViewGroup的绘制"></a>3.5 ViewGroup的绘制</h2><p>ViewGroup通常情况下不需要绘制，如果不是指定了ViewGroup的背景颜色，那么ViewGroup的onDraw()方法都不会被调用。但是ViewGroup会调用dispatchDraw()方法来绘制其子View，过程同样是遍历子View，并调用子View的绘制方法来完成绘制工作。</p>
<h2 id="3-6__u81EA_u5B9A_u4E49View"><a href="#3-6__u81EA_u5B9A_u4E49View" class="headerlink" title="3.6 自定义View"></a>3.6 自定义View</h2><p>自定义View时有一些比较重要的回调方法如下：</p>
<ul>
<li>onFinishInflate();//从xml加载组件后回调</li>
<li>onSizeChanged();//组件大小改变时回调</li>
<li>onMeasure();//回调该方法进行测量</li>
<li>onLayout();//回调该方法来确定显示的位置</li>
<li>onTouchEvent();//监听到触摸事件回调</li>
</ul>
<p>通常情况下，有以下三种方法来实现自定义的控件：</p>
<ul>
<li>对现有控件进行拓展</li>
<li>通过组合来实现新的控件</li>
<li>重写View来实现全新的控件</li>
</ul>
<p>PS ： LinearGradient也称作线性渲染，LinearGradient的作用是实现某一区域内颜色的线性渐变效果。构造函数有两个，分别如下：</p>
<p><code>public LinearGradient(float x0, float y0, float x1, float y1, int color0, int color1, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标　；color0表示渐变开始颜色；color1表示渐变结束颜色；参数tile表示平铺方式。</p>
<p>Shader.TileMode有3种参数可供选择，分别为CLAMP、REPEAT和MIRROR：</p>
<ul>
<li><p>CLAMP的作用是如果渲染器超出原始边界范围，则会复制边缘颜色对超出范围的区域进行着色</p>
</li>
<li><p>REPEAT的作用是在横向和纵向上以平铺的形式重复渲染位图</p>
</li>
<li><p>MIRROR的作用是在横向和纵向上以镜像的方式重复渲染位图</p>
</li>
</ul>
<p><code>public LinearGradient (float x0, float y0, float x1, float y1, int[] colors, float[] positions, Shader.TileMode tile)</code></p>
<p>其中，参数x0表示渐变的起始点x坐标；参数y0表示渐变的起始点y坐标；参数x1表示渐变的终点x坐标；参数y1表示渐变的终点y坐标；参数colors表示渐变的颜色数组；参数positions用来定义每个颜色处于的渐变相对位置；参数tile表示平铺方式。通常，参数positions设为null，表示颜色数组按顺序均匀的分布。</p>
<h2 id="3-7__u81EA_u5B9A_u4E49ViewGroup"><a href="#3-7__u81EA_u5B9A_u4E49ViewGroup" class="headerlink" title="3.7 自定义ViewGroup"></a>3.7 自定义ViewGroup</h2><p>自定义ViewGroup通常需要重写onMeasure()方法来对子View进行测量，重写onLayout()方法来确定子View的位置，重写onTouchEvent()方法增加响应事件。</p>
<p><code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>方法：</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    super.onMeasure(widthMeasureSpec, heightMeasureSpec);
    int count = getChildCount();
    for (int i = 0; i &lt; count; i++) {
        measureChild(getChildAt(i), widthMeasureSpec, heightMeasureSpec);
    }
}
</code></pre><h2 id="3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790"><a href="#3-8__u4E8B_u4EF6_u62E6_u622A_u673A_u5236_u5206_u6790" class="headerlink" title="3.8 事件拦截机制分析"></a>3.8 事件拦截机制分析</h2><p>本章较为浅显的分析了下事件传递的机制。当ViewGroup接收到事件，通过调用dispatchTouchEvent()，由这个方法再调用onInterceptTouchEvent()方法来判断是否要拦截事件，如果返回true则拦截将事件交给自己的onTouchEvent处理，返回false则继续向下传递。当View在接受到事件时，通过调用dispatchTouchEvent()，由此方法再调用onTouchEvent方法，如果返回true则拦截事件自己处理，如果返回false则将事件向上传递回ViewGroup并且调用其onTouchEvent方法继续做判断。</p>
<h1 id="u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7"><a href="#u7B2C_u56DB_u7AE0_uFF1AListView_u4F7F_u7528_u6280_u5DE7" class="headerlink" title="第四章：ListView使用技巧"></a>第四章：ListView使用技巧</h1><h2 id="4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7"><a href="#4-1_ListView_u5E38_u7528_u4F18_u5316_u6280_u5DE7" class="headerlink" title="4.1 ListView常用优化技巧"></a>4.1 ListView常用优化技巧</h2><ul>
<li>使用ViewHolder模式提高效率</li>
<li><p>设置项目间分隔线：</p>
<pre><code>android:divider=&quot;@android:color/darker_gray&quot;
android:dividerHeight=&quot;10dp&quot;
</code></pre><p>   特殊情况下，以下代码可以设置分割线为透明：</p>
<pre><code>android:divider=&quot;@null&quot;
</code></pre></li>
<li><p>隐藏ListView的滚动条：</p>
<pre><code>android:scrollbars=&quot;none&quot;
</code></pre></li>
<li><p>取消ListView的点击效果：</p>
<pre><code>android:listSelector=&quot;#00000000&quot;
</code></pre><p>  也可以用Android自带的透明色来实现这个效果：</p>
<pre><code>android:listSelector=&quot;@android:color/transparent&quot;
</code></pre></li>
<li><p>设置ListView需要显示在第几项：</p>
<pre><code>listView.setSelection(N);
</code></pre><p>  其中N就是需要显示的第N个Item。</p>
<p>  除此之外，还可以使用如下代码来实现平滑移动：</p>
<pre><code>mListView.smoothScrollBy(distance,duration);
mListView.smoothScrollByOffset(offset);
mListView.smoothScrollToPosition(index);
</code></pre></li>
<li><p>动态修改ListView：</p>
<pre><code>mAdapter.notifyDataSetChanged();
</code></pre></li>
<li><p>遍历ListView中的所有Item：</p>
<pre><code>for(int i=0;i&lt;mListView.getChildCount();i++){
    View view = mListView.getChildAt(i);
}
</code></pre></li>
<li><p>处理空ListView：</p>
<pre><code>&lt;RelativeLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;&gt;

    &lt;ListView
    android:id=&quot;@+id/listView&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot; /&gt;

    &lt;ImageView
        android:id=&quot;@+id/imageView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;
        android:src=&quot;@drawable/empty_view&quot; /&gt;

&lt;/RelativeLayout&gt;
</code></pre><p>  在代码中，我们通过以下方式给ListView设置空数据时要显示的布局，代码如下：</p>
<pre><code>ListView listView = (ListView)findViewById(R.id.listView);
listView.setEmptyView(findViewById(R.id.imageView));
</code></pre></li>
<li><p>ListView滑动监听：一种是通过OnTouchListener来实现监听，另外一种是使用OnScrollListener来实现监听。</p>
<p>  OnScrollListener中有两个回调方法——onScrollStateChanged()和onScroll()</p>
<pre><code> @Override
public void onScrollStateChanged(AbsListView view, int scrollState) {
    switch(scrollState){
        case SCROLL_STATE_FLING:
          // TODO    
        break;
        case SCROLL_STATE_IDLE:
        // TODO 
        break;
        case SCROLL_STATE_TOUCH_SCROLL:
        // TODO 
        break;
    }
}
</code></pre><p>  scrollState有以下三种模式：</p>
<ul>
<li>OnScrollListener.SCROLL_STATE_IDLE ： 滚动停止时；</li>
<li>OnScrollListener.SCROLL_STATE_TOUCH_SCROLL ： 正在滚动时；</li>
<li><p>OnScrollListener.SCROLL_STATE_FLING ： 手指抛动时，即手指用力滑动，在离开后ListView由于惯性继续滑动的状态；</p>
<p>当手指没有做手指抛动的状态时，这个方法只会回调2次，否则会回调3次。</p>
<pre><code>@Override
public void onScroll(AbsListView view, int firstVisibleItem,
        int visibleItemCount, int totalItemCount) {
    // TODO Auto-generated method stub
}
</code></pre></li>
<li><p>firstVisibleItem ： 当前能看见的第一个Item的ID（从0开始）</p>
</li>
<li><p>visibleItemCount ： 当前能看见的Item的总数</p>
</li>
<li><p>totalItemCount ： 整个ListView的Item总数</p>
<p>判断是否滚动到最后一行：</p>
<pre><code>if(firstVisibleItem + visibleItemCount == totalItemCount &amp;&amp; totalItemCount &gt; 0){
    // 滚动到最后一行
} 
</code></pre><p>再比如，可以通过如下代码来判断滚动的方向：</p>
<pre><code>if(firstVisibleItem &gt; lastVisibleItemPosition){
    // 上滑
}else if(firstVisibleItem &lt; lastVisibleItemPosition){
    // 下滑
}
lastVisibleItemPosition = firstVisibleItem;
</code></pre><p>当然，ListView也给我们提供了一些封装的方法来获得当前可视的Item的位置等信息：</p>
<pre><code>// 获取可视区域内最后一个Item的id
mListView.getLastVisiblePosition()；
// 获取可视区域内第一个Item的id
mListView。getFirstVisiblePosition();
</code></pre></li>
</ul>
</li>
</ul>
<h2 id="4-2_ListView_u5E38_u7528_u62D3_u5C55"><a href="#4-2_ListView_u5E38_u7528_u62D3_u5C55" class="headerlink" title="4.2 ListView常用拓展"></a>4.2 ListView常用拓展</h2><ol>
<li><p>具有弹性的ListView：</p>
<pre><code>@Override
protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX, int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
    return super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX, scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
}
</code></pre><p> 其中的maxOverScrollY，默认值为0。所以只要修改它的值，就可以让ListView具有弹性了。</p>
</li>
</ol>
<h1 id="u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790"><a href="#u7B2C_u4E94_u7AE0_uFF1AAndroid_Scroll_u5206_u6790" class="headerlink" title="第五章：Android Scroll分析"></a>第五章：Android Scroll分析</h1><h2 id="5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684"><a href="#5-1__u6ED1_u52A8_u6548_u679C_u662F_u5982_u4F55_u4EA7_u751F_u7684" class="headerlink" title="5.1 滑动效果是如何产生的"></a>5.1 滑动效果是如何产生的</h2><p>滑动一个View，本质上来说就是移动一个View。改变其当前所处的位置，它的原理与动画效果的实现非常相似，都是通过不断地改变View的坐标来实现这一效果。所以，要实现View的滑动，就必须监听用户触摸的事件，并根据事件传入的坐标，动态且不断地改变View的坐标，从而实现View跟随用户触摸的滑动而滑动。</p>
<p><strong>Android坐标系</strong></p>
<p>Android的坐标系是以屏幕最左上角为顶点，向右为x轴正方向，向下是y轴正方向。在触控事件中通过<code>getRawX()</code>和<code>getRawY()</code>获取Android坐标系中的坐标。在View中通过<code>getLocationOnScreen(int[] location)</code>获取。</p>
<p><strong>视图坐标系</strong></p>
<p>描述的是子视图在父视图中的位置关系，原点为父视图的左上角，x、y轴方向与Android坐标系一致。触控事件中通过<code>getX()</code>,<code>getY()</code>获取视图坐标系的坐标。</p>
<p><strong>触控事件——MotionEvent</strong></p>
<pre><code>// 单点触摸按下动作
public static final int MotionEvent.ACTION_DOWN = 0;
// 单点触摸离开动作
public static final int MotionEvent.ACTION_UP = 1;
// 触摸点移动动作
public static final int MotionEvent.ACTION_MOVE = 2;
// 触摸动作取消
public static final int MotionEvent.ACTION_CANCEL = 3;
// 触摸动作超出边界
public static final int MotionEvent.ACTION_OUTSIDE = 4;
// 多点触摸按下动作
public static final int MotionEvent.ACTION_POINTER_DOWN = 5;
// 多点离开动作
public static final int MotionEvent.ACTION_POINTER_UP = 6;
</code></pre><p><strong>View提供的获取坐标方法</strong></p>
<ul>
<li>getTop()：获取到的是View自身的顶边到其父布局顶边的距离</li>
<li>getLeft()：获取到的是View自身的左边到其父布局左边的距离</li>
<li>getRight()：获取到的是View自身的右边到其父布局右边的距离</li>
<li>getBottom()：获取到的是View自身的底边到其父布局底边的距离</li>
</ul>
<p><strong>MotionEvent提供的方法</strong></p>
<ul>
<li>getX()：获取点击事件距离控件左边的距离，即视图坐标</li>
<li>getY()：获取点击事件距离控件顶边的距离，即视图坐标</li>
<li>getRawX()：获取点击事件距离整个屏幕左边的距离，即绝对坐标</li>
<li>getRawY()：获取点击事件距离整个屏幕顶边的距离，即绝对坐标</li>
</ul>
<h2 id="5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5"><a href="#5-2__u5B9E_u73B0_u6ED1_u52A8_u7684_u4E03_u79CD_u65B9_u6CD5" class="headerlink" title="5.2 实现滑动的七种方法"></a>5.2 实现滑动的七种方法</h2><ul>
<li><p>layout()方法</p>
<pre><code>private int lastX;
private int lastY;
private int offsetX;
private int offsetY;

@Override
public boolean onTouchEvent(MotionEvent event) {
  int x = (int) event.getRawX();
  int y = (int) event.getRawY();

  switch (event.getAction()) {
  case MotionEvent.ACTION_DOWN:
      lastX = x;
      lastY = y;
      break;
  case MotionEvent.ACTION_MOVE:
      offsetX = x - lastX;
      offsetY = y - lastY;

      layout(getLeft() + offsetX, getTop() + offsetY, getRight() + offsetX, getBottom() + offsetY);

      lastX = x;
      lastY = y;
      break;
  }
  return true;
}
</code></pre></li>
<li><p>offsetLeftAndRight()与offsetTopAndBottom()</p>
<pre><code>// 同时对left和right进行偏移
offsetLeftAndRight(offsetX);
// 同时对top和bottom进行偏移
offsetTopAndBottom(offsetY);
</code></pre></li>
<li><p>LayoutParams</p>
<pre><code>LinearLayout.MarginLayoutParams layoutParams=(LinearLayout.LayoutParams)getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre><p>  或者</p>
<pre><code>ViewGroup.MarginLayoutParams layoutParams=(MarginLayoutParams) getLayoutParams();
layoutParams.leftMargin=getLeft()+offsetX;
layoutParams.topMargin=getTop()+offsetY;
setLayoutParams(layoutParams);
</code></pre></li>
<li><p>scrollTo()和scrollBy()</p>
<pre><code>//scrollTo和scrollBy移动的是view的内容而不是view本身
//如果在viewgroup中使用就是移动所有子view。
View view=(View) getParent();
//scrollTo和scrollBy参考的坐标系正好与视图坐标系相反，所以offset需为负
view.scrollBy(-offsetX, -offsetY);
</code></pre></li>
<li><p>Scroller</p>
<p>  scrollTo()和scrollBy()都是使View的平移瞬间发生的，这样的效果会让人感觉很突兀，而Scroller可以实现平滑移动的效果，而不是瞬间完成的移动。</p>
<p>  使用Scroller主要有三个步骤：</p>
<ol>
<li><p>初始化Scroller对象，一般在view初始化的时候同时初始化scroller，代码如下：<br><code>mScroller=new Scroller(context);</code></p>
</li>
<li><p>重写view的computeScroll()方法，实现模拟滑动。computeScroll()的模版代码如下：</p>
<pre><code>@Override
public void computeScroll() {
  super.computeScroll();
  // 判断Scroller是否执行完毕
  if (mScroller.computeScrollOffset()) {
      ((View) getParent()).scrollTo(mScroller.getCurrX(), mScroller.getCurrY());
      // 通过重绘来不断调用computeScroll
      invalidate();
  }
}
</code></pre><p> Scroller类提供了computeScrollOffset()方法来判断是否完成了整个滑动，同时也提供了getCurrX()和getCurrY()方法来获得当前的滑动坐标。computeScroll()方法是不会自动调用的，只能通过invalidate()-&gt;draw()-&gt;computeScroll()来间接调用，实现循环获取scrollX和scrollY的目的，当移动过程结束之后，Scroller.computeScrollOffset方法会返回false，从而中断循环,完成整个平滑移动过程；</p>
</li>
<li><p>startScroll开启模拟过程。调用Scroller.startScroll()方法，将起始位置、偏移量以及移动时间(可选)作为参数传递给startScroll()方法。在获取坐标时，通常可以使用getScrollX()和getScrollY()方法来获取父视图中content所滑动到的点的坐标，不过要注意的是这个值的正负，它与在scrollBy()、scrollTo()中讲解是一样的。另外，在startScroll()之后，还要invalidate()方法来通知View进行重绘，从而来调用computeScroll()的模拟过程。当然，可以给startScroll()方法增加一个duration的参数来设置滑动的持续时长。</p>
</li>
</ol>
</li>
</ul>
<ul>
<li><p>属性动画</p>
</li>
<li><p>ViewDragHelper</p>
<p>  ViewDragHelper基本可以实现各种不同滑动需求，但使用稍微复杂。</p>
<p>  示例代码：</p>
<pre><code>public class DragViewGroup extends FrameLayout {

  private ViewDragHelper mViewDragHelper;
  private View mMenuView, mMainView;
  private int mWidth;

  public DragViewGroup(Context context) {
      super(context);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs) {
      super(context, attrs);
      initView();
  }

  public DragViewGroup(Context context, AttributeSet attrs, int defStyleAttr) {
      super(context, attrs, defStyleAttr);
      initView();
  }

  @Override
  protected void onFinishInflate() {
      super.onFinishInflate();
      mMenuView = getChildAt(0);
      mMainView = getChildAt(1);
  }

  @Override
  protected void onSizeChanged(int w, int h, int oldw, int oldh) {
      super.onSizeChanged(w, h, oldw, oldh);
      mWidth = mMenuView.getMeasuredWidth();
  }

  @Override
  public boolean onInterceptTouchEvent(MotionEvent ev) {
      return mViewDragHelper.shouldInterceptTouchEvent(ev);
  }

  @Override
  public boolean onTouchEvent(MotionEvent event) {
      //将触摸事件传递给ViewDragHelper,此操作必不可少
      mViewDragHelper.processTouchEvent(event);
      return true;
  }

  private void initView() {
      mViewDragHelper = ViewDragHelper.create(this, callback);
  }

  private ViewDragHelper.Callback callback = new ViewDragHelper.Callback() {

      // 何时开始检测触摸事件
      @Override
      public boolean tryCaptureView(View child, int pointerId) {
          //如果当前触摸的child是mMainView时开始检测
          return mMainView == child;
      }

      // 触摸到View后回调
      @Override
      public void onViewCaptured(View capturedChild, int activePointerId) {
          super.onViewCaptured(capturedChild, activePointerId);
      }

      // 当拖拽状态改变，比如idle，dragging
      @Override
      public void onViewDragStateChanged(int state) {
          super.onViewDragStateChanged(state);
      }

      // 当位置改变的时候调用,常用与滑动时更改scale等
      @Override
      public void onViewPositionChanged(View changedView, int left, int top, int dx, int dy) {
          super.onViewPositionChanged(changedView, left, top, dx, dy);
      }

      // 处理垂直滑动
      @Override
      public int clampViewPositionVertical(View child, int top, int dy) {
          return 0;
      }

      // 处理水平滑动
      @Override
      public int clampViewPositionHorizontal(View child, int left, int dx) {
          return left;
      }

      // 拖动结束后调用
      @Override
      public void onViewReleased(View releasedChild, float xvel, float yvel) {
          super.onViewReleased(releasedChild, xvel, yvel);
          //手指抬起后缓慢移动到指定位置
          if (mMainView.getLeft() &lt; 500) {
              //关闭菜单，相当于Scroller的startScroll方法
              mViewDragHelper.smoothSlideViewTo(mMainView, 0, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          } else {
              //打开菜单
              mViewDragHelper.smoothSlideViewTo(mMainView, 300, 0);
              ViewCompat.postInvalidateOnAnimation(DragViewGroup.this);
          }
      }
  };

  @Override
  public void computeScroll() {
      if (mViewDragHelper.continueSettling(true)) {
          ViewCompat.postInvalidateOnAnimation(this);
      }
  }
}
</code></pre></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u7B2C_u4E09_u7AE0_uFF1AAndroid_u63A7_u4EF6_u67B6_u6784_u4E0E_u81EA_u5B9A_u4E49_u63A7_u4EF6_u8BE6_u89E3"><a href="#u7B2C_u4E09_u7AE0_]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="《Android群英传》" scheme="http://yuqirong.me/tags/%E3%80%8AAndroid%E7%BE%A4%E8%8B%B1%E4%BC%A0%E3%80%8B/"/>
    
      <category term="Book Note" scheme="http://yuqirong.me/categories/Book-Note/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[使用RecyclerView实现仿喵街效果]]></title>
    <link href="http://yuqirong.me/2016/02/26/%E4%BD%BF%E7%94%A8RecyclerView%E5%AE%9E%E7%8E%B0%E4%BB%BF%E5%96%B5%E8%A1%97%E6%95%88%E6%9E%9C/"/>
    <id>http://yuqirong.me/2016/02/26/使用RecyclerView实现仿喵街效果/</id>
    <published>2016-02-26T11:50:18.000Z</published>
    <updated>2016-03-05T09:45:43.291Z</updated>
    <content type="html"><![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></p>
<p>值得一提的是，这是旧版本的特效，新版本的喵街已经去掉了这种效果。</p>
<p>看完了效果，接下来就是动手的时间了。</p>
<p>我们先来分析一下思路：我们先给RecyclerView添加一个OnScrollListener，然后分别去获得firstVisiblePosition和firstCompletelyVisiblePosition。这里要注意一下，firstVisiblePosition是第一个在屏幕中<strong>可见</strong>的itemView对应的position，而firstCompletelyVisiblePosition是是第一个在屏幕中<strong>完全可见</strong>的itemView对应的position。之后在滚动中去动态地设置itemView的高度。整体的思路就这样了，下面我们直接来看代码。</p>
<p>创建几个自定义的属性，以便后面备用：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;resources&gt;
    &lt;declare-styleable name=&quot;ExpandRecyclerView&quot;&gt;
        &lt;!-- item最大的高度 --&gt;
        &lt;attr name=&quot;max_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
        &lt;!-- item普通的高度 --&gt;
        &lt;attr name=&quot;normal_item_height&quot; format=&quot;dimension&quot;&gt;&lt;/attr&gt;
    &lt;/declare-styleable&gt;
&lt;/resources&gt;
</code></pre><p>之后我们新建一个类继承自RecyclerView，类名就叫ExpandRecyclerView。</p>
<pre><code>//最大item的高度
private float maxItemHeight;
//普通item的高度
private float normalItemHeight;
// 默认最大的item高度
private float defaultMaxItemHeight;
// 默认普通的item高度
private float defaultNormalItemHeight;

public ExpandRecyclerView(Context context) {
    this(context, null);
}

public ExpandRecyclerView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public ExpandRecyclerView(Context context, AttributeSet attrs, int defStyle) {
    super(context, attrs, defStyle);
    TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.ExpandRecyclerView);
    defaultMaxItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 256, context.getResources().getDisplayMetrics());
    defaultNormalItemHeight = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 120, context.getResources().getDisplayMetrics());
    maxItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_max_item_height, defaultMaxItemHeight);
    normalItemHeight = a.getDimension(R.styleable.ExpandRecyclerView_normal_item_height, defaultNormalItemHeight);
    a.recycle();

    setHasFixedSize(true);
    setLayoutManager(new LinearLayoutManager(context));
    setItemAnimator(new DefaultItemAnimator());
    this.addOnScrollListener(listener);
}
</code></pre><p>在构造器中我们得到了<code>maxItemHeight</code>和<code>normalItemHeight</code>，之后设置了OnScrollListener。</p>
<pre><code>OnScrollListener listener = new RecyclerView.OnScrollListener() {

    @Override
    public void onScrolled(RecyclerView recyclerView, int dx, int dy) {
        super.onScrolled(recyclerView, dx, dy);
        Log.i(TAG,&quot;dy : &quot; + dy);
        LinearLayoutManager mLinearLayoutManager = (LinearLayoutManager) recyclerView.getLayoutManager();
        // 在屏幕中第一个可见的position
        int firstVisiblePosition = mLinearLayoutManager.findFirstVisibleItemPosition();
        // 得到第一个可见的ViewHolder
        RecyclerView.ViewHolder firstVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstVisiblePosition);
        // 在屏幕中第一个完全可见的position
        int firstCompletelyVisiblePosition = mLinearLayoutManager.findFirstCompletelyVisibleItemPosition();
        // 得到第一个完全可见的ViewHolder
        RecyclerView.ViewHolder firstCompletelyVisibleViewHolder =
                recyclerView.findViewHolderForLayoutPosition(firstCompletelyVisiblePosition);

        Log.i(TAG, &quot;firstVisiblePosition : &quot; + firstVisiblePosition + &quot; , firstCompletelyVisiblePosition : &quot; + firstCompletelyVisiblePosition);
        // 当firstVisibleViewHolder被滑出屏幕时
        if (firstVisibleViewHolder.itemView.getLayoutParams().height - dy &lt; maxItemHeight
                &amp;&amp; firstVisibleViewHolder.itemView.getLayoutParams().height - dy &gt;= normalItemHeight) {
            // 高度减小
            firstVisibleViewHolder.itemView.getLayoutParams().height -= dy;
            firstVisibleViewHolder.itemView.setLayoutParams(firstVisibleViewHolder.itemView.getLayoutParams());
        }
        // 当firstCompletelyVisibleViewHolder慢慢滑到屏幕顶部时
        if (firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &lt;= maxItemHeight
                &amp;&amp; firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height + dy &gt;= normalItemHeight) {
            // 高度增加
            firstCompletelyVisibleViewHolder.itemView.getLayoutParams().height += dy;
            firstCompletelyVisibleViewHolder.itemView.setLayoutParams(firstCompletelyVisibleViewHolder.itemView.getLayoutParams());
        }

    }

};
</code></pre><p>在<code>onScrolled(RecyclerView recyclerView, int dx, int dy)</code>里大部分的代码都加上注释了，就是根据<code>dy</code>去动态地改变了<code>firstVisibleViewHolder</code>和<code>firstCompletelyVisibleViewHolder</code>的高度。</p>
<p>上面的搞定了之后，别忘了要在Adapter里去初始化设置Item的高度。</p>
<pre><code>/**
 * 设置适配器
 *
 * @param adapter
 */
@Override
public void setAdapter(Adapter adapter) {
    super.setAdapter(adapter);
    if (adapter instanceof ExpandRecyclerViewAdapter) {
        ExpandRecyclerViewAdapter mAdapter = (ExpandRecyclerViewAdapter) adapter;
        //设置最大的item高度
        mAdapter.setMaxItemHeight(maxItemHeight);
        //设置普通的item高度
        mAdapter.setNormalItemHeight(normalItemHeight);
    }
}
</code></pre><p>ExpandRecyclerViewAdapter的代码，重写<code>onBindViewHolder(RecyclerView.ViewHolder holder, int position)</code>：</p>
<pre><code>@Override
public void onBindViewHolder(RecyclerView.ViewHolder holder, int position) {
        if(position == 0){
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) maxItemHeight));
        }else{
            holder.itemView.setLayoutParams(new RelativeLayout.LayoutParams(ViewGroup.LayoutParams.MATCH_PARENT, (int) normalItemHeight));
        }
        bindCustomViewHolder(holder, position);
}

public abstract void bindCustomViewHolder(RecyclerView.ViewHolder holder, int position);
</code></pre><p>好了，整体的代码就这些了，下面贴出运行效果：</p>
<p><img src="/uploads/20160226/20160226210235.gif" alt="这里写图片描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160226/ExpandRecyclerView.rar">ExpandRecyclerView.rar</a></p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><p><a href="http://www.jianshu.com/p/a2c3c21e3b99" target="_blank" rel="external">android版高仿喵街主页滑动效果</a></p>
<h1 id="Thanks"><a href="#Thanks" class="headerlink" title="Thanks"></a>Thanks</h1><ul>
<li><a href="https://github.com/dongjunkun/miaojiedemo" target="_blank" rel="external">miaojiedemo</a> created by <a href="https://github.com/dongjunkun" target="_blank" rel="external">dongjunkun</a></li>
</ul>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到更新博客的时间了，本次给大家带来的是在RecyclerView的基础上实现喵街的效果。那么喵街是什么效果呢？下面就贴出效果图：</p>
<p><img src="/uploads/20160226/20160226205314.gif" alt="这里写图片描述"></]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[九大基本排序算法]]></title>
    <link href="http://yuqirong.me/2016/02/18/%E4%B9%9D%E5%A4%A7%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    <id>http://yuqirong.me/2016/02/18/九大基本排序算法/</id>
    <published>2016-02-18T13:56:06.000Z</published>
    <updated>2016-03-23T08:13:50.130Z</updated>
    <content type="html"><![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O(N),最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] bubbleSort(int[] A, int n) {
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (A[j] &gt; A[j + 1]) {
                temp = A[j + 1];
                A[j + 1] = A[j];
                A[j] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u9009_u62E9_u6392_u5E8F"><a href="#u9009_u62E9_u6392_u5E8F" class="headerlink" title="选择排序"></a>选择排序</h1><p>选择排序时间复杂度 O(N^2)，最坏的情况O(N^2);空间复杂度O(1)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] selectionSort(int[] A, int n) {
    int minPos = 0;
    int temp;
    for (int i = 0; i &lt; n - 1; i++) {
        for (int j = i + 1; j &lt; n; j++) {
            if (A[j] &lt; A[minPos]) {
                minPos = j;
            }
        }
        temp = A[minPos];
        A[minPos] = A[i];
        A[i] = temp;
        minPos = i + 1;
    }
    return A;
}
</code></pre><h1 id="u63D2_u5165_u6392_u5E8F"><a href="#u63D2_u5165_u6392_u5E8F" class="headerlink" title="插入排序"></a>插入排序</h1><p>插入排序的平均复杂度是O(N^2)，最好的情况O(N)，最坏的情况O(N^2);空间复杂度O(1)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] insertionSort(int[] A, int n) {
    int temp;
    for (int i = 2; i &lt; n; i++) {
        for (int j = 0; j &lt; i; j++) {
            if (A[i] &lt; A[j]) {
                temp = A[j];
                A[j] = A[i];
                A[i] = temp;
            }
        }
    }
    return A;
}
</code></pre><h1 id="u5F52_u5E76_u6392_u5E8F"><a href="#u5F52_u5E76_u6392_u5E8F" class="headerlink" title="归并排序"></a>归并排序</h1><p>归并排序时间复杂度O(N*logN),最好的情况O(N*logN)，最坏的情况O(N*logN)；空间复杂度O(N)；稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] mergeSort(int[] A, int n) {
    if (n &gt; 1) {
        int k = n / 2;
        int[] temp1 = new int[k];
        int[] temp2 = new int[n - k];

        for (int i = 0; i &lt; k; i++) {
            temp1[i] = A[i];
        }
        for (int i = k; i &lt; n; i++) {
            temp2[i - k] = A[i];
        }
        temp1 = mergeSort(temp1, k);
        temp2 = mergeSort(temp2, n - k);

        int i = 0;
        int j = 0;
        int x = 0;
        int[] temp = new int[n];

        while (i &lt; k &amp;&amp; j &lt; n - k) {
            if (temp1[i] &lt;= temp2[j]) {
                temp[x] = temp1[i];
                x++;
                i++;
            } else {
                temp[x] = temp2[j];
                x++;
                j++;
            }
        }

        while (i &lt; k) {
            temp[x] = temp1[i];
            x++;
            i++;
        }

        while (j &lt; n - k) {
            temp[x] = temp2[j];
            x++;
            j++;
        }
        return temp;
    }
    return A;
}
</code></pre><h1 id="u5FEB_u901F_u6392_u5E8F"><a href="#u5FEB_u901F_u6392_u5E8F" class="headerlink" title="快速排序"></a>快速排序</h1><p>快速排序的平均复杂度是O(N*logN)，最好的情况O(N*logN)，最坏的情况O(N^2);空间复杂度O(logN)；不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] quickSort(int[] A, int n) {
    qSort(A, 0, n - 1);
    return A;
}

/**
 * 
 * @param A
 *            数组
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void qSort(int[] A, int start, int end) {
    if (start &lt; end) {
        Random random = new Random();
        // 产生一个随机数
        int nextInt = random.nextInt(end - start + 1) + start;
        // 把随机位和数组最后一位交换
        int temp = A[end];
        A[end] = A[nextInt];
        A[nextInt] = temp;
        // 比A[nextInt]小的数的个数
        int lt = 0;

        for (int i = start; i &lt; end; i++) {
            if (A[i] &lt;= A[end]) {
                int temp1 = A[lt + start];
                A[lt + start] = A[i];
                A[i] = temp1;
                lt++;
            }
        }
        // 把数组最后一位和A[start + lt]交换
        int temp2 = A[start + lt];
        A[lt + start] = A[end];
        A[end] = temp2;
        // 递归
        qSort(A, start, lt + start - 1);
        qSort(A, lt + start + 1, end);
    }
}
</code></pre><h1 id="u5806_u6392_u5E8F"><a href="#u5806_u6392_u5E8F" class="headerlink" title="堆排序"></a>堆排序</h1><p>时间复杂度 O(N*logN),最坏O(N*logN);不稳定算法</p>
<pre><code>/**
 * 从堆顶中取值，再重新建堆
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] heapSort(int[] A, int n) {
    while (n &gt; 0) {
        sift(A, n);
        int temp = A[n - 1];
        A[n - 1] = A[0];
        A[0] = temp;
        n--;
        sift(A, n);
    }
    return A;
}

/**
 * 建堆
 * 
 * @param A
 * @param n
 */
public static void sift(int[] A, int n) {
    // 最后一个非终端节点
    int temp = n / 2;

    while (temp &gt; 0) {
        int tt = 2 * temp - 1;
        if (2 * temp &lt;= n - 1) {
            if (A[2 * temp] &lt; A[2 * temp - 1]) {
                tt = 2 * temp - 1;
            } else {
                tt = 2 * temp;
            }
        }
        // 如果子节点大于父节点
        if (A[temp - 1] &lt; A[tt]) {
            int t = A[temp - 1];
            A[temp - 1] = A[tt];
            A[tt] = t;
        }

        // 保证下面的堆为大顶堆
        for (int i = (tt + 1); i &lt;= n; i = 2 * i) {
            int k = 2 * i - 1;
            if (k &lt; n) {
                if (i * 2 + 1 &lt;= n) {
                    if (A[2 * i] &gt; A[2 * i - 1]) {
                        k = 2 * i;
                    }
                }
                if (A[i - 1] &lt; A[k]) {
                    int t = A[i - 1];
                    A[i - 1] = A[k];
                    A[k] = t;
                }
            }
        }
        // 节点自减
        temp--;
    }
}
</code></pre><h1 id="u5E0C_u5C14_u6392_u5E8F"><a href="#u5E0C_u5C14_u6392_u5E8F" class="headerlink" title="希尔排序"></a>希尔排序</h1><p>希尔排序的平均复杂度是O(N*logN)~O(N^2)，最好的情况O(N^1.3)，最坏的情况O(N^2)；空间复杂度O(1);不稳定算法</p>
<pre><code>/**
 * A为数组，n为数组的长度
 */
private static int[] shellSort(int[] A, int n) {
    Random random = new Random();
    // 步长
    int step = random.nextInt(n);
    sSort(A,step);
    return A;
}

/**
 * 
 * @param A
 * @param start
 *            数组起始位
 * @param end
 *            数组终止位
 */
public static void sSort(int[] A, int step) {
    // 当步长大于0时循环
    while (step &gt; 0) {
        for (int i = step; i &lt; A.length; i++) {
            int k = i;
            int temp = k - step;
            while (temp &gt;= 0) {
                if (A[k] &lt; A[temp]) {
                    int temp2 = A[k];
                    A[k] = A[temp];
                    A[temp] = temp2;
                    k = temp;
                }
                temp -= step;
            }
        }
        // 步长自减
        step--;
    }
}
</code></pre><h1 id="u8BA1_u6570_u6392_u5E8F"><a href="#u8BA1_u6570_u6392_u5E8F" class="headerlink" title="计数排序"></a>计数排序</h1><p>时间复杂度 O(N)；</p>
<pre><code>/**
 * 
 * @param A
 *            数组
 * @param n
 *            数组长度
 * @return
 */
private static int[] countingSort(int[] A, int n) {
    int temp = A[0];
    for (int i = 1;i&lt;n ;i++) {
        if(A[i]&gt;temp){
            temp = A[i];
        }
    }

    int[] count = new int[temp+1];

    for (int i = 0; i &lt; n; i++) {
        count[A[i]]++;
    }
    int[] result = new int[n];
    int length = 0;
    for (int i = 0; i &lt; count.length; i++) {
        while(count[i]&gt;0){
            result[length] = i;
            count[i]--;
            length++;
        }
    }
    return result;
}
</code></pre><h1 id="u57FA_u6570_u6392_u5E8F"><a href="#u57FA_u6570_u6392_u5E8F" class="headerlink" title="基数排序"></a>基数排序</h1><p>时间复杂度 O (nlog(r)m)，其中r为所采取的基数，而m为堆数;空间复杂度O(N)；稳定算法</p>
<pre><code>public static int[] radixSort(int[] A, int n) {

    int index = 0;
    for (int i = 1; i &lt; n; i++) {
        if (A[i] &gt; A[index]) {
            index = i;
        }
    }

    int temp = A[index];
    int count = 0;
    while (temp / 10 &gt; 0) {
        count++;
        temp /= 10;
    }
    count++;

    int[][] bucket = new int[10][n + 1];

    int temp1 = count;
    while (count &gt; 0) {

        for (int i = 0; i &lt; bucket.length; i++) {
            bucket[i][0] = 0;
        }

        for (int i = 0; i &lt; n; i++) {
            int num;
            if (temp1 - count == 0) {
                num = A[i] % 10;
            } else {
                int tt = (int) Math.pow(10, temp1 - count);
                num = (int) A[i] / tt % 10;
            }
            int length = bucket[num][0];
            bucket[num][length + 1] = A[i];
            length++;
            bucket[num][0] = length;
        }
        int length = 0;
        for (int i = 0; i &lt; 10; i++) {
            for (int j = 0; j &lt; bucket[i][0]; j++) {
                A[length] = bucket[i][j + 1];
                length++;
            }
        }
        count--;
    }
    return A;
}
</code></pre>]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u5192_u6CE1_u6392_u5E8F"><a href="#u5192_u6CE1_u6392_u5E8F" class="headerlink" title="冒泡排序"></a>冒泡排序</h1><p>冒泡排序的平均复杂度是O(N^2),最好的情况O]]>
    </summary>
    
      <category term="算法" scheme="http://yuqirong.me/tags/%E7%AE%97%E6%B3%95/"/>
    
      <category term="算法" scheme="http://yuqirong.me/categories/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[带你一步步实现可拖拽的GridView控件]]></title>
    <link href="http://yuqirong.me/2016/02/15/%E5%B8%A6%E4%BD%A0%E4%B8%80%E6%AD%A5%E6%AD%A5%E5%AE%9E%E7%8E%B0%E5%8F%AF%E6%8B%96%E6%8B%BD%E7%9A%84GridView%E6%8E%A7%E4%BB%B6/"/>
    <id>http://yuqirong.me/2016/02/15/带你一步步实现可拖拽的GridView控件/</id>
    <published>2016-02-15T12:46:17.000Z</published>
    <updated>2016-03-03T04:52:45.299Z</updated>
    <content type="html"><![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述"></p>
<p>是不是也想自己也想实现出相同的效果呢？那就一起来往下看吧。</p>
<p>首先我们来梳理一下思路：</p>
<ol>
<li>当用户长按选择一个item时，将该item隐藏，然后用WindowManager添加一个新的window，该window与所选择item一模一样，并且跟随用户手指滑动而不断改变位置。</li>
<li>当window的位置坐标在GridView里面时，使用<code>pointToPosition (int x, int y)</code>方法来判断对应的应该是哪个item，在adapter中作出数据集相应的变化，然后做出平移的动画。</li>
<li>当用户手指抬起时，把window移除，使用<code>notifyDataSetChanged()</code>做出GridView更新。</li>
</ol>
<p>讲完了思路后，我们就来实践一下吧，把这个控件取名为DragGridView。</p>
<pre><code>public DragGridView(Context context) {
    this(context, null);
}

public DragGridView(Context context, AttributeSet attrs) {
    this(context, attrs, 0);
}

public DragGridView(Context context, AttributeSet attrs, int defStyleAttr) {
    super(context, attrs, defStyleAttr);
    mWindowManager = (WindowManager) context.getSystemService(Context.WINDOW_SERVICE);
    setOnItemLongClickListener(this);
}
</code></pre><h1 id="u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6"><a href="#u624B_u6307_u5728Item_u4E0A_u957F_u6309_u65F6" class="headerlink" title="手指在Item上长按时"></a>手指在Item上长按时</h1><p>首先在构造器中得到WindowManager对象以及设置长按监听器，所以只有长按item才能拖拽。</p>
<pre><code>@Override
public boolean onInterceptTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            mWindowX = ev.getRawX();
            mWindowY = ev.getRawY();
            break;
        case MotionEvent.ACTION_MOVE:
            break;
        case MotionEvent.ACTION_UP:
            break;
    }
    return super.onInterceptTouchEvent(ev);
}
</code></pre><p>然后在<code>onInterceptTouchEvent(MotionEvent ev)</code>中得到手指下落时的<code>ev.getRawX()</code>和<code>ev.getRawY()</code>，以备后面的计算使用。至于<code>getRawX()</code>和<code>getX()</code>的区别这里就不再讲述了，如果有不懂的可以自行百度。</p>
<p>下面就是<code>onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id)</code>方法了，我们在DragGridView中定义了两种模式：<code>MODE_DRAG</code>和<code>MODE_NORMAL</code>，分别对应着item拖拽和item不拖拽：</p>
<pre><code>@Override
public boolean onItemLongClick(AdapterView&lt;?&gt; parent, View view, int position, long id) {
    if (mode == MODE_DRAG) {
        return false;
    }
    this.view = view;
    this.position = position;
    this.tempPosition = position;
    mX = mWindowX - view.getLeft() - this.getLeft();
    mY = mWindowY - view.getTop() - this.getTop();
    initWindow();
    return true;
}
</code></pre><p>在onItemLongClick()中先判断了一下模式，只有在<code>MODE_NORMAL</code>的情况下才会添加window。然后计算出mX和mY。可能有些童鞋在mX和mY的计算上看不懂，我给出了一个图示：</p>
<p><img src="/uploads/20160215/20160215210800.png" alt="这里写图片描述"></p>
<p>其中红点是手指按下的坐标，也就是(mWindowX,mWindowY)这个点；绿边框为DragGridView，因为DragGridView有可能会有margin值；所以this.getLeft()就是绿边框到屏幕的距离，而view.getLeft()就是长按的Item的左边到绿边框的距离。这几个值相减就得到了mX。同理，mY也是这样得到的。</p>
<p>然后来看看<code>initWindow();</code>这个方法：</p>
<pre><code>/**
 * 初始化window
 */
private void initWindow() {
    if (dragView == null) {
        dragView = View.inflate(getContext(), R.layout.drag_item, null);
        TextView tv_text = (TextView) dragView.findViewById(R.id.tv_text);
        tv_text.setText(((TextView) view.findViewById(R.id.tv_text)).getText());
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE;
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.gravity = Gravity.TOP | Gravity.LEFT;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.width = view.getWidth();
        layoutParams.height = view.getHeight();
        layoutParams.x = view.getLeft() + this.getLeft();  //悬浮窗X的位置
        layoutParams.y = view.getTop() + this.getTop();  //悬浮窗Y的位置
        view.setVisibility(INVISIBLE);
    }

    mWindowManager.addView(dragView, layoutParams);
    mode = MODE_DRAG;
}
</code></pre><p>在<code>initWindow()</code>中，我们先创建了一个dragView，而dragView里面的内容与长按的Item的内容完全一致。然后创建<code>WindowManager.LayoutParams</code>的对象，把dragView添加到window上去。同时，也要把长按的Item隐藏了。在这里别忘了需要申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot;/&gt;
</code></pre><h1 id="u624B_u6307_u6ED1_u52A8_u65F6"><a href="#u624B_u6307_u6ED1_u52A8_u65F6" class="headerlink" title="手指滑动时"></a>手指滑动时</h1><p>在<code>initWindow()</code>之后，我们就要考虑当手指滑动时window也要跟着动了，我们重写<code>onTouchEvent(MotionEvent ev)</code>来监听滑动事件，可以看到下面的<code>updateWindow(ev)</code>方法。</p>
<pre><code>@Override
public boolean onTouchEvent(MotionEvent ev) {
    switch (ev.getAction()) {
        case MotionEvent.ACTION_DOWN:
            break;
        case MotionEvent.ACTION_MOVE:
            if (mode == MODE_DRAG) {
                updateWindow(ev);
            }
            break;
        case MotionEvent.ACTION_UP:
            if (mode == MODE_DRAG) {
                closeWindow(ev.getX(), ev.getY());
            }
            break;
    }
    return super.onTouchEvent(ev);
}
</code></pre><p>这里贴出<code>updateWindow(ev)</code>方法：</p>
<pre><code>/**
 * 触摸移动时，window更新
 *
 * @param ev
 */
private void updateWindow(MotionEvent ev) {
    if (mode == MODE_DRAG) {
        float x = ev.getRawX() - mX;
        float y = ev.getRawY() - mY;
        if (layoutParams != null) {
            layoutParams.x = (int) x;
            layoutParams.y = (int) y;
            mWindowManager.updateViewLayout(dragView, layoutParams);
        }
        float mx = ev.getX();
        float my = ev.getY();
        int dropPosition = pointToPosition((int) mx, (int) my);
        Log.i(TAG, &quot;dropPosition : &quot; + dropPosition + &quot; , tempPosition : &quot; + tempPosition);
        if (dropPosition == tempPosition || dropPosition == GridView.INVALID_POSITION) {
            return;
        }
        itemMove(dropPosition);
    }
}
</code></pre><p>在这里，mX和mY就派上用场了。根据<code>ev.getRawX()</code>和<code>ev.getRawY()</code>分别减去<code>mX</code>和<code>mY</code>就得到了移动中layoutParams.x和layoutParams.y。再调用<code>updateViewLayout (View view, ViewGroup.LayoutParams params)</code>就出现了window跟随手指滑动而滑动的效果。最后根据 <code>pointToPosition(int x, int y)</code>返回的值来执行<code>itemMove(dropPosition);</code>。</p>
<pre><code>/**
 * 判断item移动，作出移动动画
 *
 * @param dropPosition
 */
private void itemMove(int dropPosition) {
    TranslateAnimation translateAnimation;
    // 移动的位置在原位置前面时
    if (dropPosition &lt; tempPosition) {
        for (int i = dropPosition; i &lt; tempPosition; i++) {
            View view = getChildAt(i);
            View nextView = getChildAt(i + 1);
            float xValue = (nextView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (nextView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == tempPosition - 1) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    } else {
        // 移动的位置在原位置后面时
        for (int i = tempPosition + 1; i &lt;= dropPosition; i++) {
            View view = getChildAt(i);
            View prevView = getChildAt(i - 1);
            float xValue = (prevView.getLeft() - view.getLeft()) * 1f / view.getWidth();
            float yValue = (prevView.getTop() - view.getTop()) * 1f / view.getHeight();
            translateAnimation =
                    new TranslateAnimation(Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, xValue, Animation.RELATIVE_TO_SELF, 0f, Animation.RELATIVE_TO_SELF, yValue);
            translateAnimation.setInterpolator(new LinearInterpolator());
            translateAnimation.setFillAfter(true);
            translateAnimation.setDuration(300);
            if (i == dropPosition) {
                translateAnimation.setAnimationListener(animationListener);
            }
            view.startAnimation(translateAnimation);
        }
    }
    tempPosition = dropPosition;
}

/**
 * 动画监听器
 */
Animation.AnimationListener animationListener = new Animation.AnimationListener() {
    @Override
    public void onAnimationStart(Animation animation) {

    }

    @Override
    public void onAnimationEnd(Animation animation) {
        // 在动画完成时将adapter里的数据交换位置
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, true);
        }
        position = tempPosition;
    }

    @Override
    public void onAnimationRepeat(Animation animation) {

    }
};
</code></pre><p>上面的代码主要是根据dropPosition使要改变位置的Item来做出平移动画，当最后一个要改变位置的Item平移动画完成之后，在adapter中完成数据集的交换。</p>
<pre><code>/**
 * 给item交换位置
 *
 * @param originalPosition item原先位置
 * @param nowPosition      item现在位置
 */
public void exchangePosition(int originalPosition, int nowPosition, boolean isMove) {
    T t = list.get(originalPosition);
    list.remove(originalPosition);
    list.add(nowPosition, t);
    movePosition = nowPosition;
    this.isMove = isMove;
    notifyDataSetChanged();
}

@Override
public View getView(int position, View convertView, ViewGroup parent) {
    Log.i(TAG, &quot;-------------------------------&quot;);
    for (T t : list){
        Log.i(TAG, t.toString());
    }
    View view = getItemView(position, convertView, parent);
    if (position == movePosition &amp;&amp; isMove) {
        view.setVisibility(View.INVISIBLE);
    }
    return view;
}
</code></pre><h1 id="u624B_u6307_u62AC_u8D77_u65F6"><a href="#u624B_u6307_u62AC_u8D77_u65F6" class="headerlink" title="手指抬起时"></a>手指抬起时</h1><p>在上面<code>onTouchEvent(MotionEvent ev)</code>方法中，可以看到手指抬起时调用了<code>closeWindow(ev.getX(), ev.getY());</code>，那就一起来看看：</p>
<pre><code> /**
 * 关闭window
 *
 * @param x
 * @param y
 */
private void closeWindow(float x, float y) {
    if (dragView != null) {
        mWindowManager.removeView(dragView);
        dragView = null;
        layoutParams = null;
    }
    itemDrop();
    mode = MODE_NORMAL;
}

/**
 * 手指抬起时，item下落
 */
private void itemDrop() {
    if (tempPosition == position || tempPosition == GridView.INVALID_POSITION) {
        getChildAt(position).setVisibility(VISIBLE);
    } else {
        ListAdapter adapter = getAdapter();
        if (adapter != null &amp;&amp; adapter instanceof DragGridAdapter) {
            ((DragGridAdapter) adapter).exchangePosition(position, tempPosition, false);
        }
    }
}
</code></pre><p>可以看出主要做的事情就是移除了window，并且也是调用了<code>exchangePosition(int originalPosition, int nowPosition, boolean isMove)</code>，不同的是第三个参数isMove传入了false，这样所有的Item都显示出来了。</p>
<p>讲了这么多，来看看最后的效果吧：</p>
<p><img src="/uploads/20160215/20160215212234.gif" alt="这里写图片描述"></p>
<p>和网易新闻的效果不相上下吧，完整的源码太长就不贴出了，下面提供源码下载：</p>
<p><a href="/uploads/20160215/DragGridView-master.rar">DragGridView.rar</a></p>
<p>GitHub：</p>
<p><a href="https://github.com/yuqirong/DragGridView" target="_blank" rel="external">DragGridView</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>经常使用网易新闻的童鞋都知道在网易新闻中有一个新闻栏目管理，其中GridView的item是可以拖拽的，效果十分炫酷。具体效果如下图：</p>
<p><img src="/uploads/20160215/20160215203853.gif" alt="这里写图片描述">]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[在AlertDialog中EditText无法弹出键盘的解决方案]]></title>
    <link href="http://yuqirong.me/2016/02/06/%E5%9C%A8AlertDialog%E4%B8%ADEditText%E6%97%A0%E6%B3%95%E5%BC%B9%E5%87%BA%E9%94%AE%E7%9B%98%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/"/>
    <id>http://yuqirong.me/2016/02/06/在AlertDialog中EditText无法弹出键盘的解决方案/</id>
    <published>2016-02-06T06:54:11.000Z</published>
    <updated>2016-03-02T11:34:38.470Z</updated>
    <content type="html"><![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这个问题。这次算是填了一个隐藏的坑。</p>
<p>例如下面给出了一个例子，首先贴上AlertDialog的<code>layout.xml</code>：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;200dp&quot;
    android:background=&quot;@android:color/white&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;Hello friend!&quot;/&gt;

    &lt;EditText
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:hint=&quot;input content&quot; /&gt;

    &lt;Button
        android:layout_width=&quot;wrap_content&quot;
        android:layout_height=&quot;wrap_content&quot;
        android:text=&quot;submit&quot;/&gt;

&lt;/LinearLayout&gt;
</code></pre><p>AlertDialog的效果图是这样的：</p>
<p><img src="/uploads/20160206/20160206160310.png" alt="这里填写图片的描述"></p>
<p>我们会发现无论怎么点击EditText也无法弹出键盘，其实我们只要加上<code>alertDialog.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE|WindowManager.LayoutParams.FLAG_ALT_FOCUSABLE_IM);</code>这一句，就可以让键盘弹出了。</p>
<p><img src="/uploads/20160206/20160206161311.png" alt="这里填写图片的描述"></p>
<p>源码下载：</p>
<p><a href="/uploads/20160206/AlertDialogDemo.rar">AlertDialogDemo.rar</a></p>
<p>StackOverFlow：</p>
<p><a href="http://stackoverflow.com/questions/9102074/android-edittext-in-dialog-doesnt-pull-up-soft-keyboard" target="_blank" rel="external">Android: EditText in Dialog doesn’t pull up soft keyboard</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>之前在做项目的过程中，有一个需求就是在AlertDialog中有EditText，可以在EditText中输入内容。但是在实际开发的过程中却发现，点击EditText却始终无法弹出键盘。因为之前在使用AlertDialog的时候，布局中并没有EditText，因此没有发现这]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对LayoutInflater的深入解析]]></title>
    <link href="http://yuqirong.me/2016/02/03/%E5%AF%B9LayoutInflater%E7%9A%84%E6%B7%B1%E5%85%A5%E8%A7%A3%E6%9E%90/"/>
    <id>http://yuqirong.me/2016/02/03/对LayoutInflater的深入解析/</id>
    <published>2016-02-03T11:19:12.000Z</published>
    <updated>2016-03-02T11:28:20.568Z</updated>
    <content type="html"><![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身影。比如说在Fragment的<code>onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)</code>方法里，就需要我们返回Fragment的View。这时就可以用<code>inflater.inflate(R.layout.fragment_view, container, false)</code>来加载视图。那么下面就来探究一下LayoutInflater的真面目吧。</p>
<h1 id="from_28Context_context_29"><a href="#from_28Context_context_29" class="headerlink" title="from(Context context)"></a>from(Context context)</h1><p>首先我们在使用LayoutInflater时，通常用<code>LayoutInflater.from(Context context)</code>这个方法来得到其对象：</p>
<pre><code>/**
 * Obtains the LayoutInflater from the given context.
 */
public static LayoutInflater from(Context context) {
    LayoutInflater LayoutInflater =
            (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
    if (LayoutInflater == null) {
        throw new AssertionError(&quot;LayoutInflater not found.&quot;);
    }
    return LayoutInflater;
}
</code></pre><p>我们可以看到原来<code>from(Context context)</code>这个方法只不过把<code>context.getSystemService(Context.LAYOUT_INFLATER_SERVICE)</code>进行简单地封装了一下，方便开发者调用。相信大家都看得懂。</p>
<h1 id="inflate_28_u2026_29"><a href="#inflate_28_u2026_29" class="headerlink" title="inflate(…)"></a>inflate(…)</h1><p>在得到了LayoutInflater的对象之后，我们就要使用它的inflate()方法了。</p>
<p><img src="/uploads/20160203/20160203183605.png" alt="这里填写图片的描述"></p>
<p>可以看到inflate()有四个重载的方法。我们先来看看前三个的源码：</p>
<pre><code>public View inflate(@LayoutRes int resource, @Nullable ViewGroup root) {
    return inflate(resource, root, root != null);
}

public View inflate(XmlPullParser parser, @Nullable ViewGroup root) {
    return inflate(parser, root, root != null);
}

public View inflate(@LayoutRes int resource, @Nullable ViewGroup root, boolean attachToRoot) {
    final Resources res = getContext().getResources();
    if (DEBUG) {
        Log.d(TAG, &quot;INFLATING from resource: \&quot;&quot; + res.getResourceName(resource) + &quot;\&quot; (&quot;
                + Integer.toHexString(resource) + &quot;)&quot;);
    }

    final XmlResourceParser parser = res.getLayout(resource);
    try {
        return inflate(parser, root, attachToRoot);
    } finally {
        parser.close();
    }
}
</code></pre><p>看到这里，我们都明白了，前三个inflate()方法到最后都是调用了<code>inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot)</code>这个方法。原来第四个inflate()方法才是“幕后黑手”。那让我们来揭开它的黑纱吧：</p>
<pre><code>public View inflate(XmlPullParser parser, @Nullable ViewGroup root, boolean attachToRoot) {
    synchronized (mConstructorArgs) {
        Trace.traceBegin(Trace.TRACE_TAG_VIEW, &quot;inflate&quot;);

        final Context inflaterContext = mContext;
        final AttributeSet attrs = Xml.asAttributeSet(parser);
        Context lastContext = (Context) mConstructorArgs[0];
        mConstructorArgs[0] = inflaterContext;
        View result = root;

        try {
            // Look for the root node.
            int type;
            while ((type = parser.next()) != XmlPullParser.START_TAG &amp;&amp;
                    type != XmlPullParser.END_DOCUMENT) {
                // Empty
            }

            if (type != XmlPullParser.START_TAG) {
                throw new InflateException(parser.getPositionDescription()
                        + &quot;: No start tag found!&quot;);
            }

            final String name = parser.getName();

            if (DEBUG) {
                System.out.println(&quot;**************************&quot;);
                System.out.println(&quot;Creating root view: &quot;
                        + name);
                System.out.println(&quot;**************************&quot;);
            }

            if (TAG_MERGE.equals(name)) {
                if (root == null || !attachToRoot) {
                    throw new InflateException(&quot;&lt;merge /&gt; can be used only with a valid &quot;
                            + &quot;ViewGroup root and attachToRoot=true&quot;);
                }

                rInflate(parser, root, inflaterContext, attrs, false);
            } else {
                // Temp is the root view that was found in the xml
                final View temp = createViewFromTag(root, name, inflaterContext, attrs);

                ViewGroup.LayoutParams params = null;

                if (root != null) {
                    if (DEBUG) {
                        System.out.println(&quot;Creating params from root: &quot; +
                                root);
                    }
                    // Create layout params that match root, if supplied
                    params = root.generateLayoutParams(attrs);
                    if (!attachToRoot) {
                        // Set the layout params for temp if we are not
                        // attaching. (If we are, we use addView, below)
                        temp.setLayoutParams(params);
                    }
                }

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; start inflating children&quot;);
                }

                // Inflate all children under temp against its context.
                rInflateChildren(parser, temp, attrs, true);

                if (DEBUG) {
                    System.out.println(&quot;-----&gt; done inflating children&quot;);
                }

                // We are supposed to attach all the views we found (int temp)
                // to root. Do that now.
                if (root != null &amp;&amp; attachToRoot) {
                    root.addView(temp, params);
                }

                // Decide whether to return the root that was passed in or the
                // top view found in xml.
                if (root == null || !attachToRoot) {
                    result = temp;
                }
            }

        } catch (XmlPullParserException e) {
            InflateException ex = new InflateException(e.getMessage());
            ex.initCause(e);
            throw ex;
        } catch (Exception e) {
            InflateException ex = new InflateException(
                    parser.getPositionDescription()
                            + &quot;: &quot; + e.getMessage());
            ex.initCause(e);
            throw ex;
        } finally {
            // Don&apos;t retain static reference on context.
            mConstructorArgs[0] = lastContext;
            mConstructorArgs[1] = null;
        }

        Trace.traceEnd(Trace.TRACE_TAG_VIEW);

        return result;
    }
}
</code></pre><p>这段代码有点长，不过别担心，我们慢慢来看。首先把传入的<code>parser</code>进行解析，创建视图。其中我们可以注意到在Android的源码中是用Pull方式来解析xml得到视图的。接下来判断了传入的<code>root</code>是否为null，如果<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，<code>temp.setLayoutParams(params);</code>。也就是说把创建出来的视图的LayoutParams设置为params。那么params又是从哪里来的呢？可以在上面一行可以找到<code>params = root.generateLayoutParams(attrs);</code>我们来看看源码：</p>
<pre><code> public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new LayoutParams(getContext(), attrs);
}
</code></pre><p>也就是说，在<code>root</code>不为null并且<code>attachToRoot</code>为false的情况下，把<code>root</code>的LayoutParams设置给了新创建出来的View。</p>
<p>好了，再往下看，我们注意到了<code>root</code>不为null并且<code>attachToRoot</code>为true的情况。调用了<code>root.addView(temp, params);</code>，在其内部就是将temp添加进了root中。即最后得到的View的父布局就是root。</p>
<p>最后一个情况就是<code>(root == null || !attachToRoot)</code>时，直接返回了temp。</p>
<h1 id="u603B_u7ED3"><a href="#u603B_u7ED3" class="headerlink" title="总结"></a>总结</h1><p>到这里，关于LayoutInflater的讲解就差不多了，最后我们就来总结一下：</p>
<ul>
<li>在root!=null并且attachToRoot为false：将root的LayoutParams设置给了View。</li>
<li>在root!=null并且attachToRoot为true：把root作为View的父布局。</li>
<li>在root==null时：直接返回View，无视attachToRoot的状态。</li>
</ul>
<p>今天就到这，如有问题可以在下面留言。</p>
<p>~have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<h1 id="u524D_u8A00"><a href="#u524D_u8A00" class="headerlink" title="前言"></a>前言</h1><p>今天要讲的主角就是LayoutInflater，相信大家都用过吧。在动态地加载布局时，经常可以看见它的身]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="源码解析" scheme="http://yuqirong.me/tags/%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[自定义ViewGroup打造流式布局]]></title>
    <link href="http://yuqirong.me/2016/01/22/%E8%87%AA%E5%AE%9A%E4%B9%89ViewGroup%E6%89%93%E9%80%A0%E6%B5%81%E5%BC%8F%E5%B8%83%E5%B1%80/"/>
    <id>http://yuqirong.me/2016/01/22/自定义ViewGroup打造流式布局/</id>
    <published>2016-01-22T12:31:37.000Z</published>
    <updated>2016-02-24T14:15:31.817Z</updated>
    <content type="html"><![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/details/38352503" target="_blank" rel="external">《Android 自定义ViewGroup 实战篇 -&gt; 实现FlowLayout》</a>，觉得文中的FlowLayout很多地方都可以用到。于是自己按照思路实现了一遍，这就是本片博文诞生的原因了。</p>
<p>首先流式布局相信大家都见到过，比如说下图中的京东热搜就是流式布局的应用。还有更多应用的地方在这里就不一一举例了。</p>
<p><img src="/uploads/20160222/20160222205447.png" alt="这里写图片描述"></p>
<p>下面我们就来看看是如何实现的。首先新建一个class，继承自ViewGroup。在<code>generateLayoutParams(AttributeSet attrs)</code>里直接返回MarginLayoutParams就行了。</p>
<pre><code> @Override
public LayoutParams generateLayoutParams(AttributeSet attrs) {
    return new MarginLayoutParams(getContext(), attrs);
}
</code></pre><p>然后就是<code>onLayout(boolean changed, int l, int t, int r, int b)</code>了，大部分的代码都添加了注释，相信大家都能看懂。</p>
<pre><code>@Override
protected void onLayout(boolean changed, int l, int t, int r, int b) {
    int count = getChildCount();
    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    // 用来统计总宽度，初始值设为paddingLeft
    int lastWidth = getPaddingLeft();
    int lastHeight = getPaddingTop();

    for (int i = 0; i &lt; count; i++) {
        // 得到当前View
        View childView = getChildAt(i);
        // 测量得到当前View的宽度
        cWidth = childView.getMeasuredWidth();
        // 测量得到当前View的高度
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();
        // 宽度加上margin
        int width = cWidth + params.leftMargin + params.rightMargin;
        // 高度加上margin
        int height = cHeight + params.topMargin + params.bottomMargin;
        // 判断流式布局里的item总长度是否超过FlowLayout的宽度，如果是则需要换行  
        if (width + lastWidth &gt; r - getPaddingRight()) {
            // 如果超过，重置lastWidth
            lastWidth = getPaddingLeft();
            // lastHeight加上一个item的高度
            lastHeight += height;
        }
        // 给View布局
        childView.layout(lastWidth, lastHeight, lastWidth + cWidth, lastHeight + cHeight);
        //累加总宽度
        lastWidth += width;
    }
}
</code></pre><p>之后就是<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>。</p>
<pre><code>@Override
protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
    int widthSize = MeasureSpec.getSize(widthMeasureSpec);
    int widthMode = MeasureSpec.getMode(widthMeasureSpec);

    int heightSize = MeasureSpec.getSize(heightMeasureSpec);
    int heightMode = MeasureSpec.getMode(heightMeasureSpec);

    int totalWidth = getPaddingLeft() + getPaddingRight();
    int maxWidth = getPaddingLeft() + getPaddingRight();
    int maxHeight = getPaddingBottom() + getPaddingTop();
    int count = getChildCount();
    // 测量子view
    measureChildren(widthMeasureSpec, heightMeasureSpec);

    int cWidth;
    int cHeight;
    MarginLayoutParams params;
    int width;
    int height;
    for (int i = 0; i &lt; count; i++) {
        View childView = getChildAt(i);
        cWidth = childView.getMeasuredWidth();
        cHeight = childView.getMeasuredHeight();
        params = (MarginLayoutParams) childView.getLayoutParams();

        width = cWidth + params.leftMargin + params.rightMargin;
        height = cHeight + params.topMargin + params.bottomMargin;

        if (i == 0) {
            // 第一行时最大高度设为height
            maxHeight += height;
        }

        // 如果需要换行
        if (width + totalWidth &gt; widthSize) {
            // 得到最大的值作为setMeasuredDimension()的宽度
            maxWidth = Math.max(maxWidth, totalWidth);
            totalWidth = getPaddingLeft() + getPaddingRight();
            totalWidth += width;
            // 高度就是累加到最后
            maxHeight += height;
        } else {
            // 不换行就总长度累加
            totalWidth += width;
        }
        Log.i(TAG, &quot;i = &quot; + i + &quot;, width = &quot; + width + &quot;, totalWidth = &quot; + totalWidth + &quot;, widthSize = &quot; + widthSize + ((TextView) childView).getText());
        Log.i(TAG, &quot;height = &quot; + height);
        Log.i(TAG, &quot;i = &quot; + i + &quot;, maxHeight = &quot; + maxHeight);

    }
    // 设置宽高度
    setMeasuredDimension(widthMode == MeasureSpec.EXACTLY ? widthSize : maxWidth,
            heightMode == MeasureSpec.EXACTLY ? heightSize : maxHeight);

}
</code></pre><p>在<code>onMeasure(int widthMeasureSpec, int heightMeasureSpec)</code>中，如果测量模式是MeasureSpec.EXACTLY，则直接设置测量出来的宽和高；否则需要测量每个子View，根据item的行数来得到宽和高。</p>
<p>这样，FlowLayout就写好了，那就让我们来看看效果吧。当<code>android:layout_width=&quot;wrap_content&quot;</code>时</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;wrap_content&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220305.png" alt="这里写图片描述"></p>
<p>当<code>android:layout_width=&quot;300dp&quot;</code>时：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;com.yuqirong.viewgroup.view.FlowLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    xmlns:tools=&quot;http://schemas.android.com/tools&quot;
    android:layout_width=&quot;300dp&quot;
    android:layout_height=&quot;wrap_content&quot;
    android:background=&quot;#ddd&quot;
    android:padding=&quot;20dp&quot;&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;杭州&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;哈尔滨&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;宁波&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;呼和浩特&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;上海&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;北京&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;重庆&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;南昌&quot; /&gt;

    &lt;TextView
        style=&quot;@style/text_flag_01&quot;
        android:text=&quot;苏州&quot; /&gt;

&lt;/com.yuqirong.viewgroup.view.FlowLayout&gt;
</code></pre><p>运行的效果图：</p>
<p><img src="/uploads/20160222/20160122220718.png" alt="这里写图片描述"></p>
<p>最后，提供源码下载：</p>
<p><a href="/uploads/20160222/FlowLayout.rar">FlowLayout.rar</a></p>
]]></content>
    <summary type="html">
    <![CDATA[<p>前几天看了<a href="http://my.csdn.net/lmj623565791" target="_blank" rel="external">鸿洋_</a>的<a href="http://blog.csdn.net/lmj623565791/article/]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="自定义View" scheme="http://yuqirong.me/tags/%E8%87%AA%E5%AE%9A%E4%B9%89View/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[实现导航Tab栏悬浮功能之改进版]]></title>
    <link href="http://yuqirong.me/2016/01/14/%E5%AE%9E%E7%8E%B0%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD%E4%B9%8B%E6%94%B9%E8%BF%9B%E7%89%88/"/>
    <id>http://yuqirong.me/2016/01/14/实现导航Tab栏悬浮功能之改进版/</id>
    <published>2016-01-14T12:34:25.000Z</published>
    <updated>2016-02-24T14:16:17.719Z</updated>
    <content type="html"><![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/">《轻松实现app中的导航Tab栏悬浮功能》</a>。</p>
<p>当然，用WindowManager来实现由一个缺点就是当没有显示悬浮窗的权限时，该功能就无法体现出来。而在本篇博文中，我们用第二种方法，也就是不断地重新设置Tab栏的布局位置来实现悬浮功能，弥补了第一种方法的缺点。效果图这里就不放了，相信大家都看过啦。</p>
<p>不废话了，直接上代码。</p>
<p>activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_main&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;55dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>我们发现在activity_main.xml里Tab栏悬浮窗的布局放在了最后，这是因为当悬浮窗悬浮在顶部时，应该在所有的UI控件上方，所以在xml里放在了最后。</p>
<p>接下来看看MainActivity：</p>
<pre><code>public class MainActivity extends AppCompatActivity implements MyScrollView.OnScrollListener {

    private static final String TAG = &quot;MainActivity&quot;;
    private MyScrollView mScrollView;
    private LinearLayout ll_tab;
    private ImageView iv_pic;
    private int picBottom;

    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
        getSupportActionBar().hide();
        mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
        mScrollView.setOnScrollListener(this);
        ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
        iv_pic = (ImageView) findViewById(R.id.iv_pic);
        findViewById(R.id.ll_main).getViewTreeObserver().addOnGlobalLayoutListener(new ViewTreeObserver.OnGlobalLayoutListener() {
            @Override
            public void onGlobalLayout() {
                onScroll(mScrollView.getScrollY());
            }
        });
    }

    @Override
    public void onWindowFocusChanged(boolean hasFocus) {
        super.onWindowFocusChanged(hasFocus);
        if (hasFocus) {
            picBottom = iv_pic.getBottom();
        }
    }

    @Override
    public void onScroll(int scrollY) {
        int top = Math.max(scrollY, picBottom);
        ll_tab.layout(0, top, ll_tab.getWidth(), top + ll_tab.getHeight());
    }

}
</code></pre><p>我们惊奇地发现在Activity里的代码竟然这么短！但是这是这么短，实现了一模一样的功能。</p>
<p>首先在父布局中添加了OnGlobalLayoutListener，以便当布局的状态或者控件的可见性改变时去重新设置Tab栏的布局。之后在<code>onWindowFocusChanged(boolean hasFocus)</code>里得到<code>iv_pic.getBottom()</code>的值，也就是<code>iv_pic</code>的高度。也就是说你一开始想把<code>ll_tab</code>布局在<code>iv_pic</code>的下面。因此可以当作Tab栏距离ScrollView顶部的距离。</p>
<p>最后在<code>onScroll(int scrollY)</code>中比较scrollY，picBottom的最大值。当<code>scrollY&lt;picBottom</code>时，<code>ll_tab</code>会跟随ScrollView的滑动而滑动；当<code>scrollY&gt;picBottom</code>时，<code>ll_tab</code>布局的顶部的坐标始终是ScrollView的滑动距离，这样就造成了<code>ll_tab</code>悬浮在顶部的“假象”。</p>
<p>好了，一起来看看效果吧：</p>
<p><img src="/uploads/20160114/20160114223247.gif" alt="这里填写图片的描述"></p>
<p>是不是和第一种方法的效果一样呢，相信大家都学会了。如果有问题可以在下面留言。</p>
<p>最后，放出源码：</p>
<p><a href="/uploads/20160114/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>~have fun!~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在上一篇博文中，我们用WindowManager的方法实现了Tab栏的悬浮功能。如果你没有看过上篇博文，请点击<a href="/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[轻松实现app中的导航Tab栏悬浮功能]]></title>
    <link href="http://yuqirong.me/2016/01/12/%E8%BD%BB%E6%9D%BE%E5%AE%9E%E7%8E%B0app%E4%B8%AD%E7%9A%84%E5%AF%BC%E8%88%AATab%E6%A0%8F%E6%82%AC%E6%B5%AE%E5%8A%9F%E8%83%BD/"/>
    <id>http://yuqirong.me/2016/01/12/轻松实现app中的导航Tab栏悬浮功能/</id>
    <published>2016-01-12T13:59:29.000Z</published>
    <updated>2016-02-22T12:45:22.651Z</updated>
    <content type="html"><![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160112/20160112210653.gif" alt="这里填写图片的描述"></p>
<p>可以看到上图中的“分类”、“排序”、“筛选”会悬浮在app的顶部，状态随着ScrollView(也可能不是ScrollView，在这里姑且把这滑动的UI控件当作ScrollView吧)的滚动而变化。像这种导航Tab栏悬浮的作用相信大家都能体会到，Tab栏不会随着ScrollView等的滚动而被滑出屏幕外，增加了与用户之间的交互性和方便性。</p>
<p>看到上面的效果，相信大家都跃跃欲试了，那就让我们开始吧。</p>
<p>首先大家要明白一点：Tab栏的状态变化是要监听ScrollView滑动距离的。至于如何得到ScrollView的滑动距离？可以看看我的一篇Tip：<a href="/2015/10/19/给你的ScrollView设置滑动距离监听器/">《给你的ScrollView设置滑动距离监听器》</a>，这里就不过多叙述了。</p>
<p>好了，根据上面的就得到了对ScrollView滑动的监听了。接下来要思考的问题就是如何让Tab栏实现悬浮的效果呢？这里给出的方法有两种，第一种就是使用WindowManager来动态地添加一个View悬浮在顶部；第二种就是随着ScrollView的滑动不断重新设置Tab栏的布局位置。</p>
<p>我们先来看看第一种实现方法，首先是xml布局了。</p>
<p>Activity的布局，activity_main.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;

    &lt;RelativeLayout
        android:id=&quot;@+id/rl_title&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;50dp&quot;
        android:background=&quot;@color/colorPrimary&quot;&gt;

        &lt;ImageView
            android:id=&quot;@+id/iv_back&quot;
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerVertical=&quot;true&quot;
            android:layout_marginLeft=&quot;10dp&quot;
            android:src=&quot;@drawable/new_img_back&quot; /&gt;

        &lt;TextView
            android:layout_width=&quot;wrap_content&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:layout_centerInParent=&quot;true&quot;
            android:text=&quot;@string/app_name&quot;
            android:textColor=&quot;@android:color/white&quot;
            android:textSize=&quot;18sp&quot; /&gt;

    &lt;/RelativeLayout&gt;

    &lt;com.yuqirong.tabsuspenddemo.view.MyScrollView
        android:id=&quot;@+id/mScrollView&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;match_parent&quot;&gt;

        &lt;LinearLayout
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:background=&quot;#cccccc&quot;
            android:orientation=&quot;vertical&quot;&gt;

            &lt;ImageView
                android:id=&quot;@+id/iv_pic&quot;
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;180dp&quot;
                android:scaleType=&quot;centerCrop&quot;
                android:src=&quot;@drawable/ic_bg_personal_page&quot; /&gt;

            &lt;include layout=&quot;@layout/tab_layout&quot; /&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;


            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

            &lt;LinearLayout
                android:layout_width=&quot;match_parent&quot;
                android:layout_height=&quot;90dp&quot;
                android:layout_marginBottom=&quot;5dp&quot;
                android:layout_marginLeft=&quot;15dp&quot;
                android:layout_marginRight=&quot;15dp&quot;
                android:layout_marginTop=&quot;15dp&quot;
                android:background=&quot;@android:color/white&quot;
                android:orientation=&quot;horizontal&quot;&gt;

            &lt;/LinearLayout&gt;

        &lt;/LinearLayout&gt;
    &lt;/com.yuqirong.tabsuspenddemo.view.MyScrollView&gt;
&lt;/LinearLayout&gt;
</code></pre><p>Tab栏的布局，tab_layout.xml：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:id=&quot;@+id/ll_tab&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;40dp&quot;
    android:background=&quot;@color/colorPrimary&quot;
    android:orientation=&quot;horizontal&quot;&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;分类&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;排序&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

    &lt;TextView
        android:layout_width=&quot;0dp&quot;
        android:layout_height=&quot;match_parent&quot;
        android:layout_weight=&quot;1&quot;
        android:gravity=&quot;center&quot;
        android:text=&quot;筛选&quot;
        android:textColor=&quot;@android:color/white&quot;
        android:textSize=&quot;18sp&quot; /&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面布局中的很多空白LinearLayout主要是拉长ScrollView，效果图就是这样的：</p>
<p><img src="/uploads/20160112/20160112201753.png" alt="这里填写图片的描述"></p>
<p>然后我们来看看<code>onCreate(Bundle savedInstanceState)</code>：</p>
<pre><code>@Override
protected void onCreate(Bundle savedInstanceState) {
    super.onCreate(savedInstanceState);
    getSupportActionBar().hide();
    setContentView(R.layout.activity_main);
    mScrollView = (MyScrollView) findViewById(R.id.mScrollView);
    mScrollView.setOnScrollListener(this);
    ll_tab = (LinearLayout) findViewById(R.id.ll_tab);
    windowManager = (WindowManager) getSystemService(Context.WINDOW_SERVICE);
}
</code></pre><p>我们先在<code>onCreate(Bundle savedInstanceState)</code>中给ScrollView添加了滑动距离监听器以及得到了一个windowManager的对象。还有一点需要注意的是：我们调用了<code>getSupportActionBar().hide();</code>去掉了标题栏(MainActivity继承了AppCompatActivity)。这是因为标题栏的存在导致了在计算悬浮窗y轴的值时要额外加上标题栏的高度(当然你也可以保留标题栏，然后计算时再加上标题栏的高度^_^!)。</p>
<p>然后在onWindowFocusChanged(boolean hasFocus)得到Tab栏的高度、getTop()值等，以便下面备用。如果你对getLeft()、getTop()、getRight()和getBottom()还不了解的话，可以看看我的另一篇Tip： <a href="/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/">《对view的getLeft()、getTop()等的笔记》</a>。</p>
<pre><code>@Override
public void onWindowFocusChanged(boolean hasFocus) {
    super.onWindowFocusChanged(hasFocus);
    if (hasFocus) {
        tabHeight = ll_tab.getHeight();
        tabTop = ll_tab.getTop();
        scrollTop = mScrollView.getTop();
    }
}
</code></pre><p>之后在滑动监听器的回调方法<code>onScroll(int scrollY)</code>中来控制显示还是隐藏悬浮窗。</p>
<pre><code> @Override
public void onScroll(int scrollY) {
    Log.i(TAG, &quot;scrollY = &quot; + scrollY + &quot;, tabTop = &quot; + tabTop);
    if (scrollY &gt; tabTop) {
        // 如果没显示
        if (!isShowWindow) {
            showWindow();
        }
    } else {
        // 如果显示了
        if (isShowWindow) {
            removeWindow();
        }
    }
}
</code></pre><p>上面的代码比较简单，不用我过多叙述了。下面是removeWindow()、showWindow()两个方法：</p>
<pre><code>// 显示window
private void removeWindow() {
    if (ll_tab_temp != null)
        windowManager.removeView(ll_tab_temp);
    isShowWindow = false;
}

// 移除window
private void showWindow() {
    if (ll_tab_temp == null) {
        ll_tab_temp = LayoutInflater.from(this).inflate(R.layout.tab_layout, null);
    }
    if (layoutParams == null) {
        layoutParams = new WindowManager.LayoutParams();
        layoutParams.type = WindowManager.LayoutParams.TYPE_PHONE; //悬浮窗的类型，一般设为2002，表示在所有应用程序之上，但在状态栏之下
        layoutParams.format = PixelFormat.RGBA_8888;
        layoutParams.flags = WindowManager.LayoutParams.FLAG_NOT_TOUCH_MODAL
                | WindowManager.LayoutParams.FLAG_NOT_FOCUSABLE;  //悬浮窗的行为，比如说不可聚焦，非模态对话框等等
        layoutParams.gravity = Gravity.TOP;  //悬浮窗的对齐方式
        layoutParams.width = WindowManager.LayoutParams.MATCH_PARENT;
        layoutParams.height = tabHeight;
        layoutParams.x = 0;  //悬浮窗X的位置
        layoutParams.y = scrollTop;  //悬浮窗Y的位置
    }
    windowManager.addView(ll_tab_temp, layoutParams);
    isShowWindow = true;
}
</code></pre><p>这两个方法也很简单，而且有注释，相信大家可以看懂。</p>
<p>最后，不要忘了在AndroidManifest.xml里申请显示悬浮窗的权限：</p>
<pre><code>&lt;uses-permission android:name=&quot;android.permission.SYSTEM_ALERT_WINDOW&quot; /&gt;
</code></pre><p>到这里，整体的代码就这些了。一起来看看效果吧：</p>
<p><img src="/uploads/20160112/20160112204356.gif" alt="这里填写图片的描述"></p>
<p>但是用这种方法来实现Tab栏悬浮功能有一个缺点，那就是如果该app没有被赋予显示悬浮窗的权限，那么该功能就变成鸡肋了。当然还有第二种方法来实现，不过只能等到下一篇博文再讲了。</p>
<p>本Demo源码下载：</p>
<p><a href="/uploads/20160112/TabSuspendDemo.rar">TabSuspendDemo.rar</a></p>
<p>have a nice day~</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>又到了更博的时间了，今天给大家带来的就是“导航Tab栏悬浮功能”了。通常大家在玩手机的过程中应该会注意到很多的app都有这种功能，比如说外卖达人常用的“饿了么”。下面就给出了“饿了么”导航Tab栏悬浮的效果图。</p>
<p><img src="/uploads/20160]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Blog" scheme="http://yuqirong.me/categories/Android-Blog/"/>
    
  </entry>
  
  <entry>
    <title><![CDATA[对view的getLeft()、getTop()等的笔记]]></title>
    <link href="http://yuqirong.me/2016/01/05/%E5%AF%B9view%E7%9A%84getLeft()%E3%80%81getTop()%E7%AD%89%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
    <id>http://yuqirong.me/2016/01/05/对view的getLeft()、getTop()等的笔记/</id>
    <published>2016-01-05T12:01:48.000Z</published>
    <updated>2016-02-19T14:24:47.890Z</updated>
    <content type="html"><![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;LinearLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot;
    android:layout_width=&quot;match_parent&quot;
    android:layout_height=&quot;match_parent&quot;
    android:orientation=&quot;vertical&quot;&gt;


    &lt;LinearLayout
        android:id=&quot;@+id/ll_01&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_green_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_01&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第一行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

    &lt;LinearLayout
        android:id=&quot;@+id/ll_02&quot;
        android:layout_width=&quot;match_parent&quot;
        android:layout_height=&quot;60dp&quot;
        android:orientation=&quot;vertical&quot;
        android:background=&quot;@android:color/holo_blue_light&quot;&gt;

        &lt;TextView
            android:id=&quot;@+id/tv_02&quot;
            android:layout_width=&quot;match_parent&quot;
            android:layout_height=&quot;wrap_content&quot;
            android:text=&quot;我是第二行文字&quot; /&gt;
    &lt;/LinearLayout&gt;

&lt;/LinearLayout&gt;
</code></pre><p>上面是一个很简单的布局，UI效果图如下：</p>
<p><img src="/uploads/20160105/20160105202531.png" alt="这里填写图片的描述"></p>
<p>当我们用<code>tv_01.getTop()</code>的时候，得到的返回值是0，符合我的想象。但是用<code>tv_02.getTop()</code>，得到的值也为0。而我原以为<code>tv_02.getTop()</code>的值为<code>ll_01</code>的高度，也就是<code>tv_02</code>距离屏幕顶部的长度。但是结果和我的想象不一致。</p>
<p>后来我才知道原来<code>getTop()</code>方法返回的是该view距离<strong>父容器顶部</strong>的距离，所以理所应当<code>tv_02.getTop()</code>距离<code>ll_02</code>顶部的距离也为0了，同样的<code>getLeft()</code>、<code>getBottom()</code>、<code>getRight()</code>也是一个道理，以此类推。</p>
<p>那么问题来了，如何按我之前的想法一样，得到<code>tv_02</code>距离<strong>屏幕顶部</strong>的值呢？很简单，我们只要<code>tv_02.getTop() + ll_02.getTop()</code>就好了。相信聪明的你已经懂了。</p>
<p>看来在开发中还有不少的细节需要我们注意，特此一记。</p>
]]></content>
    <summary type="html">
    <![CDATA[<p>在今天的开发中，遇到了一个之前没有关注过的细节。那就是我用<code>view.getTop()</code>来获取view距离屏幕顶部高度，结果发现得到的数值和理论不一致。我们来举个例子吧，比如我们有如下的布局：</p>
<pre><code>&lt;?xml versi]]>
    </summary>
    
      <category term="Android" scheme="http://yuqirong.me/tags/Android/"/>
    
      <category term="Android Tips" scheme="http://yuqirong.me/categories/Android-Tips/"/>
    
  </entry>
  
</feed>
